<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Jersey 3.0.2 User Guide</title><link rel="stylesheet" type="text/css" href="/jersey.github.io/documentation.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-3160303-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script></head><body class="contents"><div class="contents" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div style="float:right"><a href="https://eclipse-ee4j.github.io/jersey"><img src="https://eclipse-ee4j.github.io/jersey.github.io/images/jersey_logo.png"></a></div><small>Links:
            <a href="index.html">
                Table of Contents
            </a> | <a href="user-guide.html">
                Single HTML
            </a></small><div lang="en" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="d0e2"></a>Jersey 3.0.2 User Guide</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#getting-started">1. Getting Started</a></span></dt><dd><dl><dt><span class="section"><a href="#new-from-archetype">1.1. Creating a New Project from Maven Archetype</a></span></dt><dt><span class="section"><a href="#new-project-structure">1.2. Exploring the Newly Created Project</a></span></dt><dt><span class="section"><a href="#running-project">1.3. Running the Project</a></span></dt><dt><span class="section"><a href="#new-webapp">1.4. Creating a JavaEE Web Application</a></span></dt><dt><span class="section"><a href="#heroku-webapp">1.5. Creating a Web Application that can be deployed on Heroku</a></span></dt><dd><dl><dt><span class="section"><a href="#deploy-it-on-heroku">1.5.1. Deploy it on Heroku</a></span></dt></dl></dd><dt><span class="section"><a href="#exploring-jersey-examples">1.6. Exploring Other Jersey Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#modules-and-dependencies">2. Modules and dependencies</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e559">2.1. Java SE Compatibility</a></span></dt><dt><span class="section"><a href="#d0e575">2.2. Introduction to Jersey dependencies</a></span></dt><dt><span class="section"><a href="#dependencies">2.3. Common Jersey Use Cases</a></span></dt><dd><dl><dt><span class="section"><a href="#servlet-app-glassfish">2.3.1. Servlet based application on Glassfish</a></span></dt><dt><span class="section"><a href="#servlet-app-general">2.3.2. Servlet based server-side application</a></span></dt><dt><span class="section"><a href="#client-jdk">2.3.3. Client application on JDK</a></span></dt><dt><span class="section"><a href="#server-jdk">2.3.4. Server-side application on supported containers</a></span></dt></dl></dd><dt><span class="section"><a href="#modules">2.4. List of modules</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jaxrs-resources">3. JAX-RS Application, Resources and Sub-Resources</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1820">3.1. Root Resource Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1859">3.1.1. @Path</a></span></dt><dt><span class="section"><a href="#d0e1909">3.1.2. @GET, @PUT, @POST, @DELETE, ... (HTTP Methods)</a></span></dt><dt><span class="section"><a href="#d0e1947">3.1.3. @Produces</a></span></dt><dt><span class="section"><a href="#d0e2026">3.1.4. @Consumes</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2051">3.2. Parameter Annotations (@*Param)</a></span></dt><dt><span class="section"><a href="#d0e2322">3.3. Sub-resources</a></span></dt><dt><span class="section"><a href="#d0e2469">3.4. Life-cycle of Root Resource Classes</a></span></dt><dt><span class="section"><a href="#d0e2540">3.5. Rules of Injection</a></span></dt><dt><span class="section"><a href="#d0e2648">3.6. Use of @Context</a></span></dt><dt><span class="section"><a href="#d0e2676">3.7. Programmatic resource model</a></span></dt></dl></dd><dt><span class="chapter"><a href="#deployment">4. Application Deployment and Runtime Environments</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.intro">4.1. Introduction</a></span></dt><dt><span class="section"><a href="#environmenmt.appmodel">4.2. JAX-RS Application Model</a></span></dt><dt><span class="section"><a href="#deployment.autodiscoverable">4.3. Auto-Discoverable Features</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.autodiscovery.config">4.3.1. Configuring Feature Auto-discovery Mechanism</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.classpath-scanning">4.4. Configuring the Classpath Scanning</a></span></dt><dt><span class="section"><a href="#deployment.javase">4.5. Java SE Deployment Environments</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.http">4.5.1. HTTP servers</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.jaxrs.endpoint">4.6. Creating programmatic JAX-RS endpoint</a></span></dt><dt><span class="section"><a href="#deployment.servlet">4.7. Servlet-based Deployment</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.servlet.2">4.7.1. Servlet 2.x way</a></span></dt><dt><span class="section"><a href="#deployment.servlet.5">4.7.2. Servlet 5.x Container</a></span></dt><dt><span class="section"><a href="#deployment.servlet.containers">4.7.3. Jersey Servlet container modules</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.javaee">4.8. Jakarta EE Platform</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.javaee.managed">4.8.1. Managed Beans</a></span></dt><dt><span class="section"><a href="#deployment.javaee.cdi">4.8.2. Context and Dependency Injection (CDI)</a></span></dt><dt><span class="section"><a href="#deployment.javaee.ejb">4.8.3. Enterprise Java Beans (EJB)</a></span></dt><dt><span class="section"><a href="#deployment.appservers">4.8.4. Jakarta EE Servers</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.osgi">4.9. OSGi</a></span></dt><dd><dl><dt><span class="section"><a href="#osgi.shell">4.9.1. Enabling the OSGi shell in Glassfish</a></span></dt><dt><span class="section"><a href="#osgi.wab">4.9.2. WAB Example</a></span></dt><dt><span class="section"><a href="#osgi.httpservice">4.9.3. HTTP Service Example</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.other">4.10. Other Environments</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.other.cloud">4.10.1. Oracle Java Cloud Service</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#client">5. Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3970">5.1. Uniform Interface Constraint</a></span></dt><dt><span class="section"><a href="#d0e4013">5.2. Ease of use and reusing JAX-RS artifacts</a></span></dt><dt><span class="section"><a href="#d0e4129">5.3. Overview of the Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4132">5.3.1. Getting started with the client API</a></span></dt><dt><span class="section"><a href="#d0e4151">5.3.2. 
                Creating and configuring a Client instance
            </a></span></dt><dt><span class="section"><a href="#d0e4335">5.3.3. Targeting a web resource</a></span></dt><dt><span class="section"><a href="#d0e4403">5.3.4. Identifying resource on WebTarget</a></span></dt><dt><span class="section"><a href="#d0e4479">5.3.5. Invoking a HTTP request</a></span></dt><dt><span class="section"><a href="#d0e4622">5.3.6. Example summary</a></span></dt><dt><span class="section"><a href="#d0e4651">5.3.7. Setting ExecutorService and ScheduledExecutorService</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4681">5.4. Java instances and types for representations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4700">5.4.1. Adding support for new representations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4734">5.5. Client Transport Connectors</a></span></dt><dt><span class="section"><a href="#d0e4984">5.6. Using client request and response filters</a></span></dt><dt><span class="section"><a href="#d0e5018">5.7. Closing connections</a></span></dt><dt><span class="section"><a href="#d0e5042">5.8. Injections into client providers</a></span></dt><dt><span class="section"><a href="#d0e5077">5.9. Securing a Client</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5224">5.9.1. Http Authentication Support</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5306">5.10. InvocationInterceptors</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5317">5.10.1. PreInvocationInterceptor</a></span></dt><dt><span class="section"><a href="#d0e5353">5.10.2. PostInvocationInterceptor</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5394">5.11. InvocationBuilderListener</a></span></dt><dt><span class="section"><a href="#d0e5426">5.12. Header Expect:100-continue support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#rx-client">6. Reactive JAX-RS Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5482">6.1. Motivation for Reactive Client Extension</a></span></dt><dt><span class="section"><a href="#d0e5653">6.2. Usage and Extension Modules</a></span></dt><dt><span class="section"><a href="#rx.client.supported">6.3. Supported Reactive Libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#rx-client.rxjava">6.3.1. RxJava (Observable)</a></span></dt><dt><span class="section"><a href="#rx-client.rxjava2">6.3.2. RxJava (Flowable)</a></span></dt><dt><span class="section"><a href="#rx-client.guava">6.3.3. Guava (ListenableFuture and Futures)</a></span></dt></dl></dd><dt><span class="section"><a href="#rx.client.spi">6.4. Implementing Support for Custom Reactive Libraries (SPI)</a></span></dt></dl></dd><dt><span class="chapter"><a href="#representations">7. Representations and Responses</a></span></dt><dd><dl><dt><span class="section"><a href="#reps-and-types">7.1. Representations and Java Types</a></span></dt><dt><span class="section"><a href="#d0e6241">7.2. Building Responses</a></span></dt><dt><span class="section"><a href="#d0e6278">7.3. WebApplicationException and Mapping Exceptions to Responses</a></span></dt><dt><span class="section"><a href="#d0e6359">7.4. Conditional GETs and Returning 304 (Not Modified) Responses</a></span></dt></dl></dd><dt><span class="chapter"><a href="#message-body-workers">8. JAX-RS Entity Providers</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6405">8.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e6439">8.2. How to Write Custom Entity Providers</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6476">8.2.1. MessageBodyWriter</a></span></dt><dt><span class="section"><a href="#d0e6764">8.2.2. MessageBodyReader</a></span></dt></dl></dd><dt><span class="section"><a href="#providers-selection">8.3. Entity Provider Selection</a></span></dt><dt><span class="section"><a href="#d0e7325">8.4. Jersey <code class="literal">MessageBodyWorkers</code> API</a></span></dt><dt><span class="section"><a href="#d0e7409">8.5. Default Jersey Entity Providers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#media">9. Support for Common Media Type Representations</a></span></dt><dd><dl><dt><span class="section"><a href="#json">9.1. JSON</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7580">9.1.1. Approaches to JSON Support</a></span></dt><dt><span class="section"><a href="#json.moxy">9.1.2. MOXy</a></span></dt><dt><span class="section"><a href="#json.json-p">9.1.3. Java API for JSON Processing (JSON-P)</a></span></dt><dt><span class="section"><a href="#json.jackson">9.1.4. Jackson (2.x)</a></span></dt><dt><span class="section"><a href="#json.jettison">9.1.5. Jettison</a></span></dt><dt><span class="section"><a href="#d0e8348">9.1.6. <code class="literal">@JSONP</code> - JSON with Padding Support</a></span></dt><dt><span class="section"><a href="#json.json-b">9.1.7. Java API for JSON Binding (JSON-B)</a></span></dt></dl></dd><dt><span class="section"><a href="#xml">9.2. XML</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8593">9.2.1. Low level XML support</a></span></dt><dt><span class="section"><a href="#d0e8641">9.2.2. Getting started with JAXB</a></span></dt><dt><span class="section"><a href="#d0e8729">9.2.3. POJOs</a></span></dt><dt><span class="section"><a href="#d0e8767">9.2.4. Using custom JAXBContext</a></span></dt><dt><span class="section"><a href="#d0e8799">9.2.5. MOXy</a></span></dt></dl></dd><dt><span class="section"><a href="#multipart">9.3. Multipart</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8854">9.3.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e8955">9.3.2. Client</a></span></dt><dt><span class="section"><a href="#d0e9086">9.3.3. Server</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#filters-and-interceptors">10. Filters and Interceptors</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9321">10.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e9326">10.2. Filters</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9355">10.2.1. Server filters</a></span></dt><dt><span class="section"><a href="#d0e9460">10.2.2. Client filters</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9495">10.3. Interceptors</a></span></dt><dt><span class="section"><a href="#d0e9604">10.4. Filter and interceptor execution order</a></span></dt><dt><span class="section"><a href="#d0e9665">10.5. Name binding</a></span></dt><dt><span class="section"><a href="#d0e9738">10.6. Dynamic binding</a></span></dt><dt><span class="section"><a href="#d0e9806">10.7. Priorities</a></span></dt></dl></dd><dt><span class="chapter"><a href="#async">11. Asynchronous Services and Clients</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9885">11.1. Asynchronous Server API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10006">11.1.1. Asynchronous Server-side Callbacks</a></span></dt><dt><span class="section"><a href="#chunked-output">11.1.2. Chunked Output</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10136">11.2. Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10199">11.2.1. Asynchronous Client Callbacks</a></span></dt><dt><span class="section"><a href="#d0e10275">11.2.2. Chunked input</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#uris-and-links">12. URIs and Links</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10358">12.1. Building URIs</a></span></dt><dt><span class="section"><a href="#d0e10432">12.2. Resolve and Relativize</a></span></dt><dt><span class="section"><a href="#d0e10475">12.3. Link</a></span></dt></dl></dd><dt><span class="chapter"><a href="#declarative-linking">13. Declarative Hyperlinking</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10531">13.1. Dependency</a></span></dt><dt><span class="section"><a href="#d0e10554">13.2. Links in Representations</a></span></dt><dt><span class="section"><a href="#d0e10590">13.3. List of Link Injection</a></span></dt><dt><span class="section"><a href="#d0e10598">13.4. Links from Resources</a></span></dt><dt><span class="section"><a href="#d0e10626">13.5. Binding Template Parameters</a></span></dt><dt><span class="section"><a href="#d0e10698">13.6. Conditional Link Injection</a></span></dt><dt><span class="section"><a href="#d0e10720">13.7. Link Headers</a></span></dt><dt><span class="section"><a href="#d0e10761">13.8. Prevent Recursive Injection</a></span></dt><dt><span class="section"><a href="#d0e10781">13.9. Meta-annotation support</a></span></dt><dt><span class="section"><a href="#d0e10836">13.10. Configure and register</a></span></dt></dl></dd><dt><span class="chapter"><a href="#resource-builder">14. Programmatic API for Building Resources</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10854">14.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e10899">14.2. Programmatic Hello World example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10971">14.2.1. Deployment of programmatic resources</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11033">14.3. Additional examples</a></span></dt><dt><span class="section"><a href="#d0e11093">14.4. Model processors</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jersey-configuration">15. Jersey configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#default-config">15.1. Jersey default configuration provider</a></span></dt><dt><span class="section"><a href="#mp-config">15.2. Micro profile configuration provider</a></span></dt></dl></dd><dt><span class="chapter"><a href="#sse">16. Server-Sent Events (SSE) Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11193">16.1. What are Server-Sent Events</a></span></dt><dt><span class="section"><a href="#d0e11236">16.2. When to use Server-Sent Events</a></span></dt><dt><span class="section"><a href="#jaxrs-sse-api-overview">16.3. Server-Sent Events API</a></span></dt><dt><span class="section"><a href="#d0e11298">16.4. Implementing SSE support in a JAX-RS resource (with JAX-RS SSE API)</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11301">16.4.1. Simple SSE resource method</a></span></dt><dt><span class="section"><a href="#d0e11477">16.4.2. Broadcasting with Jersey SSE</a></span></dt></dl></dd><dt><span class="section"><a href="#sse-client-jaxrs">16.5. Consuming SSE events within Jersey clients</a></span></dt><dd><dl><dt><span class="section"><a href="#sse-event-source-reconnect">16.5.1. 
                <code class="literal">SseEventSource</code>
                reconnect support
            </a></span></dt></dl></dd><dt><span class="section"><a href="#overview-jersey-specific">16.6. Jersey-specific Server-Sent Events API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11913">16.6.1. Implementing SSE support in a JAX-RS resource</a></span></dt><dt><span class="section"><a href="#d0e12102">16.6.2. Consuming SSE events with Jersey clients</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#security">17. Security</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12367">17.1. Securing server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12370">17.1.1. SecurityContext</a></span></dt><dt><span class="section"><a href="#d0e12476">17.1.2. Authorization - securing resources</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e12599">17.2. Client Security</a></span></dt><dt><span class="section"><a href="#d0e12616">17.3. OAuth Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12678">17.3.1. OAuth 1</a></span></dt><dt><span class="section"><a href="#d0e13009">17.3.2. OAuth 2 Support</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#wadl">18. WADL Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13140">18.1. WADL introduction</a></span></dt><dt><span class="section"><a href="#d0e13435">18.2. Configuration</a></span></dt><dt><span class="section"><a href="#d0e13490">18.3. Extended WADL support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#bean-validation">19. Bean Validation Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13529">19.1. Bean Validation Dependencies</a></span></dt><dt><span class="section"><a href="#d0e13555">19.2. Enabling Bean Validation in Jersey</a></span></dt><dt><span class="section"><a href="#d0e13589">19.3. Configuring Bean Validation Support</a></span></dt><dt><span class="section"><a href="#d0e13694">19.4. Validating JAX-RS resources and methods</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13723">19.4.1. Constraint Annotations</a></span></dt><dt><span class="section"><a href="#d0e13809">19.4.2. Annotation constraints and Validators</a></span></dt><dt><span class="section"><a href="#d0e13859">19.4.3. Entity Validation</a></span></dt><dt><span class="section"><a href="#d0e13940">19.4.4. Annotation Inheritance</a></span></dt></dl></dd><dt><span class="section"><a href="#bv.ValidateOnExecution">19.5. @ValidateOnExecution</a></span></dt><dt><span class="section"><a href="#bv.injecting">19.6. Injecting</a></span></dt><dt><span class="section"><a href="#d0e14064">19.7. Error Reporting</a></span></dt><dd><dl><dt><span class="section"><a href="#bv.ValidationError">19.7.1. ValidationError</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14222">19.8. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#entity-filtering">20. Entity Data Filtering</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14258">20.1. Enabling and configuring Entity Filtering in your application</a></span></dt><dt><span class="section"><a href="#d0e14371">20.2. Components used to describe Entity Filtering concepts</a></span></dt><dt><span class="section"><a href="#ef.annotations">20.3. Using custom annotations to filter entities</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14526">20.3.1. Server-side Entity Filtering</a></span></dt><dt><span class="section"><a href="#d0e14644">20.3.2. Client-side Entity Filtering</a></span></dt></dl></dd><dt><span class="section"><a href="#ef.security.annotations">20.4. Role-based Entity Filtering using (<code class="literal">jakarta.annotation.security</code>) annotations</a></span></dt><dt><span class="section"><a href="#ef.selectable.annotations">20.5. Entity Filtering based on dynamic and configurable query parameters</a></span></dt><dt><span class="section"><a href="#ef.custom.annotations">20.6. Defining custom handling for entity-filtering annotations</a></span></dt><dt><span class="section"><a href="#ef.custom.providers">20.7. Supporting Entity Data Filtering in custom entity providers or frameworks</a></span></dt><dt><span class="section"><a href="#ef.modules">20.8. Modules with support for Entity Data Filtering</a></span></dt><dt><span class="section"><a href="#d0e14845">20.9. Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mvc">21. MVC Templates</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14884">21.1. Viewable</a></span></dt><dt><span class="section"><a href="#d0e14929">21.2. @Template</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14932">21.2.1. Annotating Resource methods</a></span></dt><dt><span class="section"><a href="#d0e14988">21.2.2. Annotating Resource classes</a></span></dt></dl></dd><dt><span class="section"><a href="#mvc.references">21.3. Absolute vs. Relative template reference</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15084">21.3.1. Relative template reference</a></span></dt><dt><span class="section"><a href="#d0e15128">21.3.2. Absolute template reference</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15174">21.4. Handling errors with MVC</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15228">21.4.1. MVC &amp; Bean Validation</a></span></dt></dl></dd><dt><span class="section"><a href="#mvc.registration">21.5. Registration and Configuration</a></span></dt><dt><span class="section"><a href="#d0e15358">21.6. Supported templating engines</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15363">21.6.1. Mustache</a></span></dt><dt><span class="section"><a href="#d0e15465">21.6.2. Freemarker</a></span></dt><dt><span class="section"><a href="#d0e15581">21.6.3. JSP</a></span></dt></dl></dd><dt><span class="section"><a href="#mvc.spi">21.7. Writing Custom Templating Engines</a></span></dt><dt><span class="section"><a href="#d0e15728">21.8. Other Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#logging_chapter">22. Logging</a></span></dt><dd><dl><dt><span class="section"><a href="#logging">22.1. Logging traffic</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15743">22.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e15768">22.1.2. Configuration and registering</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#monitoring_tracing">23. Monitoring and Diagnostics</a></span></dt><dd><dl><dt><span class="section"><a href="#monitoring">23.1. Monitoring Jersey Applications</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15980">23.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e16031">23.1.2. Event Listeners</a></span></dt></dl></dd><dt><span class="section"><a href="#tracing">23.2. Tracing Support</a></span></dt><dd><dl><dt><span class="section"><a href="#tracing.configuration">23.2.1. Configuration options</a></span></dt><dt><span class="section"><a href="#d0e16762">23.2.2. Tracing Log</a></span></dt><dt><span class="section"><a href="#d0e16776">23.2.3. Configuring tracing support via HTTP request headers</a></span></dt><dt><span class="section"><a href="#d0e16819">23.2.4. Format of the HTTP response headers</a></span></dt><dt><span class="section"><a href="#d0e16976">23.2.5. Tracing Examples</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ioc">24. Custom Injection and Lifecycle Management</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17051">24.1. Implementing Custom Injection Provider</a></span></dt><dt><span class="section"><a href="#d0e17152">24.2. Defining Custom Injection Annotation</a></span></dt><dt><span class="section"><a href="#d0e17220">24.3. Custom Life Cycle Management</a></span></dt></dl></dd><dt><span class="chapter"><a href="#cdi.support">25. Jersey CDI Container Agnostic Support</a></span></dt><dd><dl><dt><span class="section"><a href="#cdi.support.intro">25.1. Introduction</a></span></dt><dt><span class="section"><a href="#cdi.support.existing.containers">25.2. Containers Known to Work With Jersey CDI Support</a></span></dt><dt><span class="section"><a href="#cdi.support.request.scope.binding">25.3. Request Scope Binding</a></span></dt><dt><span class="section"><a href="#cdi.support.weld.se">25.4. Jersey Weld SE Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#test-framework">26. Jersey Test Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17414">26.1. Basics</a></span></dt><dt><span class="section"><a href="#d0e17451">26.2. Supported Containers</a></span></dt><dt><span class="section"><a href="#testng">26.3. Running TestNG Tests</a></span></dt><dt><span class="section"><a href="#d0e17644">26.4. Advanced features</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17647">26.4.1. <code class="literal">JerseyTest</code> Features</a></span></dt><dt><span class="section"><a href="#d0e17671">26.4.2. External container</a></span></dt><dt><span class="section"><a href="#d0e17682">26.4.3. Test Client configuration</a></span></dt><dt><span class="section"><a href="#d0e17696">26.4.4. Accessing the logged test records programmatically</a></span></dt></dl></dd><dt><span class="section"><a href="#parallel">26.5. Parallel Testing with Jersey Test Framework</a></span></dt></dl></dd><dt><span class="chapter"><a href="#how-to-build">27. Building and Testing Jersey</a></span></dt><dd><dl><dt><span class="section"><a href="#checkout">27.1. Checking Out the Source</a></span></dt><dt><span class="section"><a href="#building">27.2. Building the Source</a></span></dt><dt><span class="section"><a href="#testing">27.3. Testing</a></span></dt><dt><span class="section"><a href="#netbeans-build">27.4. Using NetBeans</a></span></dt></dl></dd><dt><span class="chapter"><a href="#migration">28. Migration Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#mig-3.0.0">28.1. Migrating from Jersey 2.32 to 3.0.2.</a></span></dt><dd><dl><dt><span class="section"><a href="#mig-3.0.0-breaking-changes">28.1.1. Breaking Changes</a></span></dt><dt><span class="section"><a href="#mig-3.0.0-removed-deprecated">28.1.2. Removed deprecated APIs</a></span></dt><dt><span class="section"><a href="#mig-3.0.0-application-servers">28.1.3. Application servers for Jersey</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#appendix-properties">A. Configuration Properties</a></span></dt><dd><dl><dt><span class="section"><a href="#appendix-properties-common">A.1. Common (client/server) configuration properties</a></span></dt><dt><span class="section"><a href="#appendix-properties-server">A.2. Server configuration properties</a></span></dt><dt><span class="section"><a href="#appendix-properties-servlet">A.3. Servlet configuration properties</a></span></dt><dt><span class="section"><a href="#appendix-properties-client">A.4. Client configuration properties</a></span></dt></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>6.1. <a href="#rx.client.motivation.problem">Travel Agency Orchestration Service</a></dt><dt>6.2. <a href="#rx.client.motivation.graph.sync">Time consumed to create a response for the client &#8211; synchronous way</a></dt><dt>6.3. <a href="#rx.client.motivation.graph.async">Time consumed to create a response for the client &#8211; asynchronous way</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>2.1. <a href="#dependencies-table-org.glassfish.jersey.core">Jersey Core</a></dt><dt>2.2. <a href="#dependencies-table-org.glassfish.jersey.containers">Jersey Containers</a></dt><dt>2.3. <a href="#dependencies-table-org.glassfish.jersey.connectors">Jersey Connectors</a></dt><dt>2.4. <a href="#dependencies-table-org.glassfish.jersey.media">Jersey Media</a></dt><dt>2.5. <a href="#dependencies-table-org.glassfish.jersey.ext">Jersey Extensions</a></dt><dt>2.6. <a href="#dependencies-table-org.glassfish.jersey.test-framework">Jersey Test Framework</a></dt><dt>2.7. <a href="#dependencies-table-org.glassfish.jersey.test-framework.providers">Jersey Test Framework Providers</a></dt><dt>2.8. <a href="#dependencies-table-org.glassfish.jersey.containers.glassfish">Jersey Glassfish Bundles</a></dt><dt>2.9. <a href="#dependencies-table-org.glassfish.jersey.security">Security</a></dt><dt>2.10. <a href="#dependencies-table-org.glassfish.jersey.examples">Jersey Examples</a></dt><dt>3.1. <a href="#d0e2486">Resource scopes</a></dt><dt>3.2. <a href="#d0e2594">Overview of injection types</a></dt><dt>4.1. <a href="#environment-table-pluggability">Servlet 3 Pluggability Overview</a></dt><dt>5.1. <a href="#d0e4758">List of Jersey Connectors</a></dt><dt>9.1. <a href="#d0e7885">Default property values for MOXy MessageBodyReader&lt;T&gt; / MessageBodyWriter&lt;T&gt;</a></dt><dt>A.1. <a href="#d0e17897">List of common configuration properties</a></dt><dt>A.2. <a href="#d0e18185">List of server configuration properties</a></dt><dt>A.3. <a href="#d0e18903">List of servlet configuration properties</a></dt><dt>A.4. <a href="#d0e19014">List of client configuration properties</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>3.1. <a href="#d0e1853">Simple hello world root resource class</a></dt><dt>3.2. <a href="#d0e1892">Specifying URI path parameter</a></dt><dt>3.3. <a href="#d0e1935">PUT method</a></dt><dt>3.4. <a href="#d0e1960">Specifying output MIME type</a></dt><dt>3.5. <a href="#d0e2002">Using multiple output MIME types</a></dt><dt>3.6. <a href="#d0e2015">Server-side content negotiation</a></dt><dt>3.7. <a href="#d0e2036">Specifying input MIME type</a></dt><dt>3.8. <a href="#d0e2066">Query parameters</a></dt><dt>3.9. <a href="#d0e2079">Custom Java type for consuming request parameters</a></dt><dt>3.10. <a href="#d0e2198">Processing POSTed HTML form</a></dt><dt>3.11. <a href="#d0e2208">Obtaining general map of URI path and/or query parameters</a></dt><dt>3.12. <a href="#d0e2218">Obtaining general map of header parameters</a></dt><dt>3.13. <a href="#d0e2233">Obtaining general map of form parameters</a></dt><dt>3.14. <a href="#d0e2262">Example of the bean which will be used as @BeanParam
            </a></dt><dt>3.15. <a href="#d0e2270">Injection of MyBeanParam as a method parameter:</a></dt><dt>3.16. <a href="#d0e2317">Injection of more beans into one resource methods:</a></dt><dt>3.17. <a href="#d0e2342">Sub-resource methods</a></dt><dt>3.18. <a href="#d0e2375">Sub-resource locators</a></dt><dt>3.19. <a href="#d0e2403">Sub-resource locators with empty path</a></dt><dt>3.20. <a href="#d0e2418">Sub-resource locators returning sub-type</a></dt><dt>3.21. <a href="#d0e2431">Sub-resource locators created from classes</a></dt><dt>3.22. <a href="#d0e2455">Sub-resource locators returning resource model</a></dt><dt>3.23. <a href="#d0e2549">Injection</a></dt><dt>3.24. <a href="#d0e2559">Wrong injection into a singleton scope</a></dt><dt>3.25. <a href="#d0e2586">Injection of proxies into singleton</a></dt><dt>3.26. <a href="#d0e2637">Example of possible injections</a></dt><dt>4.1. <a href="#d0e2707">Deployment agnostic application model</a></dt><dt>4.2. <a href="#d0e2751">Reusing Jersey implementation in your custom application model</a></dt><dt>4.3. <a href="#d0e2956">Registering SPI implementations using ResourceConfig</a></dt><dt>4.4. <a href="#d0e2965">Registering SPI implementations using <code class="literal">ResourceConfig</code> subclass</a></dt><dt>4.5. <a href="#d0e3009">Using Jersey with JDK HTTP Server</a></dt><dt>4.6. <a href="#d0e3048">Using Jersey with Grizzly HTTP Server</a></dt><dt>4.7. <a href="#d0e3081">Using Jersey with the Simple framework</a></dt><dt>4.8. <a href="#d0e3122">Using Jersey with Jetty HTTP Server</a></dt><dt>4.9. <a href="#d0e3141">Using Jersey with Netty HTTP Server</a></dt><dt>4.10. <a href="#d0e3190">Hooking up Jersey as a Servlet</a></dt><dt>4.11. <a href="#d0e3199">Hooking up Jersey as a Servlet Filter</a></dt><dt>4.12. <a href="#d0e3248">
                            Configuring Jersey container Servlet or Filter to use custom <code class="literal">Application</code> subclass
                        </a></dt><dt>4.13. <a href="#d0e3280">Configuring Jersey container Servlet or Filter to use package scanning</a></dt><dt>4.14. <a href="#d0e3303">Configuring Jersey container Servlet or Filter to use a list of classes</a></dt><dt>4.15. <a href="#d0e3331">Deployment of a JAX-RS application using <code class="literal">@ApplicationPath</code> with Servlet 5.0</a></dt><dt>4.16. <a href="#d0e3369">Configuration of maven-war-plugin to ignore missing <code class="literal">web.xml</code></a></dt><dt>4.17. <a href="#d0e3399">Deployment of a JAX-RS application using <code class="literal">web.xml</code> with Servlet 5.0
                        </a></dt><dt>4.18. <a href="#d0e3452">
                            <code class="literal">web.xml</code> of a JAX-RS application without an <code class="literal">Application</code> subclass
                        </a></dt><dt>4.19. <a href="#d0e3516"></a></dt><dt>4.20. <a href="#d0e3815"></a></dt><dt>5.1. <a href="#client.ex.formpost">POST request with form parameters</a></dt><dt>5.2. <a href="#d0e4627">Using JAX-RS Client API</a></dt><dt>5.3. <a href="#d0e4633">Using JAX-RS Client API fluently</a></dt><dt>5.4. <a href="#d0e4676">Setting JAX-RS Client ExecutorService</a></dt><dt>5.5. <a href="#d0e4907">Sending restricted headers with <code class="literal">HttpUrlConnector</code></a></dt><dt>5.6. <a href="#d0e5023">Closing connections</a></dt><dt>5.7. <a href="#d0e5064">InjectionManagerClientProvider example</a></dt><dt>6.1. <a href="#rx.client.motivation.naive">Excerpt from a synchronous approach while implementing the orchestration layer</a></dt><dt>6.2. <a href="#rx.client.motivation.optimized">Excerpt from an asynchronous approach while implementing the orchestration layer</a></dt><dt>6.3. <a href="#rx.client.motivation.reactive">Excerpt from a reactive approach while implementing the orchestration layer</a></dt><dt>6.4. <a href="#rx.client.sync">Synchronous invocation of HTTP requests</a></dt><dt>6.5. <a href="#rx.client.async">Asynchronous invocation of HTTP requests</a></dt><dt>6.6. <a href="#rx.client.reactive">Reactive invocation of HTTP requests</a></dt><dt>6.7. <a href="#rx.client.rxjava.rx">Creating JAX-RS Client with RxJava reactive extension</a></dt><dt>6.8. <a href="#rx.client.rxjava.usage">Obtaining Observable&lt;Response&gt; from Jersey/RxJava Client</a></dt><dt>6.9. <a href="#rx.client.rxjava2.rx">Creating JAX-RS Client with RxJava2 reactive extension</a></dt><dt>6.10. <a href="#rx.client.rxjava2.usage">Obtaining Flowable&lt;Response&gt; from Jersey/RxJava Client</a></dt><dt>6.11. <a href="#rx.client.guava.rx">Creating Jersey/Guava Client</a></dt><dt>6.12. <a href="#rx.client.guava.usage">Obtaining ListenableFuture&lt;Response&gt; from Jersey/Guava Client</a></dt><dt>6.13. <a href="#rx.client.rxinvoker">Extending RxIvoker</a></dt><dt>6.14. <a href="#rx.client.extend.rxinvoker">Extending RxInvokerProvider</a></dt><dt>7.1. <a href="#d0e6202">Using
                    <code class="code">File</code>
                    with a specific media type to produce a response
                </a></dt><dt>7.2. <a href="#d0e6257">Returning 201 status code and adding
                    <code class="literal">Location</code>
                    header in response to POST request
                </a></dt><dt>7.3. <a href="#d0e6270">Adding an entity body to a custom response</a></dt><dt>7.4. <a href="#d0e6290">Throwing exceptions to control response</a></dt><dt>7.5. <a href="#d0e6303">Application specific exception implementation</a></dt><dt>7.6. <a href="#d0e6325">Mapping generic exceptions to responses</a></dt><dt>7.7. <a href="#d0e6373">Conditional GET support</a></dt><dt>8.1. <a href="#d0e6450">Example resource class</a></dt><dt>8.2. <a href="#d0e6470">MyBean entity class</a></dt><dt>8.3. <a href="#d0e6494">MessageBodyWriter example</a></dt><dt>8.4. <a href="#d0e6550">Example of assignment of annotations to a response entity</a></dt><dt>8.5. <a href="#client-get-call">Client code testing MyBeanMessageBodyWriter</a></dt><dt>8.6. <a href="#d0e6749">Result of MyBeanMessageBodyWriter test</a></dt><dt>8.7. <a href="#mbw.ex.mbr">MessageBodyReader example</a></dt><dt>8.8. <a href="#d0e6903">Testing MyBeanMessageBodyReader</a></dt><dt>8.9. <a href="#d0e6911">Result of testing MyBeanMessageBodyReader</a></dt><dt>8.10. <a href="#mbw.ex.client.mbr.reg">MessageBodyReader registered on a JAX-RS client</a></dt><dt>8.11. <a href="#d0e6979">Result of client code execution</a></dt><dt>8.12. <a href="#d0e7360">Usage of MessageBodyWorkers interface</a></dt><dt>9.1. <a href="#d0e7620">Simple JAXB bean implementation</a></dt><dt>9.2. <a href="#d0e7626">JAXB bean used to generate JSON representation</a></dt><dt>9.3. <a href="#d0e7646">Tweaking JSON format using JAXB</a></dt><dt>9.4. <a href="#d0e7683">JAXB bean creation</a></dt><dt>9.5. <a href="#d0e7700">Constructing a <code class="literal">JsonObject</code> (JSON-Processing)</a></dt><dt>9.6. <a href="#d0e7709">Constructing a <code class="literal">JSONObject</code> (Jettison)</a></dt><dt>9.7. <a href="#d0e7836">MoxyJsonConfig - Setting properties.</a></dt><dt>9.8. <a href="#d0e7850">Creating <code class="literal">ContextResolver&lt;MoxyJsonConfig&gt;</code></a></dt><dt>9.9. <a href="#d0e7869">Setting properties for MOXy providers into Configurable</a></dt><dt>9.10. <a href="#ex-moxy-client">Building client with MOXy JSON feature enabled.</a></dt><dt>9.11. <a href="#ex-moxy-server">Creating JAX-RS application with MOXy JSON feature enabled.</a></dt><dt>9.12. <a href="#d0e8034">Building client with JSON-Processing JSON feature enabled.</a></dt><dt>9.13. <a href="#d0e8039">Creating JAX-RS application with JSON-Processing JSON feature enabled.</a></dt><dt>9.14. <a href="#d0e8103"><code class="literal">ContextResolver&lt;ObjectMapper&gt;</code></a></dt><dt>9.15. <a href="#d0e8118">Building client with Jackson JSON feature enabled.</a></dt><dt>9.16. <a href="#d0e8124">Creating JAX-RS application with Jackson JSON feature enabled.</a></dt><dt>9.17. <a href="#d0e8190">JAXB beans for JSON supported notations description, simple address bean</a></dt><dt>9.18. <a href="#d0e8196">JAXB beans for JSON supported notations description, contact bean</a></dt><dt>9.19. <a href="#d0e8204">JAXB beans for JSON supported notations description, initialization</a></dt><dt>9.20. <a href="#json.jaxb.jettison.mapped.ns.def">
                                XML namespace to JSON mapping configuration for Jettison based <code class="literal">mapped</code> notation
                            </a></dt><dt>9.21. <a href="#d0e8250">JSON expression with XML namespaces mapped into JSON</a></dt><dt>9.22. <a href="#json.jaxb.jettison.mapped.array.def">
                                JSON Array configuration for Jettison based <code class="literal">mapped</code> notation
                            </a></dt><dt>9.23. <a href="#d0e8273">JSON expression with JSON arrays explicitly configured via Jersey</a></dt><dt>9.24. <a href="#d0e8295">JSON expression produced using <code class="literal">badgerfish</code> notation</a></dt><dt>9.25. <a href="#d0e8321"><code class="literal">ContextResolver&lt;ObjectMapper&gt;</code></a></dt><dt>9.26. <a href="#d0e8328">Building client with Jettison JSON feature enabled.</a></dt><dt>9.27. <a href="#d0e8334">Creating JAX-RS application with Jettison JSON feature enabled.</a></dt><dt>9.28. <a href="#d0e8408">Simplest case of using <code class="literal">@JSONP</code></a></dt><dt>9.29. <a href="#d0e8419">JaxbBean for @JSONP example</a></dt><dt>9.30. <a href="#d0e8475">Example of <code class="literal">@JSONP</code> with configured parameters.</a></dt><dt>9.31. <a href="#d0e8562"><code class="literal">ContextResolver&lt;Jsonb&gt;</code></a></dt><dt>9.32. <a href="#d0e8568"><code class="literal">Register the feature and ContextResolver&lt;Jsonb&gt;</code></a></dt><dt>9.33. <a href="#d0e8613">Low level XML test - methods added to <code class="literal">HelloWorldResource.java</code></a></dt><dt>9.34. <a href="#d0e8657">Planet class</a></dt><dt>9.35. <a href="#d0e8662">Resource class</a></dt><dt>9.36. <a href="#d0e8709">Method for consuming Planet</a></dt><dt>9.37. <a href="#d0e8743">Resource class - JAXBElement</a></dt><dt>9.38. <a href="#d0e8762">Client side - JAXBElement</a></dt><dt>9.39. <a href="#d0e8781">PlanetJAXBContextProvider</a></dt><dt>9.40. <a href="#d0e8794">Using Provider with JAX-RS client</a></dt><dt>9.41. <a href="#d0e8825">Add <code class="literal">jersey-media-moxy</code> dependency.</a></dt><dt>9.42. <a href="#d0e8833">Register the <code class="literal">MoxyXmlFeature</code> class.</a></dt><dt>9.43. <a href="#d0e8841">Configure and register an <code class="literal">MoxyXmlFeature</code> instance.</a></dt><dt>9.44. <a href="#d0e8935">Building client with MultiPart feature enabled.</a></dt><dt>9.45. <a href="#d0e8941">Creating JAX-RS application with MultiPart feature enabled.</a></dt><dt>9.46. <a href="#d0e8984"><code class="literal">MultiPart</code> entity</a></dt><dt>9.47. <a href="#d0e8998"><code class="literal">MultiPart</code> entity in HTTP message.</a></dt><dt>9.48. <a href="#d0e9028"><code class="literal">FormDataMultiPart</code> entity</a></dt><dt>9.49. <a href="#d0e9045"><code class="literal">FormDataMultiPart</code> entity in HTTP message.</a></dt><dt>9.50. <a href="#d0e9066">Multipart - sending files.</a></dt><dt>9.51. <a href="#d0e9134">Resource method using <code class="literal">MultiPart</code> as input parameter / return value.</a></dt><dt>9.52. <a href="#d0e9260">Use of <code class="literal">@FormDataParam</code> annotation</a></dt><dt>10.1. <a href="#d0e9361">Container response filter</a></dt><dt>10.2. <a href="#d0e9388">Container request filter</a></dt><dt>10.3. <a href="#d0e9430">Pre-matching request filter</a></dt><dt>10.4. <a href="#d0e9473">Client request filter</a></dt><dt>10.5. <a href="#d0e9512">GZIP writer interceptor</a></dt><dt>10.6. <a href="#d0e9561">GZIP reader interceptor</a></dt><dt>10.7. <a href="#d0e9686"><code class="literal">@NameBinding</code> example</a></dt><dt>10.8. <a href="#d0e9745">Dynamic binding example</a></dt><dt>10.9. <a href="#d0e9859">Priorities example</a></dt><dt>11.1. <a href="#d0e9892">Simple async resource</a></dt><dt>11.2. <a href="#d0e9979">Simple async method with timeout</a></dt><dt>11.3. <a href="#d0e10025">CompletionCallback example</a></dt><dt>11.4. <a href="#d0e10101">ChunkedOutput example</a></dt><dt>11.5. <a href="#d0e10141">Simple client async invocation</a></dt><dt>11.6. <a href="#d0e10182">Simple client fluent async invocation</a></dt><dt>11.7. <a href="#d0e10210">Client async callback</a></dt><dt>11.8. <a href="#d0e10260">Client async callback for specific entity</a></dt><dt>11.9. <a href="#d0e10297">ChunkedInput example</a></dt><dt>12.1. <a href="#d0e10385">URI building</a></dt><dt>12.2. <a href="#d0e10426">Building URIs using query parameters</a></dt><dt>13.1. <a href="#d0e10844">Creating JAX-RS application with Declarative Linking feature enabled.</a></dt><dt>14.1. <a href="#d0e10906">A standard resource class</a></dt><dt>14.2. <a href="#d0e10914">A programmatic resource</a></dt><dt>14.3. <a href="#d0e11014">A programmatic resource</a></dt><dt>14.4. <a href="#d0e11038">A programmatic resource</a></dt><dt>14.5. <a href="#d0e11074">A programmatic resource</a></dt><dt>14.6. <a href="#d0e11109">A programmatic resource</a></dt><dt>16.1. <a href="#sse-dependency-jaxrs">Adding the SSE dependency</a></dt><dt>16.2. <a href="#example-simple-sse-jaxrs">Simple SSE resource method</a></dt><dt>16.3. <a href="#d0e11485">Broadcasting SSE messages (with JAX-RS 3.0 API)</a></dt><dt>16.4. <a href="#sse-event-source-example">Consuming SSE events with SseEventSource</a></dt><dt>16.5. <a href="#sse-event-source-subscribe-methods">SseEventSource subscribe() methods</a></dt><dt>16.6. <a href="#sse.dependency">Add <code class="literal">jersey-media-sse</code> dependency.
                </a></dt><dt>16.7. <a href="#example-simple-sse">Simple SSE resource method</a></dt><dt>16.8. <a href="#d0e12046">Broadcasting SSE messages</a></dt><dt>16.9. <a href="#sse.ex.client.eventListener">Registering <code class="literal">EventListener</code> with <code class="literal">EventSource</code>
                        </a></dt><dt>16.10. <a href="#d0e12324">Overriding <code class="literal">EventSource.onEvent(InboundEvent)</code> method
                        </a></dt><dt>17.1. <a href="#d0e12395">Using <code class="literal">SecurityContext</code> for a Resource Selection</a></dt><dt>17.2. <a href="#d0e12412">Injecting <code class="literal">SecurityContext</code> into a singleton resource</a></dt><dt>17.3. <a href="#d0e12495">Securing resources using <code class="literal">web.xml</code>
                        </a></dt><dt>17.4. <a href="#d0e12533">Registering RolesAllowedDynamicFeature using ResourceConfig</a></dt><dt>17.5. <a href="#d0e12548">Registering RolesAllowedDynamicFeature by extending ResourceConfig</a></dt><dt>17.6. <a href="#d0e12559">Applying <code class="literal">jakarta.annotation.security</code> to JAX-RS resource methods.</a></dt><dt>17.7. <a href="#d0e12846">Build the authorization flow utility</a></dt><dt>17.8. <a href="#d0e12871">Perform the OAuth Authorization Flow</a></dt><dt>17.9. <a href="#d0e12914">Authenticated requests</a></dt><dt>17.10. <a href="#d0e12937">Build feature from Access Token</a></dt><dt>17.11. <a href="#d0e12971">Specifying Access Token on a Request.</a></dt><dt>17.12. <a href="#d0e12994">Creating Public/Private RSA-SHA1 keys</a></dt><dt>17.13. <a href="#d0e13093">Building OAuth 2 Authorization Flow.</a></dt><dt>18.1. <a href="#d0e13162">A simple WADL example - JAX-RS resource definition</a></dt><dt>18.2. <a href="#d0e13199">A simple WADL example - WADL content</a></dt><dt>18.3. <a href="#d0e13329">OPTIONS method returning WADL</a></dt><dt>18.4. <a href="#d0e13352">More complex WADL example - JAX-RS resource definition</a></dt><dt>18.5. <a href="#d0e13364">More complex WADL example - WADL content</a></dt><dt>19.1. <a href="#bv.example.jersey.properties">Configuring Jersey specific properties for Bean Validation.</a></dt><dt>19.2. <a href="#bv.example.ValidationConfig">Using <code class="literal">ValidationConfig</code> to configure <code class="literal">Validator</code>.</a></dt><dt>19.3. <a href="#bv.example.constraints">Constraint annotations on input parameters</a></dt><dt>19.4. <a href="#bv.example.constraints.fields">Constraint annotations on fields</a></dt><dt>19.5. <a href="#bv.example.constraints.class">Constraint annotations on class</a></dt><dt>19.6. <a href="#bv.example.constraints.definition">Definition of a constraint annotation</a></dt><dt>19.7. <a href="#bv.example.validator.definition">Validator implementation.</a></dt><dt>19.8. <a href="#bv.example.constraints.entity">Entity validation</a></dt><dt>19.9. <a href="#bv.example.constraints.entity2">Entity validation 2</a></dt><dt>19.10. <a href="#bv.example.constraints.entity.response">Response entity validation</a></dt><dt>19.11. <a href="#bv.example.validateonexecution">Validate getter on execution</a></dt><dt>19.12. <a href="#bv.examples.injecting">Injecting UriInfo into a ConstraintValidator</a></dt><dt>19.13. <a href="#bv.examples.injecting.factory">Support for injecting Jersey's resources/providers via ConstraintValidatorFactory.</a></dt><dt>19.14. <a href="#d0e14182"><code class="literal">ValidationError</code> to <code class="literal">text/plain</code></a></dt><dt>19.15. <a href="#d0e14192"><code class="literal">ValidationError</code> to <code class="literal">text/html</code></a></dt><dt>19.16. <a href="#d0e14202"><code class="literal">ValidationError</code> to <code class="literal">application/xml</code></a></dt><dt>19.17. <a href="#d0e14212"><code class="literal">ValidationError</code> to <code class="literal">application/json</code></a></dt><dt>20.1. <a href="#ef.example.server.registration">Registering and configuring entity-filtering feature on server.</a></dt><dt>20.2. <a href="#ef.example.server.security.registration">Registering and configuring entity-filtering feature with security annotations on server.</a></dt><dt>20.3. <a href="#ef.example.server.selectable.registration">Registering and configuring entity-filtering feature based on dynamic and configurable query parameters.</a></dt><dt>20.4. <a href="#ef.example.client.registration">Registering and configuring entity-filtering feature on client.</a></dt><dt>20.5. <a href="#d0e14393">Project</a></dt><dt>20.6. <a href="#d0e14399">User</a></dt><dt>20.7. <a href="#d0e14405">Task</a></dt><dt>20.8. <a href="#d0e14416">ProjectsResource</a></dt><dt>20.9. <a href="#ef.annotations.sample.annotation">ProjectDetailedView</a></dt><dt>20.10. <a href="#d0e14472">Annotated Project</a></dt><dt>20.11. <a href="#d0e14478">Annotated User</a></dt><dt>20.12. <a href="#d0e14484">Annotated Task</a></dt><dt>20.13. <a href="#d0e14537">ProjectsResource - Response entity-filtering annotations</a></dt><dt>20.14. <a href="#d0e14543">ProjectsResource - Entity-filtering annotations on methods</a></dt><dt>20.15. <a href="#d0e14654">Client - Request entity-filtering annotations</a></dt><dt>20.16. <a href="#d0e14660">Client - Request entity-filtering annotations</a></dt><dt>20.17. <a href="#d0e14735">Sever - Query Parameter driven entity-filtering</a></dt><dt>20.18. <a href="#d0e14749"></a></dt><dt>20.19. <a href="#ef.custom.annotations.annotation">Entity-filtering annotation with custom meaning</a></dt><dt>20.20. <a href="#ef.modules.custom">Entity Data Filtering support in MOXy JSON binding provider</a></dt><dt>21.1. <a href="#mvc.example.viewable.simple">Using <code class="literal">Viewable</code> in a resource class</a></dt><dt>21.2. <a href="#mvc.example.template.simple">Using <code class="literal">@Template</code> on a resource method</a></dt><dt>21.3. <a href="#mvc.example.implicit.class">Using <code class="literal">@Template</code> on a resource class</a></dt><dt>21.4. <a href="#mvc.example.viewable.absolutePath">Using absolute path to template in <code class="literal">Viewable</code></a></dt><dt>21.5. <a href="#mvc.example.error.simple">Using <code class="literal">@ErrorTemplate</code> on a resource method</a></dt><dt>21.6. <a href="#mvc.example.error.bv">Using <code class="literal">@ErrorTemplate</code> with Bean Validation</a></dt><dt>21.7. <a href="#mvc.example.error.bv.jsp">Iterating through <code class="literal">ValidationError</code> in JSP</a></dt><dt>21.8. <a href="#d0e15296">Registering <code class="literal">MvcFeature</code></a></dt><dt>21.9. <a href="#d0e15304">Registering <code class="literal">FreemarkerMvcFeature</code></a></dt><dt>21.10. <a href="#mvc.ex.rc.properties">Setting <code class="literal">MvcFeature.TEMPLATE_BASE_PATH</code> value in <code class="literal">ResourceConfig</code></a></dt><dt>21.11. <a href="#mvc.ex.web.xml.properties">Setting <code class="literal">FreemarkerMvcProperties.TEMPLATE_BASE_PATH</code> value in <code class="literal">web.xml</code></a></dt><dt>21.12. <a href="#d0e15659">Including JSP page into JSP page</a></dt><dt>21.13. <a href="#d0e15698">Custom TemplateProcessor</a></dt><dt>21.14. <a href="#d0e15706">Registering custom TemplateProcessor</a></dt><dt>22.1. <a href="#d0e15924">Logging on the client side</a></dt><dt>22.2. <a href="#d0e15941">Register <code class="literal">LoggingFeature</code> via constructor
                    </a></dt><dt>22.3. <a href="#d0e15958">Register <code class="literal">LoggingFeature</code> class
                    </a></dt><dt>23.1. <a href="#d0e16059">Application event listener</a></dt><dt>23.2. <a href="#d0e16065">Request event listener</a></dt><dt>23.3. <a href="#d0e16071">Event listener test resource</a></dt><dt>23.4. <a href="#d0e16276">Injecting MonitoringStatistics</a></dt><dt>23.5. <a href="#d0e16987">Summary level messages</a></dt><dt>23.6. <a href="#d0e17004">On demand request, snippet of MVC JSP forwarding</a></dt><dt>25.1. <a href="#d0e17379">Bootstrapping Jersey application with Weld support on Grizzly</a></dt></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a name="preface"></a>Preface</h1></div></div></div><p>
            This is user guide for Jersey 3.0.2. We are trying to keep it up to date as we add new features.
            When reading the user guide, please consult also our
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/index.html" target="_top">Jersey API documentation</a> as an additional source
            of information about Jersey features and API.
        </p><p>
            If you would like to contribute to the guide or have questions on things not covered in our docs, please
            contact us at <a class="link" href="mailto:jersey-dev@eclipse.org" target="_top">jersey-dev@eclipse.org</a>. Similarly,
            in case you spot any errors in the Jersey documentation, please report them by filing a new issue in our
            <a class="link" href="https://github.com/eclipse-ee4j/jersey/issues" target="_top">Jersey Issue Tracker</a>
            under
            <code class="literal">docs</code>
            component. Please make sure to specify the version of the Jersey User Guide where the error has been spotted
            by selecting the proper value for the
            <code class="literal">Affected Version</code>
            field.
        </p><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e28"></a>Text formatting conventions</h2></div></div></div><p>
                First mention of any Jersey and JAX-RS API component in a section links to the API documentation of the
                referenced component. Any sub-sequent mentions of the component in the same chapter are rendered using a
                <code class="literal">monospaced</code>
                font.
            </p><p>
                <span class="emphasis"><em>Emphasised font</em></span>
                is used to call attention to a newly introduce concept, when it first
                occurs in the text.
            </p><p>
                In some of the code listings, certain lines are too long to be displayed on one line for the available
                page width. In such case, the lines that exceed the available page width are broken up into multiple lines
                using a
                <code class="literal">'\'</code>
                at the end of each line to indicate that a break has been introduced to
                fit the line in the page. For example:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    gutter: false;">
This is an overly long line that \
might not fit the available page \
width and had to be broken into \
multiple lines.

This line fits the page width.
                </pre><p>

                Should read as:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    gutter: false;">
This is an overly long line that might not fit the available page width and had to be broken into multiple lines.

This line fits the page width.
                </pre><p>
            </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="getting-started"></a>Chapter&nbsp;1.&nbsp;Getting Started</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#new-from-archetype">1.1. Creating a New Project from Maven Archetype</a></span></dt><dt><span class="section"><a href="#new-project-structure">1.2. Exploring the Newly Created Project</a></span></dt><dt><span class="section"><a href="#running-project">1.3. Running the Project</a></span></dt><dt><span class="section"><a href="#new-webapp">1.4. Creating a JavaEE Web Application</a></span></dt><dt><span class="section"><a href="#heroku-webapp">1.5. Creating a Web Application that can be deployed on Heroku</a></span></dt><dd><dl><dt><span class="section"><a href="#deploy-it-on-heroku">1.5.1. Deploy it on Heroku</a></span></dt></dl></dd><dt><span class="section"><a href="#exploring-jersey-examples">1.6. Exploring Other Jersey Examples</a></span></dt></dl></div><p>
        This chapter provides a quick introduction on how to get started building RESTful services using Jersey.
        The example described here uses the lightweight Grizzly HTTP server. At the end of this chapter you will
        see how to implement equivalent functionality as a JavaEE web application you can deploy on any servlet
        container supporting Servlet 5 and higher.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-from-archetype"></a>1.1.&nbsp;Creating a New Project from Maven Archetype</h2></div></div></div><p>
            Jersey project is built using <a class="link" href="http://maven.apache.org/" target="_top">Apache Maven</a> software project build and management tool. All modules produced as
            part of Jersey project build are pushed to the <a class="link" href="https://search.maven.org/" target="_top">Central Maven Repository</a>. Therefore it is very convenient to work
            with Jersey for any Maven-based project as all the released (non-SNAPSHOT) Jersey dependencies are readily
            available without a need to configure a special maven repository to consume the Jersey modules.

            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    In case you want to depend on the latest SNAPSHOT versions of Jersey modules, the following repository
                    configuration needs to be added to your Maven project pom:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;snapshotRepository&gt;
                        &lt;id&gt;ossrh&lt;/id&gt;
                    &lt;name&gt;Sonatype Nexus Snapshots&lt;/name&gt;
                &lt;url&gt;https://jakarta.oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;
            &lt;/snapshotRepository&gt;</pre><p>
                </p></div><p>
        </p><p>
            Since starting from a Maven project is the most convenient way for working with Jersey, let's now have a look
            at this approach. We will now create a new Jersey project that runs on top of a <a class="link" href="https://javaee.github.io/grizzly/" target="_top">Grizzly</a> container. We will
            use a Jersey-provided maven archetype. To create the project, execute the following Maven command in the directory
            where the new project should reside:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn archetype:generate -DarchetypeArtifactId=jersey-quickstart-grizzly2 \
-DarchetypeGroupId=org.glassfish.jersey.archetypes -DinteractiveMode=false \
-DgroupId=com.example -DartifactId=simple-service -Dpackage=com.example \
-DarchetypeVersion=3.0.2</pre><p>

            Feel free to adjust the <code class="literal">groupId</code>, <code class="literal">package</code> and/or <code class="literal">artifactId</code>
            of your new project. Alternatively, you can change it by updating the new project pom.xml once it gets generated.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-project-structure"></a>1.2.&nbsp;Exploring the Newly Created Project</h2></div></div></div><p>
            Once the project generation from a Jersey maven archetype is successfully finished, you should see the new
            <code class="literal">simple-service</code> project directory created in your current location. The directory contains
            a standard Maven project structure:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                    Project build and management configuration is described in the <code class="literal">pom.xml</code> located
                    in the project root directory.
                </td></tr><tr><td>Project sources are located under <code class="literal">src/main/java</code>.</td></tr><tr><td>Project test sources are located under <code class="literal">src/test/java</code>.</td></tr></table><p>

            There are 2 classes in the project source directory in the <code class="literal">com.example</code> package.
            The <code class="literal">Main</code> class is responsible for bootstrapping the Grizzly container as well as configuring
            and deploying the project's JAX-RS application to the container. Another class in the same package
            is <code class="literal">MyResource</code> class, that contains implementation of a simple JAX-RS resource.
            It looks like this:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">package com.example;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

/**
 * Root resource (exposed at "myresource" path)
 */
@Path("myresource")
public class MyResource {

    /**
     * Method handling HTTP GET requests. The returned object will be sent
     * to the client as "text/plain" media type.
     *
     * @return String that will be returned as a text/plain response.
     */
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String getIt() {
        return "Got it!";
    }
}</pre><p>

            A JAX-RS resource is an annotated POJO that provides so-called <span class="emphasis"><em>resource methods</em></span> that
            are able to handle HTTP requests for URI paths that the resource is bound to. See
            <a class="xref" href="#jaxrs-resources" title="Chapter&nbsp;3.&nbsp;JAX-RS Application, Resources and Sub-Resources">Chapter&nbsp;3, <i>JAX-RS Application, Resources and Sub-Resources</i></a> for a complete guide to JAX-RS resources. In our case, the resource
            exposes a single resource method that is able to handle HTTP <code class="literal">GET</code> requests, is bound to
            <code class="literal">/myresource</code> URI path and can produce responses with response message content represented
            in <code class="literal">"text/plain"</code> media type. In this version, the resource returns the same
            <code class="literal">"Got it!"</code> response to all client requests.
        </p><p>
            The last piece of code that has been generated in this skeleton project is a <code class="literal">MyResourceTest</code>
            unit test class that is located in the same <code class="literal">com.example</code> package as the
            <code class="literal">MyResource</code> class, however, this unit test class is placed into the maven project test source
            directory <code class="literal">src/test/java</code> (certain code comments and JUnit imports have been excluded for brevity):

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">package com.example;

import jakarta.ws.rs.client.Client;
import jakarta.ws.rs.client.ClientBuilder;
import jakarta.ws.rs.client.WebTarget;

import org.glassfish.grizzly.http.server.HttpServer;

...

public class MyResourceTest {

    private HttpServer server;
    private WebTarget target;

    @Before
    public void setUp() throws Exception {
        server = Main.startServer();

        Client c = ClientBuilder.newClient();
        target = c.target(Main.BASE_URI);
    }

    @After
    public void tearDown() throws Exception {
        server.stop();
    }

    /**
     * Test to see that the message "Got it!" is sent in the response.
     */
    @Test
    public void testGetIt() {
        String responseMsg = target.path("myresource").request().get(String.class);
        assertEquals("Got it!", responseMsg);
    }
}</pre><p>

            In this unit test, a Grizzly container is first started and server application is deployed in the
            test <code class="literal">setUp()</code> method by a static call to <code class="literal">Main.startServer()</code>.
            Next, JAX-RS client components are created in the same test set-up method. First a new JAX-RS client
            instance <code class="literal">c</code> is built and then a JAX-RS web target component pointing to the context root of our
            application deployed at <code class="literal">http://localhost:8080/myapp/</code> (a value of
            <code class="literal">Main.BASE_URI</code> constant) is stored into a <code class="literal">target</code> field of the unit test class.
            This field is then used in the actual unit test method (<code class="literal">testGetIt()</code>).
        </p><p>
            In the <code class="literal">testGetIt()</code> method a fluent JAX-RS Client API is used to connect to and send
            a HTTP <code class="literal">GET</code> request to the <code class="literal">MyResource</code> JAX-RS resource class listening on
            <code class="literal">/myresource</code> URI. As part of the same fluent JAX-RS API method invocation chain, a response is
            read as a Java <code class="literal">String</code> type. On the second line in the test method, the response content string
            returned from the server is compared with the expected phrase in the test assertion. To learn more about using
            JAX-RS Client API, please see the <a class="xref" href="#client" title="Chapter&nbsp;5.&nbsp;Client API">Chapter&nbsp;5, <i>Client API</i></a> chapter.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="running-project"></a>1.3.&nbsp;Running the Project</h2></div></div></div><p>
            Now that we have seen the content of the project, let's try to test-run it. To do this, we need to invoke following
            command on the command line:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn clean test</pre><p>

            This will compile the project and run the project unit tests. We should see a similar output that informs about a
            successful build once the build is finished:

            </p><pre class="screen">Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 34.527s
[INFO] Finished at: Sun May 26 19:26:24 CEST 2020
[INFO] Final Memory: 17M/490M
[INFO] ------------------------------------------------------------------------</pre><p>

            Now that we have verified that the project compiles and that the unit test passes, we can execute the application
            in a standalone mode. To do this, run the following maven command:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn exec:java</pre><p>

            The application starts and you should soon see the following notification in your console:

            </p><pre class="screen">May 26, 2020 8:08:45 PM org.glassfish.grizzly.http.server.NetworkListener start
INFO: Started listener bound to [localhost:8080]
May 26, 2020 8:08:45 PM org.glassfish.grizzly.http.server.HttpServer start
INFO: [HttpServer] Started.
Jersey app started with WADL available at http://localhost:8080/myapp/application.wadl
Hit enter to stop it...</pre><p>

            This informs you that the application has been started and it's WADL descriptor is available at
            <code class="literal">http://localhost:8080/myapp/application.wadl</code> URL. You can retrieve the WADL content by
            executing a <code class="literal">curl http://localhost:8080/myapp/application.wadl</code> command in your console
            or by typing the WADL URL into your favorite browser. You should get back an XML document in describing
            your deployed RESTful application in a WADL format. To learn more about working with WADL, check the
            <a class="xref" href="#wadl" title="Chapter&nbsp;18.&nbsp;WADL Support">Chapter&nbsp;18, <i>WADL Support</i></a> chapter.
        </p><p>
            The last thing we should try before concluding this section is to see if we can communicate with our
            resource deployed at <code class="literal">/myresource</code> path. We can again either type the resource URL
            in the browser or we can use <code class="literal">curl</code>:

            </p><pre class="screen">$ curl http://localhost:8080/myapp/myresource
Got it!</pre><p>

            As we can see, the <code class="literal">curl</code> command returned with the <code class="literal">Got it!</code> message that
            was sent by our resource. We can also ask <code class="literal">curl</code> to provide more information about the response,
            for example we can let it display all response headers by using the <code class="literal">-i</code> switch:

            </p><pre class="screen">curl -i http://localhost:8080/myapp/myresource
HTTP/1.1 200 OK
Content-Type: text/plain
Date: Sun, 26 May 2020 18:27:19 GMT
Content-Length: 7

Got it!</pre><p>

            Here we see the whole content of the response message that our Jersey/JAX-RS application returned, including all
            the HTTP headers. Notice the <code class="literal">Content-Type: text/plain</code> header that was derived from the
            value of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> annotation attached to the <code class="literal">MyResource</code> class.
        </p><p>
            In case you want to see even more details about the communication between our <code class="literal">curl</code> client
            and our resource running on Jersey in a Grizzly I/O container, feel free to try other various options and switches
            that <code class="literal">curl</code> provides. For example, this last command will make <code class="literal">curl</code> output
            a lot of additional information about the whole communication:

            </p><pre class="screen">$ curl -v http://localhost:8080/myapp/myresource
*   Trying 127.0.0.1:8080...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 8080 (#0)
&gt; GET /myapp/myresource HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.68.0
&gt; Accept: */*
&gt;
* Mark bundle as not supporting multiuse
&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Date: Sun, 26 May 2020 18:29:18 GMT
&lt; Content-Length: 7
&lt;
* Connection #0 to host localhost left intact
Got it!</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-webapp"></a>1.4.&nbsp;Creating a JavaEE Web Application</h2></div></div></div><p>
            To create a Web Application that can be packaged as WAR and deployed in a Servlet container follow a similar process
            to the one described in <a class="xref" href="#new-from-archetype" title="1.1.&nbsp;Creating a New Project from Maven Archetype">Section&nbsp;1.1, &#8220;Creating a New Project from Maven Archetype&#8221;</a>.
            In addition to the Grizzly-based archetype, Jersey provides also a Maven archetype for creating web application
            skeletons. To create the new web application skeleton project, execute the following Maven command in the directory
            where the new project should reside:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn archetype:generate -DarchetypeArtifactId=jersey-quickstart-webapp \
                -DarchetypeGroupId=org.glassfish.jersey.archetypes -DinteractiveMode=false \
                -DgroupId=com.example -DartifactId=simple-service-webapp -Dpackage=com.example \
                -DarchetypeVersion=3.0.2</pre><p>

            As with the Grizzly based project, feel free to adjust the <code class="literal">groupId</code>, <code class="literal">package</code>
            and/or <code class="literal">artifactId</code> of your new web application project. Alternatively, you can change it by updating
            the new project <code class="literal">pom.xml</code> once it gets generated.
        </p><p>
            Once the project generation from a Jersey maven archetype is successfully finished, you should see the new
            <code class="literal">simple-service-webapp</code> project directory created in your current location. The directory contains
            a standard Maven project structure, similar to the <code class="literal">simple-service</code> project content we have seen
            earlier, except it is extended with an additional web application specific content:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                    Project build and management configuration is described in the <code class="literal">pom.xml</code> located
                    in the project root directory.
                </td></tr><tr><td>Project sources are located under <code class="literal">src/main/java</code>.</td></tr><tr><td>Project resources are located under <code class="literal">src/main/resources</code>.</td></tr><tr><td>Project web application files are located under <code class="literal">src/main/webapp</code>.</td></tr></table><p>

            The project contains the same <code class="literal">MyResouce</code> JAX-RS resource class. It does not contain any unit tests
            as well as it does not contain a <code class="literal">Main</code> class that was used to setup Grizzly container in the
            previous project. Instead, it contains the standard Java/Jakarta EE web application <code class="literal">web.xml</code> deployment
            descriptor under <code class="literal">src/main/webapp/WEB-INF</code>.
            The last component in the project is an <code class="literal">index.jsp</code> page that serves as a client for the
            <code class="literal">MyResource</code> resource class that is packaged and deployed with the application.
        </p><p>
            To compile and package the application into a WAR, invoke the following maven command in your console:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn clean package</pre><p>

            A successful build output will produce an output similar to the one below:

            </p><pre class="screen">Results :

Tests run: 0, Failures: 0, Errors: 0, Skipped: 0

[INFO]
[INFO] --- maven-war-plugin:2.2:war (default-war) @ simple-service-webapp ---
[INFO] Packaging webapp
[INFO] Assembling webapp [simple-service-webapp] in
[.../simple-service-webapp/target/simple-service-webapp]
[INFO] Processing war project
[INFO] Copying webapp resources [.../simple-service-webapp/src/main/webapp]
[INFO] Webapp assembled in [117 msecs]
[INFO] Building war: .../simple-service-webapp/target/simple-service-webapp.war
[INFO] WEB-INF/web.xml already added, skipping
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.419 s
[INFO] Finished at: 2020-11-25T09:34:59+01:00
[INFO] ------------------------------------------------------------------------
            </pre><p>

            Now you are ready to take the packaged WAR (located under <code class="literal">./target/simple-service-webapp.war</code>)
            and deploy it to a Servlet container of your choice.
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    To deploy a Jersey application, with full set of advanced features (such as JAX-RS 2.0 Async Support)
                    you will need a Servlet 5.0 or later  compliant container.
                </p></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="heroku-webapp"></a>1.5.&nbsp;Creating a Web Application that can be deployed on Heroku</h2></div></div></div><p>
            To create a Web Application that can be either packaged as WAR and deployed in a Servlet container or that can be
            pushed and deployed on <a class="link" href="https://www.heroku.com" target="_top">Heroku</a> the process is very similar to the one described in <a class="xref" href="#new-webapp" title="1.4.&nbsp;Creating a JavaEE Web Application">Section&nbsp;1.4, &#8220;Creating a JavaEE Web Application&#8221;</a>.
            To create the new web application skeleton project, execute the following Maven command in the directory
            where the new project should reside:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn archetype:generate -DarchetypeArtifactId=jersey-heroku-webapp \
                -DarchetypeGroupId=org.glassfish.jersey.archetypes -DinteractiveMode=false \
                -DgroupId=com.example -DartifactId=simple-heroku-webapp -Dpackage=com.example \
                -DarchetypeVersion=3.0.2</pre><p>

            Adjust the <code class="literal">groupId</code>, <code class="literal">package</code> and/or <code class="literal">artifactId</code> of your new web
            application project to your needs or, alternatively, you can change it by updating the new project <code class="literal">pom.xml</code> once it
            gets generated.
        </p><p>
            Once the project generation from a Jersey maven archetype is successfully finished, you should see the new
            <code class="literal">simple-heroku-webapp</code> project directory created in your current location. The directory contains
            a standard Maven project structure:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                    Project build and management configuration is described in the <code class="literal">pom.xml</code> located
                    in the project root directory.
                </td></tr><tr><td>Project sources are located under <code class="literal">src/main/java</code>.</td></tr><tr><td>Project resources are located under <code class="literal">src/main/resources</code>.</td></tr><tr><td>Project web application files are located under <code class="literal">src/main/webapp</code>.</td></tr><tr><td>Project test-sources (based on <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html" target="_top">JerseyTest</a>) are located under <code class="literal">src/test/java</code>.</td></tr><tr><td>Heroku system properties (OpenJDK version) are defined in <code class="literal">system.properties</code>.</td></tr><tr><td>Lists of the process types in an application for Heroku is in <code class="literal">Procfile</code>.</td></tr></table><p>

            The project contains one JAX-RS resource class, <code class="literal">MyResouce</code>, and one resource method which returns
            simple text message. To make sure the resource is properly tested there is also a end-to-end test-case
            in <code class="literal">MyResourceTest</code> (the test is based on <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html" target="_top">JerseyTest</a> from our <a class="xref" href="#test-framework" title="Chapter&nbsp;26.&nbsp;Jersey Test Framework">Chapter&nbsp;26, <i>Jersey Test Framework</i></a>).
            Similarly to <code class="literal">simple-service-webapp</code>, the project contains the standard Java/Jakarta EE web application
            <code class="literal">web.xml</code> deployment descriptor under <code class="literal">src/main/webapp/WEB-INF</code> since the goal is to
            deploy the application in a Servlet container (the application will run in Jetty on Heroku).
        </p><p>
            To compile and package the application into a WAR, invoke the following maven command in your console:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn clean package</pre><p>

            A successful build output will produce an output similar to the one below:

            </p><pre class="screen">    Results :

    Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

    [INFO]
    [INFO] --- maven-war-plugin:2.2:war (default-war) @ simple-heroku-webapp ---
    [INFO] Packaging webapp
    [INFO] Assembling webapp [simple-heroku-webapp] in [.../simple-heroku-webapp/target/simple-heroku-webapp]
    [INFO] Processing war project
    [INFO] Copying webapp resources [.../simple-heroku-webapp/src/main/webapp]
    [INFO] Webapp assembled in [109 msecs]
    [INFO] Building war: .../simple-heroku-webapp/target/simple-heroku-webapp.war
    [INFO] WEB-INF/web.xml already added, skipping
    [INFO]
    [INFO] --- maven-dependency-plugin:2.8:copy-dependencies (copy-dependencies) @ simple-heroku-webapp ---
    [INFO] Copying jakarta.validation-api-3.0.0.jar to ../simple-heroku-webapp/target/dependency/jakarta.validation-api-3.0.0.jar
    [INFO] Copying javassist-3.25.0-GA.jar to ../simple-heroku-webapp/target/dependency/javassist-3.25.0-GA.jar
    [INFO] Copying jersey-client-3.0.0.jar to ../simple-heroku-webapp/target/dependency/jersey-client-3.1.0-SNAPSHOT.jar
    [INFO] Copying jersey-hk2-3.0.0.jar to ../simple-heroku-webapp/target/dependency/jersey-hk2-3.1.0-SNAPSHOT.jar
    [INFO] Copying jetty-util-11.0.0.beta3.jar to ../simple-heroku-webapp/target/dependency/jetty-util-11.0.0.beta3.jar
    [INFO] Copying jakarta.annotation-api-2.0.0.jar to ../simple-heroku-webapp/target/dependency/jakarta.annotation-api-2.0.0.jar
    [INFO] Copying jersey-common-3.0.0.jar to ../simple-heroku-webapp/target/dependency/jersey-common-3.1.0-SNAPSHOT.jar
    [INFO] Copying jersey-container-servlet-core-3.0.0.jar to ../simple-heroku-webapp/target/dependency/jersey-container-servlet-core-3.1.0-SNAPSHOT.jar
    [INFO] Copying jakarta.activation-2.0.0.jar to ../simple-heroku-webapp/target/dependency/jakarta.activation-2.0.0.jar
    [INFO] Copying jetty-webapp-11.0.0.beta3.jar to ../simple-heroku-webapp/target/dependency/jetty-webapp-11.0.0.beta3.jar
    [INFO] Copying osgi-resource-locator-1.0.3.jar to ../simple-heroku-webapp/target/dependency/osgi-resource-locator-1.0.3.jar
    [INFO] Copying jersey-container-servlet-3.0.0.jar to ../simple-heroku-webapp/target/dependency/jersey-container-servlet-3.1.0-SNAPSHOT.jar
    [INFO] Copying jetty-io-11.0.0.beta3.jar to ../simple-heroku-webapp/target/dependency/jetty-io-11.0.0.beta3.jar
    [INFO] Copying slf4j-api-2.0.0-alpha1.jar to ../simple-heroku-webapp/target/dependency/slf4j-api-2.0.0-alpha1.jar
    [INFO] Copying jetty-server-11.0.0.beta3.jar to ../simple-heroku-webapp/target/dependency/jetty-server-11.0.0.beta3.jar
    [INFO] Copying jakarta.ws.rs-api-3.0.0.jar to ../simple-heroku-webapp/target/dependency/jakarta.ws.rs-api-3.0.0.jar
    [INFO] Copying jetty-servlet-11.0.0.beta3.jar to ../simple-heroku-webapp/target/dependency/jetty-servlet-11.0.0.beta3.jar
    [INFO] Copying hk2-locator-3.0.0-RC1.jar to ../simple-heroku-webapp/target/dependency/hk2-locator-3.0.0-RC1.jar
    [INFO] Copying hk2-utils-3.0.0-RC1.jar to ../simple-heroku-webapp/target/dependency/hk2-utils-3.0.0-RC1.jar
    [INFO] Copying jetty-xml-11.0.0.beta3.jar to ../simple-heroku-webapp/target/dependency/jetty-xml-11.0.0.beta3.jar
    [INFO] Copying hk2-api-3.0.0-RC1.jar to ../simple-heroku-webapp/target/dependency/hk2-api-3.0.0-RC1.jar
    [INFO] Copying jetty-security-11.0.0.beta3.jar to ../simple-heroku-webapp/target/dependency/jetty-security-11.0.0.beta3.jar
    [INFO] Copying jetty-http-11.0.0.beta3.jar to ../simple-heroku-webapp/target/dependency/jetty-http-11.0.0.beta3.jar
    [INFO] Copying jersey-server-3.0.0.jar to ../simple-heroku-webapp/target/dependency/jersey-server-3.1.0-SNAPSHOT.jar
    [INFO] Copying jakarta.inject-api-2.0.0.jar to ../simple-heroku-webapp/target/dependency/jakarta.inject-api-2.0.0.jar
    [INFO] Copying jetty-jakarta-servlet-api-5.0.1.jar to ../simple-heroku-webapp/target/dependency/jetty-jakarta-servlet-api-5.0.1.jar
    [INFO] Copying aopalliance-repackaged-3.0.0-RC1.jar to ../simple-heroku-webapp/target/dependency/aopalliance-repackaged-3.0.0-RC1.jar
    [INFO] ------------------------------------------------------------------------
    [INFO] BUILD SUCCESS
    [INFO] ------------------------------------------------------------------------
    [INFO] Total time:  12.567 s
    [INFO] Finished at: 2021-01-05T15:16:05+01:00
    [INFO] ------------------------------------------------------------------------</pre><p>

            Now that you know everything went as expected you are ready to:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                    make some changes in your project,
                </li><li class="listitem">
                    take the packaged WAR (located under <code class="literal">./target/simple-service-webapp.war</code>) and deploy it to a
                    Servlet container of your choice, or
                </li><li class="listitem">
                    <a class="xref" href="#deploy-it-on-heroku" title="1.5.1.&nbsp;Deploy it on Heroku">Section&nbsp;1.5.1, &#8220;Deploy it on Heroku&#8221;</a>
                </li></ul></div><p>

            </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                    If you want to make some changes to your application you can run the application locally by simply running
                    <code class="code">mvn clean package jetty:run</code> (which starts the embedded Jetty server) or by
                    <code class="code">java -cp target/classes:target/dependency/* com.example.heroku.Main</code> (this is how Jetty is
                    started on Heroku).
                </p></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deploy-it-on-heroku"></a>1.5.1.&nbsp;Deploy it on Heroku</h3></div></div></div><p>
                We won't go into details how to create an account on <a class="link" href="https://www.heroku.com" target="_top">Heroku</a> and setup the <code class="literal">Heroku</code> tools
                on your machine. You can find a lot of information in this article: <a class="link" href="https://devcenter.heroku.com/articles/getting-started-with-java" target="_top">Getting Started with Java on Heroku</a>.
                Instead, we'll take a look at the steps needed after your environment is ready.
            </p><p>
                The first step is to create a Git repository from your project:
                </p><pre class="screen">    $ git init
    Initialized empty Git repository in /.../simple-heroku-webapp/.git/</pre><p>
            </p><p>
                Then, create a <a class="link" href="https://www.heroku.com" target="_top">Heroku</a> instance and add a remote reference to your Git repository:
                </p><pre class="screen">    $ heroku create
    Creating simple-heroku-webapp... done, stack is cedar
    http://simple-heroku-webapp.herokuapp.com/ | git@heroku.com:simple-heroku-webapp.git
    Git remote heroku added</pre><p>

                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        The name of the instance is changed in the output to <code class="literal">simple-heroku-webapp</code>. Your will be
                        named more like <code class="literal">tranquil-basin-4744</code>.
                    </p></div><p>
            </p><p>
                Add and commit files to your Git repository:
                </p><pre class="screen">    $ git add src/ pom.xml Procfile system.properties</pre><p>
                </p><pre class="screen">    $ git commit -a -m "initial commit"
    [master (root-commit) e2b58e3] initial commit
     7 files changed, 221 insertions(+)
     create mode 100644 Procfile
     create mode 100644 pom.xml
     create mode 100644 src/main/java/com/example/MyResource.java
     create mode 100644 src/main/java/com/example/heroku/Main.java
     create mode 100644 src/main/webapp/WEB-INF/web.xml
     create mode 100644 src/test/java/com/example/MyResourceTest.java
     create mode 100644 system.properties</pre><p>
            </p><p>
                Push changes to Heroku:
                </p><pre class="screen">    $ git push heroku master
    Counting objects: 21, done.
    Delta compression using up to 8 threads.
    Compressing objects: 100% (11/11), done.
    Writing objects: 100% (21/21), 3.73 KiB | 0 bytes/s, done.
    Total 21 (delta 0), reused 0 (delta 0)

    -----&gt; Java app detected
    -----&gt; Installing OpenJDK 1.8... done
    -----&gt; Installing Maven 3.6.3... done
    -----&gt; Installing settings.xml... done
    -----&gt; executing /app/tmp/cache/.maven/bin/mvn -B -Duser.home=/tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd -Dmaven.repo.local=/app/tmp/cache/.m2/repository -s /app/tmp/cache/.m2/settings.xml -DskipTests=true clean install
           [INFO] Scanning for projects...
           [INFO]
           [INFO] ------------------------------------------------------------------------
           [INFO] Building simple-heroku-webapp 1.0-SNAPSHOT
           [INFO] ------------------------------------------------------------------------
           [INFO]
           [INFO] --- maven-clean-plugin:2.4.1:clean (default-clean) @ simple-heroku-webapp ---
           [INFO]
           [INFO] --- maven-resources-plugin:2.4.3:resources (default-resources) @ simple-heroku-webapp ---
           [INFO] Using 'UTF-8' encoding to copy filtered resources.
           [INFO] skip non existing resourceDirectory /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/src/main/resources
           [INFO]
           [INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ simple-heroku-webapp ---
           [INFO] Compiling 2 source files to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/classes
           [INFO]
           [INFO] --- maven-resources-plugin:2.4.3:testResources (default-testResources) @ simple-heroku-webapp ---
           [INFO] Using 'UTF-8' encoding to copy filtered resources.
           [INFO] skip non existing resourceDirectory /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/src/test/resources
           [INFO]
           [INFO] --- maven-compiler-plugin:2.5.1:testCompile (default-testCompile) @ simple-heroku-webapp ---
           [INFO] Compiling 1 source file to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/test-classes
           [INFO]
           [INFO] --- maven-surefire-plugin:2.7.2:test (default-test) @ simple-heroku-webapp ---
           [INFO] Tests are skipped.
           [INFO]
           [INFO] --- maven-war-plugin:2.1.1:war (default-war) @ simple-heroku-webapp ---
           [INFO] Packaging webapp
           [INFO] Assembling webapp [simple-heroku-webapp] in [/tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/simple-heroku-webapp]
           [INFO] Processing war project
           [INFO] Copying webapp resources [/tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/src/main/webapp]
           [INFO] Webapp assembled in [88 msecs]
           [INFO] Building war: /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/simple-heroku-webapp.war
           [INFO] WEB-INF/web.xml already added, skipping
           [INFO]
           [INFO] --- maven-dependency-plugin:2.1:copy-dependencies (copy-dependencies) @ simple-heroku-webapp ---
           [INFO] Copying guava-14.0.1.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/guava-14.0.1.jar
           [INFO] Copying jakarta.annotation-api-1.2.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jakarta.annotation-api-1.2.jar
           [INFO] Copying validation-api-1.1.0.Final.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/validation-api-1.1.0.Final.jar
           [INFO] Copying jakarta.ws.rs-api-2.0.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jakarta.ws.rs-api-2.0.jar
           [INFO] Copying jetty-http-9.0.6.v20130930.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jetty-http-9.0.6.v20130930.jar
           [INFO] Copying jetty-io-9.0.6.v20130930.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jetty-io-9.0.6.v20130930.jar
           [INFO] Copying jetty-security-9.0.6.v20130930.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jetty-security-9.0.6.v20130930.jar
           [INFO] Copying jetty-server-9.0.6.v20130930.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jetty-server-9.0.6.v20130930.jar
           [INFO] Copying jetty-servlet-9.0.6.v20130930.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jetty-servlet-9.0.6.v20130930.jar
           [INFO] Copying jetty-util-9.0.6.v20130930.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jetty-util-9.0.6.v20130930.jar
           [INFO] Copying jetty-webapp-9.0.6.v20130930.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jetty-webapp-9.0.6.v20130930.jar
           [INFO] Copying jetty-xml-9.0.6.v20130930.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jetty-xml-9.0.6.v20130930.jar
           [INFO] Copying javax.servlet-3.0.0.v201112011016.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/javax.servlet-3.0.0.v201112011016.jar
           [INFO] Copying hk2-api-2.2.0-b21.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/hk2-api-2.2.0-b21.jar
           [INFO] Copying hk2-locator-2.2.0-b21.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/hk2-locator-2.2.0-b21.jar
           [INFO] Copying hk2-utils-2.2.0-b21.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/hk2-utils-2.2.0-b21.jar
           [INFO] Copying osgi-resource-locator-1.0.1.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/osgi-resource-locator-1.0.1.jar
           [INFO] Copying asm-all-repackaged-2.2.0-b21.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/asm-all-repackaged-2.2.0-b21.jar
           [INFO] Copying cglib-2.2.0-b21.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/cglib-2.2.0-b21.jar
           [INFO] Copying jakarta.inject-2.2.0-b21.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jakarta.inject-2.2.0-b21.jar
           [INFO] Copying jersey-container-servlet-2.5.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jersey-container-servlet-2.5.jar
           [INFO] Copying jersey-container-servlet-core-2.5.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jersey-container-servlet-core-2.5.jar
           [INFO] Copying jersey-client-2.5.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jersey-client-2.5.jar
           [INFO] Copying jersey-common-2.5.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jersey-common-2.5.jar
           [INFO] Copying jersey-server-2.5.jar to /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/dependency/jersey-server-2.5.jar
           [INFO]
           [INFO] --- maven-install-plugin:2.3.1:install (default-install) @ simple-heroku-webapp ---
           [INFO] Installing /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/target/simple-heroku-webapp.war to /app/tmp/cache/.m2/repository/com/example/simple-heroku-webapp/1.0-SNAPSHOT/simple-heroku-webapp-1.0-SNAPSHOT.war
           [INFO] Installing /tmp/build_992cc747-26d6-4800-bdb1-add47b9583cd/pom.xml to /app/tmp/cache/.m2/repository/com/example/simple-heroku-webapp/1.0-SNAPSHOT/simple-heroku-webapp-1.0-SNAPSHOT.pom
           [INFO] ------------------------------------------------------------------------
           [INFO] BUILD SUCCESS
           [INFO] ------------------------------------------------------------------------
           [INFO] Total time: 45.861s
           [INFO] Finished at: Mon Dec 09 19:51:34 UTC 2013
           [INFO] Final Memory: 17M/514M
           [INFO] ------------------------------------------------------------------------
    -----&gt; Discovering process types
           Procfile declares types -&gt; web

    -----&gt; Compiled slug size: 75.9MB
    -----&gt; Launching... done, v6
           http://simple-heroku-webapp.herokuapp.com deployed to Heroku

    To git@heroku.com:simple-heroku-webapp.git
     * [new branch]      master -&gt; master</pre><p>
            </p><p>
                Now you can access your application at, for example: <a class="link" href="http://simple-heroku-webapp.herokuapp.com/myresource" target="_top">http://simple-heroku-webapp.herokuapp.com/myresource</a>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exploring-jersey-examples"></a>1.6.&nbsp;Exploring Other Jersey Examples</h2></div></div></div><p>
            In the sections above, we have covered an approach how to get dirty with Jersey quickly. Please consult the other
            sections of the Jersey User Guide to learn more about Jersey and JAX-RS.
            Even though we try our best to cover as much as possible in the User Guide, there is always a chance that you would
            not be able to get a full answer to the problem you are solving. In that case, consider diving in our examples that
            provide additional tips and hints to the features you may want to use in your projects.
        </p><p>
            Jersey codebase contains a number of useful examples on how to use various JAX-RS and Jersey features.
            Feel free to browse through the code of individual
            <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples" target="_top">Jersey Examples</a> in the Jersey source repository.
            For off-line browsing, you can also download a bundle with all the examples from
            <a class="link" href="https://repo1.maven.org/maven2/org/glassfish/jersey/bundles/jersey-examples/3.0.2/" target="_top">here</a>.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="modules-and-dependencies"></a>Chapter&nbsp;2.&nbsp;Modules and dependencies</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e559">2.1. Java SE Compatibility</a></span></dt><dt><span class="section"><a href="#d0e575">2.2. Introduction to Jersey dependencies</a></span></dt><dt><span class="section"><a href="#dependencies">2.3. Common Jersey Use Cases</a></span></dt><dd><dl><dt><span class="section"><a href="#servlet-app-glassfish">2.3.1. Servlet based application on Glassfish</a></span></dt><dt><span class="section"><a href="#servlet-app-general">2.3.2. Servlet based server-side application</a></span></dt><dt><span class="section"><a href="#client-jdk">2.3.3. Client application on JDK</a></span></dt><dt><span class="section"><a href="#server-jdk">2.3.4. Server-side application on supported containers</a></span></dt></dl></dd><dt><span class="section"><a href="#modules">2.4. List of modules</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e559"></a>2.1.&nbsp;Java SE Compatibility</h2></div></div></div><p>
            <span class="emphasis"><em>3.x branch: </em></span>
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>This user guide refers only to version 3 and above of Jersey, its compatibility is described below</p></li><li class="listitem"><p>Since version 3.0.0* all Jersey components are compiled with Java SE 1.8 target.
                    It means, that you will need at least Java SE 1.8 to be able to compile and run your application
                        which uses the latest Jersey 3.x.
                    All modules however are fully compatible with JDK 11 and above. So, it's possible to use JDK 11+ to
                        build your app.
                    </p></li></ul></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e575"></a>2.2.&nbsp;Introduction to Jersey dependencies</h2></div></div></div><p>
            Jersey is built, assembled and installed using <a class="link" href="http://maven.apache.org/" target="_top">Apache Maven</a>.
            Non-snapshot Jersey releases are deployed to the
            <a class="link" href="https://search.maven.org/" target="_top">Central Maven Repository</a>. Jersey is also being deployed to
            <a class="link" href="https://oss.sonatype.org/" target="_top">Sonatype Maven repositories</a>, which contain also Jersey SNAPSHOT
            versions. In case you would want to test the latest development builds check out the
            <a class="link" href="https://oss.sonatype.org/content/repositories/snapshots/org/glassfish/jersey" target="_top">
                Sonatype Snapshots Maven repository</a>.
        </p><p>
            An application that uses Jersey and depends on Jersey modules is in turn required to also include a set
            of 3rd party modules that Jersey modules depend on. Jersey is designed as a pluggable component
            architecture and different applications can therefore require different sets of Jersey modules. This also means that
            a set of external Jersey dependencies required to be included in the application dependencies may vary in each
            application based on the Jersey modules that are being used by the application.
        </p><p>
            Developers using Maven or a Maven-aware build system in their projects are likely to find it easier to include and
            manage dependencies of their applications compared to developers using ant or other build systems that are not
            compatible with Maven. This document will explain to both maven and non-maven developers how to depend on
            Jersey modules in their application. Ant developers are likely to find the
            <a class="link" href="http://maven.apache.org/ant-tasks/index.html" target="_top">Ant Tasks for Maven</a> very useful.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dependencies"></a>2.3.&nbsp;Common Jersey Use Cases</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="servlet-app-glassfish"></a>2.3.1.&nbsp;Servlet based application on Glassfish</h3></div></div></div><p>If you are using Glassfish application server, you don't need to package
                anything with your application, everything is already included. You just need to declare
                (provided) dependency on JAX-RS API to be able to compile your application.
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;jakarta.ws.rs&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.ws.rs-api&lt;/artifactId&gt;
    &lt;version&gt;3.0.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre><p>If you are using any Jersey specific feature, you will need to depend on Jersey directly.</p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- if you are using Jersey client specific features without the server side --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
            </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="servlet-app-general"></a>2.3.2.&nbsp;Servlet based server-side application</h3></div></div></div><p>Following dependencies apply to application server (servlet containers) without any
                integrated JAX-RS implementation. Then application needs to include JAX-RS API and Jersey
                implementation in deployed application.</p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Required only when you are using JAX-RS Client --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="client-jdk"></a>2.3.3.&nbsp;Client application on JDK</h3></div></div></div><p>Applications running on plain JDK using only client part of JAX-RS specification need
                to depend only on client. There are various additional modules which can be added, like
                for example grizzly or apache or jetty connector (see dependencies snipped below). Jersey client
                runs by default with plain JDK (using HttpUrlConnection). See <a class="xref" href="#client" title="Chapter&nbsp;5.&nbsp;Client API">Chapter&nbsp;5, <i>Client API</i></a>.
                for more details.
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;
            </pre><p>Currently available connectors:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.connectors&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-grizzly-connector&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.connectors&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-apache-connector&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.connectors&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-jetty-connector&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="server-jdk"></a>2.3.4.&nbsp;Server-side application on supported containers</h3></div></div></div><p>Apart for a standard JAX-RS Servlet-based deployment that works with any Servlet container that
                supports Servlet 5 and higher,
                Jersey provides support for programmatic deployment to the following containers: Grizzly 3 (HTTP and Servlet),
                JDK Http server, Simple Http server and Jetty Http server (requires JDK 11+). This chapter presents only
                required maven dependencies,
                more information can be found in <a class="xref" href="#deployment" title="Chapter&nbsp;4.&nbsp;Application Deployment and Runtime Environments">Chapter&nbsp;4, <i>Application Deployment and Runtime Environments</i></a>.
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-grizzly2-http&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-grizzly2-servlet&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-jdk-http&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-simple-http&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-jetty-http&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-jetty-servlet&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><div lang="en" class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="modules"></a>2.4.&nbsp;List of modules</h2></div></div></div><p>The following chapters provide an overview of all Jersey modules
        and their dependencies with links to the respective binaries (follow a link
        on a module name to get complete set of downloadable dependencies).
    </p><div class="table"><a name="dependencies-table-org.glassfish.jersey.core"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Jersey Core</b></p><div class="table-contents"><table summary="Jersey Core" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Jersey Core</th></tr></thead><tbody><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/jersey-client/dependencies.html" target="_top">
    jersey-client
</a>
</td><td align="left">Jersey core client implementation</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/jersey-common/dependencies.html" target="_top">
    jersey-common
</a>
</td><td align="left">Jersey core common packages</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/jersey-server/dependencies.html" target="_top">
    jersey-server
</a>
</td><td align="left">Jersey core server implementation</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-org.glassfish.jersey.containers"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Jersey Containers</b></p><div class="table-contents"><table summary="Jersey Containers" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Jersey Containers</th></tr></thead><tbody><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-container-grizzly2-http/dependencies.html" target="_top">
    jersey-container-grizzly2-http
</a>
</td><td align="left">Grizzly 2 Http Container.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-container-grizzly2-servlet/dependencies.html" target="_top">
    jersey-container-grizzly2-servlet
</a>
</td><td align="left">Grizzly 2 Servlet Container.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-container-jdk-http/dependencies.html" target="_top">
    jersey-container-jdk-http
</a>
</td><td align="left">JDK Http Container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-container-jetty-http/dependencies.html" target="_top">
    jersey-container-jetty-http
</a>
</td><td align="left">Jetty Http Container (for JDK 11+)</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-container-jetty-servlet/dependencies.html" target="_top">
    jersey-container-jetty-servlet
</a>
</td><td align="left">Jetty Servlet Container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-container-netty-http/dependencies.html" target="_top">
    jersey-container-netty-http
</a>
</td><td align="left">Netty Http Container.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-container-servlet/dependencies.html" target="_top">
    jersey-container-servlet
</a>
</td><td align="left">Jersey core Servlet 3.x/5.x implementation</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-container-servlet-core/dependencies.html" target="_top">
    jersey-container-servlet-core
</a>
</td><td align="left">Jersey core Servlet 2.x way implementation with Jakarta EE 9 adjustments</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-container-simple-http/dependencies.html" target="_top">
    jersey-container-simple-http
</a>
</td><td align="left">Simple Http Container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-gf-ejb/dependencies.html" target="_top">
    jersey-gf-ejb
</a>
</td><td align="left">Jersey EJB for GlassFish integration</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-org.glassfish.jersey.connectors"></a><p class="title"><b>Table&nbsp;2.3.&nbsp;Jersey Connectors</b></p><div class="table-contents"><table summary="Jersey Connectors" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Jersey Connectors</th></tr></thead><tbody><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-apache-connector/dependencies.html" target="_top">
    jersey-apache-connector
</a>
</td><td align="left">Jersey Client Transport via Apache</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-grizzly-connector/dependencies.html" target="_top">
    jersey-grizzly-connector
</a>
</td><td align="left">Jersey Client Transport via Grizzly</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-jdk-connector/dependencies.html" target="_top">
    jersey-jdk-connector
</a>
</td><td align="left">Jersey Client Transport via JDK connector</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-jetty-connector/dependencies.html" target="_top">
    jersey-jetty-connector
</a>
</td><td align="left">Jersey Client Transport via Jetty (for JDK 11+)</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-netty-connector/dependencies.html" target="_top">
    jersey-netty-connector
</a>
</td><td align="left">Jersey Client Transport via Netty</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-org.glassfish.jersey.media"></a><p class="title"><b>Table&nbsp;2.4.&nbsp;Jersey Media</b></p><div class="table-contents"><table summary="Jersey Media" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Jersey Media</th></tr></thead><tbody><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-jaxb/dependencies.html" target="_top">
    jersey-media-jaxb
</a>
</td><td align="left">JAX-RS features based upon JAX-B.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-binding/dependencies.html" target="_top">
    jersey-media-json-binding
</a>
</td><td align="left">Jersey JSON-B support module.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-jackson/dependencies.html" target="_top">
    jersey-media-json-jackson
</a>
</td><td align="left">Jersey JSON Jackson (2.x) entity providers support module.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-jettison/dependencies.html" target="_top">
    jersey-media-json-jettison
</a>
</td><td align="left">Jersey JSON Jettison entity providers support module.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-processing/dependencies.html" target="_top">
    jersey-media-json-processing
</a>
</td><td align="left">Jersey Jakarta JSON Processing entity providers support proxy module.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-kryo/dependencies.html" target="_top">
    jersey-media-kryo
</a>
</td><td align="left">Jersey/JAX-RS Message Body Writer and Reader using Kryo serialization framework</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-moxy/dependencies.html" target="_top">
    jersey-media-moxy
</a>
</td><td align="left">Jersey JSON entity providers support module based on EclipseLink MOXy.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-multipart/dependencies.html" target="_top">
    jersey-media-multipart
</a>
</td><td align="left">Jersey Multipart entity providers support module.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-sse/dependencies.html" target="_top">
    jersey-media-sse
</a>
</td><td align="left">Jersey Server Sent Events entity providers support module.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-org.glassfish.jersey.ext"></a><p class="title"><b>Table&nbsp;2.5.&nbsp;Jersey Extensions</b></p><div class="table-contents"><table summary="Jersey Extensions" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Jersey Extensions</th></tr></thead><tbody><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-bean-validation/dependencies.html" target="_top">
    jersey-bean-validation
</a>
</td><td align="left">Jersey extension module providing support for Bean Validation (JSR-349) API.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-cdi1x/dependencies.html" target="_top">
    jersey-cdi1x
</a>
</td><td align="left">Jersey CDI 1.1 integration</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-cdi1x-ban-custom-hk2-binding/dependencies.html" target="_top">
    jersey-cdi1x-ban-custom-hk2-binding
</a>
</td><td align="left">Jersey CDI integration - this module disables custom HK2 bindings</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-cdi1x-servlet/dependencies.html" target="_top">
    jersey-cdi1x-servlet
</a>
</td><td align="left">Jersey CDI 1.x Servlet Support</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-cdi1x-transaction/dependencies.html" target="_top">
    jersey-cdi1x-transaction
</a>
</td><td align="left">Jersey CDI 1.x Transactional Support</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-cdi1x-validation/dependencies.html" target="_top">
    jersey-cdi1x-validation
</a>
</td><td align="left">Jersey CDI 1.x Bean Validation Support</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-declarative-linking/dependencies.html" target="_top">
    jersey-declarative-linking
</a>
</td><td align="left">Jersey support for declarative hyperlinking.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-entity-filtering/dependencies.html" target="_top">
    jersey-entity-filtering
</a>
</td><td align="left">Jersey extension module providing support for Entity Data Filtering.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-metainf-services/dependencies.html" target="_top">
    jersey-metainf-services
</a>
</td><td align="left">Jersey extension module enabling automatic registration of JAX-RS providers (MBW/MBR/EM) via META-INF/services mechanism.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-mvc/dependencies.html" target="_top">
    jersey-mvc
</a>
</td><td align="left">Jersey extension module providing support for MVC.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-mvc-bean-validation/dependencies.html" target="_top">
    jersey-mvc-bean-validation
</a>
</td><td align="left">Jersey extension module providing support for Bean Validation in MVC.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-mvc-freemarker/dependencies.html" target="_top">
    jersey-mvc-freemarker
</a>
</td><td align="left">Jersey extension module providing support for Freemarker templates.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-mvc-jsp/dependencies.html" target="_top">
    jersey-mvc-jsp
</a>
</td><td align="left">Jersey extension module providing support for JSP templates.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-mvc-mustache/dependencies.html" target="_top">
    jersey-mvc-mustache
</a>
</td><td align="left">Jersey extension module providing support for Mustache templates.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-proxy-client/dependencies.html" target="_top">
    jersey-proxy-client
</a>
</td><td align="left">Jersey extension module providing support for (proxy-based) high-level client API.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-rx-client-guava/dependencies.html" target="_top">
    jersey-rx-client-guava
</a>
</td><td align="left">Jersey Reactive Client - Guava (ListenableFuture) provider.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-rx-client-rxjava/dependencies.html" target="_top">
    jersey-rx-client-rxjava
</a>
</td><td align="left">Jersey Reactive Client - RxJava (Observable) provider.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-rx-client-rxjava2/dependencies.html" target="_top">
    jersey-rx-client-rxjava2
</a>
</td><td align="left">Jersey Reactive Client - RxJava2 (Flowable) provider.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-wadl-doclet/dependencies.html" target="_top">
    jersey-wadl-doclet
</a>
</td><td align="left">A doclet that generates a resourcedoc xml file: this file contains the javadoc documentation
        of resource classes, so that this can be used for extending generated wadl with useful
        documentation.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-weld2-se/dependencies.html" target="_top">
    jersey-weld2-se
</a>
</td><td align="left">WELD 2.x SE support</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-org.glassfish.jersey.test-framework"></a><p class="title"><b>Table&nbsp;2.6.&nbsp;Jersey Test Framework</b></p><div class="table-contents"><table summary="Jersey Test Framework" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Jersey Test Framework</th></tr></thead><tbody><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/container-runner-maven-plugin/dependencies.html" target="_top">
    container-runner-maven-plugin
</a>
</td><td align="left">The container runner maven plugin provides means to start and stop a container (currently Tomcat 10 and Glassfish 6
        are supported). To deploy an application to this container or to repetitively redeploy and test an application in the container.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/custom-enforcer-rules/dependencies.html" target="_top">
    custom-enforcer-rules
</a>
</td><td align="left">Jersey test framework Maven projects</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-test-framework-core/dependencies.html" target="_top">
    jersey-test-framework-core
</a>
</td><td align="left">Jersey Test Framework Core</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-bundle/dependencies.html" target="_top">
    jersey-test-framework-provider-bundle
</a>
</td><td align="left">Jersey Test Framework Providers Bundle</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-external/dependencies.html" target="_top">
    jersey-test-framework-provider-external
</a>
</td><td align="left">Jersey Test Framework - External container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-grizzly2/dependencies.html" target="_top">
    jersey-test-framework-provider-grizzly2
</a>
</td><td align="left">Jersey Test Framework - Grizzly2 container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-inmemory/dependencies.html" target="_top">
    jersey-test-framework-provider-inmemory
</a>
</td><td align="left">Jersey Test Framework - InMemory container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-jdk-http/dependencies.html" target="_top">
    jersey-test-framework-provider-jdk-http
</a>
</td><td align="left">Jersey Test Framework - JDK HTTP container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-jetty/dependencies.html" target="_top">
    jersey-test-framework-provider-jetty
</a>
</td><td align="left">Jersey Test Framework - Jetty HTTP container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-netty/dependencies.html" target="_top">
    jersey-test-framework-provider-netty
</a>
</td><td align="left">Jersey Test Framework - Netty container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-simple/dependencies.html" target="_top">
    jersey-test-framework-provider-simple
</a>
</td><td align="left">Jersey Test Framework - Simple HTTP container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-test-framework-util/dependencies.html" target="_top">
    jersey-test-framework-util
</a>
</td><td align="left">Jersey Test Framework Utils</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/memleak-test-common/dependencies.html" target="_top">
    memleak-test-common
</a>
</td><td align="left">Jersey test framework umbrella project</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-org.glassfish.jersey.test-framework.providers"></a><p class="title"><b>Table&nbsp;2.7.&nbsp;Jersey Test Framework Providers</b></p><div class="table-contents"><table summary="Jersey Test Framework Providers" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Jersey Test Framework Providers</th></tr></thead><tbody><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-bundle/dependencies.html" target="_top">
    jersey-test-framework-provider-bundle
</a>
</td><td align="left">Jersey Test Framework Providers Bundle</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-external/dependencies.html" target="_top">
    jersey-test-framework-provider-external
</a>
</td><td align="left">Jersey Test Framework - External container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-grizzly2/dependencies.html" target="_top">
    jersey-test-framework-provider-grizzly2
</a>
</td><td align="left">Jersey Test Framework - Grizzly2 container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-inmemory/dependencies.html" target="_top">
    jersey-test-framework-provider-inmemory
</a>
</td><td align="left">Jersey Test Framework - InMemory container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-jdk-http/dependencies.html" target="_top">
    jersey-test-framework-provider-jdk-http
</a>
</td><td align="left">Jersey Test Framework - JDK HTTP container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-jetty/dependencies.html" target="_top">
    jersey-test-framework-provider-jetty
</a>
</td><td align="left">Jersey Test Framework - Jetty HTTP container (for JDK 11+)</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-netty/dependencies.html" target="_top">
    jersey-test-framework-provider-netty
</a>
</td><td align="left">Jersey Test Framework - Netty container</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-test-framework-provider-simple/dependencies.html" target="_top">
    jersey-test-framework-provider-simple
</a>
</td><td align="left">Jersey Test Framework - Simple HTTP container</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-org.glassfish.jersey.containers.glassfish"></a><p class="title"><b>Table&nbsp;2.8.&nbsp;Jersey Glassfish Bundles</b></p><div class="table-contents"><table summary="Jersey Glassfish Bundles" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Jersey Glassfish Bundles</th></tr></thead><tbody><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-gf-ejb/dependencies.html" target="_top">
    jersey-gf-ejb
</a>
</td><td align="left">Jersey EJB for GlassFish integration</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-org.glassfish.jersey.security"></a><p class="title"><b>Table&nbsp;2.9.&nbsp;Security</b></p><div class="table-contents"><table summary="Security" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Security</th></tr></thead><tbody><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/oauth1-client/dependencies.html" target="_top">
    oauth1-client
</a>
</td><td align="left">Module that adds an OAuth 1 support to Jersey client.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/oauth1-server/dependencies.html" target="_top">
    oauth1-server
</a>
</td><td align="left">Module that adds an OAuth 1 support to Jersey server</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/oauth1-signature/dependencies.html" target="_top">
    oauth1-signature
</a>
</td><td align="left">OAuth1 signature module</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/oauth2-client/dependencies.html" target="_top">
    oauth2-client
</a>
</td><td align="left">Module that adds an OAuth 2 support to Jersey client</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-org.glassfish.jersey.examples"></a><p class="title"><b>Table&nbsp;2.10.&nbsp;Jersey Examples</b></p><div class="table-contents"><table summary="Jersey Examples" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Jersey Examples</th></tr></thead><tbody><tr><td align="left">

<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/assemblies/dependencies.html" target="_top">
    assemblies
</a>
</td><td align="left">Jersey examples shared assembly types.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/bookstore-webapp/dependencies.html" target="_top">
    bookstore-webapp
</a>
</td><td align="left">Jersey MVC Bookstore example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/cdi-webapp/dependencies.html" target="_top">
    cdi-webapp
</a>
</td><td align="left">Jersey CDI example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/clipboard/dependencies.html" target="_top">
    clipboard
</a>
</td><td align="left">Jersey clipboard example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/clipboard-programmatic/dependencies.html" target="_top">
    clipboard-programmatic
</a>
</td><td align="left">Jersey programmatic resource API clipboard example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/declarative-linking/dependencies.html" target="_top">
    declarative-linking
</a>
</td><td align="left">Declarative Hyperlinking - Jersey Sample</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/entity-filtering/dependencies.html" target="_top">
    entity-filtering
</a>
</td><td align="left">Jersey Entity Data Filtering Example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/entity-filtering-security/dependencies.html" target="_top">
    entity-filtering-security
</a>
</td><td align="left">Jersey Entity Data Filtering Security Example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/entity-filtering-selectable/dependencies.html" target="_top">
    entity-filtering-selectable
</a>
</td><td align="left">Jersey Entity Data Filtering Selectable Example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/exception-mapping/dependencies.html" target="_top">
    exception-mapping
</a>
</td><td align="left">Jersey example showing exception mappers in action.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/freemarker-webapp/dependencies.html" target="_top">
    freemarker-webapp
</a>
</td><td align="left">Jersey Freemarker example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/groovy/dependencies.html" target="_top">
    groovy
</a>
</td><td align="left">Groovy Jersey</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/helloworld/dependencies.html" target="_top">
    helloworld
</a>
</td><td align="left">Jersey annotated resource class "Hello world" example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/helloworld-benchmark/dependencies.html" target="_top">
    helloworld-benchmark
</a>
</td><td align="left">Jersey "Hello World" benchmark example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/helloworld-cdi2-se/dependencies.html" target="_top">
    helloworld-cdi2-se
</a>
</td><td align="left">Jersey "Hello world" example with CDI 2 SE.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/helloworld-netty/dependencies.html" target="_top">
    helloworld-netty
</a>
</td><td align="left">Jersey "Hello world" example on Netty container.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/helloworld-programmatic/dependencies.html" target="_top">
    helloworld-programmatic
</a>
</td><td align="left">Jersey programmatic resource API "Hello world" example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/helloworld-pure-jax-rs/dependencies.html" target="_top">
    helloworld-pure-jax-rs
</a>
</td><td align="left">Example using only the standard JAX-RS API's and the lightweight HTTP server bundled in JDK.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/helloworld-webapp/dependencies.html" target="_top">
    helloworld-webapp
</a>
</td><td align="left">Jersey annotated resource class "Hello world" example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/helloworld-weld/dependencies.html" target="_top">
    helloworld-weld
</a>
</td><td align="left">Jersey annotated resource class "Hello world" example with Weld support.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/http-patch/dependencies.html" target="_top">
    http-patch
</a>
</td><td align="left">Jersey example for implementing generic PATCH support via JAX-RS reader interceptor.
        Taken from Gerard Davison's blog entry:
        http://kingsfleet.blogspot.co.uk/2014/02/transparent-patch-support-in-jax-rs-20.html</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/http-trace/dependencies.html" target="_top">
    http-trace
</a>
</td><td align="left">Jersey HTTP TRACE support example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/https-clientserver-grizzly/dependencies.html" target="_top">
    https-clientserver-grizzly
</a>
</td><td align="left">Jersey HTTPS Client/Server example on Grizzly.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/https-server-glassfish/dependencies.html" target="_top">
    https-server-glassfish
</a>
</td><td align="left">Jersey HTTPS server on GlassFish example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/java8-webapp/dependencies.html" target="_top">
    java8-webapp
</a>
</td><td align="left">Java 8 Types WebApp Example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jaxb/dependencies.html" target="_top">
    jaxb
</a>
</td><td align="left">Jersey JAXB example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jaxrs-types-injection/dependencies.html" target="_top">
    jaxrs-types-injection
</a>
</td><td align="left">Jersey JAX-RS types injection example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/jersey-ejb/dependencies.html" target="_top">
    jersey-ejb
</a>
</td><td align="left">Jersey Web Application (Servlet) examples parent POM.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/json-binding-webapp/dependencies.html" target="_top">
    json-binding-webapp
</a>
</td><td align="left">Jersey JSON Binding example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/json-jackson/dependencies.html" target="_top">
    json-jackson
</a>
</td><td align="left">Jersey JSON with Jackson example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/json-jettison/dependencies.html" target="_top">
    json-jettison
</a>
</td><td align="left">Jersey JSON with Jettison JAXB example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/json-moxy/dependencies.html" target="_top">
    json-moxy
</a>
</td><td align="left">Jersey JSON with MOXy example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/json-processing-webapp/dependencies.html" target="_top">
    json-processing-webapp
</a>
</td><td align="left">Jersey Jakarta JSON Processing example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/json-with-padding/dependencies.html" target="_top">
    json-with-padding
</a>
</td><td align="left">Jersey JSON with Padding example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/managed-beans-webapp/dependencies.html" target="_top">
    managed-beans-webapp
</a>
</td><td align="left">Jersey Managed Beans Web Application Example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/managed-client/dependencies.html" target="_top">
    managed-client
</a>
</td><td align="left">Jersey managed client example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/managed-client-simple-webapp/dependencies.html" target="_top">
    managed-client-simple-webapp
</a>
</td><td align="left">Jersey Web Application (Servlet) examples parent POM.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/managed-client-webapp/dependencies.html" target="_top">
    managed-client-webapp
</a>
</td><td align="left">Jersey managed client web application example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/multipart-webapp/dependencies.html" target="_top">
    multipart-webapp
</a>
</td><td align="left">Jersey Multipart example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/open-tracing/dependencies.html" target="_top">
    open-tracing
</a>
</td><td align="left">Jersey OpenTracing example</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/rx-client-webapp/dependencies.html" target="_top">
    rx-client-webapp
</a>
</td><td align="left">Jersey Reactive Client WebApp Example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/server-async/dependencies.html" target="_top">
    server-async
</a>
</td><td align="left">Jersey JAX-RS asynchronous server-side example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/server-async-managed/dependencies.html" target="_top">
    server-async-managed
</a>
</td><td align="left">Jersey JAX-RS asynchronous server-side example with custom Jersey executor providers.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/server-async-standalone/dependencies.html" target="_top">
    server-async-standalone
</a>
</td><td align="left">Standalone Jersey JAX-RS asynchronous server-side processing example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/server-async-standalone/server-async-standalone-client/dependencies.html" target="_top">
    server-async-standalone-client
</a>
</td><td align="left">Standalone Jersey JAX-RS asynchronous server-side processing example client.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/server-async-standalone/server-async-standalone-webapp/dependencies.html" target="_top">
    server-async-standalone-webapp
</a>
</td><td align="left">Standalone Jersey JAX-RS asynchronous server-side processing example web application.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/server-sent-events-jaxrs/dependencies.html" target="_top">
    server-sent-events-jaxrs
</a>
</td><td align="left">Jersey JAX-RS 2.1/3.0 Server-Sent Events example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/server-sent-events-jersey/dependencies.html" target="_top">
    server-sent-events-jersey
</a>
</td><td align="left">Jersey Server-Sent Events example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/servlet3-webapp/dependencies.html" target="_top">
    servlet3-webapp
</a>
</td><td align="left">Jersey Servlet 3 example with missing servlet-class in the web.xml file</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/simple-console/dependencies.html" target="_top">
    simple-console
</a>
</td><td align="left">Jersey Simple Console example</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/sse-item-store-jaxrs-webapp/dependencies.html" target="_top">
    sse-item-store-jaxrs-webapp
</a>
</td><td align="left">Jersey JAX-RS 2.1/3.0 SSE API-based item store example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/sse-item-store-jersey-webapp/dependencies.html" target="_top">
    sse-item-store-jersey-webapp
</a>
</td><td align="left">Jersey SSE API-based item store example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/sse-twitter-aggregator/dependencies.html" target="_top">
    sse-twitter-aggregator
</a>
</td><td align="left">Jersey SSE Twitter Message Aggregator Example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/system-properties-example/dependencies.html" target="_top">
    system-properties-example
</a>
</td><td align="left">Jersey system properties example.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/webapp-example-parent/dependencies.html" target="_top">
    webapp-example-parent
</a>
</td><td align="left">Jersey Web Application (Servlet) examples parent POM.</td></tr><tr><td align="left">
<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/xml-moxy/dependencies.html" target="_top">
    xml-moxy
</a>
</td><td align="left">Jersey XML MOXy example.</td></tr></tbody></table></div></div><br class="table-break"></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="jaxrs-resources"></a>Chapter&nbsp;3.&nbsp;JAX-RS Application, Resources and Sub-Resources</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e1820">3.1. Root Resource Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1859">3.1.1. @Path</a></span></dt><dt><span class="section"><a href="#d0e1909">3.1.2. @GET, @PUT, @POST, @DELETE, ... (HTTP Methods)</a></span></dt><dt><span class="section"><a href="#d0e1947">3.1.3. @Produces</a></span></dt><dt><span class="section"><a href="#d0e2026">3.1.4. @Consumes</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2051">3.2. Parameter Annotations (@*Param)</a></span></dt><dt><span class="section"><a href="#d0e2322">3.3. Sub-resources</a></span></dt><dt><span class="section"><a href="#d0e2469">3.4. Life-cycle of Root Resource Classes</a></span></dt><dt><span class="section"><a href="#d0e2540">3.5. Rules of Injection</a></span></dt><dt><span class="section"><a href="#d0e2648">3.6. Use of @Context</a></span></dt><dt><span class="section"><a href="#d0e2676">3.7. Programmatic resource model</a></span></dt></dl></div><p>This chapter presents an overview of the core JAX-RS concepts - resources and sub-resources.</p><p>The JAX-RS 3.0.0 JavaDoc can be found online <a class="link" href="https://github.com/eclipse-ee4j/jaxrs-api/apidocs/index.html" target="_top">here</a>.
    </p><p>The JAX-RS 3.0.0 specification draft can be found online <a class="link" href="https://jakarta.ee/specifications/restful-ws/3.0/jakarta-restful-ws-spec-3.0.pdf" target="_top">here</a>.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1820"></a>3.1.&nbsp;Root Resource Classes</h2></div></div></div><p>
            <span class="emphasis"><em>Root resource classes</em></span>
            are POJOs (Plain Old Java Objects) that are annotated with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a>
            have at least one method annotated with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> or a resource method designator annotation such as <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a>,
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/PUT.html" target="_top">@PUT</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/POST.html" target="_top">@POST</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/DELETE.html" target="_top">@DELETE</a>. Resource methods are methods of a resource class annotated with a resource
            method designator. This section shows how to use Jersey to annotate Java objects to create RESTful web services.
        </p><p>The following code example is a very simple example of a root
            resource class using JAX-RS annotations. The example code shown here is
            from one of the samples that ships with Jersey, the zip file of which can
            be found in the maven repository
            <a class="link" href="https://repo1.maven.org/maven2/org/glassfish/jersey/examples/helloworld/3.0.2/" target="_top">here</a>.
        </p><p>
            </p><div class="example"><a name="d0e1853"></a><p class="title"><b>Example&nbsp;3.1.&nbsp;Simple hello world root resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">package org.glassfish.jersey.examples.helloworld;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;

@Path("helloworld")
public class HelloWorldResource {
    public static final String CLICHED_MESSAGE = "Hello World!";

@GET
@Produces("text/plain")
    public String getHello() {
        return CLICHED_MESSAGE;
    }
}</pre></div></div><p><br class="example-break">
            Let's look at some of the JAX-RS annotations used in this example.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1859"></a>3.1.1.&nbsp;@Path</h3></div></div></div><p>The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> annotation's value is a relative URI path. In the example above, the Java class will be hosted at the URI path
                <code class="literal">/helloworld</code>. This is an extremely simple use of the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> annotation. What makes JAX-RS so useful is that you can embed variables in the URIs.
            </p><p>
                <span class="emphasis"><em>URI path templates</em></span>
                are URIs with variables embedded within the URI syntax. These variables are substituted at runtime in order
                for a resource to respond to a request based on the substituted URI. Variables are denoted by curly braces.
                For example, look at the following <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> annotation:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">@Path("/users/{username}")</pre><p>

                In this type of example, a user will be prompted to enter their name, and then a Jersey web service configured
                to respond to requests to this URI path template will respond. For example, if the user entered their username
                as "Galileo", the web service will respond to the following URL:
                <code class="literal">http://example.com/users/Galileo</code>
            </p><p>To obtain the value of the username variable the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/PathParam.html" target="_top">@PathParam</a> may be used on method parameter of a
                request method, for example:
                </p><div class="example"><a name="d0e1892"></a><p class="title"><b>Example&nbsp;3.2.&nbsp;Specifying URI path parameter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/users/{username}")
public class UserResource {

    @GET
    @Produces("text/xml")
    public String getUser(@PathParam("username") String userName) {
        ...
    }
}</pre></div></div><p><br class="example-break">
                If it is required that a user name must only consist of
                lower and upper case numeric characters then it is possible to declare a
                particular regular expression, which overrides the default regular
                expression, "[^/]+", for example:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("users/{username: [a-zA-Z][a-zA-Z_0-9]*}")</pre><p>
                In this type of example the username variable will only match user names that begin with one upper or lower
                case letter and zero or more alpha numeric characters and the underscore character. If a user name does not
                match that a 404 (Not Found) response will occur.
            </p><p>A <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> value may or may not begin with a '/', it makes no difference. Likewise, by default, a
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> value may or may not end in a '/', it makes no difference, and thus request URLs that end or
                do not end in a '/' will both be matched.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1909"></a>3.1.2.&nbsp;@GET, @PUT, @POST, @DELETE, ... (HTTP Methods)</h3></div></div></div><p><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/PUT.html" target="_top">@PUT</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/POST.html" target="_top">@POST</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/DELETE.html" target="_top">@DELETE</a> and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/HEAD.html" target="_top">@HEAD</a>
                are
                <span class="emphasis"><em>resource method designator</em></span>
                annotations defined
                by JAX-RS and which correspond to the similarly named HTTP methods. In
                the example above, the annotated Java method will process HTTP GET
                requests. The behavior of a resource is determined by which of the HTTP
                methods the resource is responding to.
            </p><p>The following example is an extract from the storage service
                sample that shows the use of the PUT method to create or update a
                storage container:
            </p><p>
                </p><div class="example"><a name="d0e1935"></a><p class="title"><b>Example&nbsp;3.3.&nbsp;PUT method</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@PUT
public Response putContainer() {
    System.out.println("PUT CONTAINER " + container);

    URI uri = uriInfo.getAbsolutePath();
    Container c = new Container(container, uri.toString());

    Response r;
    if (!MemoryStore.MS.hasContainer(c)) {
        r = Response.created(uri).build();
    } else {
        r = Response.noContent().build();
    }

    MemoryStore.MS.createContainer(c);
    return r;
}</pre></div></div><p><br class="example-break">
                By default the JAX-RS runtime will automatically support the methods HEAD and OPTIONS, if not explicitly
                implemented. For HEAD the runtime will invoke the implemented GET method (if present) and ignore the
                response entity (if set). A response returned for the OPTIONS method depends on the requested media type
                defined in the 'Accept' header. The OPTIONS method can return a response with a set of supported
                resource methods in the 'Allow' header or return
                a <a class="link" href="https://javaee.github.io/wadl/" target="_top">WADL</a> document.
                See <a class="link" href="#wadl" title="Chapter&nbsp;18.&nbsp;WADL Support">wadl section</a> for more information.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1947"></a>3.1.3.&nbsp;@Produces</h3></div></div></div><p>
                The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> annotation is used to specify the MIME media types of representations a resource can
                produce and send back to the client. In this example, the Java method will produce representations identified
                by the MIME media type "text/plain". <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> can be applied at both the class and method levels.
                Here's an example:
            </p><p>
                </p><div class="example"><a name="d0e1960"></a><p class="title"><b>Example&nbsp;3.4.&nbsp;Specifying output MIME type</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/myResource")
@Produces("text/plain")
public class SomeResource {
    @GET
    public String doGetAsPlainText() {
        ...
    }

    @GET
    @Produces("text/html")
    public String doGetAsHtml() {
        ...
    }
}</pre></div></div><p><br class="example-break">
                The
                <code class="literal">doGetAsPlainText</code>
                method defaults to the MIME type of the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> annotation at the class level. The
                <code class="literal">doGetAsHtml</code>
                method's <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> annotation overrides the class-level <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> setting, and specifies that the
                method can produce HTML rather than plain text.
            </p><p>If a resource class is capable of producing more that one MIME
                media type then the resource method chosen will correspond to the most
                acceptable media type as declared by the client. More specifically the
                Accept header of the HTTP request declares what is most acceptable. For
                example if the Accept header is "<code class="literal">Accept: text/plain</code>" then the
                <code class="literal">doGetAsPlainText</code>
                method will be invoked.
                Alternatively if the Accept header is "
                <code class="literal">Accept: text/plain;q=0.9, text/html</code>", which declares that the client can accept media types of
                "text/plain" and "text/html" but prefers the latter, then the
                <code class="literal">doGetAsHtml</code>
                method will be invoked.
            </p><p>More than one media type may be declared in the same <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> declaration, for example:
            </p><p>
                </p><div class="example"><a name="d0e2002"></a><p class="title"><b>Example&nbsp;3.5.&nbsp;Using multiple output MIME types</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces({"application/xml", "application/json"})
public String doGetAsXmlOrJson() {
    ...
}</pre></div></div><p><br class="example-break">
                The
                <code class="literal">doGetAsXmlOrJson</code>
                method will get
                invoked if either of the media types "application/xml" and
                "application/json" are acceptable. If both are equally acceptable then
                the former will be chosen because it occurs first.
            </p><p>Optionally, server can also specify the quality factor for individual media types. These are
                considered if several are equally acceptable by the client. For example:</p><p>
                </p><div class="example"><a name="d0e2015"></a><p class="title"><b>Example&nbsp;3.6.&nbsp;Server-side content negotiation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces({"application/xml; qs=0.9", "application/json"})
public String doGetAsXmlOrJson() {
    ...
}</pre></div></div><p><br class="example-break">
                In the above sample, if client accepts both "application/xml" and "application/json" (equally),
                then a server always sends "application/json", since "application/xml" has a lower quality factor.
            </p><p>The examples above refers explicitly to MIME media types for
                clarity. It is possible to refer to constant values, which may reduce
                typographical errors, see the constant field values of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/MediaType.html" target="_top">MediaType</a>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2026"></a>3.1.4.&nbsp;@Consumes</h3></div></div></div><p>The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Consumes.html" target="_top">@Consumes</a> annotation is used to specify the MIME media types of representations
                that can be consumed by a resource. The above example can be modified to set the cliched
                message as follows:
            </p><p>
                </p><div class="example"><a name="d0e2036"></a><p class="title"><b>Example&nbsp;3.7.&nbsp;Specifying input MIME type</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes("text/plain")
public void postClichedMessage(String message) {
    // Store the message
}</pre></div></div><p><br class="example-break">
            </p><p>In this example, the Java method will consume representations
                identified by the MIME media type "text/plain". Notice that the resource
                method returns void. This means no representation is returned and
                response with a status code of 204 (No Content) will be returned to the client.
            </p><p><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Consumes.html" target="_top">@Consumes</a> can be applied at both the class and the method levels and more than one media type
                may be declared in the same <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Consumes.html" target="_top">@Consumes</a> declaration.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2051"></a>3.2.&nbsp;Parameter Annotations (@*Param)</h2></div></div></div><p>Parameters of a resource method may be annotated with parameter-based annotations to extract information
            from a request. One of the previous examples presented the use of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/PathParam.html" target="_top">@PathParam</a> to extract a path
            parameter from the path component of the request URL that matched the path declared in <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a>.
        </p><p><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/QueryParam.html" target="_top">@QueryParam</a> is used to extract query parameters from the Query component of the request URL.
            The following example is an extract from the sparklines sample:
        </p><div class="example"><a name="d0e2066"></a><p class="title"><b>Example&nbsp;3.8.&nbsp;Query parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("smooth")
@GET
public Response smooth(
    @DefaultValue("2") @QueryParam("step") int step,
    @DefaultValue("true") @QueryParam("min-m") boolean hasMin,
    @DefaultValue("true") @QueryParam("max-m") boolean hasMax,
    @DefaultValue("true") @QueryParam("last-m") boolean hasLast,
    @DefaultValue("blue") @QueryParam("min-color") ColorParam minColor,
    @DefaultValue("green") @QueryParam("max-color") ColorParam maxColor,
    @DefaultValue("red") @QueryParam("last-color") ColorParam lastColor) {
    ...
}</pre></div></div><br class="example-break"><p>If a query parameter "step" exists in the query component of the
            request URI then the "step" value will be extracted and parsed as a
            32 bit signed integer and assigned to the step method parameter. If "step"
            does not exist then a default value of 2, as declared in the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/DefaultValue.html" target="_top">@DefaultValue</a>
            annotation, will be assigned to the step method parameter. If the "step"
            value cannot be parsed as a 32 bit signed integer then a HTTP 404 (Not
            Found) response is returned. User defined Java types such as
            <code class="literal">ColorParam</code>
            may be used, which as implemented as
            follows:
        </p><div class="example"><a name="d0e2079"></a><p class="title"><b>Example&nbsp;3.9.&nbsp;Custom Java type for consuming request parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class ColorParam extends Color {

    public ColorParam(String s) {
        super(getRGB(s));
    }

    private static int getRGB(String s) {
        if (s.charAt(0) == '#') {
            try {
                Color c = Color.decode("0x" + s.substring(1));
                return c.getRGB();
            } catch (NumberFormatException e) {
                throw new WebApplicationException(400);
            }
        } else {
            try {
                Field f = Color.class.getField(s);
                return ((Color)f.get(null)).getRGB();
            } catch (Exception e) {
                throw new WebApplicationException(400);
            }
        }
    }
}</pre></div></div><br class="example-break"><p>In general the Java type of the method parameter may:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Be a primitive type;</p></li><li class="listitem"><p>Have a constructor that accepts a single
                    <code class="literal">String</code>
                    argument;
                </p></li><li class="listitem"><p>Have a static method named
                    <code class="literal">valueOf</code>
                    or
                    <code class="literal">fromString</code>
                    that accepts a single
                    <code class="literal">String</code>
                    argument (see, for example,
                    <code class="literal">Integer.valueOf(String)</code>
                    and <code class="literal">java.util.UUID.fromString(String)</code>);
                </p></li><li class="listitem"><p>Have a registered implementation of <code class="literal">jakarta.ws.rs.ext.ParamConverterProvider</code> JAX-RS
                    extension SPI that returns a <code class="literal">jakarta.ws.rs.ext.ParamConverter</code> instance capable of
                    a "from string" conversion for the type.
                     or
                </p></li><li class="listitem"><p>Be <code class="literal">List&lt;T&gt;</code>,
                    <code class="literal">Set&lt;T&gt;</code>
                    or
                    <code class="literal">SortedSet&lt;T&gt;</code>, where
                    <code class="literal">T</code>
                    satisfies 2 or 3 above. The resulting collection is read-only.
                </p></li></ol></div><p>Sometimes parameters may contain more than one value for the same
            name. If this is the case then types in 5) may be used to obtain all
            values.
        </p><p>If the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/DefaultValue.html" target="_top">@DefaultValue</a> is not used in conjunction with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/QueryParam.html" target="_top">@QueryParam</a>
            and the query parameter is not present in the request then value will be
            an empty collection for<code class="literal">List</code>, <code class="literal">Set</code> or <code class="literal">SortedSet</code>,
            <code class="literal">null</code> for other object types, and the Java-defined default for primitive types.
        </p><p>The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/PathParam.html" target="_top">@PathParam</a> and the other parameter-based annotations, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/MatrixParam.html" target="_top">@MatrixParam</a>,
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/HeaderParam.html" target="_top">@HeaderParam</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/CookieParam.html" target="_top">@CookieParam</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/FormParam.html" target="_top">@FormParam</a> obey the same rules as <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/QueryParam.html" target="_top">@QueryParam</a>.
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/MatrixParam.html" target="_top">@MatrixParam</a> extracts information from URL path segments. <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/HeaderParam.html" target="_top">@HeaderParam</a> extracts information
            from the HTTP headers. <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/CookieParam.html" target="_top">@CookieParam</a> extracts information from the cookies declared in cookie related HTTP
            headers.
        </p><p><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/FormParam.html" target="_top">@FormParam</a> is slightly special because it extracts information from a request representation that
            is of the MIME media type
            <code class="literal">"application/x-www-form-urlencoded"</code>
            and conforms to the encoding
            specified by HTML forms, as described here. This parameter is very useful for extracting information that is
            POSTed by HTML forms, for example the following extracts the form parameter named "name" from the POSTed form
            data:
        </p><p>
            </p><div class="example"><a name="d0e2198"></a><p class="title"><b>Example&nbsp;3.10.&nbsp;Processing POSTed HTML form</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes("application/x-www-form-urlencoded")
public void post(@FormParam("name") String name) {
    // Store the message
}</pre></div></div><p><br class="example-break">
        </p><p>If it is necessary to obtain a general map of parameter name to
            values then, for query and path parameters it is possible to do the
            following:
        </p><p>
            </p><div class="example"><a name="d0e2208"></a><p class="title"><b>Example&nbsp;3.11.&nbsp;Obtaining general map of URI path and/or query parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public String get(@Context UriInfo ui) {
    MultivaluedMap&lt;String, String&gt; queryParams = ui.getQueryParameters();
    MultivaluedMap&lt;String, String&gt; pathParams = ui.getPathParameters();
}</pre></div></div><p><br class="example-break">
        </p><p>For header and cookie parameters the following:</p><p>
            </p><div class="example"><a name="d0e2218"></a><p class="title"><b>Example&nbsp;3.12.&nbsp;Obtaining general map of header parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public String get(@Context HttpHeaders hh) {
    MultivaluedMap&lt;String, String&gt; headerParams = hh.getRequestHeaders();
    Map&lt;String, Cookie&gt; pathParams = hh.getCookies();
}</pre></div></div><p><br class="example-break">
        </p><p>In general <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a> can be used to obtain contextual Java types related to the request or response.
        </p><p>Because form parameters (unlike others) are part of the message entity, it is possible to do the following:</p><p>
            </p><div class="example"><a name="d0e2233"></a><p class="title"><b>Example&nbsp;3.13.&nbsp;Obtaining general map of form parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes("application/x-www-form-urlencoded")
public void post(MultivaluedMap&lt;String, String&gt; formParams) {
    // Store the message
}</pre></div></div><p><br class="example-break">

            I.e. you don't need to use the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a> annotation.
        </p><p>Another kind of injection is the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/BeanParam.html" target="_top">@BeanParam</a> which allows to inject the parameters described above into a
            single bean. A bean annotated with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/BeanParam.html" target="_top">@BeanParam</a> containing any fields and appropriate
            <code class="literal">*param</code>
            annotation(like <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/PathParam.html" target="_top">@PathParam</a>) will be initialized with corresponding request values in expected way as if these
            fields were in the resource class. Then instead of injecting request values like path param into a constructor parameters
            or class fields the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/BeanParam.html" target="_top">@BeanParam</a> can be used to inject such a bean into a resource or resource method. The
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/BeanParam.html" target="_top">@BeanParam</a> is used this way to aggregate more request parameters into a single bean.
        </p><div class="example"><a name="d0e2262"></a><p class="title"><b>Example&nbsp;3.14.&nbsp;Example of the bean which will be used as <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/BeanParam.html" target="_top">@BeanParam</a>
            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyBeanParam {
    @PathParam("p")
    private String pathParam;

    @MatrixParam("m")
    @Encoded
    @DefaultValue("default")
    private String matrixParam;

    @HeaderParam("header")
    private String headerParam;

    private String queryParam;

    public MyBeanParam(@QueryParam("q") String queryParam) {
        this.queryParam = queryParam;
    }

    public String getPathParam() {
        return pathParam;
    }
    ...
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e2270"></a><p class="title"><b>Example&nbsp;3.15.&nbsp;Injection of MyBeanParam as a method parameter:</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
public void post(@BeanParam MyBeanParam beanParam, String entity) {
    final String pathParam = beanParam.getPathParam(); // contains injected path parameter "p"
    ...
}</pre></div></div><br class="example-break"><p>The example shows aggregation of injections <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/PathParam.html" target="_top">@PathParam</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/QueryParam.html" target="_top">@QueryParam</a> <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/MatrixParam.html" target="_top">@MatrixParam</a>
            and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/HeaderParam.html" target="_top">@HeaderParam</a> into one single bean. The rules for injections inside the bean are the same as described above
            for these injections. The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/DefaultValue.html" target="_top">@DefaultValue</a> is used to define the default value for matrix parameter matrixParam.
            Also the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Encoded.html" target="_top">@Encoded</a> annotation has the same behaviour as if it were used for injection in the resource method
            directly. Injecting the bean parameter into @Singleton resource class fields is not allowed (injections into method
            parameter must be used instead).
        </p><p><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/BeanParam.html" target="_top">@BeanParam</a> can contain all parameters injections
            (<a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/PathParam.html" target="_top">@PathParam</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/QueryParam.html" target="_top">@QueryParam</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/MatrixParam.html" target="_top">@MatrixParam</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/HeaderParam.html" target="_top">@HeaderParam</a>,
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/CookieParam.html" target="_top">@CookieParam</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/FormParam.html" target="_top">@FormParam</a>). More
            beans can be injected into one resource or method parameters even if they inject the same request values. For example
            the following is possible:
        </p><div class="example"><a name="d0e2317"></a><p class="title"><b>Example&nbsp;3.16.&nbsp;Injection of more beans into one resource methods:</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
public void post(@BeanParam MyBeanParam beanParam, @BeanParam AnotherBean anotherBean, @PathParam("p") pathParam,
String entity) {
    // beanParam.getPathParam() == pathParam
    ...
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2322"></a>3.3.&nbsp;Sub-resources</h2></div></div></div><p><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> may be used on classes and such classes are referred to as root resource classes. <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a>
            may also be used on methods of root resource classes. This enables common functionality for a number of resources
            to be grouped together and potentially reused.
        </p><p>The first way <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> may be used is on resource methods and such methods are referred to as
            <span class="emphasis"><em>sub-resource methods</em></span>. The following example shows the method signatures for a root
            resource class from the jmaki-backend sample:
        </p><p>
            </p><div class="example"><a name="d0e2342"></a><p class="title"><b>Example&nbsp;3.17.&nbsp;Sub-resource methods</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Singleton
@Path("/printers")
public class PrintersResource {

    @GET
    @Produces({"application/json", "application/xml"})
    public WebResourceList getMyResources() { ... }

    @GET @Path("/list")
    @Produces({"application/json", "application/xml"})
    public WebResourceList getListOfPrinters() { ... }

    @GET @Path("/jMakiTable")
    @Produces("application/json")
    public PrinterTableModel getTable() { ... }

    @GET @Path("/jMakiTree")
    @Produces("application/json")
    public TreeModel getTree() { ... }

    @GET @Path("/ids/{printerid}")
    @Produces({"application/json", "application/xml"})
    public Printer getPrinter(@PathParam("printerid") String printerId) { ... }

    @PUT @Path("/ids/{printerid}")
    @Consumes({"application/json", "application/xml"})
    public void putPrinter(@PathParam("printerid") String printerId, Printer printer) { ... }

    @DELETE @Path("/ids/{printerid}")
    public void deletePrinter(@PathParam("printerid") String printerId) { ... }
}</pre></div></div><p><br class="example-break">
        </p><p>If the path of the request URL is "printers" then the resource methods not annotated with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a>
            will be selected. If the request path of the request URL is "printers/list" then first the root resource class
            will be matched and then the sub-resource methods that match "list" will be selected, which in this case
            is the sub-resource method <code class="literal">getListOfPrinters</code>. So, in this example hierarchical matching
            on the path of the request URL is performed.
        </p><p>The second way <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> may be used is on methods
            <span class="bold"><strong>not</strong></span>
            annotated
            with resource method designators such as <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a> or <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/POST.html" target="_top">@POST</a>. Such methods are referred to as
            <span class="emphasis"><em>sub-resource locators</em></span>. The following example shows the method signatures for
            a root resource class and a resource class from the optimistic-concurrency sample:
        </p><p>
            </p><div class="example"><a name="d0e2375"></a><p class="title"><b>Example&nbsp;3.18.&nbsp;Sub-resource locators</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/item")
public class ItemResource {
    @Context UriInfo uriInfo;

    @Path("content")
    public ItemContentResource getItemContentResource() {
        return new ItemContentResource();
    }

    @GET
    @Produces("application/xml")
        public Item get() { ... }
    }
}

public class ItemContentResource {

    @GET
    public Response get() { ... }

    @PUT
    @Path("{version}")
    public void put(@PathParam("version") int version,
                    @Context HttpHeaders headers,
                    byte[] in) {
        ...
    }
}</pre></div></div><p><br class="example-break">
        </p><p>The root resource class
            <code class="literal">ItemResource</code>
            contains the
            sub-resource locator method
            <code class="literal">getItemContentResource</code>
            that
            returns a new resource class. If the path of the request URL is
            "item/content" then first of all the root resource will be matched, then
            the sub-resource locator will be matched and invoked, which returns an
            instance of the
            <code class="literal">ItemContentResource</code>
            resource class.
            Sub-resource locators enable reuse of resource classes. A method can be annotated with the
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> annotation with empty path (<code class="literal">@Path("/")</code> or <code class="literal">@Path("")</code>) which
            means that the sub resource locator is matched for the path of the enclosing resource (without sub-resource path).
        </p><p>
            </p><div class="example"><a name="d0e2403"></a><p class="title"><b>Example&nbsp;3.19.&nbsp;Sub-resource locators with empty path</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/item")
public class ItemResource {

    @Path("/")
    public ItemContentResource getItemContentResource() {
        return new ItemContentResource();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>In the example above the sub-resource locator method <code class="literal">getItemContentResource</code>
            is matched for example for request path "/item/locator" or even for only "/item".
        </p><p>In addition the processing of resource classes returned by
            sub-resource locators is performed at runtime thus it is possible to
            support polymorphism. A sub-resource locator may return different
            sub-types depending on the request (for example a sub-resource locator
            could return different sub-types dependent on the role of the principle
            that is authenticated). So for example the following sub resource locator is valid:
        </p><p>
            </p><div class="example"><a name="d0e2418"></a><p class="title"><b>Example&nbsp;3.20.&nbsp;Sub-resource locators returning sub-type</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/item")
public class ItemResource {

    @Path("/")
    public Object getItemContentResource() {
        return new AnyResource();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>Note that the runtime will not manage the life-cycle or perform any
            field injection onto instances returned from sub-resource locator methods.
            This is because the runtime does not know what the life-cycle of the
            instance is. If it is required that the runtime manages the sub-resources
            as standard resources the <code class="literal">Class</code> should be returned
            as shown in the following example:
        </p><p>
            </p><div class="example"><a name="d0e2431"></a><p class="title"><b>Example&nbsp;3.21.&nbsp;Sub-resource locators created from classes</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import jakarta.inject.Singleton;

@Path("/item")
public class ItemResource {
    @Path("content")
    public Class&lt;ItemContentSingletonResource&gt; getItemContentResource() {
        return ItemContentSingletonResource.class;
    }
}

@Singleton
public class ItemContentSingletonResource {
    // this class is managed in the singleton life cycle
}</pre></div></div><p><br class="example-break">
        </p><p>JAX-RS resources are managed in per-request scope by default which means that
            new resource is created for each request.
            In this example the <code class="literal">jakarta.inject.Singleton</code> annotation says
            that the resource will be managed as singleton and not in request scope.
            The sub-resource locator method returns a class which means that the runtime
            will managed the resource instance and its life-cycle. If the method would return instance instead,
            the <code class="literal">Singleton</code> annotation would have no effect and the returned instance
            would be used.
        </p><p>The sub resource locator can also return a <span class="emphasis"><em>programmatic resource model</em></span>. See <a class="link" href="#resource-builder" title="Chapter&nbsp;14.&nbsp;Programmatic API for Building Resources">resource builder section</a> for information of how the programmatic resource
            model is constructed. The following example shows very simple resource returned from the sub-resource locator method.
        </p><p>
            </p><div class="example"><a name="d0e2455"></a><p class="title"><b>Example&nbsp;3.22.&nbsp;Sub-resource locators returning resource model</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import org.glassfish.jersey.server.model.Resource;

@Path("/item")
public class ItemResource {

    @Path("content")
    public Resource getItemContentResource() {
        return Resource.from(ItemContentSingletonResource.class);
    }
}</pre></div></div><p><br class="example-break">
        </p><p>The code above has exactly the same effect as previous example. <code class="literal">Resource</code> is a resource
            simple resource constructed from <code class="literal">ItemContentSingletonResource</code>. More complex programmatic
            resource can be returned as long they are valid resources.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2469"></a>3.4.&nbsp;Life-cycle of Root Resource Classes</h2></div></div></div><p>By default the life-cycle of root resource classes is per-request which,
            namely that a new instance of a root resource class is created every time
            the request URI path matches the root resource. This makes for a very
            natural programming model where constructors and fields can be utilized
            (as in the previous section showing the constructor of the
            <code class="literal">SparklinesResource</code>
            class) without concern for multiple
            concurrent requests to the same resource.
        </p><p>In general this is unlikely to be a cause of performance issues.
            Class construction and garbage collection of JVMs has vastly improved over
            the years and many objects will be created and discarded to serve and
            process the HTTP request and return the HTTP response.
        </p><p>Instances of singleton root resource classes can be declared by an instance of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a>.
        </p><p>Jersey supports two further life-cycles using Jersey specific annotations.</p><div class="table"><a name="d0e2486"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Resource scopes</b></p><div class="table-contents"><table summary="Resource scopes" border="1"><colgroup><col width="11%"><col width="11%"><col width="22%"><col width="56%"></colgroup><thead><tr><th>Scope</th><th>Annotation</th><th>Annotation full class name</th><th>Description</th></tr></thead><tbody><tr><td>Request scope</td><td>@RequestScoped (or none)</td><td>org.glassfish.jersey.process.internal.RequestScoped</td><td><span class="emphasis"><em>Default lifecycle </em></span> (applied when no annotation is present). In this scope
                            the resource instance is created for each new request and used for processing of this request. If the
                            resource is used more than one time in the request processing, always the same instance will be used.
                            This can happen when a resource is a sub resource and is returned more times during the matching. In this
                            situation only one instance will serve the requests.</td></tr><tr><td>Per-lookup scope</td><td>@PerLookup</td><td>org.glassfish.hk2.api.PerLookup</td><td>In this scope
                            the resource instance is created every time it is needed for the processing even it handles
                            the same request.</td></tr><tr><td>Singleton</td><td>@Singleton</td><td>jakarta.inject.Singleton</td><td>In this scope there is only one instance per jax-rs application. Singleton resource can be either
                            annotated with @Singleton and its class can be registered using the instance of
                            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a>. You can also create singletons by registering singleton instances
                            into <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2540"></a>3.5.&nbsp;Rules of Injection</h2></div></div></div><p>Previous sections have presented examples of annotated types, mostly
            annotated method parameters but also annotated fields of a class, for the
            injection of values onto those types.
        </p><p>This section presents the rules of injection of values on annotated
            types. Injection can be performed on fields, constructor parameters,
            resource/sub-resource/sub-resource locator method parameters and bean
            setter methods. The following presents an example of all such injection
            cases:
        </p><p>
            </p><div class="example"><a name="d0e2549"></a><p class="title"><b>Example&nbsp;3.23.&nbsp;Injection</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("{id:\\d+}")
public class InjectedResource {
    // Injection onto field
    @DefaultValue("q") @QueryParam("p")
    private String p;

    // Injection onto constructor parameter
    public InjectedResource(@PathParam("id") int id) { ... }

    // Injection onto resource method parameter
    @GET
    public String get(@Context UriInfo ui) { ... }

    // Injection onto sub-resource resource method parameter
    @Path("sub-id")
    @GET
    public String get(@PathParam("sub-id") String id) { ... }

    // Injection onto sub-resource locator method parameter
    @Path("sub-id")
    public SubResource getSubResource(@PathParam("sub-id") String id) { ... }

    // Injection using bean setter method
    @HeaderParam("X-header")
    public void setHeader(String header) { ... }
}</pre></div></div><p><br class="example-break">
        </p><p>There are some restrictions when injecting on to resource classes
            with a life-cycle of singleton scope. In such cases the class fields or
            constructor parameters cannot be injected with request specific parameters. So, for example
            the following is not allowed.</p><p>
            </p><div class="example"><a name="d0e2559"></a><p class="title"><b>Example&nbsp;3.24.&nbsp;Wrong injection into a singleton scope</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
@Singleton
public static class MySingletonResource {

    @QueryParam("query")
    String param; // WRONG: initialization of application will fail as you cannot
                  // inject request specific parameters into a singleton resource.

    @GET
    public String get() {
        return "query param: " + param;
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The example above will cause validation failure during application initialization as singleton
            resources cannot inject request specific parameters. The same example would fail if the query
            parameter would be injected into constructor parameter of such a singleton. In other words, if you
            wish one resource instance to server more requests (in the same time) it cannot be bound
            to a specific request parameter.
        </p><p>
            The exception exists for specific request objects which can injected even into
            constructor or class fields. For these objects the runtime will inject proxies
            which are able to simultaneously server more request. These request objects are
            <code class="literal">HttpHeaders</code>, <code class="literal">Request</code>, <code class="literal">UriInfo</code>,
            <code class="literal">SecurityContext</code>. These proxies can be injected using the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a>
            annotation. The following example shows injection of proxies into the singleton resource class.
        </p><p>
            </p><div class="example"><a name="d0e2586"></a><p class="title"><b>Example&nbsp;3.25.&nbsp;Injection of proxies into singleton</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
@Singleton
public static class MySingletonResource {
    @Context
    Request request; // this is ok: the proxy of Request will be injected into this singleton

    public MySingletonResource(@Context SecurityContext securityContext) {
        // this is ok too: the proxy of SecurityContext will be injected
    }

    @GET
    public String get() {
        return "query param: " + param;
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            To summarize the injection can be done into the following constructs:
        </p><div class="table"><a name="d0e2594"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Overview of injection types</b></p><div class="table-contents"><table summary="Overview of injection types" border="1"><colgroup><col width="16%"><col width="84%"></colgroup><thead><tr><th>Java construct</th><th>Description</th></tr></thead><tbody><tr><td>Class fields</td><td>
                            Inject value directly into the field of the class. The field can be private
                            and must not be final. Cannot be used in Singleton scope except proxiable types mentioned above.
                        </td></tr><tr><td>Constructor parameters</td><td>
                            The constructor will be invoked with injected values. If more
                            constructors exists the one with the most injectable parameters will be invoked.
                            Cannot be used in Singleton scope except proxiable types mentioned above.
                        </td></tr><tr><td>Resource methods</td><td>
                            The resource methods (these annotated with @GET, @POST, ...) can contain
                            parameters that can be injected when the resource method is executed.
                            Can be used in any scope.
                        </td></tr><tr><td>Sub resource locators</td><td>
                            The sub resource locators (methods annotated with @Path but not @GET, @POST, ...)
                            can contain parameters that can be injected when the resource method is executed.
                            Can be used in any scope.
                        </td></tr><tr><td>Setter methods</td><td>
                            Instead of injecting values directly into field the value can be injected into the
                            setter method which will initialize the field. This injection can be used only with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a>
                            annotation. This means
                            it cannot be used for example for injecting of query params but it can be used for injections of
                            request. The setters will be called after the object creation and
                            only once. The name of the method does not necessary have a setter pattern. Cannot be used
                            in Singleton scope except proxiable types mentioned above.
                        </td></tr></tbody></table></div></div><br class="table-break"><p>
            The following example shows all possible java constructs into which the values can be injected.

            </p><div class="example"><a name="d0e2637"></a><p class="title"><b>Example&nbsp;3.26.&nbsp;Example of possible injections</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public static class SummaryOfInjectionsResource {
    @QueryParam("query")
    String param; // injection into a class field


    @GET
    public String get(@QueryParam("query") String methodQueryParam) {
        // injection into a resource method parameter
        return "query param: " + param;
    }

    @Path("sub-resource-locator")
    public Class&lt;SubResource&gt; subResourceLocator(@QueryParam("query") String subResourceQueryParam) {
        // injection into a sub resource locator parameter
        return SubResource.class;
    }

    public SummaryOfInjectionsResource(@QueryParam("query") String constructorQueryParam) {
        // injection into a constructor parameter
    }


    @Context
    public void setRequest(Request request) {
        // injection into a setter method
        System.out.println(request != null);
    }
}

public static class SubResource {
    @GET
    public String get() {
        return "sub resource";
    }
}</pre></div></div><p><br class="example-break">
        </p><p>The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/FormParam.html" target="_top">@FormParam</a> annotation is special and may only be utilized on resource and sub-resource methods.
            This is because it extracts information from a request entity.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2648"></a>3.6.&nbsp;Use of @Context</h2></div></div></div><p>Previous sections have introduced the use of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a>. Chapter "Context" in the JAX-RS
            specification presents all the standard JAX-RS Java types that may be used with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a>.
        </p><p>When deploying a JAX-RS application using servlet then
            <a class="link" href="https://jakarta.ee/specifications/servlet/5.0/apidocs/jakarta/servlet/ServletConfig.html" target="_top">ServletConfig</a>,
            <a class="link" href="https://jakarta.ee/specifications/servlet/5.0/apidocs/jakarta/servlet/ServletContext.html" target="_top">ServletContext</a>,
            <a class="link" href="https://jakarta.ee/specifications/servlet/5.0/apidocs/jakarta/servlet/http/HttpServletRequest.html" target="_top">HttpServletRequest</a>
            and
            <a class="link" href="https://jakarta.ee/specifications/servlet/5.0/apidocs/jakarta/servlet/http/HttpServletResponse.html" target="_top">HttpServletResponse</a>
            are available using <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2676"></a>3.7.&nbsp;Programmatic resource model</h2></div></div></div><p>Resources can be constructed from classes or instances but also can be constructed from a programmatic resource
            model. Every resource created from resource classes can also
            be constructed using the programmatic resource builder api. See <a class="link" href="#resource-builder" title="Chapter&nbsp;14.&nbsp;Programmatic API for Building Resources">resource builder section</a> for more information.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="deployment"></a>Chapter&nbsp;4.&nbsp;Application Deployment and Runtime Environments</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#deployment.intro">4.1. Introduction</a></span></dt><dt><span class="section"><a href="#environmenmt.appmodel">4.2. JAX-RS Application Model</a></span></dt><dt><span class="section"><a href="#deployment.autodiscoverable">4.3. Auto-Discoverable Features</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.autodiscovery.config">4.3.1. Configuring Feature Auto-discovery Mechanism</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.classpath-scanning">4.4. Configuring the Classpath Scanning</a></span></dt><dt><span class="section"><a href="#deployment.javase">4.5. Java SE Deployment Environments</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.http">4.5.1. HTTP servers</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.jaxrs.endpoint">4.6. Creating programmatic JAX-RS endpoint</a></span></dt><dt><span class="section"><a href="#deployment.servlet">4.7. Servlet-based Deployment</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.servlet.2">4.7.1. Servlet 2.x way</a></span></dt><dt><span class="section"><a href="#deployment.servlet.5">4.7.2. Servlet 5.x Container</a></span></dt><dt><span class="section"><a href="#deployment.servlet.containers">4.7.3. Jersey Servlet container modules</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.javaee">4.8. Jakarta EE Platform</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.javaee.managed">4.8.1. Managed Beans</a></span></dt><dt><span class="section"><a href="#deployment.javaee.cdi">4.8.2. Context and Dependency Injection (CDI)</a></span></dt><dt><span class="section"><a href="#deployment.javaee.ejb">4.8.3. Enterprise Java Beans (EJB)</a></span></dt><dt><span class="section"><a href="#deployment.appservers">4.8.4. Jakarta EE Servers</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.osgi">4.9. OSGi</a></span></dt><dd><dl><dt><span class="section"><a href="#osgi.shell">4.9.1. Enabling the OSGi shell in Glassfish</a></span></dt><dt><span class="section"><a href="#osgi.wab">4.9.2. WAB Example</a></span></dt><dt><span class="section"><a href="#osgi.httpservice">4.9.3. HTTP Service Example</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.other">4.10. Other Environments</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.other.cloud">4.10.1. Oracle Java Cloud Service</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.intro"></a>4.1.&nbsp;Introduction</h2></div></div></div><p>
            This chapter is an overview of various server-side environments currently capable of running JAX-RS applications
            on top of Jersey server runtime. Jersey supports wide range of server environments from lightweight http containers
            up to full-fledged Java/Jakarta EE servers. Jersey applications can also run in an OSGi runtime.
            The way how the application is published depends on whether the application shall run in a Java SE environment or
            within a container.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                This chapter is focused on server-side Jersey deployment models. The
                <a class="link" href="#client" title="Chapter&nbsp;5.&nbsp;Client API">Jersey client runtime</a> does
                not have any specific container requirements and runs in plain Java SE 8 or higher runtime.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="environmenmt.appmodel"></a>4.2.&nbsp;JAX-RS Application Model</h2></div></div></div><p>
            JAX-RS provides a deployment agnostic abstract class <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a>
            for declaring root resource and provider classes, and root resource and provider singleton instances.
            A Web service may extend this class to declare root resource and provider classes. For example,
            </p><div class="example"><a name="d0e2707"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Deployment agnostic application model</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyApplication extends Application {
    @Override
    public Set&lt;Class&lt;?&gt;&gt; getClasses() {
        Set&lt;Class&lt;?&gt;&gt; s = new HashSet&lt;Class&lt;?&gt;&gt;();
        s.add(HelloWorldResource.class);
        return s;
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            Alternatively it is possible to reuse <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> - Jersey's own implementations
            of <code class="literal">Application</code> class. This class can either be directly instantiated and then configured
            or it can be extended and the configuration code placed into the constructor of the extending class. The
            approach typically depends on the chosen deployment runtime.
        </p><p>
            Compared to <code class="literal">Application</code>, the <code class="literal">ResourceConfig</code> provides advanced capabilities
            to simplify registration of JAX-RS components, such as scanning for root resource and provider classes in a provided
            classpath or a set of package names etc. All JAX-RS component classes that are either manually registered or
            found during scanning are automatically added to the set of classes that are returned by
            <code class="literal">getClasses</code>. For example, the following application class that extends from
            <code class="literal">ResourceConfig</code> scans during deployment for JAX-RS components in packages
            <code class="literal">org.foo.rest</code> and <code class="literal">org.bar.rest</code>:
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    <span class="emphasis"><em>Package scanning</em></span> ignores an inheritance and therefore <code class="literal">@Path</code> annotation
                    on parent classes and interfaces will be ignored. These classes won't be registered as the JAX-RS component
                    classes.
                </p></div><p>
            </p><div class="example"><a name="d0e2751"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Reusing Jersey implementation in your custom application model</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyApplication extends ResourceConfig {
    public MyApplication() {
        packages("org.foo.rest;org.bar.rest");
    }
}</pre></div></div><p><br class="example-break">
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Later in this chapter, the term <span class="emphasis"><em><code class="literal">Application</code> subclass</em></span> is frequently used.
                Whenever used, this term refers to the JAX-RS Application Model explained above.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.autodiscoverable"></a>4.3.&nbsp;Auto-Discoverable Features</h2></div></div></div><p>
            By default Jersey 3.x does not implicitly register any extension features from the modules available on the
            classpath, unless explicitly stated otherwise in the documentation of each particular extension.
            Users are expected to explicitly register the extension <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Feature.html" target="_top">Feature</a>s using their
            <code class="literal">Application</code> subclass.
            For a few Jersey provided modules however there is no need to explicitly register their extension
            <code class="literal">Feature</code>s as these are discovered and registered in the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configuration.html" target="_top">Configuration</a> (on client/server)
            automatically by Jersey runtime whenever the modules implementing these features are present on the classpath
            of the deployed JAX-RS application. The modules that are automatically discovered include:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>JSON binding feature from <code class="literal">jersey-media-moxy</code></p></li><li class="listitem"><p><code class="literal">jersey-media-json-processing</code></p></li><li class="listitem"><p><code class="literal">jersey-bean-validation</code></p></li></ul></div><p>
        </p><p>
            Besides these modules there are also few features/providers present in <code class="literal">jersey-server</code> module that
            are discovered by this mechanism and their availability is affected by Jersey auto-discovery support configuration
            (see <a class="xref" href="#deployment.autodiscovery.config" title="4.3.1.&nbsp;Configuring Feature Auto-discovery Mechanism">Section&nbsp;4.3.1, &#8220;Configuring Feature Auto-discovery Mechanism&#8221;</a>), namely:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/wadl/WadlFeature.html" target="_top">WadlFeature</a> - enables WADL processing.</p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/filter/UriConnegFilter.html" target="_top">UriConnegFilter</a> - a URI-based content negotiation filter.</p></li></ul></div><p>

            Almost all Jersey auto-discovery implementations have <code class="code">AutoDiscoverable.DEFAULT_PRIORITY</code>
            <code class="literal">@Priority</code> set.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Auto discovery functionality is in Jersey supported by implementing an internal
                <code class="literal">AutoDiscoverable</code> Jersey SPI. This interface is not public at the moment,
                and is subject to change in the future, so be careful when trying to use it.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.autodiscovery.config"></a>4.3.1.&nbsp;Configuring Feature Auto-discovery Mechanism</h3></div></div></div><p>
                The mechanism of feature auto-discovery in Jersey that described above is enabled by default. It can be
                disabled by using special (common/server/client) properties:

                </p><div class="itemizedlist"><p class="title"><b>Common auto discovery properties</b></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></p><p>When set, disables auto discovery globally on client/server.</p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">CommonProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p><p>When set, disables configuration of Json Processing (JSR-353) feature.</p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">CommonProperties.MOXY_JSON_FEATURE_DISABLE</a></p><p>When set, disables configuration of MOXy Json feature.</p></li></ul></div><p>

                For each of these properties there is a client/server counter-part that is only honored by the Jersey
                client or server runtime respectively (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html" target="_top">ClientProperties</a>/<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html" target="_top">ServerProperties</a>).
                When set, each of these client/server specific auto-discovery related properties overrides the value of the
                related common property.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    In case an auto-discoverable mechanism (in general or for a specific feature) is disabled, then all the
                    features, components and/or properties, registered by default using the auto-discovery mechanism have
                    to be registered manually.
                </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.classpath-scanning"></a>4.4.&nbsp;Configuring the Classpath Scanning</h2></div></div></div><p>
            Jersey uses a common Java Service Provider mechanism to obtain all service implementations. It means that Jersey
            scans the whole class path to find appropriate <code class="literal">META-INF/services/</code> files. The class path scanning
            may be time consuming. The more jar or war files on the classpath the longer the scanning time.
            In use cases where you need to save every millisecond of application bootstrap time,
            you may typically want to disable the services provider lookup in Jersey.

            </p><div class="itemizedlist"><p class="title"><b>List of SPIs recognized by Jersey</b></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">AutoDiscoverable</code> (server, client) -
                        it means if you disable service loading the AutoDiscoverable feature is automatically disabled too</p></li><li class="listitem"><p><code class="literal">ForcedAutoDiscoverable</code> (server, client) -
                        Jersey always looks for these auto discoverable features even if the service loading is disabled</p></li><li class="listitem"><p><code class="literal">HeaderDelegateProvider</code> (server, client)</p></li><li class="listitem"><p><code class="literal">ComponentProvider</code> (server)</p></li><li class="listitem"><p><code class="literal">ContainerProvider</code> (server)</p></li><li class="listitem"><p><code class="literal">AsyncContextDelegateProvider</code> (server/Servlet)</p></li></ul></div><p>

            </p><div class="itemizedlist"><p class="title"><b>List of additional SPIs recognized by Jersey in case the <code class="literal">metainf-services</code> module is on the classpath</b></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">MessageBodyReader</code> (server, client)</p></li><li class="listitem"><p><code class="literal">MessageBodyWriter</code> (server, client)</p></li><li class="listitem"><p><code class="literal">ExceptionMapper</code> (server, client)</p></li></ul></div><p>

            Since it is possible to configure all SPI implementation classes or instances manually in your
            <code class="literal">Application</code> subclass, disabling services lookup in Jersey does not affect any
            functionality of Jersey core modules and extensions and can save dozens of ms during application
            initialization in exchange for a more verbose application configuration code.
        </p><p>
            The services lookup in Jersey (enabled by default) can be disabled via a dedicated
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">CommonProperties.METAINF_SERVICES_LOOKUP_DISABLE</a> property.
            There is a client/server counter-part that only disables the feature on the client or server respectively:
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">ClientProperties.METAINF_SERVICES_LOOKUP_DISABLE</a>/<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">ServerProperties.METAINF_SERVICES_LOOKUP_DISABLE</a>.
            As in all other cases, the client/server specific properties overrides the value of the related common property,
            when set.
        </p><p>
            For example, following code snippet disables service provider lookup and manually registers implementations
            of different JAX-RS and Jersey provider types
            (<a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerRequestFilter.html" target="_top">ContainerRequestFilter</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Feature.html" target="_top">Feature</a>, <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/spi/ComponentProvider.html" target="_top">ComponentProvider</a>
            and <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/spi/ContainerProvider.html" target="_top">ContainerProvider</a>):
            </p><div class="example"><a name="d0e2956"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Registering SPI implementations using ResourceConfig</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ResourceConfig resourceConfig = new ResourceConfig(MyResource.class);
resourceConfig.register(org.glassfish.jersey.server.filter.UriConnegFilter.class);
resourceConfig.register(org.glassfish.jersey.server.validation.ValidationFeature.class);
resourceConfig.register(org.glassfish.jersey.server.spring.SpringComponentProvider.class);
resourceConfig.register(org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpContainerProvider.class);
resourceConfig.property(ServerProperties.METAINF_SERVICES_LOOKUP_DISABLE, true);</pre></div></div><p><br class="example-break">

            Similarly, in scenarios where the deployment model requires extending the <code class="literal">Application</code> subclass
            (e.g. in all Servlet container deployments), the following code could be used to achieve the same application
            configuration:

            </p><div class="example"><a name="d0e2965"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Registering SPI implementations using <code class="literal">ResourceConfig</code> subclass</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyApplication extends ResourceConfig {
    public MyApplication() {
        register(org.glassfish.jersey.server.filter.UriConnegFilter.class);
        register(org.glassfish.jersey.server.validation.ValidationFeature.class);
        register(org.glassfish.jersey.server.spring.SpringComponentProvider.class);
        register(org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpContainerProvider.class);
        property(ServerProperties.METAINF_SERVICES_LOOKUP_DISABLE, true);
    }
}</pre></div></div><p><br class="example-break">
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.javase"></a>4.5.&nbsp;Java SE Deployment Environments</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.http"></a>4.5.1.&nbsp;HTTP servers</h3></div></div></div><p>
                Java based HTTP servers represent a minimalistic and flexible way of deploying Jersey application.
                The HTTP servers are usually embedded in the application and configured and started programmatically.
                In general, Jersey container for a specific HTTP server provides a custom factory method that returns
                a correctly initialized HTTP server instance.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.http.jdk"></a>4.5.1.1.&nbsp;JDK Http Server</h4></div></div></div><p>
                    Starting with Java SE 6, Java runtime ships with a built-in lightweight HTTP server. Jersey offers
                    integration with this Java SE HTTP server through the <code class="literal">jersey-container-jdk-http</code>
                    container extension module.
                    Instead of creating the <code class="literal"><a class="link" href="http://docs.oracle.com/javase/6/docs/jre/api/net/httpserver/spec/com/sun/net/httpserver/HttpServer.html" target="_top">HttpServer</a></code> instance directly, use the
                    <code class="literal">createHttpServer()</code> method of <code class="literal"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jdkhttp/JdkHttpServerFactory.html" target="_top">JdkHttpServerFactory</a></code>,
                    which creates the <code class="literal">HttpServer</code> instance configured as a Jersey container and
                    initialized with the supplied <code class="literal">Application</code> subclass.
                </p><p>
                    Creating new Jersey-enabled jdk http server is as easy as:

                    </p><div class="example"><a name="d0e3009"></a><p class="title"><b>Example&nbsp;4.5.&nbsp;Using Jersey with JDK HTTP Server</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    "> URI baseUri = UriBuilder.fromUri("http://localhost/").port(9998).build();
ResourceConfig config = new ResourceConfig(MyResource.class);
HttpServer server = JdkHttpServerFactory.createHttpServer(baseUri, config);</pre>

                        A JDK HTTP Container dependency needs to be added:

                        <pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-jdk-http&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.http.grizzly"></a>4.5.1.2.&nbsp;Grizzly HTTP Server</h4></div></div></div><p><a class="link" href="https://javaee.github.io/grizzly/" target="_top">Grizzly</a> is a multi-protocol framework built on top of Java <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/nio/package-summary.html" target="_top">NIO</a>. Grizzly aims to simplify
                    development of robust and scalable servers.
                    Jersey provides a container extension module that enables support for using Grizzly as a plain vanilla
                    HTTP container that runs JAX-RS applications. Starting a Grizzly server to run
                    a JAX-RS or Jersey application is one of the most lightweight and easy ways how to expose a functional
                    RESTful services application.
                </p><p>
                    Grizzly HTTP container supports injection of Grizzly-specific
                    <code class="literal">org.glassfish.grizzly.http.server.Request</code> and
                    <code class="literal">org.glassfish.grizzly.http.server.Response</code> instances into JAX-RS and Jersey
                    application resources and providers. However, since Grizzly <code class="literal">Request</code> is not proxiable,
                    the injection of Grizzly <code class="literal">Request</code> into singleton (by default) JAX-RS / Jersey providers
                    is only possible via <code class="literal">jakarta.inject.Provider</code> instance. (Grizzly <code class="literal">Response</code>
                    does not suffer the same restriction.)
                </p><div class="example"><a name="d0e3048"></a><p class="title"><b>Example&nbsp;4.6.&nbsp;Using Jersey with Grizzly HTTP Server</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">URI baseUri = UriBuilder.fromUri("http://localhost/").port(9998).build();
    ResourceConfig config = new ResourceConfig(MyResource.class);
    HttpServer server = GrizzlyHttpServerFactory.createHttpServer(baseUri, config);</pre>

                    The container extension module dependency to be added is:

                    <pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-grizzly2-http&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Jersey uses Grizzly extensively in the project unit and end-to-end tests via
                        <a class="link" href="#test-framework" title="Chapter&nbsp;26.&nbsp;Jersey Test Framework">test framework</a>.
                    </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.http.simple"></a>4.5.1.3.&nbsp;Simple server</h4></div></div></div><p>
                    <a class="link" href="http://www.simpleframework.org/" target="_top">Simple</a> is a framework which allows developers
                    to create a HTTP server instance and embed it within
                    an application. Again, creating the server instance is achieved by calling a factory method from the
                    <code class="literal">jersey-container-simple-http</code> container extension module.
                </p><p>
                    Simple framework HTTP container supports injection of Simple framework-specific
                    <code class="literal">org.simpleframework.http.Request</code> and
                    <code class="literal">org.simpleframework.http.Response</code> instances into JAX-RS and Jersey
                    application resources and providers.
                </p><div class="example"><a name="d0e3081"></a><p class="title"><b>Example&nbsp;4.7.&nbsp;Using Jersey with the Simple framework</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">URI baseUri = UriBuilder.fromUri("http://localhost/").port(9998).build();
    ResourceConfig config = new ResourceConfig(MyResource.class);
    SimpleContainer server = SimpleContainerFactory.create(baseUri, config);</pre>

                    The necessary container extension module dependency in this case is:

                    <pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-simple-http&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Simple framework HTTP container does not support deployment on context paths other than
                        root path ("<code class="literal">/</code>"). Non-root context path is ignored during deployment.
                    </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.http.jetty"></a>4.5.1.4.&nbsp;Jetty HTTP Server</h4></div></div></div><p>
                    Jetty is a popular Servlet container and HTTP server. We will not look into Jetty's capabilities as a
                    Servlet container (although we are using it in our tests and examples), because there is nothing specific
                    to Jetty when using a Servlet-based deployment model, which is extensively described later in our
                    <a class="xref" href="#deployment.servlet" title="4.7.&nbsp;Servlet-based Deployment">Section&nbsp;4.7, &#8220;Servlet-based Deployment&#8221;</a> section. We will here only focus on describing how to use
                    Jetty's HTTP server.
                </p><p>
                    Jetty HTTP container supports injection of Jetty-specific
                    <code class="literal">org.eclipse.jetty.server.Request</code> and
                    <code class="literal">org.eclipse.jetty.server.Response</code> instances into JAX-RS and Jersey
                    application resources and providers. However, since Jetty HTTP <code class="literal">Request</code> is not proxiable,
                    the injection of Jetty <code class="literal">Request</code> into singleton (by default) JAX-RS / Jersey providers
                    is only possible via <code class="literal">jakarta.inject.Provider</code> instance. (Jetty <code class="literal">Response</code>
                    does not suffer the same restriction.)
                </p><div class="example"><a name="d0e3122"></a><p class="title"><b>Example&nbsp;4.8.&nbsp;Using Jersey with Jetty HTTP Server</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">URI baseUri = UriBuilder.fromUri("http://localhost/").port(9998).build();
ResourceConfig config = new ResourceConfig(MyResource.class);
Server server = JettyHttpContainerFactory.createServer(baseUri, config);</pre>

                    And, of course, we add the necessary container extension module dependency:

                    <pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-jetty-http&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Jetty HTTP container does not support deployment on context paths other than
                        root path ("<code class="literal">/</code>"). Non-root context path is ignored during deployment.
                    </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.http.netty"></a>4.5.1.5.&nbsp;Netty HTTP Server</h4></div></div></div><p>
                    Netty is a NIO client server framework which enables quick and easy development of network
                    applications such as protocol servers and clients. Jersey supports Netty as a container and
                    as a client connector - this chapter will present how to use the container.
                </p><div class="example"><a name="d0e3141"></a><p class="title"><b>Example&nbsp;4.9.&nbsp;Using Jersey with Netty HTTP Server</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">URI baseUri = UriBuilder.fromUri("http://localhost/").port(9998).build();
ResourceConfig resourceConfig = new ResourceConfig(HelloWorldResource.class);
Channel server = NettyHttpContainerProvider.createServer(baseUri, resourceConfig, false);</pre>

                    And, of course, we add the necessary container extension module dependency:

                    <pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-netty-http&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Netty HTTP container does not support deployment on context paths other than
                        root path ("<code class="literal">/</code>"). Non-root context path is ignored during deployment.
                    </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.jaxrs.endpoint"></a>4.6.&nbsp;Creating programmatic JAX-RS endpoint</h2></div></div></div><p>
            JAX-RS specification also defines the ability to programmatically create a JAX-RS application endpoint
            (i.e. container) for any instance of a <code class="literal">Application</code> subclass. For example, Jersey supports
            creation of <a class="link" href="http://grizzly.java.net/" target="_top">Grizzly</a> <code class="literal">HttpHandler</code> instance
            as follows:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">HttpHandler endpoint = RuntimeDelegate.getInstance()
        .createEndpoint(new MyApplication(), HttpHandler.class);</pre><p>

            Once the Grizzly <code class="literal">HttpHandler</code> endpoint is created, it can be used for in-process deployment
            to a specific base URL.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.servlet"></a>4.7.&nbsp;Servlet-based Deployment</h2></div></div></div><p>
            In a Servlet container, JAX-RS defines multiple deployment options depending on the Servlet API version supported by
            the Servlet container. Following sections describe these options in detail.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.servlet.2"></a>4.7.1.&nbsp;Servlet 2.x way</h3></div></div></div><p>
                Jersey integrates with any Servlet containers supporting at least Servlet 2.5 specification. Running on a
                Servlet container that supports Servlet API 5.0 it's required to adjust this approach to jakartified Servlet API.
                This includes Jakarta EE 9 namespaces which is applied since the 5.x Servlet API version.
                In this section we will focus on the basic deployment models available in any Servlet 2.5 container.
            </p><p>
                Using Servlet 2.x way, you have to explicitly declare the Jersey container Servlet in your Web application's
                <code class="literal">web.xml</code> deployment descriptor file.

                </p><div class="example"><a name="d0e3190"></a><p class="title"><b>Example&nbsp;4.10.&nbsp;Hooking up Jersey as a Servlet</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app&gt;
                        &lt;servlet&gt;
                        &lt;servlet-name&gt;MyApplication&lt;/servlet-name&gt;
                        &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt;
                        &lt;init-param&gt;
                        ...
                        &lt;/init-param&gt;
                        &lt;/servlet&gt;
                        ...
                        &lt;servlet-mapping&gt;
                        &lt;servlet-name&gt;MyApplication&lt;/servlet-name&gt;
                        &lt;url-pattern&gt;/myApp/*&lt;/url-pattern&gt;
                        &lt;/servlet-mapping&gt;
                        ...
                        &lt;/web-app&gt;</pre></div></div><p><br class="example-break">

                Alternatively, you can register Jersey container as a <span class="emphasis"><em>filter</em></span>:

                </p><div class="example"><a name="d0e3199"></a><p class="title"><b>Example&nbsp;4.11.&nbsp;Hooking up Jersey as a Servlet Filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app&gt;
                        &lt;filter&gt;
                        &lt;filter-name&gt;MyApplication&lt;/filter-name&gt;
                        &lt;filter-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/filter-class&gt;
                        &lt;init-param&gt;
                        ...
                        &lt;/init-param&gt;
                        &lt;/filter&gt;
                        ...
                        &lt;filter-mapping&gt;
                        &lt;filter-name&gt;MyApplication&lt;/filter-name&gt;
                        &lt;url-pattern&gt;/myApp/*&lt;/url-pattern&gt;
                        &lt;/filter-mapping&gt;
                        ...
                        &lt;/web-app&gt;</pre></div></div><p><br class="example-break">
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    Since pure Servlet 2.x way deployment does not provide a way how to programmatically read the filter
                    mappings in order to make application with filter work correctly, the context path of the app needs
                    to be defined using init parameter <code class="literal">jersey.config.servlet.filter.contextPath</code> for
                    <code class="literal">jersey-container-servlet-core</code>.
                    Or <code class="literal">jersey-container-servlet</code> shall be used.
                </p></div><p>
                The content of the <code class="literal">&lt;init-param&gt;</code> element will vary depending on the way you decide to
                configure Jersey resources.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.servlet.2.application"></a>4.7.1.1.&nbsp;Custom <code class="literal">Application</code> subclass</h4></div></div></div><p>
                    If you extend the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a> class to provide the list of relevant root resource
                    classes (<code class="literal">getClasses()</code>) and singletons (<code class="literal">getSingletons()</code>),
                    i.e. your JAX-RS application model, you then need to register it in your web application
                    <code class="literal">web.xml</code> deployment descriptor using a Servlet or Servlet filter initialization
                    parameter with a name of  <code class="literal">jakarta.ws.rs.Application</code> [<span class="emphasis"><em>sic</em></span>] as follows:

                    </p><div class="example"><a name="d0e3248"></a><p class="title"><b>Example&nbsp;4.12.&nbsp;
                            Configuring Jersey container Servlet or Filter to use custom <code class="literal">Application</code> subclass
                        </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;init-param&gt;
                            &lt;param-name&gt;jakarta.ws.rs.Application&lt;/param-name&gt;
                            &lt;param-value&gt;org.foo.MyApplication&lt;/param-value&gt;
                            &lt;/init-param&gt;</pre></div></div><p><br class="example-break">

                    Jersey will consider all the classes returned by <code class="literal">getClasses()</code> and
                    <code class="literal">getSingletons()</code> methods of your <code class="literal">Application</code> implementation.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        The name of the configuration property as defined by JAX-RS specification is indeed
                        <code class="literal">jakarta.ws.rs.Application</code> and not <code class="literal">jakarta.ws.rs.core.Application</code>
                        as one might expect.
                    </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.servlet.2.package"></a>4.7.1.2.&nbsp;Jersey package scanning</h4></div></div></div><p>
                    If there is no configuration properties to be set and deployed application consists only from resources
                    and providers stored in particular packages, you can instruct Jersey to scan these packages
                    and register any found resources and providers automatically:

                    </p><div class="example"><a name="d0e3280"></a><p class="title"><b>Example&nbsp;4.13.&nbsp;Configuring Jersey container Servlet or Filter to use package scanning</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;init-param&gt;
                            &lt;param-name&gt;jersey.config.server.provider.packages&lt;/param-name&gt;
                            &lt;param-value&gt;
                            org.foo.myresources,org.bar.otherresources
                            &lt;/param-value&gt;
                            &lt;/init-param&gt;
                            &lt;init-param&gt;
                            &lt;param-name&gt;jersey.config.server.provider.scanning.recursive&lt;/param-name&gt;
                            &lt;param-value&gt;false&lt;/param-value&gt;
                            &lt;/init-param&gt;</pre></div></div><p><br class="example-break">

                    Jersey will automatically discover the resources and providers in the selected packages.
                    You can also decide whether Jersey should recursively scan also sub-packages by setting the
                    <code class="literal">jersey.config.server.provider.scanning.recursive</code> property.
                    The default value is <code class="literal">true</code>, i.e. the recursive scanning of sub-packages is enabled.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.servlet.2.classes"></a>4.7.1.3.&nbsp;Selecting concrete resource and provider classes</h4></div></div></div><p>
                    While the above-mentioned package scanning is useful esp. for development and testing, you may want to
                    have a little bit more control when it comes to production deployment in terms of being able to enumerate
                    specific resource and provider classes. In Jersey it is possible to achieve this even without a need to
                    implement a custom <code class="literal">Application</code> subclass. The specific resource and provider
                    fully-qualified class names can be provided in a comma-separated value of
                    <code class="literal">jersey.config.server.provider.classnames</code> initialization parameter.
                </p><div class="example"><a name="d0e3303"></a><p class="title"><b>Example&nbsp;4.14.&nbsp;Configuring Jersey container Servlet or Filter to use a list of classes</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;init-param&gt;
                        &lt;param-name&gt;jersey.config.server.provider.classnames&lt;/param-name&gt;
                        &lt;param-value&gt;
                        org.foo.myresources.MyDogResource,
                        org.bar.otherresources.MyCatResource
                        &lt;/param-value&gt;
                        &lt;/init-param&gt;</pre></div></div><br class="example-break"></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    All of the techniques that have been described in this section also apply to Servlet containers that
                    support Servlet API 5.0 with jakartified adjustments. Newer Servlet specifications only give you additional
                    features, deployment options and more flexibility.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.servlet.5"></a>4.7.2.&nbsp;Servlet 5.x Container</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.servlet.5.no.descriptor"></a>4.7.2.1.&nbsp;Descriptor-less deployment</h4></div></div></div><p>
                    There are multiple deployment options in the Servlet 5.0 container for a JAX-RS application defined
                    by implementing a custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a> subclass. For simple deployments, no
                    <code class="literal">web.xml</code> is necessary at all. Instead, an <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ApplicationPath.html" target="_top">@ApplicationPath</a> annotation can be used
                    to annotate the custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a> subclass and define the base application URI for all
                    JAX-RS resources configured in the application:

                    </p><div class="example"><a name="d0e3331"></a><p class="title"><b>Example&nbsp;4.15.&nbsp;Deployment of a JAX-RS application using <code class="literal">@ApplicationPath</code> with Servlet 5.0</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@ApplicationPath("resources")
public class MyApplication extends ResourceConfig {
    public MyApplication() {
        packages("org.foo.rest;org.bar.rest");
    }
}</pre></div></div><p><br class="example-break">
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        There are many other convenience methods in the <code class="literal">ResourceConfig</code> that can be used
                        in the constructor of your custom subclass to configure your JAX-RS application,
                        see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> API documentation for more details.
                    </p></div><p>
                    In case you are not providing <code class="literal">web.xml</code> deployment descriptor for your maven-based web
                    application project, you need to configure your <code class="literal">maven-war-plugin</code> to ignore the missing
                    <code class="literal">web.xml</code> file by setting
                    <a class="link" href="http://maven.apache.org/plugins/maven-war-plugin/war-mojo.html#failOnMissingWebXml" target="_top">failOnMissingWebXml</a>
                    configuration property to <code class="literal">false</code> in your project <code class="literal">pom.xml</code> file:

                    </p><div class="example"><a name="d0e3369"></a><p class="title"><b>Example&nbsp;4.16.&nbsp;Configuration of maven-war-plugin to ignore missing <code class="literal">web.xml</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;plugins&gt;
    ...
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.3&lt;/version&gt;
        &lt;configuration&gt;
            &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
    ...
&lt;/plugins&gt;</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.servlet.5.descriptor"></a>4.7.2.2.&nbsp;Deployment using <code class="literal">web.xml</code> descriptor</h4></div></div></div><p>
                    Another Servlet 5.x container deployment model is to declare the JAX-RS application details in the
                    <code class="literal">web.xml</code>.
                    This is typically suitable for more complex deployments, e.g. when security model needs to be
                    properly defined or when additional initialization parameters have to be passed to Jersey runtime.
                    JAX-RS 1.1 and later specifies that a fully qualified name of the class that implements
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a> may be used in the definition of a <code class="literal">&lt;servlet-name&gt;</code>
                    element as part of your application's <code class="literal">web.xml</code> deployment descriptor.
                </p><p>
                    Following example illustrates this approach:

                    </p><div class="example"><a name="d0e3399"></a><p class="title"><b>Example&nbsp;4.17.&nbsp;Deployment of a JAX-RS application using <code class="literal">web.xml</code> with Servlet 5.0
                        </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;org.foo.rest.MyApplication&lt;/servlet-name&gt;
    &lt;/servlet&gt;
    ...
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;org.foo.rest.MyApplication&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/resources&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</pre></div></div><p><br class="example-break">

                    Note that the <code class="literal">&lt;servlet-class&gt;</code> element is omitted from the Servlet declaration.
                    This is a correct declaration utilizing the Servlet 5.0 extension mechanism described in detail in the
                    <a class="xref" href="#deployment.servlet.5.pluggability" title="4.7.2.3.&nbsp;Servlet Pluggability Mechanism">Section&nbsp;4.7.2.3, &#8220;Servlet Pluggability Mechanism&#8221;</a> section. Also note that
                    <code class="literal">&lt;servlet-mapping&gt;</code> is used in the example to define the base resource URI.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.servlet.5.pluggability"></a>4.7.2.3.&nbsp;Servlet Pluggability Mechanism</h4></div></div></div><p>
                    Servlet framework pluggability mechanism is a feature introduced with Servlet 3.0 specification. It
                    simplifies the configuration of various frameworks built on top of Servlets. Instead of having one
                    <code class="literal">web.xml</code> file working as a central point for all the configuration options, it is possible
                    to modularize the deployment descriptor by using the concept of so-called web fragments - several specific
                    and focused <code class="literal">web.xml</code> files. A set of web fragments basically builds up the final
                    deployment descriptor. This mechanism also provides SPI hooks that enable web frameworks to register
                    themselves in the Servlet container or customize the Servlet container deployment process in some other way.
                    This section describes how JAX-RS and Jersey leverage the Servlet pluggability mechanism.
                </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="deployment.servlet.5.pluggability.noapp"></a>4.7.2.3.1.&nbsp;JAX-RS application without an <code class="literal">Application</code> subclass</h5></div></div></div>

                    If no <code class="literal">Application</code> (or <code class="literal">ResourceConfig</code>) subclass is present,
                    Jersey will dynamically add a Jersey container Servlet and set its name to
                    <code class="literal">jakarta.ws.rs.core.Application</code>. The web application path will be scanned and all the
                    root resource classes (the classes annotated with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> annotation) as well as any providers that are
                    annotated with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/Provider.html" target="_top">@Provider</a> annotation packaged with the application will be automatically registered
                    in the JAX-RS application. The web application has to be packaged with a deployment descriptor specifying
                    at least the mapping for the added <code class="literal">jakarta.ws.rs.core.Application</code> Servlet:

                    <div class="example"><a name="d0e3452"></a><p class="title"><b>Example&nbsp;4.18.&nbsp;
                            <code class="literal">web.xml</code> of a JAX-RS application without an <code class="literal">Application</code> subclass
                        </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app version="5.0"
    xmlns="https://jakarta.ee/xml/ns/jakartaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;

    &lt;!-- Servlet declaration can be omitted in which case
         it would be automatically added by Jersey --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;jakarta.ws.rs.core.Application&lt;/servlet-name&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;jakarta.ws.rs.core.Application&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/myresources/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="deployment.servlet.5.pluggability.app"></a>4.7.2.3.2.&nbsp;JAX-RS application with a custom <code class="literal">Application</code> subclass</h5></div></div></div><p>
                        When a custom <code class="literal">Application</code> subclass is provided, in such case the Jersey server runtime
                        behavior depends od whether or not there is a Servlet defined to handle the application subclass.
                    </p><p>
                        If the <code class="literal">web.xml</code> contains a Servlet definition, that has an initialization parameter
                        <code class="literal">jakarta.ws.rs.Application</code> whose value is the fully qualified name of the
                        <code class="literal">Application</code> subclass, Jersey does not perform any additional steps in such case.
                    </p><p>
                        If no such Servlet is defined to handle the custom <code class="literal">Application</code> subclass, Jersey
                        dynamically adds a Servlet with a fully qualified name equal to the name of the provided
                        <code class="literal">Application</code> subclass. To define the mapping for the added Servlet, you can either
                        annotate the custom <code class="literal">Application</code> subclass with an <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ApplicationPath.html" target="_top">@ApplicationPath</a> annotation
                        (Jersey will use the annotation value appended with <code class="literal">/*</code> to automatically define
                        the mapping for the Servlet), or specify the mapping for the Servlet in the
                        <code class="literal">web.xml</code> descriptor directly.
                    </p><p>
                        In the following example, let's assume that the JAX-RS application is defined using a custom
                        <code class="literal">Application</code> subclass named <code class="literal">org.example.MyApplication</code>.
                        Then the <code class="literal">web.xml</code> file could have the following structure:
                        </p><div class="example"><a name="d0e3516"></a><p class="title"><b>Example&nbsp;4.19.&nbsp;</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app version="5.0"
    xmlns="https://jakarta.ee/xml/ns/jakartaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;

    &lt;!-- Servlet declaration can be omitted in which case
         it would be automatically added by Jersey --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;org.example.MyApplication&lt;/servlet-name&gt;
    &lt;/servlet&gt;

    &lt;!-- Servlet mapping can be omitted in case the Application subclass
         is annotated with @ApplicationPath annotation; in such case
         the mapping would be automatically added by Jersey --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;org.example.MyApplication&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/myresources/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div></div><p><br class="example-break">
                    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                            If your custom <code class="literal">Application</code> subclass is packaged in the <code class="literal">war</code>, it defines
                            which resources will be taken into account.
                            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                                    If both <code class="literal">getClasses()</code> and <code class="literal">getSingletons()</code> methods return
                                    an empty collection, then ALL the root resource classes and providers packaged in the web
                                    application archive will be used, Jersey will automatically discover them by scanning the
                                    <code class="literal">.war</code> file.
                                </li><li class="listitem">
                                    If any of the two mentioned methods - <code class="literal">getClasses()</code> or
                                    <code class="literal">getSingletons()</code> returns a non-empty collection, only those classes and/or
                                    singletons will be published in the JAX-RS application.
                                </li></ul></div><p>
                        </p></div><div class="table"><a name="environment-table-pluggability"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Servlet 3 Pluggability Overview</b></p><div class="table-contents"><table summary="Servlet 3 Pluggability Overview" width="100%" border="1"><colgroup><col width="25%"><col width="25%"><col width="25%"><col width="25%"></colgroup><thead><tr><th align="left">Condition</th><th align="left">Jersey action</th><th align="left">Servlet Name</th><th align="left"><code class="literal">web.xml</code></th></tr></thead><tbody><tr><td align="left">No <code class="literal">Application</code> subclass</td><td align="left">Adds Servlet</td><td align="left"><code class="literal">jakarta.ws.rs.core.Application</code></td><td align="left">Servlet mapping is required</td></tr><tr><td align="left"><code class="literal">Application</code> subclass handled by existing Servlet</td><td align="left">No action</td><td align="left">Already defined</td><td align="left">Not required</td></tr><tr><td align="left"><code class="literal">Application</code> subclass NOT handled by existing Servlet</td><td align="left">Adds Servlet</td><td align="left">FQN of the <code class="literal">Application</code> subclass</td><td align="left">
                                        if no <code class="literal">@ApplicationPath</code> on the <code class="literal">Application</code>
                                        subclass, then Servlet mapping is required
                                    </td></tr></tbody></table></div></div><br class="table-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.servlet.containers"></a>4.7.3.&nbsp;Jersey Servlet container modules</h3></div></div></div><p>
                Jersey uses its own <code class="literal"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/servlet/ServletContainer.html" target="_top">ServletContainer</a></code> implementation of Servlet and
                Servlet Filter API to integrate with Servlet containers. As any Jakartified JAX-RS runtime (JAX-RS spec 3.0),
                Jersey provides support for Servlet containers that support Servlet specification version 5.0 or higher
                is required.
            </p><p>
                When deploying to a Servlet container, Jersey application is typically packaged as a <code class="literal">.war</code> file.
                As with any other Servlet application, JAX-RS application classes are packaged in
                <code class="literal">WEB-INF/classes</code> or <code class="literal">WEB-INF/lib</code> and required application libraries are
                located in <code class="literal">WEB-INF/lib</code>.
                For more details, please refer to the Servlet Specification (<a class="link" href="https://jakarta.ee/specifications/servlet/5.0/" target="_top">Servlet 5 spec</a>).
            </p><p>
                Jersey provides two Servlet modules. The first module is the Jersey core Servlet module that provides
                the core Servlet integration support and is required in any Servlet 5 or higher container:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-servlet-core&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><p>

                To support additional Servlet 5.x deployment modes and asynchronous JAX-RS resource programming model,
                an additional Jersey module is required:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><p>

                The <code class="literal">jersey-container-servlet</code> module depends on
                <code class="literal">jersey-container-servlet-core</code> module, therefore when it is used, it is not necessary to
                explicitly declare the <code class="literal">jersey-container-servlet-core</code> dependency.
            </p><p>
                Note that in simple cases, you don't need to provide the deployment descriptor (<code class="literal">web.xml</code>)
                and can use the <code class="literal">@ApplicationPath</code> annotation, as described in
                <a class="xref" href="#">???</a> section.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.javaee"></a>4.8.&nbsp;Jakarta EE Platform</h2></div></div></div><p>
            This section describes, how you can publish Jersey JAX-RS resources as various Jakarta EE platform elements.
            JAX-RS and Jersey give you wide choice of possibilities and it is up to your taste (and design of your application),
            what Jakarta EE technology you decide to use for the management of your resources.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.javaee.managed"></a>4.8.1.&nbsp;Managed Beans</h3></div></div></div><p>
                Jersey supports the use of Jakarta EE Managed beans as root resource classes, providers as well as
                <code class="literal">Application</code> subclasses.
            </p><p>
                In the code below, you can find an example of a bean, that uses a managed-bean interceptor defined as a JAX-RS
                bean. The bean is used to intercept calls to the resource method <code class="literal">getIt()</code>:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@ManagedBean
@Path("/managedbean")
public class ManagedBeanResource {

    public static class MyInterceptor {
        @AroundInvoke
        public String around(InvocationContext ctx) throws Exception {
            System.out.println("around() called");
            return (String) ctx.proceed();
        }
    }

    @GET
    @Produces("text/plain")
    @Interceptors(MyInterceptor.class)
    public String getIt() {
        return "Hi managed bean!";
    }
}</pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.javaee.cdi"></a>4.8.2.&nbsp;Context and Dependency Injection (CDI)</h3></div></div></div><p>
                CDI beans can be used as Jersey root resource classes, providers as well as <code class="literal">Application</code>
                subclasses. Providers and <code class="literal">Application</code> subclasses have to be singleton or application scoped.
            </p><p>
                The next example shows a usage of a CDI bean as a JAX-RS root resource class. We assume, that CDI has been
                enabled. The code snipped uses the type-safe dependency injection provided in CDI by using another bean
                (<code class="literal">MyOtherCdiBean</code>):

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/cdibean")
public class CdiBeanResource {
    @Inject MyOtherCdiBean bean;  // CDI injected bean

    @GET
    @Produces("text/plain")
    public String getIt() {
        return bean.getIt();
    }
}</pre><p>
            </p><p>
              The above works naturally inside any Java/Jakarta EE compliant AS container. In Jersey version 2.15, container agnostic CDI support was introduced.
              This feature allows you to publish CDI based JAX-RS resources also in other containers. Jersey cdi-webapp example shows Jersey/CDI integration
              in Grizzly HTTP and Apache Tomcat server. Detailed description of Jersey CDI support outside of a fully fledged Java/Jakarta EE application container
              could be found in <a class="xref" href="#cdi.support" title="Chapter&nbsp;25.&nbsp;Jersey CDI Container Agnostic Support">Chapter&nbsp;25, <i>Jersey CDI Container Agnostic Support</i></a>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.javaee.ejb"></a>4.8.3.&nbsp;Enterprise Java Beans (EJB)</h3></div></div></div><p>
                Stateless and Singleton Session beans can be used as Jersey root resource classes, providers and/or
                <code class="literal">Application</code> subclasses. You can choose from annotating the methods in the EJB's local
                interface or directly the method in an interface-less EJB POJO. JAX-RS specifications requires its
                implementors to discover EJBs by inspecting annotations on classes (or local interfaces),
                but not in the deployment descriptors (<code class="literal">ejb-jar.xml</code>). As such, to keep your JAX-RS
                application portable, do not override EJB annotations or provide any additional meta-data in the deployment
                descriptor file.
            </p><p>
                Following example consists of a stateless EJB and a local interface used in Jersey:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Local
public interface LocalEjb {
    @GET
    @Produces("text/plain")
   public String getIt();
}

@Stateless
@Path("/stateless")
public class StatelessEjbResource implements LocalEjb {
    @Override
    public String getIt() {
        return "Hi Stateless!";
    }
}</pre><p>
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Please note that Jersey currently does not support deployment of JAX-RS applications packaged as standalone
                    EJB modules (ejb-jars). To use EJBs as JAX-RS resources, the EJBs need to be packaged either directly in a
                    WAR or in an EAR that contains at least one WAR. This is to ensure Servlet container initialization that is
                    necessary for bootstrapping of the Jersey runtime.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.appservers"></a>4.8.4.&nbsp;Jakarta EE Servers</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.appservers.glassfish"></a>4.8.4.1.&nbsp;GlassFish Application Server</h4></div></div></div><p>
                    As explained in <a class="link" href="#servlet-app-glassfish" title="2.3.1.&nbsp;Servlet based application on Glassfish">2.3.1</a> , you don't need to add any specific
                    dependencies on GlassFish, Jersey is already packaged within GlassFish. You only need to add the
                    <code class="literal">provided</code>-scoped dependencies to your project to be able to compile it. At runtime,
                    GlassFish will make sure that your application has access to the Jersey libraries.
                </p><p>
                  Started with version 2.7, Jersey allows injecting Jersey specific types into CDI enabled JAX-RS components
                  using the <code class="literal">@jakarta.inject.Inject</code> annotation. This covers also custom HK2 bindings, that are configured
                  as part of Jersey application. The feature specifically enables usage of Jersey monitoring statistics (provided that the statistic feature is turned on)
                  in CDI environment, where injection is the only mean to get access to monitoring data.
                </p><p>
                  Since both CDI and HK2 use the same injection annotation, Jersey could get confused in certain
                  cases, which could lead to nasty runtime issues. The get better control over what Jersey evaluates
                  as HK2 injection, end-users could take advantage of newly introduced, <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/ext/cdi1x/spi/Hk2CustomBoundTypesProvider.html" target="_top">Hk2CustomBoundTypesProvider</a>, SPI.
                  Please see the linked javadoc to get detailed information on how to use the SPI in your application.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.appservers.weblogic"></a>4.8.4.2.&nbsp;Oracle WebLogic Server</h4></div></div></div><p>
                    For now Oracle WebLogic Server does not support Jakartified Jersey 3.x deployment (for deployment of prior
                    versions of Jersey please refer to corresponding manual/user guide)
                </p><p>
                    In 10.3.x, a set of pre-built shared libraries were delivered with WebLogic Server to support
                    Jersey 1.9 and 1.1.5.1 Java API for RESTful Web Services (JAX-RS) Reference Implementations (RIs).
                    In 12.2.x, WebLogic Server supports Jersey 2.21.x (JAX-RS 2.0 RI) by default. To use the pre-built
                    shared libraries of 10.3.x, you needed to register them with the WebLogic Server instance, and
                    modify the web.xml and weblogic.xml deployment descriptors to use the Jersey servlet and reference
                    the shared libraries, respectively.
                    In 12.2.x, as WebLogic Server supports Jersey 2.21.x (JAX-RS 2.0 RI) by default, registration as a
                    shared library with WebLogic Server is no longer required.
                    Please read through
                    the <a class="link" href="https://docs.oracle.com/middleware/12213/wls/WLUPG/upgrade_ws.htm#WLUPG331" target="_top">
                    Upgrading a 10.3.x RESTful Web Service (JAX-RS) to 12.2.x</a>
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="deployment.appservers.other"></a>4.8.4.3.&nbsp;Other Application Servers</h4></div></div></div><p>
                    Third party Java/Jakarta EE application servers usually ship with a JAX-RS implementation. If you want to
                    use Jersey instead of the default JAX-RS provider, you need to add Jersey libraries to your classpath and
                    disable the default JAX-RS provider in the container.
                </p><p>
                    In general, Jersey will be deployed as a Servlet and the resources can be deployed in various ways,
                    as described in this section. However, the exact steps will vary from vendor to vendor.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.osgi"></a>4.9.&nbsp;OSGi</h2></div></div></div><p>
            OSGi support has been added to the Jersey version 1.2. Since then, you should be able to utilize standard OSGi
            means to run Jersey based web applications in OSGi runtime as described in the OSGi Service Platform Enterprise
            Specification. Jersey is currently compatible with OSGi 4.2.0, the specification could be downloaded from the
            <a class="link" href="http://www.osgi.org/Download/Release4V42" target="_top">OSGi 4.2.0 Download Site</a>.
        </p><p>
            The two supported ways of running an OSGi web application are:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">WAB (Web Application Bundle)</li><li class="listitem">HTTP Service</li></ul></div><p>

            WAB is in fact just an OSGified WAR archive. HTTP Service feature allows you to publish Jakarta EE Servlets in
            the OSGi runtime.
        </p><p>
            Two examples were added to the Jersey distribution to depict the above mentioned features and show how to use
            them with Jersey:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/osgi-helloworld-webapp" target="_top">WAB Example</a></li><li class="listitem"><a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/osgi-http-service" target="_top">HTTP Service example</a></li></ul></div><p>

            Both examples are multi-module maven projects and both consist of an application OSGi bundle module and a test module.
            The tests are based on the <a class="link" href="http://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam" target="_top">PAX Exam</a>
            framework. Both OSGi examples also include a readme file containing instructions
            how to manually run the example applications using <a class="link" href="https://felix.apache.org/" target="_top">Apache Felix</a> framework.
        </p><p>
            The rest of the chapter describes how to run the above mentioned examples on GlassFish 6 application server.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="osgi.shell"></a>4.9.1.&nbsp;Enabling the OSGi shell in Glassfish</h3></div></div></div><p>
                Since GlassFish utilizes Apache Felix, an OSGi runtime comes out of the box with GlassFish.
                However, for security reasons, the OSGi shell has been turned off. You can however explicitly enable it
                either by starting GlassFish the <code class="literal">asadmin</code> console and creating a Java system property
                <code class="literal">glassfish.osgi.start.level.final</code> and setting its value to <code class="literal">3</code>:

                </p><div class="example"><a name="d0e3815"></a><p class="title"><b>Example&nbsp;4.20.&nbsp;</b></p><div class="example-contents">
                    Start the admin console:

                    <pre class="&#xA;    toolbar: false;&#xA;    brush: bash shell;&#xA;    ">
~/glassfish/bin$ ./asadmin
Use "exit" to exit and "help" for online help.
asadmin&gt;</pre>

                    You can check the actual value of the java property (loaded from the configuration file):

                    <pre class="&#xA;    toolbar: false;&#xA;    brush: bash shell;&#xA;    ">
asadmin&gt;  list-jvm-options
...
-Dglassfish.osgi.start.level.final=2
...</pre>

                    And change the value by typing:

                    <pre class="&#xA;    toolbar: false;&#xA;    brush: bash shell;&#xA;    ">
asadmin&gt;  create-jvm-options --target server -Dglassfish.osgi.start.level.final=3</pre></div></div><p><br class="example-break">
            </p><p>
                The second option is to change the value in the <code class="literal">osgi.properties</code> configuration file:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash shell;&#xA;    ">
# Final start level of OSGi framework. This is used by GlassFish launcher code
# to set the start level of the OSGi framework once server is up and running so that
# optional services can start. The initial start level of framework is controlled using
# the standard framework property called org.osgi.framework.startlevel.beginning
glassfish.osgi.start.level.final=3</pre><p>

                You can then execute the Felix shell commands by typing <code class="literal">osgi &lt;felix_command&gt;</code> in
                the <code class="literal">asadmin</code> console. For example:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash shell;&#xA;    ">
asadmin&gt; osgi lb
... list of bundles ...</pre><p>

                or launching the shell using <code class="literal">osgi-shell</code> command in the admin console (the domain must be
                started, otherwise the osgi shell won't launch):

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash shell;&#xA;    ">
asadmin&gt; osgi-shell
Use "exit" to exit and "help" for online help.
gogo$</pre><p>

                and execute the osgi commands directly (without the "<code class="literal">osgi</code>" prefix):

</p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash shell;&#xA;    ">
gogo$ lb
... list of bundles ...</pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="osgi.wab"></a>4.9.2.&nbsp;WAB Example</h3></div></div></div><p>
                As mentioned above, WAB is just an OSGi-fied WAR archive. Besides the usual OSGi headers it must
                in addition contain a special header, Web-ContextPath, specifying the web application context path.
                Our WAB has (beside some other) the following headers present in the manifest:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: text;&#xA;    ">Web-ContextPath: helloworld
Webapp-Context: helloworld
Bundle-ClassPath: WEB-INF/classese</pre><p>

                Here, the second header is ignored by GlassFish, but may be required by other containers not fully
                compliant with the OSGi Enterprise Specification mentioned above. The third manifest header
                worth mentioning is the Bundle-ClassPath specifying where to find the application
                Java classes within the bundle archive.
                More about manifest headers in OSGi can be found in the
                <a class="link" href="http://wiki.osgi.org/wiki/Category:Manifest_Header" target="_top">OSGi Wiki</a>.
            </p><p>
                For more detailed information on the example please see the <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/osgi-helloworld-webapp" target="_top">WAB Example</a> source code. This
                example does not package into a single <code class="literal">war</code> file. Instead a <code class="literal">war</code> and a
                set of additional <code class="literal">jar</code>s is produced during the build. See the next example to see how to deploy OSGi
                based Jersey application to GlassFish.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="osgi.httpservice"></a>4.9.3.&nbsp;HTTP Service Example</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    When deploying an OSGi HTTP Service example to GlassFish, please make sure the OSGi HTTP Service bundle is
                    installed on your GlassFish instance.
                </p></div><p>
                You can directly install and activate the Jersey application bundle. In case of our example, you can either
                install the example bundle stored locally (and alternatively build from Jersey sources):
            </p><p>
                1) Build (optional)

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    ">
examples$ cd osgi-http-service/bundle
bundle$ mvn clean package</pre><p>

                You can also get the binary readily compiled from
                <a class="link" href="https://maven.java.net/content/repositories/releases/org/glassfish/jersey/examples/osgi-http-service/bundle/3.0.2" target="_top">Java.net Maven Repository</a>.
            </p><p>
                2) Install into OSGi runtime:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash shell;&#xA;    ">
gogo$ install file:///path/to/file/bundle.jar
Bundle ID: 303</pre><p>

                or install it directly from the maven repository:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash shell;&#xA;    ">
gogo$ install https://repo1.maven.org/maven2/org/glassfish/jersey/examples/osgi-http-service/bundle/&lt;version&gt;/bundle-&lt;version&gt;.jar
Bundle ID: 303</pre><p>
            </p><p>
                Make sure to replace <code class="literal">&lt;version&gt;</code> with an appropriate version number. Which one is
                appropriate depends on the specific GlassFish 6.x version you are using. The version of the bundle cannot
                be higher than the version of Jersey integrated in your GlassFish 6.x server. Jersey bundles declare
                dependencies on other bundles at the OSGi level and those dependencies are version-sensitive. If you use
                example bundle from let's say version 3.0.0-RC2, but Glassfish has Jersey 3.0.0-M1, dependencies will not be satisfied
                and bundle will not start. If this happens, the error will look something like this:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    ">gogo$ lb
...
303 | Installed  |    1| jersey-examples-osgi-http-service-bundle (2.5.0.SNAPSHOT)
gogo$ start 303

org.osgi.framework.BundleException: Unresolved constraint in bundle
org.glassfish.jersey.examples.osgi-http-service.bundle [303]: Unable to resolve 308.0: missing requirement
[303.0] osgi.wiring.package; (&amp;(osgi.wiring.package=org.glassfish.jersey.servlet)
(version&gt;=3.0.0.RC2))

gogo$</pre><p>

                In the opposite scenario (example bundle version 3.0.0-M1 and Glassfish Jersey version higher), everything should
                work fine.
            </p><p>
                Also, if you build GlassFish from the main trunk sources and use the example from most recent
                Jersey release, you will most likely be able to run the examples from the latest Jersey release, as Jersey
                team typically integrates all newly released versions of Jersey immediately into GlassFish.
            </p><p>
                As a final step, start the bundle:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    ">gogo$ start 303</pre><p>

                Again, the Bundle ID (in our case 303) has to be replaced by the correct one returned from the
                <code class="literal">install</code> command.
            </p><p>
                The example app should now be up and running. You can access it on
                <a class="link" href="http://localhost:8080/osgi/jersey-http-service/status" target="_top">
                    http://localhost:8080/osgi/jersey-http-service/status
                </a>. Please see <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/osgi-http-service" target="_top">HTTP Service example</a> source code for more details on the example.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.other"></a>4.10.&nbsp;Other Environments</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.other.cloud"></a>4.10.1.&nbsp;Oracle Java Cloud Service</h3></div></div></div><p>
                As Oracle Public Cloud is based on WebLogic server, the same applies as in the paragraph about WebLogic
                deployment (see <a class="xref" href="#deployment.appservers.weblogic" title="4.8.4.2.&nbsp;Oracle WebLogic Server">Section&nbsp;4.8.4.2, &#8220;Oracle WebLogic Server&#8221;</a>). More on developing applications for
                Oracle Java Cloud Service can be found in this <a class="link" href="http://docs.oracle.com/cloud/131/developer_services/CSJSU/java-develop.htm#BABHDAJH" target="_top">guide</a>.
            </p></div></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="client"></a>Chapter&nbsp;5.&nbsp;Client API</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e3970">5.1. Uniform Interface Constraint</a></span></dt><dt><span class="section"><a href="#d0e4013">5.2. Ease of use and reusing JAX-RS artifacts</a></span></dt><dt><span class="section"><a href="#d0e4129">5.3. Overview of the Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4132">5.3.1. Getting started with the client API</a></span></dt><dt><span class="section"><a href="#d0e4151">5.3.2. 
                Creating and configuring a Client instance
            </a></span></dt><dt><span class="section"><a href="#d0e4335">5.3.3. Targeting a web resource</a></span></dt><dt><span class="section"><a href="#d0e4403">5.3.4. Identifying resource on WebTarget</a></span></dt><dt><span class="section"><a href="#d0e4479">5.3.5. Invoking a HTTP request</a></span></dt><dt><span class="section"><a href="#d0e4622">5.3.6. Example summary</a></span></dt><dt><span class="section"><a href="#d0e4651">5.3.7. Setting ExecutorService and ScheduledExecutorService</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4681">5.4. Java instances and types for representations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4700">5.4.1. Adding support for new representations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4734">5.5. Client Transport Connectors</a></span></dt><dt><span class="section"><a href="#d0e4984">5.6. Using client request and response filters</a></span></dt><dt><span class="section"><a href="#d0e5018">5.7. Closing connections</a></span></dt><dt><span class="section"><a href="#d0e5042">5.8. Injections into client providers</a></span></dt><dt><span class="section"><a href="#d0e5077">5.9. Securing a Client</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5224">5.9.1. Http Authentication Support</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5306">5.10. InvocationInterceptors</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5317">5.10.1. PreInvocationInterceptor</a></span></dt><dt><span class="section"><a href="#d0e5353">5.10.2. PostInvocationInterceptor</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e5394">5.11. InvocationBuilderListener</a></span></dt><dt><span class="section"><a href="#d0e5426">5.12. Header Expect:100-continue support</a></span></dt></dl></div><p>
        This section introduces the JAX-RS Client API, which is a fluent Java based API for communication with RESTful Web
        services. This standard API that is also part of Jakarta EE 9 is designed to make it very easy to consume a Web service
        exposed via HTTP protocol and enables developers to concisely and efficiently implement portable client-side solutions
        that leverage existing and well established client-side HTTP connector implementations.
    </p><p>
        The JAX-RS client API can be utilized to consume any Web service exposed on top of a HTTP protocol or it's
        extension (e.g. WebDAV), and is not restricted to services implemented using JAX-RS. Yet, developers familiar with JAX-RS
        should find the client API complementary to their services, especially if the client API is utilized by those services
        themselves, or to test those services.
        The JAX-RS client API finds inspiration in the proprietary Jersey 1.x Client API and developers familiar with the Jersey
        1.x Client API should find it easy to understand all the concepts introduced in the new JAX-RS Client API.
    </p><p>
        The goals of the client API are threefold:

        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    Encapsulate a key constraint of the REST architectural style, namely the Uniform Interface Constraint and
                    associated data elements, as client-side Java artifacts;
                </p></li><li class="listitem"><p>
                    Make it as easy to consume RESTful Web services exposed over HTTP, same as the JAX-RS server-side API makes
                    it easy to develop RESTful Web services; and
                </p></li><li class="listitem"><p>
                    Share common concepts and extensibility points of the JAX-RS API between the server and the client side
                    programming models.
                </p></li></ol></div><p>

        As an extension to the standard JAX-RS Client API, the  Jersey Client API supports a pluggable architecture to enable the
        use of different underlying HTTP client <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> implementations. Several such implementations are
        currently provided with Jersey. We have a default client connector using <code class="literal">Http(s)URLConnection</code> supplied
        with the JDK as well as connector implementations based on Apache HTTP Client, Jetty HTTP client and Grizzly Asynchronous Client.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3970"></a>5.1.&nbsp;Uniform Interface Constraint</h2></div></div></div><p>
            The uniform interface constraint bounds the architecture of RESTful Web services so that a client, such
            as a browser, can utilize the same interface to communicate with any service. This is a very powerful concept
            in software engineering that makes Web-based search engines and service mash-ups possible. It induces properties
            such as:

            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>simplicity, the architecture is easier to understand and maintain; and</p></li><li class="listitem"><p>
                        evolvability or loose coupling, clients and services can evolve over time perhaps in new and
                        unexpected ways, while retaining backwards compatibility.
                    </p></li></ol></div><p>

            Further constraints are required:

            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>every resource is identified by a URI;</p></li><li class="listitem"><p>
                        a client interacts with the resource via HTTP requests and responses using a fixed set of
                        HTTP methods;
                    </p></li><li class="listitem"><p>one or more representations can be returned and are identified by media types; and</p></li><li class="listitem"><p>the contents of which can link to further resources.</p></li></ol></div><p>

            The above process repeated over and again should be familiar to anyone who has used a browser to fill
            in HTML forms and follow links. That same process is applicable to non-browser based clients.
        </p><p>
            Many existing Java-based client APIs, such as the Apache HTTP client API or <code class="literal">HttpUrlConnection</code>
            supplied with the JDK place too much focus on the Client-Server constraint for the exchanges of request and
            responses rather than a resource, identified by a URI, and the use of a fixed set of HTTP methods.
        </p><p>A resource in the JAX-RS client API is an instance of the Java class
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a>.
            and encapsulates an URI. The fixed set of HTTP methods can be invoked based on the
            <code class="literal">WebTarget</code>.
            The representations are Java types, instances of which, may contain links that new instances of
            <code class="literal">WebTarget</code> may be created from.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4013"></a>5.2.&nbsp;Ease of use and reusing JAX-RS artifacts</h2></div></div></div><p>
            Since a JAX-RS component is represented as an annotated Java type, it makes it easy to configure, pass around and
            inject in ways that are not so intuitive or possible with other client-side APIs.
            The Jersey Client API reuses many aspects of the JAX-RS and the Jersey implementation such as:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                        URI building using <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriBuilder.html" target="_top">UriBuilder</a> and <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/uri/UriTemplate.html" target="_top">UriTemplate</a> to safely build URIs;
                    </p></li><li class="listitem"><p>Built-in support for Java types of representations such as
                        <code class="literal">byte[]</code>,
                        <code class="literal">String</code>,
                        <code class="literal">Number</code>,
                        <code class="literal">Boolean</code>,
                        <code class="literal">Character</code>,
                        <code class="literal">InputStream</code>,
                        <code class="literal">java.io.Reader</code>,
                        <code class="literal">File</code>,
                        <code class="literal">DataSource</code>,
                        JAXB beans as well as additional Jersey-specific JSON and <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/package-summary.html" target="_top">Multi Part</a> support.
                    </p></li><li class="listitem"><p>Using the fluent builder-style API pattern to make it easier to construct requests.</p></li></ol></div><p>
            Some APIs, like the Apache HTTP Client or <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/net/HttpURLConnection.html" target="_top">HttpURLConnection</a>
            can be rather hard to use and/or require too much code to do something relatively simple, especially when
            the client needs to understand different payload representations.
            This is why the Jersey implementation of JAX-RS Client API provides support for wrapping <code class="literal">HttpUrlConnection</code>
            and the Apache HTTP client. Thus it is possible to get the benefits of the established JAX-RS implementations and
            features while getting the ease of use benefit of the simple design of the JAX-RS client API.
            For example, with a low-level HTTP client library, sending a POST request with a bunch of typed HTML form parameters
            and receiving a response de-serialized into a JAXB bean is not straightforward at all. With the new JAX-RS Client API
            supported by Jersey this task is very easy:

            </p><div class="example"><a name="client.ex.formpost"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;POST request with form parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient();
WebTarget target = client.target("http://localhost:9998").path("resource");

Form form = new Form();
form.param("x", "foo");
form.param("y", "bar");

MyJAXBBean bean =
target.request(MediaType.APPLICATION_JSON_TYPE)
    .post(Entity.entity(form,MediaType.APPLICATION_FORM_URLENCODED_TYPE),
        MyJAXBBean.class);</pre></div></div><p><br class="example-break">

            In the <a class="xref" href="#client.ex.formpost" title="Example&nbsp;5.1.&nbsp;POST request with form parameters">Example&nbsp;5.1, &#8220;POST request with form parameters&#8221;</a> a new <code class="literal">WebTarget</code> instance is created using a new
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a> instance first, next a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Form.html" target="_top">Form</a> instance is created with two form parameters.
            Once ready, the <code class="literal">Form</code> instance is <code class="literal">POST</code>ed to the target resource.
            First, the acceptable media type is specified in the <code class="literal">request(...)</code> method. Then in the
            <code class="literal">post(...)</code> method, a call to a static method on JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Entity.html" target="_top">Entity</a> is made to construct
            the request entity instance and attach the proper content media type to the form entity that is being sent. The
            second parameter in the <code class="literal">post(...)</code> method specifies the Java type of the response entity that should
            be returned from the method in case of a successful response. In this case an instance of JAXB bean is requested to
            be returned on success. The Jersey client API takes care of selecting the proper <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for
            the serialization of the <code class="literal">Form</code> instance, invoking the <code class="literal">POST</code> request and producing and
            de-serialization of the response message payload into an instance of a JAXB bean using a proper
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>.
        </p><p>If the code above had to be written using <code class="literal">HttpUrlConnection</code>, the developer would have to write custom
            code to serialize the form data that are sent within the POST request and de-serialize the response input stream
            into a JAXB bean. Additionally, more code would have to be written to make it easy to reuse the logic when
            communicating with the same resource <code class="literal">&#8220;http://localhost:8080/resource&#8221;</code> that is represented by
            the JAX-RS <code class="literal">WebTarget</code> instance in our example.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4129"></a>5.3.&nbsp;Overview of the Client API</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4132"></a>5.3.1.&nbsp;Getting started with the client API</h3></div></div></div><p>
                Refer to the <a class="link" href="#dependencies" title="2.3.&nbsp;Common Jersey Use Cases">dependencies</a> for details on the dependencies when using the
                Jersey JAX-RS Client support.
            </p><p>
                You may also want to use a custom <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> implementation. In such case you would need to include
                additional dependencies on the module(s) containing the custom client connector that you want to use. See section
                <a class="link" href="#connectors">"Configuring custom Connectors"</a> about how to use and configure a custom
                Jersey client transport <code class="literal">Connector</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4151"></a>5.3.2.&nbsp;
                Creating and configuring a Client instance
            </h3></div></div></div><p>
                JAX-RS Client API is designed to allow fluent programming model. This means, a construction of a
                <code class="literal">Client</code> instance, from which a <code class="literal">WebTarget</code> is created, from which a
                request <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Invocation.html" target="_top">Invocation</a> is built and invoked can be chained in a single "flow" of invocations.
                The individual steps of the flow will be shown in the following sections.
                To utilize the client API it is first necessary to build an instance of a
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a> using one of the static <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientBuilder.html" target="_top">ClientBuilder</a> factory methods. Here's the most
                simple example:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient();</pre><p>

                The <code class="literal">ClientBuilder</code> is a JAX-RS API used to create new instances of <code class="literal">Client</code>.
                In a slightly more advanced scenarios, <code class="literal">ClientBuilder</code> can be used to configure additional
                client instance properties, such as a SSL transport settings, if needed (see <a class="xref" href="#">???</a>
                below).
            </p><p>
                A <code class="literal">Client</code> instance can be configured during creation by passing a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientConfig.html" target="_top">ClientConfig</a>
                to the <code class="literal">newClient(Configurable)</code> <code class="literal">ClientBuilder</code> factory method.
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientConfig.html" target="_top">ClientConfig</a> implements <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> and therefore it offers methods to register
                providers (e.g. features or individual entity providers, filters or interceptors) and setup properties.
                The following code shows a registration of custom client filters:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());
Client client = ClientBuilder.newClient(clientConfig);</pre><p>

                In the example, filters are registered using the <code class="literal">ClientConfig.register(...)</code> method. There are
                multiple overloaded versions of the method that support registration of feature and provider classes or instances.
                Once a <code class="literal">ClientConfig</code> instance is configured, it can be passed to the
                <code class="literal">ClientBuilder</code> to create a pre-configured <code class="literal">Client</code> instance.
            </p><p>
                Note that the Jersey <code class="literal">ClientConfig</code> supports the fluent API model of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a>.
                With that the code that configures a new client instance can be also written using a more compact style as shown
                below.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
Client client = ClientBuilder.newClient(new ClientConfig()
        .register(MyClientResponseFilter.class)
        .register(new AnotherClientFilter());</pre><p>

                The ability to leverage this compact pattern is inherent to all JAX-RS and Jersey Client API components.
            </p><p>
                Since <code class="literal">Client</code> implements <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> interface too, it can be configured further
                even after it has been created. Important is to mention that any configuration change done on a
                <code class="literal">Client</code> instance will not influence the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientConfig.html" target="_top">ClientConfig</a> instance that was used to
                provide the initial <code class="literal">Client</code> instance configuration at the instance creation time.
                The next piece of code shows a configuration of an existing <code class="literal">Client</code> instance.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.register(ThirdClientFilter.class);</pre><p>

                Similarly to earlier examples, since <code class="literal">Client.register(...)</code> method supports the fluent API style,
                multiple client instance configuration calls can be chained:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.register(FilterA.class)
      .register(new FilterB())
      .property("my-property", true);</pre><p>

                To get the current configuration of the <code class="literal">Client</code> instance a <code class="literal">getConfiguration()</code>
                method can be used.

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());
Client client = ClientBuilder.newClient(clientConfig);
client.register(ThirdClientFilter.class);
Configuration newConfiguration = client.getConfiguration();</pre><p>

                In the code, an additional <code class="literal">MyClientResponseFilter</code> class and
                <code class="literal">AnotherClientFilter</code> instance are registered in the <code class="literal">clientConfig</code>. The
                <code class="literal">clientConfig</code> is then used to construct a new <code class="literal">Client</code> instance. The
                <code class="literal">ThirdClientFilter</code> is added separately to the constructed <code class="literal">Client</code> instance.
                This does not influence the configuration represented by the original <code class="literal">clientConfig</code>.
                In the last step a <code class="literal">newConfiguration</code> is retrieved from the <code class="literal">client</code>. This
                configuration contains all three registered filters while the original <code class="literal">clientConfig</code> instance
                still contains only two filters. Unlike <code class="literal">clientConfig</code> created separately, the
                <code class="literal">newConfiguration</code> retrieved from the <code class="literal">client</code> instance represents a live
                client configuration view. Any additional configuration changes made to the <code class="literal">client</code> instance
                are also reflected in the <code class="literal">newConfiguration</code>. So, <code class="literal">newConfiguration</code> is really
                a view of the <code class="literal">client</code> configuration and not a configuration state copy. These principles are
                important in the client API and will be used in the following sections too. For example, you can construct a
                common base configuration for all clients (in our case it would be <code class="literal">clientConfig</code>) and
                then reuse this common configuration instance to configure multiple <code class="literal">client</code> instances that can
                be further specialized. Similarly, you can use an existing <code class="literal">client</code> instance configuration to
                configure another client instance without having to worry about any side effects in the original
                <code class="literal">client</code> instance.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4335"></a>5.3.3.&nbsp;Targeting a web resource</h3></div></div></div><p>
                Once you have a <code class="literal">Client</code> instance you can create a <code class="literal">WebTarget</code> from it.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget webTarget = client.target("http://example.com/rest");</pre><p>

                A <code class="literal">Client</code> contains several <code class="literal">target(...)</code> methods that allow for creation of
                <code class="literal">WebTarget</code> instance. In this case we're using <code class="literal">target(String uri)</code> version.
                The <code class="literal">uri</code> passed to the method as a <code class="literal">String</code> is the URI of the targeted
                web resource. In more complex scenarios it could be the context root URI of the whole RESTful application, from
                which <code class="literal">WebTarget</code> instances representing individual resource targets can be derived and
                individually configured. This is possible, because JAX-RS <code class="literal">WebTarget</code> also implements
                <code class="literal">Configurable</code>:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget webTarget = client.target("http://example.com/rest");
webTarget.register(FilterForExampleCom.class);</pre><p>

                The configuration principles used in JAX-RS client API apply to <code class="literal">WebTarget</code> as well. Each
                <code class="literal">WebTarget</code> instance inherits a configuration from its parent (either a client or another
                web target) and can be further custom-configured without affecting the configuration of the parent component.
                In this case, the <code class="literal">FilterForExampleCom</code> will be registered only in the
                <code class="literal">webTarget</code> and not in <code class="literal">client</code>. So, the <code class="literal">client</code>
                can still be used to create new <code class="literal">WebTarget</code> instances pointing at other URIs using just the
                common client configuration, which <code class="literal">FilterForExampleCom</code> filter is not part of.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4403"></a>5.3.4.&nbsp;Identifying resource on WebTarget</h3></div></div></div><p>
                Let's assume we have a <code class="literal">webTarget</code> pointing at <code class="literal">"http://example.com/rest"</code> URI
                that represents a context root of a RESTful application and there is a resource exposed on the URI
                <code class="literal">"http://example.com/rest/resource"</code>. As already mentioned, a <code class="literal">WebTarget</code>
                instance can be used to derive other web targets. Use the following code to define a path to the resource.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget resourceWebTarget = webTarget.path("resource");</pre><p>

                The <code class="literal">resourceWebTarget</code> now points to the resource on URI
                <code class="literal">"http://example.com/rest/resource"</code>. Again if we configure the
                <code class="literal">resourceWebTarget</code> with a filter specific to the <code class="literal">resource</code>,
                it will not influence the original <code class="literal">webTarget</code> instance. However, the filter
                <code class="literal">FilterForExampleCom</code> registration will still be inherited by the
                <code class="literal">resourceWebTarget</code> as it has been created from <code class="literal">webTarget</code>. This mechanism
                allows you to share the common configuration of related resources (typically hosted under the same URI root,
                in our case represented by the <code class="literal">webTarget</code> instance), while allowing for further configuration
                specialization based on the specific requirements of each individual resource. The same configuration principles
                of inheritance (to allow common config propagation) and decoupling (to allow individual config customization)
                applies to all components in JAX-RS Client API discussed below.
            </p><p>
                Let's say there is a sub resource on the path <code class="literal">"http://example.com/rest/resource/helloworld"</code>.
                You can derive a <code class="literal">WebTarget</code> for this resource simply by:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");</pre><p>

                Let's assume that the <code class="literal">helloworld</code> resource accepts a query param for <code class="literal">GET</code>
                requests which defines the greeting message. The next code snippet shows a code that creates
                a new <code class="literal">WebTarget</code> with the query param defined.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget helloworldWebTargetWithQueryParam =
        helloworldWebTarget.queryParam("greeting", "Hi World!");</pre><p>

                Please note that apart from methods that can derive new <code class="literal">WebTarget</code> instance based on a URI path
                or query parameters, the JAX-RS <code class="literal">WebTarget</code> API contains also methods for working with matrix
                parameters too.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4479"></a>5.3.5.&nbsp;Invoking a HTTP request</h3></div></div></div><p>
                Let's now focus on invoking a <code class="literal">GET</code> HTTP request on the created web targets. To start building a new
                HTTP request invocation, we need to create a new <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Invocation.Builder.html" target="_top">Invocation.Builder</a>.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Invocation.Builder invocationBuilder =
        helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);
invocationBuilder.header("some-header", "true");</pre><p>

                A new invocation builder instance is created using one of the <code class="literal">request(...)</code> methods that are
                available on <code class="literal">WebTarget</code>. A couple of these methods accept parameters that let you define
                the media type of the representation requested to be returned from the resource. Here we are saying that we
                request a <code class="literal">"text/plain"</code> type. This tells Jersey to add a <code class="literal">Accept: text/plain</code>
                HTTP header to our request.
            </p><p>
                The <code class="literal">invocationBuilder</code> is used to setup request specific parameters. Here we can setup headers
                for the request or for example cookie parameters. In our example we set up a <code class="literal">"some-header"</code>
                header to value <code class="literal">true</code>.
            </p><p>
                Once finished with request customizations, it's time to invoke the request. We have two options now.
                We can use the <code class="literal">Invocation.Builder</code> to build a generic <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Invocation.html" target="_top">Invocation</a> instance
                that will be invoked some time later. Using <code class="literal">Invocation</code> we will be able to e.g. set additional
                request properties which are properties in a batch of several requests and use the generic JAX-RS
                <code class="literal">Invocation</code> API to invoke the batch of requests without actually knowing all the details
                (such as request HTTP method, configuration etc.). Any properties set on an invocation instance can be read
                during the request processing. For example, in a custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientRequestFilter.html" target="_top">ClientRequestFilter</a> you can call
                <code class="literal">getProperty()</code> method on the supplied <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientRequestContext.html" target="_top">ClientRequestContext</a> to read a request
                property. Note that these request properties are different from the configuration properties set on
                <code class="literal">Configurable</code>. As mentioned earlier, an <code class="literal">Invocation</code> instance provides generic
                invocation API to invoke the HTTP request it represents either synchronously or asynchronously. See
                the <a class="xref" href="#async" title="Chapter&nbsp;11.&nbsp;Asynchronous Services and Clients">Chapter&nbsp;11, <i>Asynchronous Services and Clients</i></a> for more information on asynchronous invocations.
            </p><p>
                In case you do not want to do any batch processing on your HTTP request invocations prior to invoking them, there
                is another, more convenient approach that you can use to invoke your requests directly from an
                <code class="literal">Invocation.Builder</code> instance. This approach is demonstrated in the next Java code listing.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Response response = invocationBuilder.get();</pre><p>

                While short, the code in the example performs multiple actions. First, it will build the the request from the
                <code class="literal">invocationBuilder</code>. The URI of request will be
                <code class="literal">http://example.com/rest/resource/helloworld?greeting="Hi%20World!"</code> and the request will contain
                <code class="literal">some-header: true</code> and <code class="literal">Accept: text/plain</code> headers. The request will then pass
                trough all configured request filters ( <code class="literal">AnotherClientFilter</code>,
                <code class="literal">ThirdClientFilter</code> and
                <code class="literal">FilterForExampleCom</code>). Once processed by the filters, the request will be sent to the remote
                resource. Let's say the resource then returns an HTTP 200 message with a plain text response content that contains
                the value sent in the request <code class="literal">greeting</code> query parameter. Now we can observe the returned
                response:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));</pre><p>

                which will produce the following output to the console:

                </p><pre class="screen">200
Hi World!</pre><p>

                As we can see, the request was successfully processed (code 200) and returned an entity (representation) is
                <code class="literal">"Hi World!"</code>. Note that since we have configured a <code class="literal">MyClientResponseFilter</code>
                in the resource target, when <code class="literal">response.readEntity(String.class)</code> gets called, the response
                returned from the remote endpoint is passed through the response filter chain (including the
                <code class="literal">MyClientResponseFilter</code>) and entity interceptor chain and at last a proper
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> is located to read the response content bytes from the response stream into a
                Java <code class="literal">String</code> instance. Check <a class="xref" href="#filters-and-interceptors" title="Chapter&nbsp;10.&nbsp;Filters and Interceptors">Chapter&nbsp;10, <i>Filters and Interceptors</i></a> to lear more about
                request and response filters and entity interceptors.
            </p><p>
                Imagine now that you would like to invoke a <code class="literal">POST</code> request but without any query parameters. You would
                just use the <code class="literal">helloworldWebTarget</code> instance created earlier and call the
                <code class="literal">post()</code> instead of <code class="literal">get()</code>.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Response postResponse =
        helloworldWebTarget.request(MediaType.TEXT_PLAIN_TYPE)
                .post(Entity.entity("A string entity to be POSTed", MediaType.TEXT_PLAIN));</pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4622"></a>5.3.6.&nbsp;Example summary</h3></div></div></div><p>
                The following code puts together the pieces used in the earlier examples.

                </p><div class="example"><a name="d0e4627"></a><p class="title"><b>Example&nbsp;5.2.&nbsp;Using JAX-RS Client API</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());

Client client = ClientBuilder.newClient(clientConfig);
client.register(ThirdClientFilter.class);

WebTarget webTarget = client.target("http://example.com/rest");
webTarget.register(FilterForExampleCom.class);
WebTarget resourceWebTarget = webTarget.path("resource");
WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");
WebTarget helloworldWebTargetWithQueryParam =
        helloworldWebTarget.queryParam("greeting", "Hi World!");

Invocation.Builder invocationBuilder =
        helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);
invocationBuilder.header("some-header", "true");

Response response = invocationBuilder.get();
System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));</pre></div></div><p><br class="example-break">

                Now we can try to leverage the fluent API style to write this code in a more compact way.

                </p><div class="example"><a name="d0e4633"></a><p class="title"><b>Example&nbsp;5.3.&nbsp;Using JAX-RS Client API fluently</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient(new ClientConfig()
            .register(MyClientResponseFilter.class)
            .register(new AnotherClientFilter()));

String entity = client.target("http://example.com/rest")
            .register(FilterForExampleCom.class)
            .path("resource/helloworld")
            .queryParam("greeting", "Hi World!")
            .request(MediaType.TEXT_PLAIN_TYPE)
            .header("some-header", "true")
            .get(String.class);</pre></div></div><p><br class="example-break">

                The code above does the same thing except it skips the generic <code class="literal">Response</code> processing and directly
                requests an entity in the last <code class="literal">get(String.class)</code> method call. This shortcut method let's you
                specify that (in case the response was returned successfully with a HTTP 2xx status code) the response entity
                should be returned as Java <code class="literal">String</code> type. This compact example demonstrates another advantage of
                the JAX-RS client API. The fluency of JAX-RS Client API is convenient especially with simple use cases.
                Here is another a very simple GET request returning a String representation (entity):

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">String responseEntity = ClientBuilder.newClient()
            .target("http://example.com").path("resource/rest")
                        .request().get(String.class);</pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4651"></a>5.3.7.&nbsp;Setting ExecutorService and ScheduledExecutorService</h3></div></div></div><p>
                Some client invocations, like asynchronous or reactive, could lead to a need to start a new thread. This is
                being done on provided ExecutorService or ScheduledExecutorService. <code class="literal">ClientBuilder</code> has two
                methods, which can be used to define them: <code class="literal">executorService(ExecutorService)</code> and
                <code class="literal">scheduledExecutorService(ScheduledExecutorService)</code>. When specified, all invocations which
                do require running on another thread, should be executed using provided services.
            </p><p>
                Default values do depend on the environment - in Java/Jakarta EE container, it has to be <a class="link" href="https://jakarta.ee/specifications//jakarta.enterprise/concurrent/ManagedExecutorService.html" target="_top">ManagedExecutorService</a>
                and <a class="link" href="https://jakarta.ee/specifications//jakarta.enterprise/concurrent/ManagedScheduledExecutorService.html" target="_top">ManagedScheduledExecutorService</a>, for Java SE it would be
                <code class="literal">ForkJoinPool.commonPool</code> for Executor service and something undefined for Scheduled
                executor service.
            </p><div class="example"><a name="d0e4676"></a><p class="title"><b>Example&nbsp;5.4.&nbsp;Setting JAX-RS Client ExecutorService</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ExecutorService myExecutorService = Executors.newCachedThreadPool();
Client client = ClientBuilder.newBuilder().executorService(myExecutorService).build();</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4681"></a>5.4.&nbsp;Java instances and types for representations</h2></div></div></div><p>
            All the Java types and representations supported by default on the Jersey server side for
            requests and responses are also supported on the client side.
            For example, to process a response entity (or representation) as a stream of bytes use InputStream as follows:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">InputStream in = response.readEntity(InputStream.class);

... // Read from the stream

in.close();
            </pre><p>

            Note that it is important to close the stream after processing so that resources are freed up.
        </p><p>
            To <code class="literal">POST</code> a file use a <code class="literal">File</code> instance as follows:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">File f = ...

...

webTarget.request().post(Entity.entity(f, MediaType.TEXT_PLAIN_TYPE));
            </pre><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4700"></a>5.4.1.&nbsp;Adding support for new representations</h3></div></div></div><p>
                The support for new application-defined representations as Java types requires the
                implementation of the same JAX-RS entity provider extension interfaces as for the server side JAX-RS API, namely
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>
                respectively, for request and response entities (or inbound and outbound representations).
            </p><p>
                Classes or implementations of the provider-based interfaces need to be registered as providers within the
                JAX-RS or Jersey Client API components that implement <code class="literal">Configurable</code> contract
                (<code class="literal">ClientBuilder</code>, <code class="literal">Client</code>, <code class="literal">WebTarget</code> or
                <code class="literal">ClientConfig</code>), as was shown in the earlier sections.
                Some media types are provided in the form of JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Feature.html" target="_top">Feature</a> a concept that allows the extension
                providers to group together multiple different extension providers and/or configuration properties in order
                to simplify the registration and configuration of the provided feature by the end users. For example,
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonFeature.html" target="_top">MoxyJsonFeature</a> can be register to enable and configure JSON binding support via MOXy
                library.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4734"></a>5.5.&nbsp;<a name="connectors"></a>Client Transport Connectors</h2></div></div></div><p>
            By default, the transport layer in Jersey is provided by <code class="literal">HttpUrlConnection</code>. This transport is implemented
            in Jersey via <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/HttpUrlConnector.html" target="_top">HttpUrlConnectorProvider</a> that implements Jersey-specific <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> SPI.
            You can implement and/or register your own <code class="literal">Connector</code> instance to the Jersey
            <code class="literal">Client</code> implementation, that will replace the default <code class="literal">HttpUrlConnection</code>-based
            transport layer. Jersey provides several alternative client transport connector implementations that are ready-to-use.

            </p><div class="table"><a name="d0e4758"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;List of Jersey Connectors</b></p><div class="table-contents"><table summary="List of Jersey Connectors" border="1"><colgroup><col align="left" class="c1" width="33%"><col align="left" class="c2" width="33%"><col align="left" class="c3" width="34%"></colgroup><thead><tr><th align="left">Transport framework</th><th align="left">Jersey Connector implementation</th><th align="left">Maven dependency</th></tr></thead><tbody><tr><td align="left">Grizzly NIO framework</td><td align="left"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/grizzly/connector/GrizzlyConnectorProvider.html" target="_top">GrizzlyConnectorProvider</a></td><td align="left"><code class="literal">org.glassfish.jersey.connectors:jersey-grizzly-connector</code></td></tr><tr><td align="left">Apache HTTP client</td><td align="left"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/apache/connector/ApacheConnectorProvider.html" target="_top">ApacheConnectorProvider</a></td><td align="left"><code class="literal">org.glassfish.jersey.connectors:jersey-apache-connector</code></td></tr><tr><td align="left">Jetty HTTP client</td><td align="left"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jetty/connector/JettyConnectorProvider.html" target="_top">JettyConnectorProvider</a></td><td align="left"><code class="literal">org.glassfish.jersey.connectors:jersey-jetty-connector</code></td></tr><tr><td align="left">Netty NIO framework</td><td align="left"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/netty/connector/NettyConnectorProvider.html" target="_top">NettyConnectorProvider</a></td><td align="left"><code class="literal">org.glassfish.jersey.connectors:jersey-netty-connector</code></td></tr><tr><td align="left">JDK NIO client</td><td align="left"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jdk/connector/JdkConnectorProvider.html" target="_top">JdkConnectorProvider</a></td><td align="left"><code class="literal">org.glassfish.jersey.connectors:jersey-jdk-connector</code></td></tr></tbody></table></div></div><p><br class="table-break">

            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="connectors.warning"></a>Warning</h3><p>
                    Be aware of using other than default <code class="literal">Connector</code> implementation.
                    There is an issue handling HTTP headers in
                    <code class="literal">WriterInterceptor</code> or <code class="literal">MessageBodyWriter&lt;T&gt;</code>.
                    If you need to change header fields do not use nor
                    <code class="literal">ApacheConnectorProvider</code> nor <code class="literal">GrizzlyConnectorProvider</code>
                    nor <code class="literal">JettyConnectorProvider</code> neither <code class="literal">NettyConnectorProvider</code>.
                    The issue for example applies to Jersey <a class="xref" href="#multipart" title="9.3.&nbsp;Multipart">Multipart</a>
                    feature that also modifies HTTP headers.
                </p><p>
                    On the other hand, in the default transport connector, there are some restrictions on the headers, that
                    can be sent in the default configuration.
                    <code class="literal">HttpUrlConnectorProvider</code> uses <code class="literal">HttpUrlConnection</code> as an underlying connection
                    implementation. This JDK class by default restricts the use of following headers:
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">Access-Control-Request-Headers</code></li><li class="listitem"><code class="literal">Access-Control-Request-Method</code></li><li class="listitem"><code class="literal">Connection</code> (with one exception - <code class="literal">Connection</code> header with
                            value <code class="literal">Closed</code> is allowed by default)</li><li class="listitem"><code class="literal">Content-Length</code></li><li class="listitem"><code class="literal">Content-Transfer-Encoding</code>-</li><li class="listitem"><code class="literal">Host</code></li><li class="listitem"><code class="literal">Keep-Alive</code></li><li class="listitem"><code class="literal">Origin</code></li><li class="listitem"><code class="literal">Trailer</code></li><li class="listitem"><code class="literal">Transfer-Encoding</code></li><li class="listitem"><code class="literal">Upgrade</code></li><li class="listitem"><code class="literal">Via</code></li><li class="listitem">all the headers starting with <code class="literal">Sec-</code></li></ul></div><p>
                    The underlying connection can be configured to permit all headers to be sent,
                    however this behaviour can be changed only by setting the system property
                    <code class="literal">sun.net.http.allowRestrictedHeaders</code>.
                    </p><div class="example"><a name="d0e4907"></a><p class="title"><b>Example&nbsp;5.5.&nbsp;Sending restricted headers with <code class="literal">HttpUrlConnector</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                            Client client = ClientBuilder.newClient();
                            System.setProperty("sun.net.http.allowRestrictedHeaders", "true");

                            Response response = client.target(yourUri).path(yourPath).request().
                            header("Origin", "http://example.com").
                            header("Access-Control-Request-Method", "POST").
                            get();
                        </pre></div></div><p><br class="example-break">
                </p><p>
                    Note, that internally the <code class="literal">HttpUrlConnection</code> instances are pooled, so (un)setting the
                    property after already creating a target typically does not have any effect.
                    The property influences all the connections <span class="emphasis"><em>created</em></span> after the property has been
                    (un)set, but there is no guarantee, that your request will use a connection
                    created after the property change.
                </p><p>
                    In a simple environment, setting the property before creating the first target is sufficient, but in complex
                    environments (such as application servers), where some poolable connections might exist before your
                    application even bootstraps, this approach is not 100% reliable and we recommend using a different client
                    transport connector, such as Apache Connector.
                    These limitations have to be considered especially when invoking <span class="emphasis"><em>CORS</em></span> (Cross Origin
                    Resource Sharing) requests.
                </p></div><p>
        </p><p>
            As indicated earlier, <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> and <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/spi/ConnectorProvider.html" target="_top">ConnectorProvider</a> contracts are Jersey-specific
            extension APIs that would only work with Jersey and as such are not part of JAX-RS. Following example shows how to
            setup the custom Grizzly Asynchronous HTTP Client based <code class="literal">ConnectorProvider</code> in a Jersey client
            instance:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
clientConfig.connectorProvider(new GrizzlyConnectorProvider());
Client client = ClientBuilder.newClient(clientConfig);</pre><p>

            <code class="literal">Client</code> accepts as a constructor argument a <code class="literal">Configurable</code> instance. Jersey
            implementation of the <code class="literal">Configurable</code> provider for the client is <code class="literal">ClientConfig</code>.
            By using the Jersey <code class="literal">ClientConfig</code> you can configure the custom
            <code class="literal">ConnectorProvider</code>
            into the <code class="literal">ClientConfig</code>. The <code class="literal">GrizzlyConnectorProvider</code> is used as a custom
            connector provider in the example above. Please note that the connector provider cannot be registered as a provider
            using <code class="literal">Configurable</code><code class="literal">.register(...)</code>. Also, please note that in this API has changed
            since Jersey 2.5, where the <code class="literal">ConnectorProvider</code> SPI has been introduced in order to decouple client
            initialization from the connector instantiation. Starting with Jersey 2.5 it is therefore not possible to directly
            register <code class="literal">Connector</code> instances in the Jersey <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientConfig.html" target="_top">ClientConfig</a>. The new
            <code class="literal">ConnectorProvider</code> SPI must be used instead to configure a custom client-side transport connector.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4984"></a>5.6.&nbsp;Using client request and response filters</h2></div></div></div><p>
            Filtering requests and responses can provide useful lower-level concept focused on a certain independent aspect or
            domain that is decoupled from the application layer of building and sending requests, and processing responses.
            Filters can read/modify the request URI, headers and entity or read/modify the response status, headers and entity.
        </p><p>
            Jersey contains the following useful client-side filters (and features registering filters)
            that you may want to use in your applications:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/filter/CsrfProtectionFilter.html" target="_top">CsrfProtectionFilter</a>: Cross-site request forgery protection filter (adds
                    <code class="literal">X-Requested-By</code> to each state changing request).</td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/filter/EncodingFeature.html" target="_top">EncodingFeature</a>: Feature that registers encoding filter which use registered
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/spi/ContentEncoder.html" target="_top">ContentEncoder</a>s to encode and decode the communication. The encoding/decoding is performed
                    in interceptor (you don't need to register this interceptor). Check the javadoc of the
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/filter/EncodingFeature.html" target="_top">EncodingFeature</a> in order to use it.</td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/authentication/HttpAuthenticationFeature.html" target="_top">HttpAuthenticationFeature</a>: HTTP Authentication Feature
                    (see <a class="xref" href="#">???</a>
                    below).</td></tr></table><p>

            Note that these features are provided by Jersey, but since they use and implement JAX-RS API, the features should
            be portable and run in any JAX-RS implementation, not just Jersey. See <a class="xref" href="#filters-and-interceptors" title="Chapter&nbsp;10.&nbsp;Filters and Interceptors">Chapter&nbsp;10, <i>Filters and Interceptors</i></a>
            chapter for more information on filters and interceptors.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5018"></a>5.7.&nbsp;Closing connections</h2></div></div></div><p>
            The underlying connections are opened for each request
            and closed after the response is received and entity is processed (entity is read). See the
            following example:
        </p><div class="example"><a name="d0e5023"></a><p class="title"><b>Example&nbsp;5.6.&nbsp;Closing connections</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final WebTarget target = ... some web target
Response response = target.path("resource").request().get();
System.out.println("Connection is still open.");
System.out.println("string response: " + response.readEntity(String.class));
System.out.println("Now the connection is closed.");</pre></div></div><br class="example-break"><p>
            If you don't read the entity, then you need to close the response manually by
            <code class="literal">response.close()</code>. Also if the entity is read into an <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/InputStream.html" target="_top">InputStream</a>
            (by <code class="literal">response.readEntity(InputStream.class)</code>), the connection stays open until
            you finish reading from the <code class="literal">InputStream</code>. In that case, the InputStream
            or the Response should be closed manually at the end of reading from InputStream.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5042"></a>5.8.&nbsp;Injections into client providers</h2></div></div></div><p>
            In some cases you might need to inject some custom types into your client provider instance. JAX-RS
            types do not need to be injected as they are passed as arguments into API methods.
            Injections into client providers (filters, interceptor) are possible as long as the provider is
            registered as a class. If the provider is registered as an instance then runtime will not inject
            the provider. The reason is that this provider instance might be registered into multiple client
            configurations. For example one instance of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientRequestFilter.html" target="_top">ClientRequestFilter</a> can be registered
            to two <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a>s.
        </p><p>
            To solve injection of a custom type into a client provider instance
            use <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/InjectionManagerClientProvider.html" target="_top">InjectionManagerClientProvider</a> to
            extract <a class="link" href="https://javaee.github.io/hk2/apidocs//org/glassfish/hk2/api/ServiceLocator.html" target="_top">ServiceLocator</a> which can return the required injection. The following example shows how to utilize
            <code class="literal">InjectionManagerClientProvider</code>:
        </p><div class="example"><a name="d0e5064"></a><p class="title"><b>Example&nbsp;5.7.&nbsp;InjectionManagerClientProvider example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public static class MyRequestFilter implements ClientRequestFilter {
    // this injection does not work as filter is registered as an instance:
    // @Inject
    // private MyInjectedService service;

    @Override
    public void filter(ClientRequestContext requestContext) throws IOException {
        // use InjectionManagerClientProvider to extract InjectionManager from request
        final InjectionManager injectionManager = InjectionManagerClientProvider.getInjectionManager(requestContext);

        // and ask for MyInjectedService:
        final MyInjectedService service = injectionManager.getInstance(MyInjectedService.class);

        final String name = service.getName();
        ...
    }
}</pre></div></div><br class="example-break"><p>
            For more information see javadoc of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/InjectionManagerClientProvider.html" target="_top">InjectionManagerClientProvider</a>
            (and javadoc of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/InjectionManagerProvider.html" target="_top">InjectionManagerProvider</a> which supports common JAX-RS components).
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5077"></a>5.9.&nbsp;Securing a Client</h2></div></div></div><p>
            This section describes how to setup SSL configuration on Jersey client (using JAX-RS API). The SSL configuration is
            setup in <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientBuilder.html" target="_top">ClientBuilder</a>. The client builder contains methods for definition of <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/security/KeyStore.html" target="_top">KeyStore</a>,
            <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/security/TrustStore.html" target="_top">TrustStore</a> or entire <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/SslContext.html" target="_top">SslContext</a>. See the following example:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">SSLContext ssl = ... your configured SSL context;
Client client = ClientBuilder.newBuilder().sslContext(ssl).build();
Response response = client.target("https://example.com/resource").request().get();</pre><p>

            The example above shows how to setup a custom <code class="literal">SslContext</code> to the <code class="literal">ClientBuilder</code>.
            Creating a <code class="literal">SslContext</code> can be more difficult as you might need to init instance properly with the protocol,
            <code class="literal">KeyStore</code>, <code class="literal">TrustStore</code>, etc. Jersey offers a utility <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/SslConfigurator.html" target="_top">SslConfigurator</a> class that
            can be used to setup the <code class="literal">SslContext</code>. The <code class="literal">SslConfigurator</code> can be configured based on
            standardized system properties for SSL configuration, so for example you can configure the <code class="literal">KeyStore</code> file
            name using a environment variable <code class="literal">javax.net.ssl.keyStore</code> and <code class="literal">SslConfigurator</code>
            will use such a variable to setup the <code class="literal">SslContext</code>. See javadoc of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/SslConfigurator.html" target="_top">SslConfigurator</a> for more
            details. The following code shows how a <code class="literal">SslConfigurator</code> can be used to create a custom SSL
            context.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">SslConfigurator sslConfig = SslConfigurator.newInstance()
        .trustStoreFile("./truststore_client")
        .trustStorePassword("secret-password-for-truststore")
        .keyStoreFile("./keystore_client")
        .keyPassword("secret-password-for-keystore");

SSLContext sslContext = sslConfig.createSSLContext();
Client client = ClientBuilder.newBuilder().sslContext(sslContext).build();</pre><p>
        </p><p>
            Note that you can also setup <code class="literal">KeyStore</code> and <code class="literal">TrustStore</code> directly on a
            <code class="literal">ClientBuilder</code> instance without wrapping them into the <code class="literal">SslContext</code>. However, if you setup
            a <code class="literal">SslContext</code> it will override any previously defined <code class="literal">KeyStore</code> and <code class="literal">TrustStore</code>
            settings.
            <code class="literal">ClientBuilder</code> also offers a method for defining a custom <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/HostnameVerifier.html" target="_top">HostnameVerifier</a> implementation.
            <code class="literal">HostnameVerifier</code> implementations are invoked when default host URL verification fails.
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                A behaviour of <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/HostnameVerifier.html" target="_top">HostnameVerifier</a> is dependent on an http client implementation.
                <code class="literal">HttpUrlConnectorProvider</code> and <code class="literal">ApacheConnectorProvider</code> work properly, that means that after
                the unsuccessful URL verification <code class="literal">HostnameVerifier</code> is called and by means of it is possible to
                revalidate URL using a custom implementation of <code class="literal">HostnameVerifier</code> and go on in a handshake processing.
                <code class="literal">JettyConnectorProvider</code> and <code class="literal">GrizzlyConnectorProvider</code> provide only host URL verification
                and throw a <code class="literal">CertificateException</code> without any possibility to use custom <code class="literal">HostnameVerifier</code>.
                Moreover, in case of <code class="literal">JettyConnectorProvider</code> there is a property
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/JettyClientProperties.html#ENABLE_SSL_HOSTNAME_VERIFICATION" target="_top">JettyClientProperties.ENABLE_SSL_HOSTNAME_VERIFICATION</a> to disable an entire host URL verification
                mechanism in a handshake.
            </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                Note that to utilize HTTP with SSL it is necessary to utilize the <code class="literal">&#8220;https&#8221;</code> scheme.
            </p></div><p>
            Currently the default connector provider <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/HttpUrlConnector.html" target="_top">HttpUrlConnectorProvider</a> provides connectors based on
            <code class="literal">HttpUrlConnection</code> which implement support for SSL defined by JAX-RS configuration discussed in this
            example.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5224"></a>5.9.1.&nbsp;Http Authentication Support</h3></div></div></div><p>Jersey supports Basic and Digest HTTP Authentication.</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    In version of Jersey 3.x both authentication methods are provided by single <code class="literal">Feature</code>
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/authentication/HttpAuthenticationFeature.html" target="_top">HttpAuthenticationFeature</a>.
                    For migration of older applications: <code class="literal">org.glassfish.jersey.client.filter.HttpBasicAuthFilter</code>
                    and <code class="literal">org.glassfish.jersey.client.filter.HttpDigestAuthFilter</code> shall be replaced by
                    those two authentication methods.
                </p></div><p>
                In order to enable http authentication support in Jersey client register
                the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/authentication/HttpAuthenticationFeature.html" target="_top">HttpAuthenticationFeature</a>. This feature can provide both authentication methods, digest
                and basic. Feature can work in the following modes:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <span class="emphasis"><em>BASIC:</em></span> Basic preemptive authentication. In preemptive mode the authentication information
                          is send always with each HTTP request. This mode is more usual than the following non-preemptive mode
                          (if you require BASIC authentication you will probably use this preemptive mode). This mode must
                          be combined with usage of SSL/TLS as the password is send only BASE64 encoded.
                    </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>BASIC NON-PREEMPTIVE:</em></span>Basic non-preemptive authentication. In non-preemptive mode the
                          authentication information is added only when server refuses the request with <code class="literal">401</code> status code and
                          then the request is repeated with authentication information. This mode has negative impact on the performance.
                          The advantage is that it does not send credentials when they are not needed. This mode must
                          be combined with usage of SSL/TLS as the password is send only BASE64 encoded.
                    </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>DIGEST:</em></span> Http digest authentication. Does not require usage of SSL/TLS.
                    </p></li><li class="listitem"><p>
                        <span class="emphasis"><em>UNIVERSAL:</em></span> Combination of basic and digest authentication. The feature works in non-preemptive
                          mode which means that it sends requests without authentication information. If <code class="literal">401</code> status
                          code is returned, the request is repeated and an appropriate authentication is used based on the
                          authentication requested in the response (defined in <code class="literal">WWW-Authenticate</code> HTTP header). The feature
                          remembers which authentication requests were successful for given URI and next time tries to preemptively
                          authenticate against this URI with latest successful authentication method.
                    </p></li></ul></div><p>
                To initialize the feature use static methods and builder of this feature. Example of building the feature in
                 Basic authentication mode:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">HttpAuthenticationFeature feature = HttpAuthenticationFeature.basic("user", "superSecretPassword");</pre><p>
            </p><p>
                Example of building the feature in basic non-preemptive mode:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">HttpAuthenticationFeature feature = HttpAuthenticationFeature.basicBuilder()
    .nonPreemptive().credentials("user", "superSecretPassword").build();</pre><p>
            </p><p>
                You can also build the feature without any default credentials:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">HttpAuthenticationFeature feature = HttpAuthenticationFeature.basicBuilder().build();</pre><p>
                In this case you need to supply username and password for each request using request properties:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Response response = client.target("http://localhost:8080/rest/homer/contact").request()
    .property(HTTP_AUTHENTICATION_BASIC_USERNAME, "homer")
    .property(HTTP_AUTHENTICATION_BASIC_PASSWORD, "p1swd745").get();</pre><p>
                This allows you to reuse the same client for authenticating with many different credentials.
            </p><p>
                See javadoc of the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/authentication/HttpAuthenticationFeature.html" target="_top">HttpAuthenticationFeature</a> for more details.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5306"></a>5.10.&nbsp;InvocationInterceptors</h2></div></div></div><p>
            Suppose a case that the start of the request is to be logged and even measured.
            This can be done by <code class="literal">ClientRequestFilter</code>, which is usually invoked before the request is wired on the network.
            However, the filter may be called as a last of the filters in the chain. Sure, it can have the highest priority,
            but the other filters can have the very same priority! Some long-running operations can be performed before the
            measuring can actually start. Even worse, the filter may even be skipped from the chain by the previous
            <code class="literal">#abortWith</code>!
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5317"></a>5.10.1.&nbsp;PreInvocationInterceptor</h3></div></div></div><p>
                For this, <code class="literal">PreInvocationInterceptor</code>, the code that executes before the <code class="literal">ClientRequestFilters</code>
                are invoked, has been added to the client request chain. Jersey ensures all the interceptors are invoked with each request.
                The interceptor contains a single <code class="literal">#beforeRequest</code> method, which corresponds to <code class="literal">ClientRequestFilter</code>:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                /**
                * The method invoked before the request starts.
                * @param requestContext the request context shared with
                * ClientRequestFilter.
                */
                void beforeRequest(ClientRequestContext requestContext);
            </pre><p>
                Note that only a single <code class="literal">#abortWith</code> is allowed in all <code class="literal">PreInvocationInterceptors</code>,
                otherwise an <code class="literal">IllegalStateException</code> is thrown.
                All the exceptions accumulated in <code class="literal">PreInvocationInterceptors</code> are thrown in a single Exception,
                available through <code class="literal">#getSuppressed()</code>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5353"></a>5.10.2.&nbsp;PostInvocationInterceptor</h3></div></div></div><p>
                Similarly, <code class="literal">ClientResponseFilter</code> seems to be a good place where the total time of the HTTP request can be measured,
                but similarly to <code class="literal">ClientRequestFilter</code>, the response filter may not be invoked at all.
                For this, <code class="literal">PostInvocationInterceptor</code> has been introduced. Jersey runtime ensures that every
                <code class="literal">PostInvocationInterceptor</code> is called. Since an exception can occur during the HTTP request,
                <code class="literal">PostInvocationInterceptor</code> comes with two methods:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                /**
                * The method is invoked after a request when no
                * is thrown, or the Throwables are resolved
                * by previous PostInvocationInterceptor.
                *
                * @param requestContext the request context.
                * @param responseContext the response context
                * of the original Response or response context
                * defined by the new resolving Response.
                */
                void afterRequest(ClientRequestContext requestContext, ClientResponseContext responseContext);

                /**
                * The method is invoked after a Throwable is caught
                * during the client request chain processing.
                *
                * @param requestContext the request context.
                * @param exceptionContext the context available to handle the
                * caught Throwables.
                */
                void onException(ClientRequestContext requestContext, ExceptionContext exceptionContext);
            </pre><p>
                The <code class="literal">#afterRequest</code> method is executed when no exception has been thrown during the HTTP request,
                <code class="literal">#onException</code> method is executed if the exception has been thrown during the request.
                It is possible to set a response in <code class="literal">#onException</code>, and the consecutive <code class="literal">PostInvocationInterceptor</code> will
                execute its <code class="literal">#afterRequest</code> method.

                The measuring example can looks as follows, then:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                String response = ClientBuilder.newClient().target("path")
                    .register(new PreInvocationInterceptor() {
                        @Override
                        public void beforeRequest(ClientRequestContext requestContext) {
                            startTime = System.currentTimeMillis();
                        }
                    })
                    .register(new PostInvocationInterceptor() {
                        @Override
                        public void afterRequest(ClientRequestContext requestContext, ClientResponseContext responseContext) {
                            logDuration(System.currentTimeMillis() - startTime);
                        }
                        @Override
                        public void onException(ClientRequestContext requestContext, ExceptionContext exceptionContext) {
                            logDuration(System.currentTimeMillis() - startTime);
                        }
                    })
                    .request().get().readEntity(String.class);
            </pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5394"></a>5.11.&nbsp;InvocationBuilderListener</h2></div></div></div><p>
            InvocationBuilderListener is an interface that is inspired by Microprofile REST Client <code class="literal">RestClientBuilderListener</code>
            and it contains a single method:
        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
            /**
            * Whenever an Invocation.Builder is created, (i.e. when
            * WebTarget#request() is called, this method would be invoked.
            *
            * @param context the updated InvocationBuilderContext.
            */
            void onNewBuilder(InvocationBuilderContext context);
        </pre><p>
            <code class="literal">InvocationBuilderContext</code> a subset of methods of the <code class="literal">Invocation.Builder</code>. It can be used to call the default
            values of the <code class="literal">Invocation.Builder</code>. Since it is invoked at the time <code class="literal">Invocation.Builder</code> is instantiated, any consequent
            calls of the <code class="literal">Invocation.Builder</code>&#8216;s methods will replace the defaults set by the <code class="literal">InvocationBuilderListener</code>.

            For instance, if all the HTTP requests should contain a custom HTTP header,
            there can be created a feature that would be registered on the client:
        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
            public static class MyFeature implements Feature {
                @Override
                public boolean configure(FeatureContext context) {
                    context.register(
                        (InvocationBuilderListener)(l)-&gt;
                        l.getHeaders().add("MY_HEADER", "MY_VALUE")
                    );
                    return true;
                }
            }
        </pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5426"></a>5.12.&nbsp;Header Expect:100-continue support</h2></div></div></div><p>
        This section describes support of Expect:100-continue in Jersey client using Expect100Continue feature.
        Jersey client supports given header for default JDK HTTP connector only.
        </p><p>
        <span class="emphasis"><em>Jersey client Expect100Continue feature</em></span>
        </p><p>
            Since Jersey 2.32 it is possible to send Expect:100-continue header from Jersey client. Feature shall be
            registered in client using (for example)
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                target(RESOURCE_PATH).register(Expect100ContinueFeature.basic());
            </pre><p>
            Note that registration can be done in several ways: with basic settings, and with custom settings:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                target(RESOURCE_PATH).register(Expect100ContinueFeature.withCustomThreshold(100L));
            </pre><p>
            Basic registration means that default sending threshold will be used. Value of the default threshold is
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                DEFAULT_EXPECT_100_CONTINUE_THRESHOLD_SIZE = 65536L;
            </pre><p>
            Threshold is used to determine allowed size of request after which 100-continue header shall be sent before
            sending request itself.
        </p><p>
            <span class="emphasis"><em>Environment properties configuration</em></span>
        </p><p>
            Previous paragraph described programmatic way of configuration. However the Expect100Continue feature can
            be configured using environment variables as well.
        </p><p>
            Since Jersey client can be influenced through environment variables, there are two variables which come
            since Jersey 2.32:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">
                -Djersey.config.client.request.expect.100.continue.processing=true/false
                -Djersey.config.client.request.expect.100.continue.threshold.size=12345
            </pre><p>
        </p><p>
            First variable can be used to forbid the Expect (100-continue) header be sent at all even though it is
            registered as described in the previous paragraph. If this property is not provided (or true) and the
            Expect100Continue feature is registered, sending of the Expect header is enabled.
        </p><p>
            The second property defines (or modifies) threshold size. So, if the Expect100Continue feature is registered
            using basic (default threshold size) parameters, value of the threshold can be modified using this property.
            This is valid for custom threshold as well - when the Expect100Continue feature is registered using
            withCustomThreshold method its value can be modified anyway by the environment property
            <code class="literal">jersey.config.client.request.expect.100.continue.threshold.size</code>.
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>
                In other words this variable has precedence over any programmatically set value of the threshold.
            </div><p>
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="rx-client"></a>Chapter&nbsp;6.&nbsp;Reactive JAX-RS Client API</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e5482">6.1. Motivation for Reactive Client Extension</a></span></dt><dt><span class="section"><a href="#d0e5653">6.2. Usage and Extension Modules</a></span></dt><dt><span class="section"><a href="#rx.client.supported">6.3. Supported Reactive Libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#rx-client.rxjava">6.3.1. RxJava (Observable)</a></span></dt><dt><span class="section"><a href="#rx-client.rxjava2">6.3.2. RxJava (Flowable)</a></span></dt><dt><span class="section"><a href="#rx-client.guava">6.3.3. Guava (ListenableFuture and Futures)</a></span></dt></dl></dd><dt><span class="section"><a href="#rx.client.spi">6.4. Implementing Support for Custom Reactive Libraries (SPI)</a></span></dt></dl></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
            Jersey 2.26 (JAX-RS 2.1 implementation) dropped Jersey-proprietary API in favor of JAX-RS 2.1 Reactive Client API.
            For Jersey 3.x this approach is still valid.
        </p></div><p>
        Reactive client extension is quite a generic API allowing end users to utilize the popular reactive programming model
        when using JAX-RS Client. The API is designed to be extensible, so any existing reactive framework can integrate with
        it and there is build in support for CompletionStage. Along with describing the API itself, this section also covers
        existing extension modules and provides hints to implement a custom extension if needed.
    </p><p>
        If you are not familiar with the JAX-RS Client API, it is recommended that you see <a class="xref" href="#client" title="Chapter&nbsp;5.&nbsp;Client API">Chapter&nbsp;5, <i>Client API</i></a>
        where the basics of JAX-RS Client API along with some advanced techniques are described.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5482"></a>6.1.&nbsp;Motivation for Reactive Client Extension</h2></div></div></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5485"></a>The Problem</h3></div></div></div><p>
                Imagine a travel agency whose information system consists of multiple basic services. These services might be built
                using different technologies (JMS, EJB, WS, ...). For simplicity we presume that the services can be
                consumed using REST interface via HTTP method calls (e.g. using a JAX-RS Client). We also presume that the basic
                services we need to work with are:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <span class="emphasis"><em>Customers service</em></span> &#8211; provides information about customers of the travel agency.
                        </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Destinations service</em></span> &#8211; provides a list of visited and recommended destinations
                            for an authenticated customer.
                        </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Weather service</em></span> &#8211; provides weather forecast for a given destination.
                        </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Quoting service</em></span> &#8211; provides price calculation for a customer to travel to
                            a recommended destination.
                        </p></li></ul></div><p>
            </p><p>
                The task is to create a publicly available feature that would, for an authenticated user, display a list of 10 last visited places and
                also display a list of 10 new recommended destinations including weather forecast and price calculations for the
                user. Notice that some of the requests (to retrieve data) depend on results of previous requests. E.g. getting
                recommended destinations depends on obtaining information about the authenticated user first. Obtaining weather
                forecast depends on destination information, etc. This relationship between some of the requests is an important part of the
                problem and an area where you can take a real advantage of the reactive programming model.
            </p><p>
                One way how to obtain data is to make multiple HTTP method calls from the client (e.g. mobile device) to all
                services involved and combine the retrieved data on the client. However, since the basic services are available
                in the internal network only we'd rather create a public orchestration layer instead of exposing all internal services to the outside world.
                The orchestration layer would expose only the desired operations of the basic services
                to the public. To limit traffic and achieve lower latency we'd like to return all the necessary
                information to the client in a single response.
            </p><p>
                The orchestration layer is illustrated in the <a class="xref" href="#rx.client.motivation.problem" title="Figure&nbsp;6.1.&nbsp;Travel Agency Orchestration Service">Figure&nbsp;6.1</a>.
                The layer accepts requests from the outside and is responsible of invoking multiple requests to the internal services.
                When responses from the internal services are available in the orchestration layer they're combined into
                a single response that is sent back to the client.

                </p><div class="figure"><a name="rx.client.motivation.problem"></a><p class="title"><b>Figure&nbsp;6.1.&nbsp;Travel Agency Orchestration Service</b></p><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="80%"><tr><td align="center"><img src="images/rx-client-problem.png" align="middle" width="100%" alt="Travel Agency Orchestration Service"></td></tr></table></div></div></div><p><br class="figure-break">

                The next sections describe various approaches (using JAX-RS Client) how the orchestration layer can be implemented.
            </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5531"></a>A Naive Approach</h3></div></div></div><p>
                The simplest way to implement the orchestration layer is to use synchronous approach. For this purpose we can use
                JAX-RS Client Sync API (see <a class="xref" href="#rx.client.motivation.naive" title="Example&nbsp;6.1.&nbsp;Excerpt from a synchronous approach while implementing the orchestration layer">Example&nbsp;6.1, &#8220;Excerpt from a synchronous approach while implementing the orchestration layer&#8221;</a>). The implementation is simple to do,
                easy to read and straightforward to debug.

                </p><div class="example"><a name="rx.client.motivation.naive"></a><p class="title"><b>Example&nbsp;6.1.&nbsp;Excerpt from a synchronous approach while implementing the orchestration layer</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final WebTarget destination = ...;
final WebTarget forecast = ...;

// Obtain recommended destinations.
List&lt;Destination&gt; recommended = Collections.emptyList();
try {
    recommended = destination.path("recommended").request()
            // Identify the user.
            .header("Rx-User", "Sync")
            // Return a list of destinations.
            .get(new GenericType&lt;List&lt;Destination&gt;&gt;() {});
} catch (final Throwable throwable) {
    errors.offer("Recommended: " + throwable.getMessage());
}

// Forecasts. (depend on recommended destinations)
final Map&lt;String, Forecast&gt; forecasts = new HashMap&lt;&gt;();
for (final Destination dest : recommended) {
    try {
        forecasts.put(dest.getDestination(),
                forecast.resolveTemplate("destination", dest.getDestination()).request().get(Forecast.class));
    } catch (final Throwable throwable) {
        errors.offer("Forecast: " + throwable.getMessage());
    }
}</pre></div></div><p><br class="example-break">

                The downside of this approach is its slowness. You need to sequentially process all the independent requests which
                means that you're wasting resources. You are needlessly blocking threads, that could be otherwise used for some real work.
            </p><p>
                If you take a closer look at the example you can notice that at the moment when all the recommended destinations are
                available for further processing we try to obtain forecasts for these destinations. Obtaining a weather forecast
                can be done only for a single destination with a single request, so we need to make 10 requests to
                the <span class="emphasis"><em>Forecast service</em></span> to get all the destinations covered. In a synchronous way this means getting the forecasts
                one-by-one. When one response with a forecast arrives we can send another request to obtain another one. This takes
                time. The whole process of constructing a response for the client can be seen in
                <a class="xref" href="#rx.client.motivation.graph.sync" title="Figure&nbsp;6.2.&nbsp;Time consumed to create a response for the client &#8211; synchronous way">Figure&nbsp;6.2</a>.
            </p><p>
                Let's try to quantify this with assigning an approximate time to every request we make to the internal services.
                This way we can easily compute the time needed to complete a response for the client. For example, obtaining

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Customer details</em></span> takes 150 ms</p></li><li class="listitem"><p><span class="emphasis"><em>Recommended destinations</em></span> takes 250 ms</p></li><li class="listitem"><p><span class="emphasis"><em>Price calculation for a customer and destination</em></span> takes 170 ms (each)</p></li><li class="listitem"><p><span class="emphasis"><em>Weather forecast for a destination</em></span> takes 330 ms (each)</p></li></ul></div><p>

                When summed up, 5400 ms is approximately needed to construct a response for the client.

                </p><div class="figure"><a name="rx.client.motivation.graph.sync"></a><p class="title"><b>Figure&nbsp;6.2.&nbsp;Time consumed to create a response for the client &#8211; synchronous way</b></p><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="80%"><tr><td align="center"><img src="images/rx-client-sync-approach.png" align="middle" width="100%" alt="Time consumed to create a response for the client &#8211; synchronous way"></td></tr></table></div></div></div><p><br class="figure-break">

                Synchronous approach is better to use for lower number of requests (where the accumulated time doesn't matter that
                much) or for a single request that depends on the result of previous operations.
            </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5582"></a>Optimized Approach</h3></div></div></div><p>
                The amount of time needed by the synchronous approach can be lowered by invoking independent requests in parallel.
                We're going to use JAX-RS Client Async API to illustrate this approach. The implementation in this case is slightly
                more difficult to get right because of the nested callbacks and the need to wait at some points for the moment
                when all partial responses are ready to be processed. The implementation is also a little bit harder to debug and maintain.
                The nested calls are causing a lot of complexity here. An example of concrete Java code following the asynchronous approach
                can be seen in <a class="xref" href="#rx.client.motivation.optimized" title="Example&nbsp;6.2.&nbsp;Excerpt from an asynchronous approach while implementing the orchestration layer">Example&nbsp;6.2, &#8220;Excerpt from an asynchronous approach while implementing the orchestration layer&#8221;</a>.

                </p><div class="example"><a name="rx.client.motivation.optimized"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;Excerpt from an asynchronous approach while implementing the orchestration layer</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final WebTarget destination = ...;
final WebTarget forecast = ...;

// Obtain recommended destinations. (does not depend on visited ones)
destination.path("recommended").request()
        // Identify the user.
        .header("Rx-User", "Async")
        // Async invoker.
        .async()
        // Return a list of destinations.
        .get(new InvocationCallback&lt;List&lt;Destination&gt;&gt;() {
            @Override
            public void completed(final List&lt;Destination&gt; recommended) {
                final CountDownLatch innerLatch = new CountDownLatch(recommended.size());

                // Forecasts. (depend on recommended destinations)
                final Map&lt;String, Forecast&gt; forecasts = Collections.synchronizedMap(new HashMap&lt;&gt;());
                for (final Destination dest : recommended) {
                    forecast.resolveTemplate("destination", dest.getDestination()).request()
                            .async()
                            .get(new InvocationCallback&lt;Forecast&gt;() {
                                @Override
                                public void completed(final Forecast forecast) {
                                    forecasts.put(dest.getDestination(), forecast);
                                    innerLatch.countDown();
                                }

                                @Override
                                public void failed(final Throwable throwable) {
                                    errors.offer("Forecast: " + throwable.getMessage());
                                    innerLatch.countDown();
                                }
                            });
                }

                // Have to wait here for dependent requests ...
                try {
                    if (!innerLatch.await(10, TimeUnit.SECONDS)) {
                        errors.offer("Inner: Waiting for requests to complete has timed out.");
                    }
                } catch (final InterruptedException e) {
                    errors.offer("Inner: Waiting for requests to complete has been interrupted.");
                }

                // Continue with processing.
            }

            @Override
            public void failed(final Throwable throwable) {
                errors.offer("Recommended: " + throwable.getMessage());
            }
        });</pre></div></div><p><br class="example-break">
            </p><p>
                The example is a bit more complicated from the first glance. We provided an <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/InvocationCallback.html" target="_top">InvocationCallback</a> to async
                <code class="literal">get</code> method. One of the callback methods (<code class="literal">completed</code> or <code class="literal">failed</code>)
                is called when the request finishes. This is a pretty convenient way to handle async invocations when no nested
                calls are present. Since we have some nested calls (obtaining weather forecasts) we needed to introduce
                a <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/CountDownLatch.html" target="_top">CountDownLatch</a> synchronization primitive as we use asynchronous approach in obtaining the weather
                forecasts as well. The latch is decreased every time a request, to the <span class="emphasis"><em>Forecasts service</em></span>,
                completes successfully or fails. This indicates that the request actually finished and it is a signal for us that
                we can continue with processing (otherwise we wouldn't have all required data to construct the response for the
                client). This additional synchronization is something that was not present when taking the synchronous approach,
                but it is needed here.
            </p><p>
                Also the error processing can not be written as it could be in an ideal case. The error handling is scattered in
                too many places within the code, that it is quite difficult to create a comprehensive response for the client.
            </p><p>
                On the other hand taking asynchronous approach leads to code that is as fast as it gets.
                The resources are used optimally (no waiting threads) to achieve
                quick response time. The whole process of constructing the response for the client can be seen in
                <a class="xref" href="#rx.client.motivation.graph.async" title="Figure&nbsp;6.3.&nbsp;Time consumed to create a response for the client &#8211; asynchronous way">Figure&nbsp;6.3</a>. It only took 730 ms instead of
                5400 ms which we encountered in the previous approach.

                </p><div class="figure"><a name="rx.client.motivation.graph.async"></a><p class="title"><b>Figure&nbsp;6.3.&nbsp;Time consumed to create a response for the client &#8211; asynchronous way</b></p><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="80%"><tr><td align="center"><img src="images/rx-client-async-approach.png" align="middle" width="100%" alt="Time consumed to create a response for the client &#8211; asynchronous way"></td></tr></table></div></div></div><p><br class="figure-break">

                As you can guess, this approach, even with all it's benefits, is the one that is really hard to implement, debug
                and maintain. It's a safe bet when you have many independent calls to make but it gets uglier with an increasing
                number of nested calls.
            </p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5628"></a>Reactive Approach</h3></div></div></div><p>
                Reactive approach is a way out of the so-called <span class="emphasis"><em>Callback Hell</em></span> which you can encounter when
                dealing with Java's <code class="literal">Future</code>s or invocation callbacks. Reactive approach is based on a data-flow
                concept and the execution model propagate changes through the flow. An example of a single item in the data-flow
                chain can be a JAX-RS Client HTTP method call. When the JAX-RS request finishes then the next item (or the user code)
                in the data-flow chain is notified about the continuation, completion or error in the chain. You're more describing
                what should be done next than how the next action in the chain should be triggered. The other important part here
                is that the data-flows are composable. You can compose/transform multiple flows into the resulting one and apply
                more operations on the result.
            </p><p>
                An example of this approach can be seen in <a class="xref" href="#rx.client.motivation.reactive" title="Example&nbsp;6.3.&nbsp;Excerpt from a reactive approach while implementing the orchestration layer">Example&nbsp;6.3, &#8220;Excerpt from a reactive approach while implementing the orchestration layer&#8221;</a>. The APIs would be
                described in more detail in the next sections.

                </p><div class="example"><a name="rx.client.motivation.reactive"></a><p class="title"><b>Example&nbsp;6.3.&nbsp;Excerpt from a reactive approach while implementing the orchestration layer</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final WebTarget destination = ...;
final WebTarget forecast = ...;

// Recommended places.
CompletionStage&lt;List&lt;Destination&gt;&gt; recommended =
        destination.path("recommended")
                   .request()
                   // Identify the user.
                   .header("Rx-User", "CompletionStage")
                   // Reactive invoker.
                   .rx()
                   // Return a list of destinations.
                   .get(new GenericType&lt;List&lt;Destination&gt;&gt;() {})
                   .exceptionally(throwable -&gt; {
                       errors.offer("Recommended: " + throwable.getMessage());
                       return Collections.emptyList();
                   });

// get Forecast for recommended destinations.
return recommended.thenCompose(destinations -&gt; {

    List&lt;CompletionStage&lt;Recommendation&gt;&gt; recommendations = destinations.stream().map(destination -&gt; {
    // For each destination, obtain a weather forecast ...
    final CompletionStage&lt;Forecast&gt; forecastResult =
            forecast.resolveTemplate("destination", destination.getDestination())
                    .request().rx().get(Forecast.class)
                    .exceptionally(throwable -&gt; {
                        errors.offer("Forecast: " + throwable.getMessage());
                        return new Forecast(destination.getDestination(), "N/A");
                    });

                    //noinspection unchecked
                    return CompletableFuture.completedFuture(new Recommendation(destination))
                                            // Set forecast for recommended destination.
                                            .thenCombine(forecastResult, Recommendation::forecast)
                    }).collect(Collectors.toList());

                    // Transform List&lt;CompletionStage&lt;Recommendation&gt;&gt; to CompletionStage&lt;List&lt;Recommendation&gt;&gt;
                    return sequence(recommendations);
    });</pre></div></div><p><br class="example-break">
            </p><p>
                As you can see the code achieves the same work as the previous two examples. It's more readable than the pure
                asynchronous approach even though it's equally fast. It's as easy to read and implement as the synchronous approach.
                The error processing is also better handled in this way than in the asynchronous approach.
            </p><p>
                When dealing with a large amount of requests (that depend on each other) and when you need to compose/combine the
                results of these requests, the reactive programming model is the right technique to use.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5653"></a>6.2.&nbsp;Usage and Extension Modules</h2></div></div></div><p>
            Reactive Client API is part of the JAX-RS specification since version 2.1. 
        </p><p>
            When you compare synchronous invocation of HTTP calls (
            <a class="xref" href="#rx.client.sync" title="Example&nbsp;6.4.&nbsp;Synchronous invocation of HTTP requests">Example&nbsp;6.4, &#8220;Synchronous invocation of HTTP requests&#8221;</a>)

            </p><div class="example"><a name="rx.client.sync"></a><p class="title"><b>Example&nbsp;6.4.&nbsp;Synchronous invocation of HTTP requests</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Response response = ClientBuilder.newClient()
        .target("http://example.com/resource")
        .request()
        .get();</pre></div></div><p><br class="example-break">

            with asynchronous invocation (<a class="xref" href="#rx.client.async" title="Example&nbsp;6.5.&nbsp;Asynchronous invocation of HTTP requests">Example&nbsp;6.5, &#8220;Asynchronous invocation of HTTP requests&#8221;</a>)

            </p><div class="example"><a name="rx.client.async"></a><p class="title"><b>Example&nbsp;6.5.&nbsp;Asynchronous invocation of HTTP requests</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Future&lt;Response&gt; response = ClientBuilder.newClient()
        .target("http://example.com/resource")
        .request()
        .async()
        .get();</pre></div></div><p><br class="example-break">

            it is apparent how to pretty conveniently modify the way how a request is invoked (from sync to async) only by calling
            <code class="literal">async</code> method on an <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Invocation.Builder.html" target="_top">Invocation.Builder</a>.
        </p><p>
            Naturally, it'd be nice to copy the same pattern to allow invoking requests in a reactive way. Just instead of
            <code class="literal">async</code> you'd call <code class="literal">rx</code> on an extension of <code class="literal">Invocation.Builder</code>,
            like in <a class="xref" href="#rx.client.reactive" title="Example&nbsp;6.6.&nbsp;Reactive invocation of HTTP requests">Example&nbsp;6.6, &#8220;Reactive invocation of HTTP requests&#8221;</a>.

            </p><div class="example"><a name="rx.client.reactive"></a><p class="title"><b>Example&nbsp;6.6.&nbsp;Reactive invocation of HTTP requests</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">CompletionStage&lt;Response&gt; response = ClientBuilder.newClient()
        .target("http://example.com/resource")
        .request()
        .rx()
        .get();</pre></div></div><p><br class="example-break">
        </p><p>
            The first reactive interface in the invocation chain is <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/RxInvoker.html" target="_top">RxInvoker</a> which is very similar to
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/SyncInvoker.html" target="_top">SyncInvoker</a> and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/AsyncInvoker.html" target="_top">AsyncInvoker</a>. It contains all methods present in the two latter
            JAX-RS interfaces but the <code class="literal">RxInvoker</code> interface is more generic, so that it can be extended
            and used in particular implementations taking advantage of various reactive libraries. Extending this new interface
            in a particular implementation also preserves type safety which means that you're not loosing type information when a HTTP
            method call returns an object that you want to process further.
        </p><p>
            The method "rx()" in the example above is perfect example of that principle. It returns <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/CompletionStageRxInvoker.html" target="_top">CompletionStageRxInvoker</a>,
            which extends <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/RxInvoker.html" target="_top">RxInvoker</a>.
        </p><p>
            As a user of the Reactive Client API you only need to keep in mind that you won't be working with
            <code class="literal">RxInvoker</code> directly. You'd rather be working with an extension of this interface created for
            a particular implementation and you don't need to be bothered much with why are things designed the way they are.

            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    To see how the <code class="literal">RxInvoker</code> should be extended, refer to
                    <a class="xref" href="#rx.client.spi" title="6.4.&nbsp;Implementing Support for Custom Reactive Libraries (SPI)">Section&nbsp;6.4, &#8220;Implementing Support for Custom Reactive Libraries (SPI)&#8221;</a>.
                </p></div><p>

            The important thing to notice here is that an extension of <code class="literal">RxInvoker</code> holds the type
            information and the Reactive Client needs to know about this type to properly propagate it among the method
            calls you'll be making. This is the reason why other interfaces (described bellow) are parametrized with this type.
        </p><p>
            In order to extend the API to be used with other reactive frameworks, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/RxInvokerProvider.html" target="_top">RxInvokerProvider</a> needs to be
            registered into the Client runtime:
        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient();
client.register(RxFlowableInvokerProvider.class);

Flowable&lt;String&gt; responseFlowable =
        client.target("http://eclipse-ee4j.github.io/jersey")
              .request()
              .rx(RxFlowableInvoker.class)
              .get(String.class);

String responseString = responseFlowable.blockingFirst();</pre><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5747"></a>Dependencies</h3></div></div></div><p>
                    JAX-RS mandates support for CompletionStage, which doesn't required any other dependency and can be
                    used out of the box.
                </p><p>
                    To add support for a particular library, see the <a class="xref" href="#rx.client.supported" title="6.3.&nbsp;Supported Reactive Libraries">Section&nbsp;6.3, &#8220;Supported Reactive Libraries&#8221;</a>.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If you're not using Maven (or other dependency management tool) make sure to add also all the transitive
                        dependencies of Jersey client module and any other extensions (when used) on the class-path.
                    </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rx.client.supported"></a>6.3.&nbsp;Supported Reactive Libraries</h2></div></div></div><p>
            There are already some available reactive (or reactive-like) libraries out there and Jersey brings support for some of
            them out of the box. Jersey currently supports:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="#rx-client.rxjava" title="6.3.1.&nbsp;RxJava &#8211; Observable">RxJava (Observable)</a></p></li><li class="listitem"><p><a class="xref" href="#rx-client.rxjava2" title="6.3.2.&nbsp;RxJava &#8211; Flowable">RxJava (Flowable)</a></p></li><li class="listitem"><p><a class="xref" href="#rx-client.guava" title="6.3.3.&nbsp;Guava &#8211; ListenableFuture and Futures">Guava (ListenableFuture and Futures)</a></p></li></ul></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="rx-client.rxjava"></a>6.3.1.&nbsp;RxJava &#8211; Observable</h3></div></div></div><p>
                <a class="link" href="https://github.com/ReactiveX/RxJava" target="_top">RxJava</a>, contributed by Netflix, is probably the most advanced reactive library for Java at the moment. It's
                used for composing asynchronous and event-based programs by using observable sequences. It uses the
                <a class="link" href="http://en.wikipedia.org/wiki/Observer_pattern" target="_top">observer pattern</a> to support these sequences of data/events
                via its <a class="link" href="http://reactivex.io/RxJava/javadoc//io/reactivex/Observable.html" target="_top">Observable</a> entry point class which implements the Reactive Pattern. <code class="literal">Observable</code> is
                actually the parameter type in the RxJava's extension of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/RxInvoker.html" target="_top">RxInvoker</a>, called
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/rx/rxjava/RxObservableInvoker.html" target="_top">RxObservableInvoker</a>. This means that the return type of HTTP method calls is
                <code class="literal">Observable</code> in this case (accordingly parametrized).
            </p><p>
                Requests are by default invoked at the moment when a subscriber is subscribed to an observable (it's a cold
                <code class="literal">Observable</code>). If not said otherwise a separate thread (JAX-RS Async Client requests) is used to
                obtain data. This behavior can be overridden by providing an <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutorService.html" target="_top">ExecutorService</a> when a reactive
                <code class="literal">Client</code> is created.
            </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5814"></a>Usage</h4></div></div></div><p>
                    The extensibility is built-in JAX-RS Client API, so there are no special dependencies on Jersey Client
                    API other than the extension itself.

                    </p><div class="example"><a name="rx.client.rxjava.rx"></a><p class="title"><b>Example&nbsp;6.7.&nbsp;Creating JAX-RS Client with RxJava reactive extension</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// New Client
Client client = ClientBuilder.newClient();
client.register(RxObservableInvokerProvider.class);</pre></div></div><p><br class="example-break">
                </p><p>
                    An example of obtaining <code class="literal">Observable</code> with JAX-RS <code class="literal">Response</code> from a remote service
                    can be seen in <a class="xref" href="#rx.client.rxjava.usage" title="Example&nbsp;6.8.&nbsp;Obtaining Observable<Response&gt; from Jersey/RxJava Client">Example&nbsp;6.8, &#8220;Obtaining Observable&lt;Response&gt; from Jersey/RxJava Client&#8221;</a>.

                    </p><div class="example"><a name="rx.client.rxjava.usage"></a><p class="title"><b>Example&nbsp;6.8.&nbsp;Obtaining Observable&lt;Response&gt; from Jersey/RxJava Client</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Observable&lt;Response&gt; observable = RxObservable.newClient()
                                                    .target("http://example.com/resource")
                                                    .request()
                                                    .rx(RxObservableInvoker.class)
                                                    .get();</pre></div></div><p><br class="example-break">
                </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5841"></a>Dependencies</h4></div></div></div><p>
                    The RxJava support is available as an extension module in Jersey. For Maven users,
                    simply add the following dependency to your <code class="literal">pom.xml</code>:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext.rx&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-rx-client-rxjava&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    After this step you can use the extended client right away. The dependency transitively adds the following
                    dependencies to your class-path as well: <code class="literal">io.reactivex:rxjava</code>.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If you're not using Maven (or other dependency management tool) make sure to add also all the transitive
                        dependencies of this extension module (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-rx-client-rxjava/dependencies.html" target="_top">jersey-rx-client-rxjava</a>) on the class-path.
                    </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="rx-client.rxjava2"></a>6.3.2.&nbsp;RxJava &#8211; Flowable</h3></div></div></div><p>
                <a class="link" href="https://github.com/ReactiveX/RxJava" target="_top">RxJava</a>, contributed by Netflix, is probably the most advanced reactive library for Java at the moment. It's
                used for composing asynchronous and event-based programs by using observable sequences. It uses the
                <a class="link" href="http://en.wikipedia.org/wiki/Observer_pattern" target="_top">observer pattern</a> to support these sequences of data/events
                via its <a class="link" href="http://reactivex.io/RxJava/javadoc//io/reactivex/Flowable.html" target="_top">Flowable</a> entry point class which implements the Reactive Pattern. <code class="literal">Flowable</code> is
                actually the parameter type in the RxJava's extension of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/RxInvoker.html" target="_top">RxInvoker</a>, called
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/rx/rxjava2/RxFlowableInvoker.html" target="_top">RxFlowableInvoker</a>. This means that the return type of HTTP method calls is
                <code class="literal">Flowable</code> in this case (accordingly parametrized).
            </p><p>
                Requests are by default invoked at the moment when a subscriber is subscribed to a flowable (it's a cold
                <code class="literal">Flowable</code>). If not said otherwise a separate thread (JAX-RS Async Client requests) is used to
                obtain data. This behavior can be overridden by providing an <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutorService.html" target="_top">ExecutorService</a> when a reactive
                <code class="literal">Client</code> is created.
            </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5900"></a>Usage</h4></div></div></div><p>
                    The extensibility is built-in JAX-RS Client API, so there are no special dependencies on Jersey Client
                    API other than the extension itself.

                    </p><div class="example"><a name="rx.client.rxjava2.rx"></a><p class="title"><b>Example&nbsp;6.9.&nbsp;Creating JAX-RS Client with RxJava2 reactive extension</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// New Client
Client client = ClientBuilder.newClient();
client.register(RxFlowableInvokerProvider.class);</pre></div></div><p><br class="example-break">
                </p><p>
                    An example of obtaining <code class="literal">Flowable</code> with JAX-RS <code class="literal">Response</code> from a remote service
                    can be seen in <a class="xref" href="#rx.client.rxjava.usage" title="Example&nbsp;6.8.&nbsp;Obtaining Observable<Response&gt; from Jersey/RxJava Client">Example&nbsp;6.8, &#8220;Obtaining Observable&lt;Response&gt; from Jersey/RxJava Client&#8221;</a>.

                    </p><div class="example"><a name="rx.client.rxjava2.usage"></a><p class="title"><b>Example&nbsp;6.10.&nbsp;Obtaining Flowable&lt;Response&gt; from Jersey/RxJava Client</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Flowable&lt;Response&gt; observable = RxObservable.newClient()
                            .target("http://example.com/resource")
                            .request()
                            .rx(RxFlowableInvoker.class)
                            .get();
                        </pre></div></div><p><br class="example-break">
                </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5927"></a>Dependencies</h4></div></div></div><p>
                    The RxJava support is available as an extension module in Jersey. For Maven users,
                    simply add the following dependency to your <code class="literal">pom.xml</code>:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext.rx&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-rx-client-rxjava2&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    After this step you can use the extended client right away. The dependency transitively adds the following
                    dependencies to your class-path as well: <code class="literal">io.reactivex:rxjava2</code>.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If you're not using Maven (or other dependency management tool) make sure to add also all the transitive
                        dependencies of this extension module (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-rx-client-rxjava2/dependencies.html" target="_top">jersey-rx-client-rxjava2</a>) on the class-path.
                    </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="rx-client.guava"></a>6.3.3.&nbsp;Guava &#8211; ListenableFuture and Futures</h3></div></div></div><p>
                <a class="link" href="https://guava.dev/" target="_top">Guava</a>, contributed by Google, also contains a type, <a class="link" href="https://guava.dev/releases/18.0/api/docs/com/google/common/util/concurrent/ListenableFuture.html" target="_top">ListenableFuture</a>, which can be decorated with
                listeners that are notified when the future completes. The <code class="literal">ListenableFuture</code> can be combined with
                <a class="link" href="https://guava.dev/releases/18.0/api/docs/com/google/common/util/concurrent/Futures.html" target="_top">Futures</a> to achieve asynchronous/event-based completion aware processing. <code class="literal">ListenableFuture</code>
                is the parameter type in the Guava's extension of <code class="literal">RxInvoker</code>, called
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/rx/guava/RxListenableFutureInvoker.html" target="_top">RxListenableFutureInvoker</a>. This means that the return type of HTTP method calls is
                <code class="literal">ListenableFuture</code> in this case (accordingly parametrized).
            </p><p>
                Requests are by default invoked immediately. If not said otherwise the <a class="link" href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool--" target="_top">Executors#newCachedThreadPool()</a> pool
                is used to obtain a thread which processed the request. This behavior can be overridden by providing a
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ExecutorService.html" target="_top">ExecutorService</a> when a <code class="literal">Client</code> is created.
            </p><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5989"></a>Usage</h4></div></div></div><p>
                    The extensibility is built-in JAX-RS Client API, so there are no special dependencies on Jersey Client
                    API other than the extension itself.

                    </p><div class="example"><a name="rx.client.guava.rx"></a><p class="title"><b>Example&nbsp;6.11.&nbsp;Creating Jersey/Guava Client</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// New Client
Client client = ClientBuilder.newClient();
client.register(RxListenableFutureInvokerProvider.class);</pre></div></div><p><br class="example-break">
                </p><p>
                    An example of obtaining <code class="literal">ListenableFuture</code> with JAX-RS <code class="literal">Response</code> from a remote
                    service can be seen in <a class="xref" href="#rx.client.guava.usage" title="Example&nbsp;6.12.&nbsp;Obtaining ListenableFuture<Response&gt; from Jersey/Guava Client">Example&nbsp;6.12, &#8220;Obtaining ListenableFuture&lt;Response&gt; from Jersey/Guava Client&#8221;</a>.

                    </p><div class="example"><a name="rx.client.guava.usage"></a><p class="title"><b>Example&nbsp;6.12.&nbsp;Obtaining ListenableFuture&lt;Response&gt; from Jersey/Guava Client</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
ListenableFuture&lt;Response&gt; response = client.target("http://eclipse-ee4j.github.io/jersey")
                                            .request()
                                            .rx(RxListenableFutureInvoker.class)
                                            .get();
</pre></div></div><p><br class="example-break">
                </p></div><div class="simplesect"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6016"></a>Dependencies</h4></div></div></div><p>
                    The Reactive Jersey Client with Guava support is available as an extension module in Jersey. For Maven users,
                    simply add the following dependency to your <code class="literal">pom.xml</code>:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext.rx&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-rx-client-guava&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    After this step you can use the extended client right away. The dependency transitively adds the following
                    dependencies to your class-path as well: <code class="literal">com.google.guava:guava</code>.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If you're not using Maven (or other dependency management tool) make sure to add also all the transitive
                        dependencies of this extension module (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/project/jersey-rx-client-guava/dependencies.html" target="_top">jersey-rx-client-guava</a>) on the class-path.
                    </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rx.client.spi"></a>6.4.&nbsp;Implementing Support for Custom Reactive Libraries (SPI)</h2></div></div></div><p>
            In case you want to bring support for some other library providing Reactive Programming Model into your application
            you can extend functionality of Reactive JAX-RS Client by implementing <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/RxInvokerProvider.html" target="_top">RxInvokerProvider</a>, registering
            that implementation into the client runtime and then using rx(Class&lt;T&gt;) in your code.
        </p><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6044"></a>Implement RxInvoker and RxInvokerProvider interfaces</h3></div></div></div><p>
                The first step when implementing support for another reactive library is to implement <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/RxInvoker.html" target="_top">RxInvoker</a>.
                JAX-RS API itself contains one implementation, which will be used as an example: <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/CompletionStageRxInvoker.html" target="_top">CompletionStageRxInvoker</a>.

                </p><div class="example"><a name="rx.client.rxinvoker"></a><p class="title"><b>Example&nbsp;6.13.&nbsp;Extending RxIvoker</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public interface CompletionStageRxInvoker extends RxInvoker&lt;CompletionStage&gt; {
    @Override
    public CompletionStage&lt;Response&gt; get();

    @Override
    public &lt;T&gt; CompletionStage&lt;T&gt; get(Class&lt;T&gt; responseType);

    // ...
}</pre></div></div><p><br class="example-break">
            </p><p>
                The important fact to notice is that the generic parameter of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/RxInvoker.html" target="_top">RxInvoker</a> is <a class="link" href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" target="_top">CompletionStage</a>
                and also that the return type is overriden to be always <a class="link" href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html" target="_top">CompletionStage</a> with some generic param (<a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a>;
                or T).
            </p><p>
                After having the extended RxInvoker interface, the implementor has to provide <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/RxInvokerProvider.html" target="_top">RxInvokerProvider</a>,
                which will be registered as an provider to a client instance.
            </p><div class="example"><a name="rx.client.extend.rxinvoker"></a><p class="title"><b>Example&nbsp;6.14.&nbsp;Extending RxInvokerProvider</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public static class CompletionStageRxInvokerProvider implements RxInvokerProvider&lt;CompletionStageRxInvoker&gt; {
    @Override
    public boolean isProviderFor(Class&lt;?%gt; clazz) {
        return CompletionStage.class.equals(clazz);
    }

    @Override
    public CompletionStageRxInvoker getRxInvoker(SyncInvoker syncInvoker, ExecutorService executorService) {
        return new CompletionStageRxInvoker() {
            // ...
        };
    }
}</pre></div></div><br class="example-break"></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6085"></a>Example of using custom RxInvokerProvider</h3></div></div></div><p>
                Considering the work above was done and the implementation of custom <code class="literal">RxInvoker</code> and
                <code class="literal">RxInvokerProvider</code> is available, the client code using those extensions will be:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient();
// register custom RxInvokerProvider
client.register(CompletionStageRxInvokerProvider.class);

CompletionStage&lt;Response&gt; response =
        client.target("http://eclipse-ee4j.github.io/jersey")
              .request()
              .rx(CompletionStageRxInvoker.class)
              // Now we have an instance of CompletionStageRxInvoker returned from our registered RxInvokerProvider,
              // which is CompletionStageRxInvokerProvider in this particular scenario.
              .get();</pre></div></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="representations"></a>Chapter&nbsp;7.&nbsp;Representations and Responses</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#reps-and-types">7.1. Representations and Java Types</a></span></dt><dt><span class="section"><a href="#d0e6241">7.2. Building Responses</a></span></dt><dt><span class="section"><a href="#d0e6278">7.3. WebApplicationException and Mapping Exceptions to Responses</a></span></dt><dt><span class="section"><a href="#d0e6359">7.4. Conditional GETs and Returning 304 (Not Modified) Responses</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reps-and-types"></a>7.1.&nbsp;Representations and Java Types</h2></div></div></div><p>Previous sections on <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Consumes.html" target="_top">@Consumes</a> annotations
            referred to media type of an entity representation. Examples above depicted resource
            methods that could consume and/or produce String Java type for a number of
	    different media types. This approach is easy to understand and relatively
	    straightforward when applied to simple use cases.
	    </p><p>To cover also other cases, handling non-textual data for example or handling data stored in the file system, etc.,
            JAX-RS implementations are required to support also other kinds of media type
            conversions where additional, non-String, Java types are being utilized. Following is a short listing of the Java types
            that are supported out of the box with respect to supported media type:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">All media types (<code class="literal">*/*</code>)
            		<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><code class="literal">byte[]</code></li><li class="listitem"><code class="literal">java.lang.String</code></li><li class="listitem"><code class="literal">java.io.Reader</code> (inbound only)</li><li class="listitem"><code class="literal">java.io.File</code></li><li class="listitem"><code class="literal">jakarta.activation.DataSource</code></li><li class="listitem"><code class="literal">jakarta.ws.rs.core.StreamingOutput</code> (outbound only)</li></ul></div></li><li class="listitem">XML media types (<code class="literal">text/xml</code>, <code class="literal">application/xml</code> and <code class="literal">application/...+xml</code>)
            		<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><code class="literal">javax.xml.transform.Source</code></li><li class="listitem"><code class="literal">jakarta.xml.bind.JAXBElement</code></li><li class="listitem">Application supplied JAXB classes (types annotated with
	    <a class="link" href="http://docs.oracle.com/javase/6/docs/api/jakarta.xml.bind/annotation/XmlRootElement.html" target="_top">@XmlRootElement</a>
	    or<a class="link" href="http://docs.oracle.com/javase/6/docs/api/jakarta.xml.bind/annotation/XmlType.html" target="_top">@XmlType</a>)</li></ul></div></li><li class="listitem">Form content (<code class="literal">application/x-www-form-urlencoded</code>)
                        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><code class="literal">MultivaluedMap&lt;String,String&gt;</code></li></ul></div></li><li class="listitem">Plain text (<code class="literal">text/plain</code>)
                        <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><code class="literal">java.lang.Boolean</code></li><li class="listitem"><code class="literal">java.lang.Character</code></li><li class="listitem"><code class="literal">java.lang.Number</code></li></ul></div></li></ul></div><p>
        </p><p>Unlike method parameters that are associated with the extraction of
            request parameters, the method parameter associated with the
            representation being consumed does not require annotating. In other words the
            representation (entity) parameter does not require a specific 'entity' annotation. A method parameter
            without an annotation is an entity. A maximum of
            one such unannotated method parameter may exist since there may only be a
            maximum of one such representation sent in a request.
        </p><p>The representation being produced corresponds to what is returned by
            the resource method. For example JAX-RS makes it simple to produce images
            that are instance of
            <code class="literal">File</code>
            as follows:
        </p><p>
            </p><div class="example"><a name="d0e6202"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;Using
                    <code class="code">File</code>
                    with a specific media type to produce a response
                </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Path("/images/{image}")
@Produces("image/*")
public Response getImage(@PathParam("image") String image) {
  File f = new File(image);

  if (!f.exists()) {
    throw new WebApplicationException(404);
  }

  String mt = new MimetypesFileTypeMap().getContentType(f);
  return Response.ok(f, mt).build();
}</pre></div></div><p><br class="example-break">
        </p><p>The
            <code class="literal">File</code> type can also be used when consuming a representation (request entity).
            In that case a temporary file will be created from the incoming request entity and passed as a
            parameter to the resource method.
        </p><p>
            The <code class="literal">Content-Type</code> response header
            (if not set programmatically as described in the next section)
            will be automatically set based on the media types declared by <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> annotation.
 Given the following method, the most acceptable media type is used when multiple output media types are allowed:
        </p><p>
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces({"application/xml", "application/json"})
public String doGetAsXmlOrJson() {
  ...
}</pre><p>

            If <code class="literal">application/xml</code> is the most acceptable media type defined
            by the request (e.g. by header <code class="literal">Accept: application/xml</code>), then the
            <code class="literal">Content-Type</code> response header
            will be set to <code class="literal">application/xml</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6241"></a>7.2.&nbsp;Building Responses</h2></div></div></div><p>Sometimes it is necessary to return additional
            information in response to a HTTP request. Such information may be built
            and returned using <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a> and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.ResponseBuilder.html" target="_top">Response.ResponseBuilder</a>.
            For example, a common RESTful pattern for the creation of a new resource
            is to support a POST request that returns a 201 (Created) status code and
            a
            <code class="literal">Location</code>
            header whose value is the URI to the newly
            created resource. This may be achieved as follows:
        </p><p>
            </p><div class="example"><a name="d0e6257"></a><p class="title"><b>Example&nbsp;7.2.&nbsp;Returning 201 status code and adding
                    <code class="literal">Location</code>
                    header in response to POST request
                </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes("application/xml")
public Response post(String content) {
  URI createdUri = ...
  create(content);
  return Response.created(createdUri).build();
}</pre></div></div><p><br class="example-break">
        </p><p>In the above no representation produced is returned, this can be
            achieved by building an entity as part of the response as follows:
        </p><p>
            </p><div class="example"><a name="d0e6270"></a><p class="title"><b>Example&nbsp;7.3.&nbsp;Adding an entity body to a custom response</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes("application/xml")
public Response post(String content) {
  URI createdUri = ...
  String createdContent = create(content);
  return Response.created(createdUri).entity(Entity.text(createdContent)).build();
}</pre></div></div><p><br class="example-break">
        </p><p>Response building provides other functionality such as setting the
            entity tag and last modified date of the representation.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6278"></a>7.3.&nbsp;WebApplicationException and Mapping Exceptions to Responses</h2></div></div></div><p>Previous section shows how to return HTTP responses,
              that are built up programmatically.
            It is possible to use the very same mechanism
            to return HTTP errors directly,
            e.g. when handling exceptions in a try-catch block.
            However, to better align with the Java programming model,
            JAX-RS allows to define direct mapping of Java exceptions to HTTP error responses.
        </p><p>The following example shows throwing
            <code class="literal">CustomNotFoundException</code>
            from a resource method in order to return an error HTTP response to the client:
        </p><p>
            </p><div class="example"><a name="d0e6290"></a><p class="title"><b>Example&nbsp;7.4.&nbsp;Throwing exceptions to control response</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("items/{itemid}/")
public Item getItem(@PathParam("itemid") String itemid) {
  Item i = getItems().get(itemid);
  if (i == null) {
    throw new CustomNotFoundException("Item, " + itemid + ", is not found");
  }

  return i;
}</pre></div></div><p><br class="example-break">
        </p><p>This exception is an application specific exception that extends <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/WebApplicationException.html" target="_top">WebApplicationException</a>
            and builds a HTTP response with the 404 status code and an optional
            message as the body of the response:
        </p><p>
            </p><div class="example"><a name="d0e6303"></a><p class="title"><b>Example&nbsp;7.5.&nbsp;Application specific exception implementation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class CustomNotFoundException extends WebApplicationException {

  /**
  * Create a HTTP 404 (Not Found) exception.
  */
  public CustomNotFoundException() {
    super(Responses.notFound().build());
  }

  /**
  * Create a HTTP 404 (Not Found) exception.
  * @param message the String that is the entity of the 404 response.
  */
  public CustomNotFoundException(String message) {
    super(Response.status(Responses.NOT_FOUND).
    entity(message).type("text/plain").build());
  }
}</pre></div></div><p><br class="example-break">
        </p><p>In other cases it may not be appropriate to throw instances of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/WebApplicationException.html" target="_top">WebApplicationException</a>,
            or classes that extend <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/WebApplicationException.html" target="_top">WebApplicationException</a>, and instead it may be preferable to map an existing exception to a
            response. For such cases it is possible to use a custom exception mapping provider. The provider must implement
            the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ExceptionMapper.html" target="_top">ExceptionMapper&lt;E extends Throwable&gt;</a> interface. For example, the following
            maps the
            <a class="link" href="http://docs.oracle.com/javaee/5/api/jakarta.persistence/EntityNotFoundException.html" target="_top">EntityNotFoundException</a>
            to a HTTP 404 (Not Found) response:
        </p><p>
            </p><div class="example"><a name="d0e6325"></a><p class="title"><b>Example&nbsp;7.6.&nbsp;Mapping generic exceptions to responses</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class EntityNotFoundMapper implements ExceptionMapper&lt;jakarta.persistence.EntityNotFoundException&gt; {
  public Response toResponse(jakarta.persistence.EntityNotFoundException ex) {
    return Response.status(404).
      entity(ex.getMessage()).
      type("text/plain").
      build();
  }
}</pre></div></div><p><br class="example-break">
        </p><p>The above class is annotated with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/Provider.html" target="_top">@Provider</a>, this declares that the class is of interest to the JAX-RS runtime. Such a
            class may be added to the set of classes of the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a> instance that is configured. When an application throws an
            <a class="link" href="http://docs.oracle.com/javaee/6/api/jakarta.persistence/EntityNotFoundException.html" target="_top">EntityNotFoundException</a>
            the
            <code class="literal">toResponse</code>
            method of the
            <code class="literal">EntityNotFoundMapper</code>
            instance will be invoked.
        </p><p>
            Jersey supports extension of the exception mappers. These extended mappers must implement
            the <code class="literal">org.glassfish.jersey.spi.ExtendedExceptionMapper</code> interface. This interface additionally
            defines method <code class="literal">isMappable(Throwable)</code> which will be invoked by the Jersey runtime
            when exception is thrown and this provider is considered as mappable based on the exception type. Using this
            method the provider can reject mapping of the exception before the method <code class="literal">toResponse</code>
            is invoked. The provider can for example check the exception parameters and based on them return false
            and let other provider to be chosen for the exception mapping.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6359"></a>7.4.&nbsp;Conditional GETs and Returning 304 (Not Modified) Responses</h2></div></div></div><p>Conditional GETs are a great way to reduce bandwidth, and
            potentially improve on the server-side performance, depending on how the information used
            to determine conditions is calculated. A well-designed web site may for example return
            304 (Not Modified) responses for many of static images it serves.
        </p><p>JAX-RS provides support for conditional GETs using the contextual interface <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Request.html" target="_top">Request</a>.
        </p><p>The following example shows conditional GET support:</p><p>
            </p><div class="example"><a name="d0e6373"></a><p class="title"><b>Example&nbsp;7.7.&nbsp;Conditional GET support</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public SparklinesResource(
  @QueryParam("d") IntegerList data,
  @DefaultValue("0,100") @QueryParam("limits") Interval limits,
  @Context Request request,
  @Context UriInfo ui) {
  if (data == null) {
    throw new WebApplicationException(400);
  }

  this.data = data;
  this.limits = limits;

  if (!limits.contains(data)) {
    throw new WebApplicationException(400);
  }

  this.tag = computeEntityTag(ui.getRequestUri());

  if (request.getMethod().equals("GET")) {
    Response.ResponseBuilder rb = request.evaluatePreconditions(tag);
    if (rb != null) {
      throw new WebApplicationException(rb.build());
    }
  }
}</pre></div></div><p><br class="example-break">
        </p><p>The constructor of the
            <code class="literal">SparklinesResource</code>
            root
            resource class computes an entity tag from the request URI and then calls
            the
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Request.html#evaluatePreconditions(jakarta.ws.rs.core.EntityTag)" target="_top">request.evaluatePreconditions</a>
            with that entity tag. If a client request contains an
            <code class="literal">If-None-Match</code>
            header with a value that contains the
            same entity tag that was calculated then the
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Request.html#evaluatePreconditions(jakarta.ws.rs.core.EntityTag)" target="_top">evaluatePreconditions</a>
            returns a pre-filled out response, with the 304 status code and entity tag
            set, that may be built and returned. Otherwise,
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Request.html#evaluatePreconditions(jakarta.ws.rs.core.EntityTag)" target="_top">evaluatePreconditions</a>
            returns
            <code class="literal">null</code>
            and the normal response can be
            returned.
        </p><p>Notice that in this example the constructor of a resource class is used
            to perform actions that may otherwise have to be duplicated to
            be invoked for each resource method. The life cycle of resource classes is per-request
            which means that the resource instance is created for each request and therefore
            can work with request parameters and for example make changes to the request processing by
            throwing an exception as it is shown in this example.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="message-body-workers"></a>Chapter&nbsp;8.&nbsp;JAX-RS Entity Providers</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e6405">8.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e6439">8.2. How to Write Custom Entity Providers</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6476">8.2.1. MessageBodyWriter</a></span></dt><dt><span class="section"><a href="#d0e6764">8.2.2. MessageBodyReader</a></span></dt></dl></dd><dt><span class="section"><a href="#providers-selection">8.3. Entity Provider Selection</a></span></dt><dt><span class="section"><a href="#d0e7325">8.4. Jersey <code class="literal">MessageBodyWorkers</code> API</a></span></dt><dt><span class="section"><a href="#d0e7409">8.5. Default Jersey Entity Providers</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6405"></a>8.1.&nbsp;Introduction</h2></div></div></div><p>
            Entity payload, if present in an received HTTP message, is passed to Jersey from an I/O container as an input stream.
            The stream may, for example, contain data represented as a plain text, XML or JSON document. However, in many JAX-RS
            components that process these inbound data, such as resource methods or client responses, the JAX-RS API user can
            access the inbound entity as an arbitrary Java object that is created from the content of the input stream based on
            the representation type information. For example, an entity created from an input stream that contains data
            represented as a XML document, can be converted to a custom JAXB bean.
            Similar concept is supported for the outbound entities. An entity returned from the resource method in the form
            of an arbitrary Java object can be serialized by Jersey into a container output stream as a specified representation.
            Of course, while JAX-RS implementations do provide default support for most common combinations of Java type and it's
            respective on-the-wire representation formats, JAX-RS implementations do not support the conversion described above
            for any arbitrary Java type and any arbitrary representation format by default. Instead, a generic extension concept
            is exposed in JAX-RS API to allow application-level customizations of this JAX-RS runtime to support for entity
            conversions. The JAX-RS extension API components that provide the user-level extensibility are typically referred to
            by several terms with the same meaning, such as <span class="emphasis"><em>entity providers</em></span>,
            <span class="emphasis"><em>message body providers</em></span>, <span class="emphasis"><em>message body workers</em></span> or
            <span class="emphasis"><em>message body readers and writers</em></span>. You may find all these terms used interchangeably throughout
            the user guide and they all refer to the same concept.
        </p><p>
            In JAX-RS extension API (or SPI - service provider interface, if you like) the concept is captured in 2 interfaces.
            One for handling inbound entity representation-to-Java de-serialization - <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> and the other
            one for handling the outbound entity Java-to-representation serialization - <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>.
            A <code class="literal">MessageBodyReader&lt;T&gt;</code>, as the name suggests, is an extension that supports reading the message body
            representation from an input stream and converting the data into an instance of a specific Java type.
            A <code class="literal">MessageBodyWriter&lt;T&gt;</code> is then responsible for converting a message payload from an instance of a
            specific Java type into a specific representation format that is sent over the wire to the other party as part of an
            HTTP message exchange.
            Both of these providers can be used to provide message payload serialization and de-serialization support on the
            server as well as the client side. A message body reader or writer is always used whenever a HTTP request or
            response contains an entity and the entity is either requested by the application code (e.g. injected as a parameter
            of JAX-RS resource method or a response entity read on the client from a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a>) or has to be
            serialized and sent to the other party (e.g. an instance returned from a JAX-RS resource method or a request
            entity sent by a JAX-RS client).
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6439"></a>8.2.&nbsp;How to Write Custom Entity Providers</h2></div></div></div><p>
            A best way how to learn about entity providers is to walk through an example of writing one. Therefore we will
            describe here the process of implementing a custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> and
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> using a practical example. Let's first setup the stage by defining a JAX-RS
            resource class for the server side story of our application.

            </p><div class="example"><a name="d0e6450"></a><p class="title"><b>Example&nbsp;8.1.&nbsp;Example resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public class MyResource {
    @GET
    @Produces("application/xml")
    public MyBean getMyBean() {
        return new MyBean("Hello World!", 42);
    }

    @POST
    @Consumes("application/xml")
    public String postMyBean(MyBean myBean) {
        return myBean.anyString;
    }
}</pre></div></div><p><br class="example-break">

            The resource class defines <code class="literal">GET</code> and <code class="literal">POST</code> resource methods. Both methods work with an entity
            that is an instance of <code class="literal">MyBean</code>.
        </p><p>
            The <code class="literal">MyBean</code> class is defined in the next example:

            </p><div class="example"><a name="d0e6470"></a><p class="title"><b>Example&nbsp;8.2.&nbsp;MyBean entity class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class MyBean {
    @XmlElement
    public String anyString;
    @XmlElement
    public int anyNumber;

    public MyBean(String anyString, int anyNumber) {
        this.anyString = anyString;
        this.anyNumber = anyNumber;
    }

    // empty constructor needed for deserialization by JAXB
    public MyBean() {
    }

    @Override
    public String toString() {
        return "MyBean{" +
            "anyString='" + anyString + '\'' +
            ", anyNumber=" + anyNumber +
            '}';
    }
}</pre></div></div><p><br class="example-break">
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6476"></a>8.2.1.&nbsp;MessageBodyWriter</h3></div></div></div><p>
                The <code class="literal">MyBean</code> is a JAXB-annotated POJO. In <code class="literal">GET</code> resource method we return
                the instance of MyBean and we would like Jersey runtime to serialize it into XML and write
                it as an entity body to the response output stream. We design a custom <code class="literal">MessageBodyWriter&lt;T&gt;</code>
                that can serialize this POJO into XML. See the following code sample:

                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Please note, that this is only a demonstration of how to write a custom entity provider.
                        Jersey already contains default support for entity providers that can serialize JAXB beans
                        into XML.
                    </p></div><p>

                </p><div class="example"><a name="d0e6494"></a><p class="title"><b>Example&nbsp;8.3.&nbsp;MessageBodyWriter example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Produces("application/xml")
public class MyBeanMessageBodyWriter implements MessageBodyWriter&lt;MyBean&gt; {

    @Override
    public boolean isWriteable(Class&lt;?&gt; type, Type genericType,
                               Annotation[] annotations, MediaType mediaType) {
        return type == MyBean.class;
    }

    @Override
    public long getSize(MyBean myBean, Class&lt;?&gt; type, Type genericType,
                        Annotation[] annotations, MediaType mediaType) {
        // deprecated by JAX-RS 2.0 and ignored by Jersey runtime
        return -1;
    }

    @Override
    public void writeTo(MyBean myBean,
                        Class&lt;?&gt; type,
                        Type genericType,
                        Annotation[] annotations,
                        MediaType mediaType,
                        MultivaluedMap&lt;String, Object&gt; httpHeaders,
                        OutputStream entityStream)
                        throws IOException, WebApplicationException {

        try {
            JAXBContext jaxbContext = JAXBContext.newInstance(MyBean.class);

            // serialize the entity myBean to the entity output stream
            jaxbContext.createMarshaller().marshal(myBean, entityStream);
        } catch (JAXBException jaxbException) {
            throw new ProcessingException(
                "Error serializing a MyBean to the output stream", jaxbException);
        }
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                The <code class="literal">MyBeanMessageBodyWriter</code> implements the <code class="literal">MessageBodyWriter&lt;T&gt;</code>
                interface that contains three methods. In the next sections we'll explore these methods more closely.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6508"></a>8.2.1.1.&nbsp;
                    <code class="literal">MessageBodyWriter.isWriteable</code>
                </h4></div></div></div><p>
                    A method <code class="literal">isWriteable</code>
                    should return true if the <code class="literal">MessageBodyWriter&lt;T&gt;</code> is able to write the given type. Method
                    does not decide only based on the Java type of the entity but also on annotations attached to the entity
                    and the requested representation media type.
                </p><p>
                    Parameters <code class="literal">type</code> and <code class="literal">genericType</code> both define the entity,
                    where <code class="literal">type</code> is a raw Java type
                    (for example, a <code class="literal">java.util.List</code> class) and <code class="literal">genericType</code> is a
                    <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/ParameterizedType.html" target="_top">ParameterizedType</a> including generic information (for example <code class="literal">List&lt;String&gt;</code>).
                </p><p>
                    Parameter <code class="literal">annotations</code> contains annotations that are either attached to the resource
                    method and/or annotations that are attached to the entity by building response like in the following piece
                    of code:

                    </p><div class="example"><a name="d0e6550"></a><p class="title"><b>Example&nbsp;8.4.&nbsp;Example of assignment of annotations to a response entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public static class AnnotatedResource {

    @GET
    public Response get() {
        Annotation annotation = AnnotatedResource.class
                            .getAnnotation(Path.class);
        return Response.ok()
                .entity("Entity", new Annotation[] {annotation}).build();
    }
}</pre></div></div><p><br class="example-break">

                    In the example above, the <code class="literal">MessageBodyWriter&lt;T&gt;</code> would get
                    <code class="literal">annotations</code> parameter containing a JAX-RS <code class="literal">@GET</code> annotation
                    as it annotates the resource method and also a <code class="literal">@Path</code> annotation as it
                    is passed in the response (but not because it annotates the resource; only resource
                    method annotations are included). In the case of <code class="literal">MyResource</code>
                    and method <code class="literal">getMyBean</code> the annotations would contain the
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a> and the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> annotation.
                </p><p>
                    The last parameter of the <code class="literal">isWriteable</code> method is the <code class="literal">mediaType</code>
                    which is the media type attached to the response entity by annotating the resource method with a
                    <code class="literal">@Produces</code> annotation or the request media type specified in the JAX-RS Client API.
                    In our example, the media type passed to providers for the resource <code class="literal">MyResource</code> and method
                    <code class="literal">getMyBean</code> would be <code class="literal">"application/xml"</code>.
                </p><p>
                    In our implementation of the <code class="literal">isWriteable</code> method, we
                    just check that the type is <code class="literal">MyBean</code>. Please note, that
                    this method might be executed multiple times by Jersey runtime as Jersey needs to check
                    whether this provider can be used for a particular combination of entity Java type, media type, and attached
                    annotations, which may be potentially a performance hog. You can limit the number of execution by
                    properly defining the <code class="literal">@Produces</code> annotation on the <code class="literal">MessageBodyWriter&lt;T&gt;</code>.
                    In our case thanks to <code class="literal">@Produces</code> annotation, the provider will be considered
                    as writeable (and the method <code class="literal">isWriteable</code> might be executed) only if the
                    media type of the outbound message is <code class="literal">"application/xml"</code>. Additionally, the provider
                    will only be considered as possible candidate and its <code class="literal">isWriteable</code> method will
                    be executed, if the generic type of the provider is either a sub class or super class of
                    <code class="literal">type</code> parameter.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6629"></a>8.2.1.2.&nbsp;
                <code class="literal">MessageBodyWriter.writeTo</code>
            </h4></div></div></div><p>
                Once a message body writer is selected as the most appropriate (see the <a class="xref" href="#providers-selection" title="8.3.&nbsp;Entity Provider Selection">Section&nbsp;8.3, &#8220;Entity Provider Selection&#8221;</a>
                for more details on entity provider selection), its <code class="literal">writeTo</code> method is invoked. This method
                receives parameters with the same meaning as in <code class="literal">isWriteable</code> as well as a few additional ones.
            </p><p>
                In addition to the parameters already introduced, the <code class="literal">writeTo</code> method defies also
                <code class="literal">httpHeaders</code> parameter, that contains HTTP headers associated with the
                outbound message.

                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        When a <code class="literal">MessageBodyWriter&lt;T&gt;</code> is invoked, the headers still can be modified in this point
                        and any modification will be reflected in the outbound HTTP message being sent. The modification of
                        headers must however happen before a first byte is written to the supplied output stream.
                    </p></div><p>
            </p><p>
                Another new parameter, <code class="literal">myBean</code>, contains the entity instance to be serialized (the type of
                entity corresponds to generic type of <code class="literal">MessageBodyWriter&lt;T&gt;</code>). Related parameter
                <code class="literal">entityStream</code> contains the entity output stream to which the method should serialize the entity.
                In our case we use JAXB to marshall the entity into the <code class="literal">entityStream</code>. Note, that the
                <code class="literal">entityStream</code> is not closed at the end of method; the stream will be closed by Jersey.
                </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                        Do not close the entity output stream in the <code class="literal">writeTo</code> method of your
                        <code class="literal">MessageBodyWriter&lt;T&gt;</code> implementation.
                    </p></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6687"></a>8.2.1.3.&nbsp;
                <code class="literal">MessageBodyWriter.getSize</code>
            </h4></div></div></div><p>
                The method is deprecated since JAX-RS 2.0 and Jersey 2 ignores the return value. In JAX-RS 1.0 the
                method could return the size of the entity that would be then used for "Content-Length" response
                header. In Jersey 2.0 the "Content-Length" parameter is computed automatically using an internal
                outbound entity buffering. For details about configuration options of outbound entity buffering see the javadoc
                of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/MessageProperties.html" target="_top">MessageProperties</a>, property <code class="literal">OUTBOUND_CONTENT_LENGTH_BUFFER</code>
                which configures the size of the buffer.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        You can disable the Jersey outbound entity buffering by setting the buffer size to 0.
                    </p></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6705"></a>8.2.1.4.&nbsp;Testing a <code class="literal">MessageBodyWriter&lt;T&gt;</code></h4></div></div></div><p>
                Before testing the <code class="literal">MyBeanMessageBodyWriter</code>, the writer must
                be registered as a custom JAX-RS extension provider. It should either be added to your application
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a>, or returned from your custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a> sub-class, or
                annotated with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/Provider.html" target="_top">@Provider</a> annotation to leverage JAX-RS provider auto-discovery feature.
            </p><p>
                After registering the <code class="literal">MyBeanMessageBodyWriter</code> and <code class="literal">MyResource</code> class
                in our application, the request can be initiated (in this example from Client API).

                </p><div class="example"><a name="client-get-call"></a><p class="title"><b>Example&nbsp;8.5.&nbsp;Client code testing MyBeanMessageBodyWriter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget webTarget = // initialize web target to the context root
            // of example application
Response response = webTarget.path("resource")
                        .request(MediaType.APPLICATION_XML).get();
System.out.println(response.getStatus());
String myBeanXml = response.readEntity(String.class);
System.out.println(myBeanXml);</pre></div></div><p><br class="example-break">

                The client code initiates the <code class="literal">GET</code> which will be matched to the resource method
                <code class="literal">MyResource.getMyBean()</code>. The response entity is de-serialized as a <code class="literal">String</code>.
            </p><p>
                The result of console output is:

                </p><div class="example"><a name="d0e6749"></a><p class="title"><b>Example&nbsp;8.6.&nbsp;Result of MyBeanMessageBodyWriter test</b></p><div class="example-contents"><pre class="screen">200
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;myBean&gt;
&lt;anyString&gt;Hello World!&lt;/anyString&gt;&lt;anyNumber&gt;42&lt;/anyNumber&gt;&lt;/myBean&gt;</pre></div></div><p><br class="example-break">

                The returned status is 200 and the entity is stored in the response in a <code class="literal">XML</code> format.
                Next, we will look at how the Jersey de-serializes this XML document into a <code class="literal">MyBean</code> consumed by
                our <code class="literal">POST</code> resource method.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6764"></a>8.2.2.&nbsp;MessageBodyReader</h3></div></div></div><p>
                In order to de-serialize the entity of <code class="literal">MyBean</code> on the server or the client, we need to implement
                a custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Please note, that this is only a demonstration of how to write a custom entity provider.
                        Jersey already contains default support for entity providers that can serialize JAXB beans
                        into XML.
                    </p></div><p>
            </p><p>
                Our <code class="literal">MessageBodyReader&lt;T&gt;</code> implementation is listed in <a class="xref" href="#mbw.ex.mbr" title="Example&nbsp;8.7.&nbsp;MessageBodyReader example">Example&nbsp;8.7, &#8220;MessageBodyReader example&#8221;</a>.

                </p><div class="example"><a name="mbw.ex.mbr"></a><p class="title"><b>Example&nbsp;8.7.&nbsp;MessageBodyReader example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public static class MyBeanMessageBodyReader
        implements MessageBodyReader&lt;MyBean&gt; {

@Override
public boolean isReadable(Class&lt;?&gt; type, Type genericType,
    Annotation[] annotations, MediaType mediaType) {
    return type == MyBean.class;
}

@Override
public MyBean readFrom(Class&lt;MyBean&gt; type,
    Type genericType,
    Annotation[] annotations, MediaType mediaType,
    MultivaluedMap&lt;String, String&gt; httpHeaders,
    InputStream entityStream)
        throws IOException, WebApplicationException {

    try {
        JAXBContext jaxbContext = JAXBContext.newInstance(MyBean.class);
        MyBean myBean = (MyBean) jaxbContext.createUnmarshaller()
            .unmarshal(entityStream);
        return myBean;
    } catch (JAXBException jaxbException) {
        throw new ProcessingException("Error deserializing a MyBean.",
            jaxbException);
    }
}
}</pre></div></div><p><br class="example-break">

                It is obvious that the <code class="literal">MessageBodyReader&lt;T&gt;</code> interface is similar to <code class="literal">MessageBodyWriter&lt;T&gt;</code>.
                In the next couple of sections we will explore it's API methods.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6798"></a>8.2.2.1.&nbsp;<code class="literal">MessageBodyReader.isReadable</code></h4></div></div></div><p>
                    It defines the method <code class="literal">isReadable()</code> which has a very similar meaning as method
                    <code class="literal">isWriteable()</code> in <code class="literal">MessageBodyWriter&lt;T&gt;</code>. The method returns <code class="literal">true</code>
                    if it is able to de-serialize the given type. The <code class="literal">annotations</code> parameter contains annotations
                    that are attached to the entity parameter in the resource method. In our <code class="literal">POST</code> resource
                    method <code class="literal">postMyBean</code> the entity parameter <code class="literal">myBean</code> is not
                    annotated, therefore no annotation will be passed to the isReadable. The <code class="literal">mediaType</code>
                    parameter contains the entity media type. The media type, in our case, must be consumable by the <code class="literal">POST</code>
                    resource method, which is specified by placing a JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Consumes.html" target="_top">@Consumes</a> annotation to the method.
                    The resource method <code class="literal">postMyBean()</code> is annotated with
                    <code class="literal">@Consumes("application/xml")</code>,
                    therefore for purpose of de-serialization of entity for the <code class="literal">postMyBean()</code> method,
                    only requests with entities represented as <code class="literal">"application/xml"</code>
                    media type will match the method. However, this method might be executed for entity types that are sub classes
                    or super classes of the declared generic type on the <code class="literal">MessageBodyReader&lt;T&gt;</code> will be also considered.
                    It is a responsibility of the <code class="literal">isReadable</code> method to decide whether it is able
                    to de-serialize the entity and type comparison is one of the basic decision steps.
                    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                            In order to reduce number of <code class="literal">isReadable</code> executions, always define correctly the consumable
                            media type(s) with the <code class="literal">@Consumes</code> annotation on your custom <code class="literal">MessageBodyReader&lt;T&gt;</code>.
                        </p></div><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6868"></a>8.2.2.2.&nbsp;<code class="literal">MessageBodyReader.readFrom</code></h4></div></div></div><p>
                    The <code class="literal">readForm()</code> method gets the parameters with the same meaning as in
                    <code class="literal">isReadable()</code>. The additional <code class="literal">entityStream</code> parameter provides a handle
                    to the entity input stream from which the entity bytes should be read and de-serialized into a Java entity which
                    is then returned from the method. Our <code class="literal">MyBeanMessageBodyReader</code> de-serializes the incoming
                    XML data into an instance of <code class="literal">MyBean</code> using JAXB.

                    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                            Do not close the entity input stream in your <code class="literal">MessageBodyReader&lt;T&gt;</code> implementation. The stream
                            will be automatically closed by Jersey runtime.
                        </p></div><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6896"></a>8.2.2.3.&nbsp;Testing a <code class="literal">MessageBodyWriter&lt;T&gt;</code></h4></div></div></div><p>
                    Now let's send a test request using the JAX-RS Client API.

                    </p><div class="example"><a name="d0e6903"></a><p class="title"><b>Example&nbsp;8.8.&nbsp;Testing MyBeanMessageBodyReader</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final MyBean myBean = new MyBean("posted MyBean", 11);
Response response = webTarget.path("resource").request("application/xml")
        .post(Entity.entity(myBean, "application/xml"));

System.out.println(response.getStatus());
final String responseEntity = response.readEntity(String.class);
System.out.println(responseEntity);
</pre></div></div><p><br class="example-break">
                </p><p>
                    The console output is:

                    </p><div class="example"><a name="d0e6911"></a><p class="title"><b>Example&nbsp;8.9.&nbsp;Result of testing MyBeanMessageBodyReader</b></p><div class="example-contents"><pre class="screen">200
posted MyBean</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6917"></a>8.2.2.4.&nbsp;Using Entity Providers with JAX-RS Client API</h4></div></div></div><p>
                    Both, <code class="literal">MessageBodyReader&lt;T&gt;</code> and <code class="literal">MessageBodyWriter&lt;T&gt;</code> can be registered in a
                    configuration of JAX-RS Client API components typically without any need to change their code. The example
                    <a class="xref" href="#mbw.ex.client.mbr.reg" title="Example&nbsp;8.10.&nbsp;MessageBodyReader registered on a JAX-RS client">Example&nbsp;8.10, &#8220;MessageBodyReader registered on a JAX-RS client&#8221;</a> is a variation on the <a class="xref" href="#client-get-call" title="Example&nbsp;8.5.&nbsp;Client code testing MyBeanMessageBodyWriter">Example&nbsp;8.5, &#8220;Client code testing MyBeanMessageBodyWriter&#8221;</a>
                    listed in one of the previous sections.

                    </p><div class="example"><a name="mbw.ex.client.mbr.reg"></a><p class="title"><b>Example&nbsp;8.10.&nbsp;MessageBodyReader registered on a JAX-RS client</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
    .register(MyBeanMessageBodyReader.class).build();

Response response = client.target("http://example/comm/resource")
    .request(MediaType.APPLICATION_XML).get();
System.out.println(response.getStatus());
MyBean myBean = response.readEntity(MyBean.class);
System.out.println(myBean);</pre></div></div><p><br class="example-break">
                </p><p>
                    The code above registers <code class="literal">MyBeanMessageBodyReader</code> to the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a> configuration
                    using a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientBuilder.html" target="_top">ClientBuilder</a> which means that the provider will be used for any <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a>
                    produced by the <code class="literal">client</code> instance.
                    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                            You could also register the JAX-RS entity (and any other) providers to individual
                            <code class="literal">WebTarget</code> instances produced by the client.
                        </p></div><p>

                    Then, using the fluent chain of method invocations, a resource target pointing to our
                    <code class="literal">MyResource</code> is defined, a HTTP <code class="literal">GET</code> request is invoked.
                    The response entity is then read as an instance of a <code class="literal">MyBean</code> type by invoking the
                    <code class="literal">response.readEntity</code> method, that internally locates the registered
                    <code class="literal">MyBeanMessageBodyReader</code> and uses it for entity de-serialization.
                </p><p>
                    The console output for the example is:
                    </p><div class="example"><a name="d0e6979"></a><p class="title"><b>Example&nbsp;8.11.&nbsp;Result of client code execution</b></p><div class="example-contents"><pre class="screen">200
MyBean{anyString='Hello World!', anyNumber=42}</pre></div></div><p><br class="example-break">
                </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="providers-selection"></a>8.3.&nbsp;Entity Provider Selection</h2></div></div></div><p>
            Usually there are many entity providers registered on the server or client side (be default there must be
            at least providers mandated by the JAX-RS specification, such as providers for primitive types, byte array,
            JAXB beans, etc.).
            JAX-RS defines an algorithm for selecting the most suitable provider for entity processing. This algorithm
            works with information such as entity Java type and on-the-wire media type representation of entity, and searches
            for the most suitable entity provider from the list of available providers based on the supported media type
            declared on each provider (defined by <code class="literal">@Produces</code> or <code class="literal">@Consumes</code> on the provider class)
            as well as based on the generic type declaration of the available providers. When a list of suitable candidate
            entity providers is selected and sorted based on the rules defined in JAX-RS specification, a JAX-RS runtime
            then it invokes <code class="literal">isReadable</code> or <code class="literal">isWriteable</code> method respectively on each
            provider in the list until a first provider is found that returns <code class="literal">true</code>. This provider is then used to
            process the entity.
        </p><p>
            The following steps describe the algorithm for selecting a <code class="literal">MessageBodyWriter&lt;T&gt;</code> (extracted
            from JAX-RS with little modifications). The steps refer to the previously discussed example application.
            The <code class="literal">MessageBodyWriter&lt;T&gt;</code> is searched for purpose of deserialization of <code class="literal">MyBean</code>
            entity returned from the method <code class="literal">getMyBean</code>. So, <span class="emphasis"><em>type is <code class="literal">MyBean</code>
            and media type <code class="literal">"application/xml"</code></em></span>. Let's assume the runtime contains also
            registered providers, namely:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                    <code class="literal">A</code>: <code class="literal">@Produces("application/*")</code> with generic type
                    <code class="literal">&lt;Object&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">B</code>: <code class="literal">@Produces("*/*")</code> with generic type <code class="literal">&lt;MyBean&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">C</code>: <code class="literal">@Produces("text/plain")</code> with generic type
                    <code class="literal">&lt;MyBean&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">D</code>: <code class="literal">@Produces("application/xml")</code> with generic type
                    <code class="literal">&lt;Object&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">MyBeanMessageBodyWriter</code>: <code class="literal">@Produces("application/xml")</code> with generic
                    type <code class="literal">&lt;MyBean&gt;</code>
                </td></tr></table><p>
        </p><p>
            The algorithm executed by a JAX-RS runtime to select a proper <code class="literal">MessageBodyWriter&lt;T&gt;</code> implementation
            is illustrated in <a class="xref" href="#mbw.writer.selection.algorithm" title="Procedure&nbsp;8.1.&nbsp;MessageBodyWriter<T&gt; Selection Algorithm">Procedure&nbsp;8.1, &#8220;<code class="literal">MessageBodyWriter&lt;T&gt;</code> Selection Algorithm&#8221;</a>.
        </p><div class="procedure"><a name="mbw.writer.selection.algorithm"></a><p class="title"><b>Procedure&nbsp;8.1.&nbsp;<code class="literal">MessageBodyWriter&lt;T&gt;</code> Selection Algorithm</b></p><ol class="procedure" type="1"><li class="step"><p>
                    Obtain the object that will be mapped to the message entity body. For a return type of Response
                    or subclasses, the object is the value of the entity property, for other return types it is the returned
                    object.
                </p><p>
                    So in our case, for the resource method <code class="literal">getMyBean</code> the type will
                    be <code class="literal">MyBean</code>.
                </p></li><li class="step"><p>
                    Determine the media type of the response.
                </p><p>
                    In our case, for resource method <code class="literal">getMyBean</code>
                    annotated with <code class="literal">@Produces("application/xml")</code>, the media type will be
                    <code class="literal">"application/xml"</code>.
                </p></li><li class="step"><p>
                    Select the set of MessageBodyWriter providers that support the object and media
                    type of the message entity body.
                </p><p>
                    In our case, for entity media type <code class="literal">"application/xml"</code>
                    and type <code class="literal">MyBean</code>, the appropriate <code class="literal">MessageBodyWriter&lt;T&gt;</code> will
                    be the <code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">D</code>
                    and <code class="literal">MyBeanMessageBodyWriter</code>. The provider <code class="literal">C</code> does
                    not define the appropriate
                    media type. <code class="literal">A</code> and <code class="literal">B</code> are fine as
                    their type is more generic and compatible with <code class="literal">"application/xml"</code>.
                </p></li><li class="step"><a name="mbw.writer.selection.algorithm.sortStep"></a><p>
                    Sort the selected MessageBodyWriter providers with a primary key of generic type where providers
                    whose generic type is the nearest superclass of the object class are sorted first and a secondary key of
                    media type. Additionally, JAX-RS specification mandates that custom, user registered providers have to
                    be sorted ahead of default providers provided by JAX-RS implementation. This is used as a tertiary
                    comparison key. User providers are places prior to Jersey internal providers in to the final ordered list.
                </p><p>
                    The sorted providers will be: <code class="literal">MyBeanMessageBodyWriter</code>,
                    <code class="literal">B</code>. <code class="literal">D</code>, <code class="literal">A</code>.
                </p></li><li class="step"><p>
                    Iterate through the sorted <code class="literal">MessageBodyWriter&lt;T&gt;</code> providers and, utilizing the
                    <code class="literal">isWriteable</code> method of each until you find a <code class="literal">MessageBodyWriter&lt;T&gt;</code> that
                    returns <code class="literal">true</code>.
                </p><p>
                    The first provider in the list - our <code class="literal">MyBeanMessageBodyWriter</code> returns <code class="literal">true</code> as
                    it compares types and the types matches. If it would return <code class="literal">false</code>, the next provider
                    <code class="literal">B</code> would by check by invoking its <code class="literal">isWriteable</code> method.
                </p></li><li class="step"><p>
                    If step 5 locates a suitable <code class="literal">MessageBodyWriter&lt;T&gt;</code> then use its writeTo method to map the
                    object to the entity body.
                </p><p>
                    <code class="literal">MyBeanMessageBodyWriter.writeTo</code> will be executed and it will serialize the
                    entity.
                </p><ul class="stepalternatives">
                    <li class="step"><p>
                            Otherwise, the server runtime MUST generate an
                            <code class="literal">InternalServerErrorException</code>, a subclass of
                            <code class="literal">WebApplicationException</code> with its status set to 500, and no entity and the client
                            runtime MUST generate a <code class="literal">ProcessingException</code>.
                        </p><p>
                            We have successfully found a provider, thus no exception is generated.
                        </p></li>
                </ul></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                JAX-RS 3.x/2.x is incompatible with JAX-RS 1.x in one step of the entity provider selection algorithm.
                JAX-RS 1.x defines sorting keys priorities in the <a class="xref" href="#mbw.writer.selection.algorithm.sortStep" title="Step 4">Step 4</a>
                in exactly opposite order. So, in JAX-RS 1.x the keys are defined in the order: primary media type,
                secondary type declaration distance where custom providers have always precedence to internal providers.
                If you want to force Jersey to use the algorithm compatible with JAX-RS 1.x, setup the property
                (to <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> or return from <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a> from its
                <code class="literal">getProperties</code> method):

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">jersey.config.workers.legacyOrdering=true</pre><p>

                Documentation of this property can be found in the javadoc of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/MessageProperties.html" target="_top">MessageProperties</a>.
            </p></div><p>
            The algorithm for selection of <code class="literal">MessageBodyReader&lt;T&gt;</code> is similar, including the incompatibility
            between JAX-RS 3.x/2.x and JAX-RS 1.x and the property to workaround it. The algorithm is defined as follows:
        </p><div class="procedure"><a name="mbw.reader.selection.algorithm"></a><p class="title"><b>Procedure&nbsp;8.2.&nbsp;<code class="literal">MessageBodyReader&lt;T&gt;</code> Selection Algorithm</b></p><ol class="procedure" type="1"><li class="step"><p>
                    Obtain the media type of the request. If the request does not contain a <code class="literal">Content-Type</code>
                    header then use <code class="literal">application/octet-stream</code> media type.
                </p></li><li class="step"><p>
                    Identify the Java type of the parameter whose value will be mapped from the entity body. The
                    Java type on the server is the type of the entity parameter of the resource method. On the client
                    it is the <code class="literal">Class</code> passed to <code class="literal">readFrom</code> method.
                </p></li><li class="step"><p>
                    Select the set of available <code class="literal">MessageBodyReader&lt;T&gt;</code> providers that support the media type
                    of the request.
                </p></li><li class="step"><a name="mbw.reader.selection.algorithm.selectStep"></a><p>
                    Iterate through the selected <code class="literal">MessageBodyReader&lt;T&gt;</code> classes and, utilizing their
                    <code class="literal">isReadable</code> method, choose the first <code class="literal">MessageBodyReader&lt;T&gt;</code> provider that
                    supports the desired combination of Java type/media type/annotations parameters.
                </p></li><li class="step"><p>
                    If <a class="xref" href="#mbw.reader.selection.algorithm.selectStep" title="Step 4">Step 4</a> locates a suitable
                    <code class="literal">MessageBodyReader&lt;T&gt;</code>, then use its <code class="literal">readFrom</code> method to map the entity
                    body to the desired Java type.
                </p><ul class="stepalternatives">
                    <li class="step"><p>
                            Otherwise, the server runtime MUST generate a <code class="literal">NotSupportedException</code>
                            (HTTP 415 status code) and no entity and the client runtime MUST generate an instance
                            of <code class="literal">ProcessingException</code>.
                        </p></li>
                </ul></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7325"></a>8.4.&nbsp;Jersey <code class="literal">MessageBodyWorkers</code> API</h2></div></div></div><p>
            In case you need to directly work with JAX-RS entity providers, for example to serialize an entity in your resource
            method, filter or in a composite entity provider, you would need to perform quite a lot of steps.
            You would need to choose the appropriate <code class="literal">MessageBodyWriter&lt;T&gt;</code> based on the type, media type and
            other parameters. Then you would need to instantiate it, check it by <code class="literal">isWriteable</code> method and
            basically perform all the steps that are normally performed by Jersey
            (see <a class="xref" href="#mbw.reader.selection.algorithm" title="Procedure&nbsp;8.2.&nbsp;MessageBodyReader<T&gt; Selection Algorithm">Procedure&nbsp;8.2, &#8220;<code class="literal">MessageBodyReader&lt;T&gt;</code> Selection Algorithm&#8221;</a>).
        </p><p>
            To remove this burden from developers, Jersey exposes a proprietary public API that simplifies the manipulation
            of entity providers. The API is defined by <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/MessageBodyWorkers.html" target="_top">MessageBodyWorkers</a> interface and Jersey provides an
            implementation that can be injected using the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a> injection annotation. The interface declares
            methods for selection of most appropriate <code class="literal">MessageBodyReader&lt;T&gt;</code> and <code class="literal">MessageBodyWriter&lt;T&gt;</code>
            based on the rules defined in JAX-RS spec, methods for writing and reading entity that ensure proper and timely
            invocation of interceptors and other useful methods.
        </p><p>
            See the following example of usage of <code class="literal">MessageBodyWorkers</code>.

            </p><div class="example"><a name="d0e7360"></a><p class="title"><b>Example&nbsp;8.12.&nbsp;Usage of MessageBodyWorkers interface</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("workers")
public static class WorkersResource {

    @Context
    private MessageBodyWorkers workers;

    @GET
    @Produces("application/xml")
    public String getMyBeanAsString() {

        final MyBean myBean = new MyBean("Hello World!", 42);

        // buffer into which myBean will be serialized
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        // get most appropriate MBW
        final MessageBodyWriter&lt;MyBean&gt; messageBodyWriter =
                workers.getMessageBodyWriter(MyBean.class, MyBean.class,
                        new Annotation[]{}, MediaType.APPLICATION_XML_TYPE);

        try {
            // use the MBW to serialize myBean into baos
            messageBodyWriter.writeTo(myBean,
                MyBean.class, MyBean.class, new Annotation[] {},
                MediaType.APPLICATION_XML_TYPE, new MultivaluedHashMap&lt;String, Object&gt;(),
                baos);
        } catch (IOException e) {
            throw new RuntimeException(
                "Error while serializing MyBean.", e);
        }

        final String stringXmlOutput = baos.toString();
        // stringXmlOutput now contains XML representation:
        // "&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
        // &lt;myBean&gt;&lt;anyString&gt;Hello World!&lt;/anyString&gt;
        // &lt;anyNumber&gt;42&lt;/anyNumber&gt;&lt;/myBean&gt;"

        return stringXmlOutput;
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            In the example a resource injects <code class="literal">MessageBodyWorkers</code> and uses it for selection
            of the most appropriate <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Then the writer is utilized to serialize the entity
            into the buffer as XML document. The <code class="literal">String</code> content of the buffer is then returned.
            This will cause that Jersey will not use <code class="literal">MyBeanMessageBodyWriter</code>
            to serialize the entity as it is already in the <code class="literal">String</code> type
            (<code class="literal">MyBeanMessageBodyWriter</code> does not support <code class="literal">String</code>). Instead, a simple
            <code class="literal">String</code>-based  <code class="literal">MessageBodyWriter&lt;T&gt;</code> will be chosen and it will only serialize the
            <code class="literal">String</code> with XML to the output entity stream by writing out the bytes of the
            <code class="literal">String</code>.
        </p><p>
            Of course, the code in the example does not bring any benefit as the entity could
            have been serialized by <code class="literal">MyBeanMessageBodyWriter</code> by Jersey as in previous examples;
            the purpose of the example was to show how to use <code class="literal">MessageBodyWorkers</code> in a resource method.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7409"></a>8.5.&nbsp;Default Jersey Entity Providers</h2></div></div></div><p>
            Jersey internally contains entity providers for these types with combination of media types (in brackets):
        </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <code class="literal">byte[]</code> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/String.html" target="_top">String</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/InputStream.html" target="_top">InputStream</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/Reader.html" target="_top">Reader</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_top">File</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="https://jakarta.ee/specifications//activation/2.0/apidocs/jakarta.activation/jakarta/activation/datasource" target="_top">DataSource</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Source.html" target="_top">Source</a> (<code class="literal">text/xml</code>, <code class="literal">application/xml</code> and media types of the form
                <code class="literal">application/*+xml</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/jakarta.xml.bind/JAXBElement.html" target="_top">JAXBElement</a> (<code class="literal">text/xml</code>, <code class="literal">application/xml</code> and media types of the form
                <code class="literal">application/*+xml</code>)
            </td></tr><tr><td>
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/MultivaluedMap.html" target="_top">MultivaluedMap&lt;K,V&gt;</a> (<code class="literal">application/x-www-form-urlencoded</code>)
            </td></tr><tr><td>
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Form.html" target="_top">Form</a> (<code class="literal">application/x-www-form-urlencoded</code>)
            </td></tr><tr><td>
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/StreamingOutput.html" target="_top">StreamingOutput</a> ((<code class="literal">*/*</code>)) - this class can be used as an lightweight
                <code class="literal">MessageBodyWriter&lt;T&gt;</code> that can be returned from a resource method
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Boolean.html" target="_top">Boolean</a>, <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Character.html" target="_top">Character</a> and <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Number.html" target="_top">Number</a> (<code class="literal">text/plain</code>) - corresponding
                primitive types supported via boxing/unboxing conversion
            </td></tr></table><p>
            For other media type supported in jersey please see the <a class="xref" href="#media" title="Chapter&nbsp;9.&nbsp;Support for Common Media Type Representations">Chapter&nbsp;9, <i>Support for Common Media Type Representations</i></a> which describes
            additional Jersey entity provider extensions for serialization to JSON, XML, serialization of collections,
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/package-summary.html" target="_top">Multi Part</a> and others.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="media"></a>Chapter&nbsp;9.&nbsp;Support for Common Media Type Representations</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#json">9.1. JSON</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7580">9.1.1. Approaches to JSON Support</a></span></dt><dt><span class="section"><a href="#json.moxy">9.1.2. MOXy</a></span></dt><dt><span class="section"><a href="#json.json-p">9.1.3. Java API for JSON Processing (JSON-P)</a></span></dt><dt><span class="section"><a href="#json.jackson">9.1.4. Jackson (2.x)</a></span></dt><dt><span class="section"><a href="#json.jettison">9.1.5. Jettison</a></span></dt><dt><span class="section"><a href="#d0e8348">9.1.6. <code class="literal">@JSONP</code> - JSON with Padding Support</a></span></dt><dt><span class="section"><a href="#json.json-b">9.1.7. Java API for JSON Binding (JSON-B)</a></span></dt></dl></dd><dt><span class="section"><a href="#xml">9.2. XML</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8593">9.2.1. Low level XML support</a></span></dt><dt><span class="section"><a href="#d0e8641">9.2.2. Getting started with JAXB</a></span></dt><dt><span class="section"><a href="#d0e8729">9.2.3. POJOs</a></span></dt><dt><span class="section"><a href="#d0e8767">9.2.4. Using custom JAXBContext</a></span></dt><dt><span class="section"><a href="#d0e8799">9.2.5. MOXy</a></span></dt></dl></dd><dt><span class="section"><a href="#multipart">9.3. Multipart</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8854">9.3.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e8955">9.3.2. Client</a></span></dt><dt><span class="section"><a href="#d0e9086">9.3.3. Server</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="json"></a>9.1.&nbsp;JSON</h2></div></div></div><p>
            Jersey JSON support comes as a set of extension modules where each of these modules contains an implementation of
            a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Feature.html" target="_top">Feature</a> that needs to be registered into your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> instance (client/server).
            There are multiple frameworks that provide support for JSON processing and/or JSON-to-Java binding.
            The modules listed below provide support for JSON representations by integrating the individual JSON frameworks into
            Jersey. At present, Jersey integrates with the following modules to provide JSON support:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="#json.moxy" title="9.1.2.&nbsp;MOXy">MOXy</a> - JSON binding support via MOXy is a default and preferred way of supporting JSON binding
                        in your Jersey applications since Jersey 2.0. When JSON MOXy module is on the class-path, Jersey will
                        automatically discover the module and seamlessly enable JSON binding support via MOXy in your
                        applications. (See <a class="xref" href="#deployment.autodiscoverable" title="4.3.&nbsp;Auto-Discoverable Features">Section&nbsp;4.3, &#8220;Auto-Discoverable Features&#8221;</a>.)
                    </p></li><li class="listitem"><p><a class="link" href="#json.json-p" title="9.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a></p></li><li class="listitem"><p><a class="link" href="#json.jackson" title="9.1.4.&nbsp;Jackson (2.x)">Jackson</a></p></li><li class="listitem"><p><a class="link" href="#json.jettison" title="9.1.5.&nbsp;Jettison">Jettison</a></p></li><li class="listitem"><p><a class="link" href="#json.json-b" title="9.1.7.&nbsp;Java API for JSON Binding (JSON-B)">Java API for JSON Binding (JSON-B)</a></p></li></ul></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7580"></a>9.1.1.&nbsp;Approaches to JSON Support</h3></div></div></div><p>
                Each of the aforementioned extension modules uses one or more of the three basic approaches available when
                working with JSON representations:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POJO based JSON binding support</p></li><li class="listitem"><p>JAXB based JSON binding support</p></li><li class="listitem"><p>Low-level JSON parsing &amp; processing support</p></li></ul></div><p>

                The first method is pretty generic and allows you to map any Java Object to JSON and vice versa.
                The other two approaches limit you in Java types your resource methods could produce and/or consume.
                JAXB based approach is useful if you plan to utilize certain JAXB features and support both XML and JSON
                representations. The last, low-level, approach gives you the best fine-grained control over the out-coming
                JSON data format.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="json-pojo"></a>9.1.1.1.&nbsp;POJO support</h4></div></div></div><p>POJO support represents the easiest way to convert your Java Objects to JSON and back.</p><p>Media modules that support this approach are <a class="link" href="#json.moxy" title="9.1.2.&nbsp;MOXy">MOXy</a>, <a class="link" href="#json.jackson" title="9.1.4.&nbsp;Jackson (2.x)">Jackson</a>, and <a class="link" href="#json.json-b" title="9.1.7.&nbsp;Java API for JSON Binding (JSON-B)">Java API for JSON Binding (JSON-B)</a></p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="json-jaxb"></a>9.1.1.2.&nbsp;JAXB based JSON support</h4></div></div></div><p>
                    Taking this approach will save you a lot of time, if you want to easily produce/consume both JSON and XML
                    data format. With JAXB beans you will be able to use the same Java model to generate JSON as well as XML
                    representations.
                    Another advantage is simplicity of working with such a model and availability of the API in Java SE Platform.
                    JAXB leverages annotated POJOs and these could be handled as simple Java beans.
                </p><p>
                    A disadvantage of JAXB based approach could be if you need to work with a very specific JSON format. Then it
                    might be difficult to find a proper way to get such a format produced and consumed. This is a reason why a
                    lot of configuration options are provided, so that you can control how JAXB beans get serialized and
                    de-serialized. The extra configuration options however requires you to learn more details about the framework
                    you are using.
                </p><p>
                    Following is a very simple example of how a JAXB bean could look like.

                    </p><div class="example"><a name="d0e7620"></a><p class="title"><b>Example&nbsp;9.1.&nbsp;Simple JAXB bean implementation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class MyJaxbBean {
    public String name;
    public int age;

    public MyJaxbBean() {} // JAXB needs this

    public MyJaxbBean(String name, int age) {
        this.name = name;
        this.age = age;
    }
}</pre></div></div><p><br class="example-break">

                    Using the above JAXB bean for producing JSON data format from you resource method, is then as simple as:

                    </p><div class="example"><a name="d0e7626"></a><p class="title"><b>Example&nbsp;9.2.&nbsp;JAXB bean used to generate JSON representation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces("application/json")
public MyJaxbBean getMyBean() {
    return new MyJaxbBean("Agamemnon", 32);
}</pre></div></div><p><br class="example-break">

                    Notice, that JSON specific mime type is specified in <code class="literal">@Produces</code> annotation, and the method returns
                    an instance of <code class="literal">MyJaxbBean</code>, which JAXB is able to process. Resulting JSON in this case
                    would look like:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: text;&#xA;    gutter: false;">{"name":"Agamemnon", "age":"32"}</pre><p>
                </p><p>
                    A proper use of JAXB annotations itself enables you to control output JSON format to certain extent.
                    Specifically, renaming and omitting items is easy to do directly just by using JAXB annotations.
                    For example, the following example depicts changes in the above mentioned MyJaxbBean that will result in
                    <code class="literal">{"king":"Agamemnon"}</code> JSON output.

                    </p><div class="example"><a name="d0e7646"></a><p class="title"><b>Example&nbsp;9.3.&nbsp;Tweaking JSON format using JAXB</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class MyJaxbBean {

    @XmlElement(name="king")
    public String name;

    @XmlTransient
    public int age;

    // several lines removed
}</pre></div></div><p><br class="example-break">
                </p><p>Media modules that support this approach are <a class="link" href="#json.moxy" title="9.1.2.&nbsp;MOXy">MOXy</a>, <a class="link" href="#json.jackson" title="9.1.4.&nbsp;Jackson (2.x)">Jackson</a>, <a class="link" href="#json.jettison" title="9.1.5.&nbsp;Jettison">Jettison</a></p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="json-lowlevel"></a>9.1.1.3.&nbsp;Low-level based JSON support</h4></div></div></div><p>
                    JSON Processing API is a new standard API for parsing and processing JSON structures in similar way to what
                    SAX and StAX parsers provide for XML. The API is part of Jakarta EE 9 and later. Another such JSON
                    parsing/processing API is provided by Jettison framework (which is also supported in jakartified environment).
                    Both APIs provide a low-level access to producing
                    and consuming JSON data structures. By adopting this low-level approach you would be working with
                    <code class="literal">JsonObject</code> (or <code class="literal">JSONObject</code> respectively) and/or
                    <code class="literal">JsonArray</code> (or <code class="literal">JSONArray</code> respectively) classes when processing your
                    JSON data representations.
                </p><p>
                    The biggest advantage of these low-level APIs is that you will gain full control over the JSON format
                    produced and consumed. You will also be able to produce and consume very large JSON structures using
                    streaming JSON parser/generator APIs.
                    On the other hand, dealing with your data model objects will probably be a lot more complex, compared
                    to the POJO or JAXB based binding approach. Differences are depicted at the following code snippets.
                </p><p>
                    Let's start with JAXB-based approach.

                    </p><div class="example"><a name="d0e7683"></a><p class="title"><b>Example&nbsp;9.4.&nbsp;JAXB bean creation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">MyJaxbBean myBean = new MyJaxbBean("Agamemnon", 32);</pre></div></div><p><br class="example-break">

                    Above you construct a simple JAXB bean, which could be written in JSON as
                    <code class="literal">{"name":"Agamemnon", "age":32}</code>
                </p><p>
                    Now to build an equivalent <code class="literal">JsonObject</code>/<code class="literal">JSONObject</code> (in terms of
                    resulting JSON expression), you would need several more lines of code. The following example illustrates
                    how to construct the same JSON data using the standard Jakarta EE 9 JSON-Processing API.
                    </p><div class="example"><a name="d0e7700"></a><p class="title"><b>Example&nbsp;9.5.&nbsp;Constructing a <code class="literal">JsonObject</code> (JSON-Processing)</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">JsonObject myObject = Json.createObjectBuilder()
        .add("name", "Agamemnon")
        .add("age", 32)
        .build();</pre></div></div><p><br class="example-break">

                    And at last, here's how the same work can be done with Jettison API.
                    </p><div class="example"><a name="d0e7709"></a><p class="title"><b>Example&nbsp;9.6.&nbsp;Constructing a <code class="literal">JSONObject</code> (Jettison)</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">JSONObject myObject = new JSONObject();
try {
    myObject.put("name", "Agamemnon");
    myObject.put("age", 32);
} catch (JSONException ex) {
    LOGGER.log(Level.SEVERE, "Error ...", ex);
}</pre></div></div><p><br class="example-break">
                </p><p>
                    Media modules that support the low-level JSON parsing and generating approach are <a class="link" href="#json.json-p" title="9.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a>
                    and <a class="link" href="#json.jettison" title="9.1.5.&nbsp;Jettison">Jettison</a>. Unless you have a strong reason for using the non-standard <a class="link" href="#json.jettison" title="9.1.5.&nbsp;Jettison">Jettison</a> API,
                    we recommend you to use the new standard <a class="link" href="#json.json-p" title="9.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a> API instead.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json.moxy"></a>9.1.2.&nbsp;MOXy</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7735"></a>9.1.2.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use MOXy as your JSON provider you need to add <code class="literal">jersey-media-moxy</code> module to your <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-moxy&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-moxy/dependencies.html" target="_top">jersey-media-moxy</a>) on the classpath.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="moxy-registration"></a>9.1.2.2.&nbsp;Configure and register</h4></div></div></div><p>
                    As stated in the <a class="xref" href="#deployment.autodiscoverable" title="4.3.&nbsp;Auto-Discoverable Features">Section&nbsp;4.3, &#8220;Auto-Discoverable Features&#8221;</a> as well as earlier in this chapter, MOXy media
                    module is one of the modules where you don't need to explicitly register its <code class="literal">Feature</code>s
                    (<code class="literal">MoxyJsonFeature</code>) in your client/server <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> as this feature is
                    automatically discovered and registered when you add <code class="literal">jersey-media-moxy</code> module to your class-path.
                </p><p>
                    The auto-discoverable <code class="literal">jersey-media-moxy</code> module defines a few properties that can be used to control the
                    automatic registration of <code class="literal">MoxyJsonFeature</code> (besides the generic
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a> an the its client/server variants):

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">CommonProperties.MOXY_JSON_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">ServerProperties.MOXY_JSON_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">ClientProperties.MOXY_JSON_FEATURE_DISABLE</a></p></li></ul></div><p>
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        A manual registration of any other Jersey JSON provider feature (except for <a class="link" href="#json.json-p" title="9.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a>)
                        disables the automated enabling and configuration of <code class="literal">MoxyJsonFeature</code>.
                    </p></div><p>
                    To configure <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>s / <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>s provided by MOXy you can simply
                    create an instance of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html" target="_top">MoxyJsonConfig</a> and set values of needed properties. For most common
                    properties you can use a particular method to set the value of the property or you can use more generic
                    methods to set the property:

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html#property(java.lang.String, java.lang.Object)" target="_top">MoxyJsonConfig#property(java.lang.String, java.lang.Object)</a> - sets a property value for both Marshaller and Unmarshaller.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html#marshallerProperty(java.lang.String, java.lang.Object)" target="_top">MoxyJsonConfig#marshallerProperty(java.lang.String, java.lang.Object)</a> - sets a property value for Marshaller.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html#unmarshallerProperty(java.lang.String, java.lang.Object)" target="_top">MoxyJsonConfig#unmarshallerProperty(java.lang.String, java.lang.Object)</a> - sets a property value for Unmarshaller.
                            </p></li></ul></div><p>

                    </p><div class="example"><a name="d0e7836"></a><p class="title"><b>Example&nbsp;9.7.&nbsp;<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html" target="_top">MoxyJsonConfig</a> - Setting properties.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Map&lt;String, String&gt; namespacePrefixMapper = new HashMap&lt;String, String&gt;();
namespacePrefixMapper.put("http://www.w3.org/2001/XMLSchema-instance", "xsi");

final MoxyJsonConfig configuration = new MoxyJsonConfig()
        .setNamespacePrefixMapper(namespacePrefixMapper)
        .setNamespaceSeparator(':');
                        </pre></div></div><p><br class="example-break">

                    In order to make <code class="literal">MoxyJsonConfig</code> visible for MOXy you need to create and register
                    <code class="literal">ContextResolver&lt;T&gt;</code> in your client/server code.

                    </p><div class="example"><a name="d0e7850"></a><p class="title"><b>Example&nbsp;9.8.&nbsp;Creating <code class="literal">ContextResolver&lt;MoxyJsonConfig&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Map&lt;String, String&gt; namespacePrefixMapper = new HashMap&lt;String, String&gt;();
namespacePrefixMapper.put("http://www.w3.org/2001/XMLSchema-instance", "xsi");

final MoxyJsonConfig moxyJsonConfig = MoxyJsonConfig()
            .setNamespacePrefixMapper(namespacePrefixMapper)
            .setNamespaceSeparator(':');

final ContextResolver&lt;MoxyJsonConfig&gt; jsonConfigResolver = moxyJsonConfig.resolver();
</pre></div></div><p><br class="example-break">
                </p><p>
                    Another way to pass configuration properties to the underlying <code class="literal">MOXyJsonProvider</code> is to set
                    them directly into your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> instance (see an example below). These are overwritten by
                    properties set into the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html" target="_top">MoxyJsonConfig</a>.

                    </p><div class="example"><a name="d0e7869"></a><p class="title"><b>Example&nbsp;9.9.&nbsp;Setting properties for MOXy providers into <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
                            .property(MarshallerProperties.JSON_NAMESPACE_SEPARATOR, ".")
                            // further configuration</pre></div></div><p><br class="example-break">
                </p><p>
                    There are some properties for which Jersey sets the default value when
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> / <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> from MOXy is used and they are:

                    </p><div class="table"><a name="d0e7885"></a><p class="title"><b>Table&nbsp;9.1.&nbsp;Default property values for MOXy <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> / <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a></b></p><div class="table-contents"><table summary="Default property values for MOXy MessageBodyReader<T&gt; / MessageBodyWriter<T&gt;" border="1"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><td align="left"><code class="literal">jakarta.xml.bind.Marshaller#JAXB_FORMATTED_OUTPUT</code></td><td align="left"><code class="literal">false</code></td></tr><tr><td align="left">
                                        <code class="literal">org.eclipse.persistence.jaxb.JAXBContextProperties#JSON_INCLUDE_ROOT</code>
                                    </td><td align="left"><code class="literal">false</code></td></tr><tr><td align="left">
                                        <code class="literal">org.eclipse.persistence.jaxb.MarshallerProperties#JSON_MARSHAL_EMPTY_COLLECTIONS</code>
                                    </td><td align="left"><code class="literal">true</code></td></tr><tr><td align="left">
                                        <code class="literal">org.eclipse.persistence.jaxb.JAXBContextProperties#JSON_NAMESPACE_SEPARATOR</code>
                                    </td><td align="left"><code class="literal">org.eclipse.persistence.oxm.XMLConstants#DOT</code></td></tr></tbody></table></div></div><p><br class="table-break">
                </p><div class="example"><a name="ex-moxy-client"></a><p class="title"><b>Example&nbsp;9.10.&nbsp;Building client with MOXy JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
        // The line below that registers MOXy feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is
        // not disabled.
        .register(MoxyJsonFeature.class)
        .register(jsonConfigResolver)
        .build();</pre></div></div><br class="example-break"><div class="example"><a name="ex-moxy-server"></a><p class="title"><b>Example&nbsp;9.11.&nbsp;Creating JAX-RS application with MOXy JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        .packages("org.glassfish.jersey.examples.jsonmoxy")
        // The line below that registers MOXy feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is
        // not disabled.
        .register(MoxyJsonFeature.class)
        .register(jsonConfigResolver);</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7940"></a>9.1.2.3.&nbsp;Examples</h4></div></div></div><p>
                    Jersey provides a <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-moxy" target="_top">JSON MOXy example</a>
                    on how to use MOXy to consume/produce JSON.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json.json-p"></a>9.1.3.&nbsp;Java API for JSON Processing (JSON-P)</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7951"></a>9.1.3.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use JSON-P as your JSON provider you need to add <code class="literal">jersey-media-json-processing</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-processing&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-processing/dependencies.html" target="_top">jersey-media-json-processing</a>)
                    on the class-path.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jsonp-registration"></a>9.1.3.2.&nbsp;Configure and register</h4></div></div></div><p>
                    As stated in <a class="xref" href="#deployment.autodiscoverable" title="4.3.&nbsp;Auto-Discoverable Features">Section&nbsp;4.3, &#8220;Auto-Discoverable Features&#8221;</a> JSON-Processing media module is one of the
                    modules where you don't need to explicitly register its
                    <code class="literal">Feature</code>s (<code class="literal">JsonProcessingFeature</code>) in your client/server
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> as this feature is automatically discovered and registered when you add
                    <code class="literal">jersey-media-json-processing</code> module to your classpath.
                </p><p>
                    As for the other modules, <code class="literal">jersey-media-json-processing</code> has also few properties that can affect the
                    registration of <code class="literal">JsonProcessingFeature</code>
                    (besides <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a> and the like):

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">CommonProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">ServerProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">ClientProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p></li></ul></div><p>
                </p><p>
                    To configure <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>s / <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>s provided by JSON-P you can simply
                    add values for supported properties into the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configuration.html" target="_top">Configuration</a> instance (client/server). Currently
                    supported are these properties:

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <code class="literal">JsonGenerator.PRETTY_PRINTING</code>
                                ("<code class="literal">jakarta.json.stream.JsonGenerator.prettyPrinting</code>")
                            </p></li></ul></div><p>
                </p><div class="example"><a name="d0e8034"></a><p class="title"><b>Example&nbsp;9.12.&nbsp;Building client with JSON-Processing JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientBuilder.newClient(new ClientConfig()
        // The line below that registers JSON-Processing feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is not disabled.
        .register(JsonProcessingFeature.class)
        .property(JsonGenerator.PRETTY_PRINTING, true)
);</pre></div></div><br class="example-break"><div class="example"><a name="d0e8039"></a><p class="title"><b>Example&nbsp;9.13.&nbsp;Creating JAX-RS application with JSON-Processing JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        // The line below that registers JSON-Processing feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is not disabled.
        .register(JsonProcessingFeature.class)
        .packages("org.glassfish.jersey.examples.jsonp")
        .property(JsonGenerator.PRETTY_PRINTING, true);</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8044"></a>9.1.3.3.&nbsp;Examples</h4></div></div></div><p>Jersey provides a
                    <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-processing-webapp" target="_top">JSON Processing example</a>
                    on how to use JSON-Processing to consume/produce JSON.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json.jackson"></a>9.1.4.&nbsp;Jackson (2.x)</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8055"></a>9.1.4.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use Jackson 2.x as your JSON provider you need to add <code class="literal">jersey-media-json-jackson</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-jackson/dependencies.html" target="_top">jersey-media-json-jackson</a>)
                    on the classpath.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jackson-registration"></a>9.1.4.2.&nbsp;Configure and register</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Note that namespace for Jackson 2.x is (<code class="literal">com.fasterxml.jackson</code>).
                    </p></div><p>
                    Jackson JSON processor could be controlled via providing a custom Jackson 2 <a class="link" href="http://fasterxml.github.io/jackson-databind/javadoc/2.3.0/com/fasterxml/jackson/databind/ObjectMapper.html" target="_top">ObjectMapper</a> instance.
                    This could be handy if you need to redefine the default Jackson behaviour and to fine-tune how your JSON data
                    structures look like. Detailed description of all Jackson features is out of scope of this guide. The example
                    below gives you a hint on how to wire your <code class="literal">ObjectMapper</code>
                    instance into your Jersey application.
                </p><p>
                    In order to use Jackson as your JSON (JAXB/POJO) provider you need to register <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jackson/JacksonFeature.html" target="_top">JacksonFeature</a>
                    and a <code class="literal">ContextResolver&lt;T&gt;</code> for <code class="literal">ObjectMapper</code>,
                    if needed, in your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> (client/server).

                    </p><div class="example"><a name="d0e8103"></a><p class="title"><b>Example&nbsp;9.14.&nbsp;<code class="literal">ContextResolver&lt;ObjectMapper&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class MyObjectMapperProvider implements ContextResolver&lt;ObjectMapper&gt; {

    final ObjectMapper defaultObjectMapper;

    public MyObjectMapperProvider() {
        defaultObjectMapper = createDefaultMapper();
    }

    @Override
    public ObjectMapper getContext(Class&lt;?&gt; type) {
            return defaultObjectMapper;
        }
    }

    private static ObjectMapper createDefaultMapper() {
        final ObjectMapper result = new ObjectMapper();
        result.configure(Feature.INDENT_OUTPUT, true);

        return result;
    }

    // ...
}</pre><p>To view the complete example source code, see
    <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-jackson/src/main/java/org/glassfish/jersey/examples/jackson/MyObjectMapperProvider.java" target="_top">
    MyObjectMapperProvider</a> class from the
    <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-jackson" target="_top">JSON-Jackson</a> example.</p></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8118"></a><p class="title"><b>Example&nbsp;9.15.&nbsp;Building client with Jackson JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
        .register(MyObjectMapperProvider.class)  // No need to register this provider if no special configuration is required.
        .register(JacksonFeature.class)
        .build();</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8124"></a><p class="title"><b>Example&nbsp;9.16.&nbsp;Creating JAX-RS application with Jackson JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        .packages("org.glassfish.jersey.examples.jackson")
        .register(MyObjectMapperProvider.class)  // No need to register this provider if no special configuration is required.
        .register(JacksonFeature.class);</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8130"></a>9.1.4.3.&nbsp;Examples</h4></div></div></div><p>
                    Jersey provides <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-jackson" target="_top">JSON Jackson (2.x) example</a>
                    showing how to use Jackson to consume/produce JSON.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json.jettison"></a>9.1.5.&nbsp;Jettison</h3></div></div></div><p>
                JAXB approach for (de)serializing JSON in Jettison module provides, in addition to using pure JAXB,
                configuration options that could be set on an <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jettison/JettisonConfig.html" target="_top">JettisonConfig</a> instance. The instance could be then
                further used to create a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jettison/JettisonJaxbContext.html" target="_top">JettisonJaxbContext</a>, which serves as a main configuration point in this
                area.
                To pass your specialized <code class="literal">JettisonJaxbContext</code> to Jersey, you will finally need to implement
                a JAXBContext <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ContextResolver.html" target="_top">ContextResolver&lt;T&gt;</a> (see below).
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8155"></a>9.1.5.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use Jettison as your JSON provider you need to add <code class="literal">jersey-media-json-jettison</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-jettison&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-jettison/dependencies.html" target="_top">jersey-media-json-jettison</a>) on
                    the classpath.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8172"></a>9.1.5.2.&nbsp;JSON Notations</h4></div></div></div><p>
                    <code class="literal">JettisonConfig</code> allows you to use two JSON notations. Each of these notations serializes
                    JSON in a different way. Following is a list of supported notations:

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>JETTISON_MAPPED (default notation)</p></li><li class="listitem"><p>BADGERFISH</p></li></ul></div><p>

                    You might want to use one of these notations, when working with more complex XML documents. Namely when you
                    deal with multiple XML namespaces in your JAXB beans.
                </p><p>
                    Individual notations and their further configuration options are described below. Rather then explaining
                    rules for mapping XML constructs into JSON, the notations will be described using a simple example. Following
                    are JAXB beans, which will be used.

                    </p><div class="example"><a name="d0e8190"></a><p class="title"><b>Example&nbsp;9.17.&nbsp;JAXB beans for JSON supported notations description, simple address bean</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class Address {
    public String street;
    public String town;

    public Address(){}

    public Address(String street, String town) {
        this.street = street;
        this.town = town;
    }
}</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8196"></a><p class="title"><b>Example&nbsp;9.18.&nbsp;JAXB beans for JSON supported notations description, contact bean</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class Contact {

    public int id;
    public String name;
    public List&lt;Address&gt; addresses;

    public Contact() {};

    public Contact(int id, String name, List&lt;Address&gt; addresses) {
        this.name = name;
        this.id = id;
        this.addresses =
            (addresses != null) ? new LinkedList&lt;Address&gt;(addresses) : null;
    }
}</pre></div></div><p><br class="example-break">
                </p><p>
                    Following text will be mainly working with a contact bean initialized with:

                    </p><div class="example"><a name="d0e8204"></a><p class="title"><b>Example&nbsp;9.19.&nbsp;JAXB beans for JSON supported notations description, initialization</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Address[] addresses = {new Address("Long Street 1", "Short Village")};
Contact contact = new Contact(2, "Bob", Arrays.asList(addresses));</pre></div></div><p><br class="example-break">

                    I.e. contact bean with <code class="literal">id=2</code>, <code class="literal">name="Bob"</code> containing
                    a single address (<code class="literal">street="Long Street 1"</code>, <code class="literal">town="Short Village"</code>).
                </p><p>
                    All below described configuration options are documented also in api-docs at <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jettison/JettisonConfig.html" target="_top">JettisonConfig</a>.
                </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8227"></a>9.1.5.2.1.&nbsp;Jettison mapped notation</h5></div></div></div><p>
                        If you need to deal with various XML namespaces, you will find Jettison <code class="literal">mapped</code>
                        notation pretty useful. Lets define a particular namespace for <code class="code">id</code> item:

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
@XmlElement(namespace="http://example.com")
public int id;
...</pre><p>

                        Then you simply configure a mapping from XML namespace into JSON prefix as follows:

                        </p><div class="example"><a name="json.jaxb.jettison.mapped.ns.def"></a><p class="title"><b>Example&nbsp;9.20.&nbsp;
                                XML namespace to JSON mapping configuration for Jettison based <code class="literal">mapped</code> notation
                            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Map&lt;String,String&gt; ns2json = new HashMap&lt;String, String&gt;();
ns2json.put("http://example.com", "example");
context = new JettisonJaxbContext(
    JettisonConfig.mappedJettison().xml2JsonNs(ns2json).build(),
    types);</pre></div></div><p><br class="example-break">

                        Resulting JSON will look like in the example below.

                        </p><div class="example"><a name="d0e8250"></a><p class="title"><b>Example&nbsp;9.21.&nbsp;JSON expression with XML namespaces mapped into JSON</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "contact":{
      "example.id":2,
      "name":"Bob",
      "addresses":{
         "street":"Long Street 1",
         "town":"Short Village"
      }
   }
}</pre></div></div><p><br class="example-break">

                        Please note, that <code class="code">id</code> item became <code class="code">example.id</code> based on the XML namespace mapping.
                        If you have more XML namespaces in your XML, you will need to configure appropriate mapping for all of
                        them.
                    </p><p>
                        Another configurable option introduced in Jersey version 2.2 is related to serialization of JSON arrays with Jettison's
                        mapped notation. When serializing elements representing single item lists/arrays, you might want to utilise
                        the following Jersey configuration method to explicitly name which elements to treat as arrays no matter what the actual content is.

                        </p><div class="example"><a name="json.jaxb.jettison.mapped.array.def"></a><p class="title"><b>Example&nbsp;9.22.&nbsp;
                                JSON Array configuration for Jettison based <code class="literal">mapped</code> notation
                            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">context = new JettisonJaxbContext(
    JettisonConfig.mappedJettison().serializeAsArray("name").build(),
    types);</pre></div></div><p><br class="example-break">

                        Resulting JSON will look like in the example below, unimportant lines removed for sanity.

                        </p><div class="example"><a name="d0e8273"></a><p class="title"><b>Example&nbsp;9.23.&nbsp;JSON expression with JSON arrays explicitly configured via Jersey</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "contact":{
      ...
      "name":["Bob"],
      ...
   }
}</pre></div></div><p><br class="example-break">

                    </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8279"></a>9.1.5.2.2.&nbsp;Badgerfish notation</h5></div></div></div><p>
                        From JSON and JavaScript perspective, this notation is definitely the worst readable one.
                        You will probably not want to use it, unless you need to make sure your JAXB beans could be flawlessly
                        written and read back to and from JSON, without bothering with any formatting configuration, namespaces,
                        etc.
                    </p><p>
                        <code class="literal">JettisonConfig</code> instance using <code class="literal">badgerfish</code> notation could be built
                        with

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">JettisonConfig.badgerFish().build()</pre><p>

                        and the JSON output JSON will be as follows.

                        </p><div class="example"><a name="d0e8295"></a><p class="title"><b>Example&nbsp;9.24.&nbsp;JSON expression produced using <code class="literal">badgerfish</code> notation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "contact":{
      "id":{
         "$":"2"
      },
      "name":{
         "$":"Bob"
      },
      "addresses":{
         "street":{
            "$":"Long Street 1"
         },
         "town":{
            "$":"Short Village"
         }
      }
   }
}</pre></div></div><p><br class="example-break">
                    </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jettison-registration"></a>9.1.5.3.&nbsp;Configure and register</h4></div></div></div><p>
                    In order to use Jettison as your JSON (JAXB/POJO) provider you need to register <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jettison/JettisonFeature.html" target="_top">JettisonFeature</a>
                    and a <code class="literal">ContextResolver&lt;T&gt;</code> for <code class="literal">JAXBContext</code> (if needed) in your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a>
                    (client/server).

                    </p><div class="example"><a name="d0e8321"></a><p class="title"><b>Example&nbsp;9.25.&nbsp;<code class="literal">ContextResolver&lt;ObjectMapper&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class JaxbContextResolver implements ContextResolver&lt;JAXBContext&gt; {

    private final JAXBContext context;
    private final Set&lt;Class&lt;?&gt;&gt; types;
    private final Class&lt;?&gt;[] cTypes = {Flights.class, FlightType.class, AircraftType.class};

    public JaxbContextResolver() throws Exception {
        this.types = new HashSet&lt;Class&lt;?&gt;&gt;(Arrays.asList(cTypes));
        this.context = new JettisonJaxbContext(JettisonConfig.DEFAULT, cTypes);
    }

    @Override
    public JAXBContext getContext(Class&lt;?&gt; objectType) {
        return (types.contains(objectType)) ? context : null;
    }
}</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8328"></a><p class="title"><b>Example&nbsp;9.26.&nbsp;Building client with Jettison JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
        .register(JaxbContextResolver.class)  // No need to register this provider if no special configuration is required.
        .register(JettisonFeature.class)
        .build();</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8334"></a><p class="title"><b>Example&nbsp;9.27.&nbsp;Creating JAX-RS application with Jettison JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        .packages("org.glassfish.jersey.examples.jettison")
        .register(JaxbContextResolver.class)  // No need to register this provider if no special configuration is required.
        .register(JettisonFeature.class);</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8340"></a>9.1.5.4.&nbsp;Examples</h4></div></div></div><p>
                    Jersey provides an <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-jettison" target="_top">JSON Jettison example</a>
                    on how to use Jettison to consume/produce JSON.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8348"></a>9.1.6.&nbsp;<code class="literal">@JSONP</code> - JSON with Padding Support</h3></div></div></div><p>
                Jersey provides out-of-the-box support for <a class="link" href="http://en.wikipedia.org/wiki/JSONP" target="_top">JSONP</a>
                - JSON with padding. The following conditions has to be met to take advantage of this capability:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Resource method, which should return wrapped JSON, needs to be annotated with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/JSONP.html" target="_top">@JSONP</a>
                            annotation.
                        </p></li><li class="listitem"><p>
                            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for <code class="literal">application/json</code> media type, which also accepts
                            the return type of the resource method, needs to be registered (see <a class="link" href="#json" title="9.1.&nbsp;JSON">JSON</a>
                            section of this chapter).
                        </p></li><li class="listitem"><p>
                            User's request has to contain <code class="literal">Accept</code> header with one of the JavaScript media types
                            defined (see below).
                        </p></li></ul></div><p>

                Acceptable media types compatible with <code class="literal">@JSONP</code> are: <code class="literal">application/javascript</code>,
                <code class="literal">application/x-javascript</code>, <code class="literal">application/ecmascript</code>,
                <code class="literal">text/javascript</code>, <code class="literal">text/x-javascript</code>, <code class="literal">text/ecmascript</code>,
                <code class="literal">text/jscript</code>.

                </p><div class="example"><a name="d0e8408"></a><p class="title"><b>Example&nbsp;9.28.&nbsp;Simplest case of using <code class="literal">@JSONP</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@JSONP
@Produces({"application/json", "application/javascript"})
public JaxbBean getSimpleJSONP() {
    return new JaxbBean("jsonp");
}</pre></div></div><p><br class="example-break">

                Assume that we have registered a JSON providers and that the <code class="literal">JaxbBean</code> looks like:

                </p><div class="example"><a name="d0e8419"></a><p class="title"><b>Example&nbsp;9.29.&nbsp;JaxbBean for @JSONP example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class JaxbBean {

    private String value;

    public JaxbBean() {}

    public JaxbBean(final String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    public void setValue(final String value) {
        this.value = value;
    }
}</pre></div></div><p><br class="example-break">

                When you send a <code class="literal">GET</code> request with <code class="literal">Accept</code> header set to
                <code class="literal">application/javascript</code> you'll get a result entity that look like:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">callback({
    "value" : "jsonp",
})</pre><p>
            </p><p>
                There are, of course, ways to configure wrapping method of the returned entity which defaults to
                <code class="literal">callback</code> as you can see in the previous example.
                <code class="literal">@JSONP</code> has two parameters that can be configured: <code class="literal">callback</code> and
                <code class="literal">queryParam</code>.
                <code class="literal">callback</code> stands for the name of the JavaScript callback function defined by the application.
                The second parameter, <code class="literal">queryParam</code>, defines the name of the query parameter holding the name of
                the callback function to be used (if present in the request). Value of <code class="literal">queryParam</code> defaults to
                <code class="literal">__callback</code> so even if you do not set the name of the query parameter yourself, client can
                always affect the result name of the wrapping JavaScript callback method.

                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        <code class="literal">queryParam</code> value (if set) always takes precedence over <code class="literal">callback</code>
                        value.
                    </p></div><p>
            </p><p>
                Lets modify our example a little bit:

                </p><div class="example"><a name="d0e8475"></a><p class="title"><b>Example&nbsp;9.30.&nbsp;Example of <code class="literal">@JSONP</code> with configured parameters.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces({"application/json", "application/javascript"})
@JSONP(callback = "eval", queryParam = "jsonpCallback")
public JaxbBean getSimpleJSONP() {
    return new JaxbBean("jsonp");
}</pre></div></div><p><br class="example-break">

                And make two requests:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">curl -X GET http://localhost:8080/jsonp</pre><p>

                will return

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">eval({
    "value" : "jsonp",
})</pre><p>

                and the

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">curl -X GET http://localhost:8080/jsonp?jsonpCallback=alert</pre><p>

                will return

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">alert({
    "value" : "jsonp",
})</pre><p>
            </p><p><b>Example.&nbsp;</b>
                    You can take a look at a provided
                    <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-with-padding" target="_top">JSON with Padding example</a>.
                </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json.json-b"></a>9.1.7.&nbsp;Java API for JSON Binding (JSON-B)</h3></div></div></div><p>
                Jersey uses <a class="link" href="https://eclipse-ee4j.github.io/yasson/" target="_top">Yasson</a> for JSON Binding (JSR-367) implementation.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8512"></a>9.1.7.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use JSON-B as your JSON provider you need to add <code class="literal">jersey-media-json-binding</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies
                    (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-binding/dependencies.html" target="_top">jersey-media-json-binding</a>) on the classpath.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="json.jsonb-registration"></a>9.1.7.2.&nbsp;Configure and register</h4></div></div></div><p>
                    As stated in <a class="xref" href="#deployment.autodiscoverable" title="4.3.&nbsp;Auto-Discoverable Features">Section&nbsp;4.3, &#8220;Auto-Discoverable Features&#8221;</a> JSON-Binding media module is one of the
                    modules where you don't need to explicitly register its
                    <code class="literal">Feature</code>s (<code class="literal">JsonBindingFeature</code>) in your client/server
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> as this feature is automatically discovered and registered when you add
                    <code class="literal">jersey-media-json-binding</code> module to your classpath.
                </p><p>
                    To use custom preconfigured JSON-B, it is simply possible to register
                    a <code class="literal">ContextResolver&lt;T&gt;</code> for <code class="literal">Jsonb</code> in your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a>
                    (client/server) and configure <a class="link" href="https://javaee.github.io/javaee-spec/javadocs/javax/json/bind/JsonbConfig" target="_top">JsonbConfig</a>.
                </p><div class="example"><a name="d0e8562"></a><p class="title"><b>Example&nbsp;9.31.&nbsp;<code class="literal">ContextResolver&lt;Jsonb&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class JsonbContextResolver implements ContextResolver&lt;Jsonb&gt; {

        @Override
        public Jsonb getContext(Class&gt;?&lt; type) {
            JsonbConfig config = new JsonbConfig();
            // configure JsonbConfig
            ...
            return JsonbBuilder.create(config);
        }
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e8568"></a><p class="title"><b>Example&nbsp;9.32.&nbsp;<code class="literal">Register the feature and ContextResolver&lt;Jsonb&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientBuilder.newClient(new ClientConfig()
    // The line below that registers JSON-Binding feature can be
    // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is not disabled.
    .register(JsonBindingFeature.class)
    .register(JsonbContextResolver.class)
);</pre></div></div><br class="example-break"><p><b>Example.&nbsp;</b>
                        You can take a look at a provided
                        <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-binding-webapp" target="_top">JSON-B example.</a>.
                    </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml"></a>9.2.&nbsp;XML</h2></div></div></div><p>
            As you probably already know, Jersey uses <code class="literal">MessageBodyWriter&lt;T&gt;</code>s and <code class="literal">MessageBodyReader&lt;T&gt;</code>s to
            parse incoming requests and create outgoing responses. Every user can create its own representation but... this is not
            recommended way how to do things. XML is proven standard for interchanging information, especially in web services.
            Jerseys supports low level data types used for direct manipulation and JAXB XML entities.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8593"></a>9.2.1.&nbsp;Low level XML support</h3></div></div></div><p>
                Jersey currently support several low level data types: <a class="link" href="http://docs.oracle.com/javase/7/docs/api/javax/xml/transform/stream/StreamSource.html" target="_top">StreamSource</a>, <a class="link" href="http://docs.oracle.com/javase/7/docs/api/javax/xml/transform/sax/SAXSource.html" target="_top">SAXSource</a>, <a class="link" href="http://docs.oracle.com/javase/7/docs/api/javax/xml/transform/dom/DOMSource.html" target="_top">DOMSource</a>
                and <a class="link" href="http://docs.oracle.com/javase/7/docs/api/org/w3c/dom/Document.html" target="_top">Document</a>. You can use these types as the return type or as a method (resource) parameter.
                Lets say we want to test this feature and we have
                <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/helloworld" target="_top">helloworld example</a> as a starting point.
                All we need to do is add methods (resources) which consumes and produces XML and types mentioned above will be
                used.
            </p><div class="example"><a name="d0e8613"></a><p class="title"><b>Example&nbsp;9.33.&nbsp;Low level XML test - methods added to <code class="literal">HelloWorldResource.java</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Path("StreamSource")
public StreamSource getStreamSource(StreamSource streamSource) {
    return streamSource;
}

@POST
@Path("SAXSource")
public SAXSource getSAXSource(SAXSource saxSource) {
    return saxSource;
}

@POST
@Path("DOMSource")
public DOMSource getDOMSource(DOMSource domSource) {
    return domSource;
}

@POST
@Path("Document")
public Document getDocument(Document document) {
    return document;
}</pre></div></div><br class="example-break"><p>
                Both <code class="literal">MessageBodyWriter&lt;T&gt;</code> and <code class="literal">MessageBodyReader&lt;T&gt;</code> are used in this case, all we need is
                a <code class="literal">POST</code> request with some XML document as a request entity. To keep this as simple as possible only root
                element with no content will be sent: <code class="literal">"&lt;test /&gt;"</code>. You can create JAX-RS client to do that
                or use some other tool, for example <code class="literal">curl</code>:
                </p><div class="informalexample"><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">curl -v http://localhost:8080/base/helloworld/StreamSource -d "&lt;test/&gt;"</pre></div><p>
                You should get exactly the same XML from our service as is present in the request; in this case, XML headers are
                added to response but content stays. Feel free to iterate through all resources.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8641"></a>9.2.2.&nbsp;Getting started with JAXB</h3></div></div></div><p>
                Good start for people which already have some experience with JAXB annotations
                is <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/jaxb" target="_top">JAXB example</a>. You can see various use-cases there.
                This text is mainly meant for those who don't have prior experience with JAXB. Don't expect that all possible
                annotations and their combinations will be covered in this chapter,
                <a class="link" href="http://jaxb.java.net" target="_top">JAXB (JSR 222 implementation)</a>
                is pretty complex and comprehensive. But if you just want to know how you can interchange XML messages with your
                REST service, you are looking at the right chapter.
            </p><p>
                Lets start with simple example. Lets say we have class <code class="literal">Planet</code> and service which produces
                "Planets".
            </p><div class="example"><a name="d0e8657"></a><p class="title"><b>Example&nbsp;9.34.&nbsp;Planet class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class Planet {
    public int id;
    public String name;
    public double radius;
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e8662"></a><p class="title"><b>Example&nbsp;9.35.&nbsp;Resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("planet")
public class Resource {

    @GET
    @Produces(MediaType.APPLICATION_XML)
    public Planet getPlanet() {
        final Planet planet = new Planet();

        planet.id = 1;
        planet.name = "Earth";
        planet.radius = 1.0;

        return planet;
    }
}</pre></div></div><br class="example-break"><p>
                You can see there is some extra annotation declared on <code class="literal">Planet</code> class, particularly
                <a class="link" href="https://eclipse-ee4j.github.io/jaxb-ri/docs/api/jakarta.xml.bind/annotation/XmlRootElement.html" target="_top">@XmlRootElement</a>. This is an JAXB annotation which maps java classes
                to XML elements. We don't need to specify anything else, because <code class="literal">Planet</code> is very simple class
                and all fields are public. In this case, XML element name will be derived from the class name or
                you can set the name property: <code class="literal">@XmlRootElement(name="yourName")</code>.
            </p><p>
                Our resource class will respond to <code class="literal">GET /planet</code> with

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;planet&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;name&gt;Earth&lt;/name&gt;
    &lt;radius&gt;1.0&lt;/radius&gt;
&lt;/planet&gt;</pre><p>

                which might be exactly what we want... or not. Or we might not really care, because we
                can use JAX-RS client for making requests to this resource and this is easy as:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">
                    Planet planet = webTarget.path("planet").request(MediaType.APPLICATION_XML_TYPE).get(Planet.class);
                </pre><p>
                There is pre-created <code class="literal">WebTarget</code> object which points to our applications context root and
                we simply add path (in our case its <code class="literal">planet</code>), accept header (not mandatory, but service could
                provide different content based on this header; for example <code class="literal">text/html</code> can be served for web
                browsers) and at the end we specify that we are expecting <code class="literal">Planet</code> class via <code class="literal">GET</code>
                request.
            </p><p>
                There may be need for not just producing XML, we might want to consume it as well.

                </p><div class="example"><a name="d0e8709"></a><p class="title"><b>Example&nbsp;9.36.&nbsp;Method for consuming Planet</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes(MediaType.APPLICATION_XML)
public void setPlanet(Planet planet) {
    System.out.println("setPlanet " + planet);
}</pre></div></div><p><br class="example-break">

                After valid request is made, service will print out string representation of <code class="literal">Planet</code>, which can
                look like <code class="literal">Planet{id=2, name='Mars', radius=1.51}</code>. With JAX-RS client you can do:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">
                    webTarget.path("planet").request().post(Entity.xml(planet));
                </pre><p>
            </p><p>
                If there is a need for some other (non default) XML representation, other JAXB annotations would
                need to be used. This process is usually simplified by generating java source from XML Schema which is
                done by <code class="literal">xjc</code> which is XML to java compiler and it is part of JAXB.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8729"></a>9.2.3.&nbsp;POJOs</h3></div></div></div><p>
                Sometimes you can't / don't want to add JAXB annotations to source code and you still want to have resources
                consuming and producing XML representation of your classes. In this case, <a class="link" href="https://eclipse-ee4j.github.io/jaxb-ri/docs/api/jakarta.xml.bind/JAXBElement.html" target="_top">JAXBElement</a> class should help
                you. Let's redo planet resource but this time we won't have an <a class="link" href="https://eclipse-ee4j.github.io/jaxb-ri/docs/api/jakarta.xml.bind/annotation/XmlRootElement.html" target="_top">@XmlRootElement</a> annotation on
                <code class="literal">Planet</code> class.
            </p><div class="example"><a name="d0e8743"></a><p class="title"><b>Example&nbsp;9.37.&nbsp;Resource class - JAXBElement</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("planet")
public class Resource {

    @GET
    @Produces(MediaType.APPLICATION_XML)
    public JAXBElement&lt;Planet&gt; getPlanet() {
        Planet planet = new Planet();

        planet.id = 1;
        planet.name = "Earth";
        planet.radius = 1.0;

        return new JAXBElement&lt;Planet&gt;(new QName("planet"), Planet.class, planet);
    }

    @POST
    @Consumes(MediaType.APPLICATION_XML)
    public void setPlanet(JAXBElement&lt;Planet&gt; planet) {
        System.out.println("setPlanet " + planet.getValue());
    }
}</pre></div></div><br class="example-break"><p>
                As you can see, everything is little more complicated with <code class="literal">JAXBElement</code>. This is because now you need
                to explicitly set element name for <code class="literal">Planet</code> class XML representation. Client side is even more
                complicated than server side because you can't do <code class="literal">JAXBElement&lt;Planet&gt;</code> so JAX-RS client
                API provides way how to workaround it by declaring subclass of <code class="literal">GenericType&lt;T&gt;</code>.
            </p><div class="example"><a name="d0e8762"></a><p class="title"><b>Example&nbsp;9.38.&nbsp;Client side - JAXBElement</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// GET
GenericType&lt;JAXBElement&lt;Planet&gt;&gt; planetType = new GenericType&lt;JAXBElement&lt;Planet&gt;&gt;() {};

Planet planet = (Planet) webTarget.path("planet").request(MediaType.APPLICATION_XML_TYPE).get(planetType).getValue();
System.out.println("### " + planet);

// POST
planet = new Planet();

// ...

webTarget.path("planet").post(new JAXBElement&lt;Planet&gt;(new QName("planet"), Planet.class, planet));</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8767"></a>9.2.4.&nbsp;Using custom JAXBContext</h3></div></div></div><p>In some scenarios you can take advantage of using custom <a class="link" href="https://eclipse-ee4j.github.io/jaxb-ri/docs/api/jakarta.xml.bind/JAXBContext.html" target="_top">JAXBContext</a>. Creating
                <code class="literal">JAXBContext</code> is an expensive operation and if you already have one created, same instance
                can be used by Jersey. Other possible use-case for this is when you need to set some specific things
                to <code class="literal">JAXBContext</code>, for example to set a different class loader.
            </p><div class="example"><a name="d0e8781"></a><p class="title"><b>Example&nbsp;9.39.&nbsp;PlanetJAXBContextProvider</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class PlanetJAXBContextProvider implements ContextResolver&lt;JAXBContext&gt; {
    private JAXBContext context = null;

    public JAXBContext getContext(Class&lt;?&gt; type) {
        if (type != Planet.class) {
            return null; // we don't support nothing else than Planet
        }

        if (context == null) {
            try {
                context = JAXBContext.newInstance(Planet.class);
            } catch (JAXBException e) {
                // log warning/error; null will be returned which indicates that this
                // provider won't/can't be used.
            }
        }

        return context;
    }
}</pre></div></div><br class="example-break"><p>
                Sample above shows simple <code class="literal">JAXBContext</code> creation, all you need to do is put
                this <code class="literal">@Provider</code> annotated class somewhere where Jersey can find it. Users sometimes
                have problems with using provider classes on client side, so just to reminder - you have to
                register them in the client config (client does not do anything like package scanning done by server).
            </p><div class="example"><a name="d0e8794"></a><p class="title"><b>Example&nbsp;9.40.&nbsp;Using Provider with JAX-RS client</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
ClientConfig config = new ClientConfig();
config.register(PlanetJAXBContextProvider.class);

Client client = ClientBuilder.newClient(config);
                </pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8799"></a>9.2.5.&nbsp;MOXy</h3></div></div></div><p>
                If you want to use <a class="link" href="http://www.eclipse.org/eclipselink/moxy.php" target="_top">MOXy</a> as your JAXB
                implementation instead of JAXB RI you have two options. You can either use the standard JAXB mechanisms to define
                the <code class="literal">JAXBContextFactory</code> from which a <code class="literal">JAXBContext</code> instance would be obtained (for more
                on this topic, read JavaDoc on <a class="link" href="https://eclipse-ee4j.github.io/jaxb-ri/docs/api/jakarta.xml.bind/JAXBContext.html" target="_top">JAXBContext</a>) or you can add <code class="literal">jersey-media-moxy</code> module to
                your project and register/configure
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/xml/MoxyXmlFeature.html" target="_top">MoxyXmlFeature</a> class/instance in
                the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a>.
            </p><div class="example"><a name="d0e8825"></a><p class="title"><b>Example&nbsp;9.41.&nbsp;Add <code class="literal">jersey-media-moxy</code> dependency.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-moxy&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><br class="example-break"><div class="example"><a name="d0e8833"></a><p class="title"><b>Example&nbsp;9.42.&nbsp;Register the <code class="literal">MoxyXmlFeature</code> class.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final ResourceConfig config = new ResourceConfig()
    .packages("org.glassfish.jersey.examples.xmlmoxy")
    .register(MoxyXmlFeature.class);</pre></div></div><br class="example-break"><div class="example"><a name="d0e8841"></a><p class="title"><b>Example&nbsp;9.43.&nbsp;Configure and register an <code class="literal">MoxyXmlFeature</code> instance.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Configure Properties.
final Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
// ...

// Obtain a ClassLoader you want to use.
final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

final ResourceConfig config = new ResourceConfig()
    .packages("org.glassfish.jersey.examples.xmlmoxy")
    .register(new MoxyXmlFeature(
        properties,
        classLoader,
        true, // Flag to determine whether eclipselink-oxm.xml file should be used for lookup.
        CustomClassA.class, CustomClassB.class  // Classes to be bound.
    ));</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="multipart"></a>9.3.&nbsp;Multipart</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8854"></a>9.3.1.&nbsp;Overview</h3></div></div></div><p>
                The classes in this module provide an integration of <code class="literal">multipart/*</code> request and response bodies
                in a JAX-RS runtime environment. The set of registered providers is leveraged, in that the content type for a body
                part of such a message reuses the same <code class="literal">MessageBodyReader&lt;T&gt;</code>/<code class="literal">MessageBodyWriter&lt;T&gt;</code>
                implementations as would be used for that content type as a standalone entity.
            </p><p>
                The following list of general MIME MultiPart features is currently supported:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The <code class="literal">MIME-Version: 1.0</code> HTTP header is included on generated responses.
                            It is accepted, but not required, on processed requests.
                        </p></li><li class="listitem"><p>
                            A <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> implementation for consuming MIME MultiPart entities.
                        </p></li><li class="listitem"><p>
                            A <code class="literal">MessageBodyWriter&lt;T&gt;</code> implementation for producing MIME MultiPart entities.
                            The appropriate <code class="literal">@Provider</code> is used to serialize each body part, based on its media type.
                        </p></li><li class="listitem"><p>
                            Optional creation of an appropriate <code class="literal">boundary</code> parameter on a generated
                            <code class="literal">Content-Type</code> header, if not already present.
                        </p></li></ul></div><p>
            </p><p>
                For more information refer to <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/package-summary.html" target="_top">Multi Part</a>.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8907"></a>9.3.1.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use multipart features you need to add <code class="literal">jersey-media-multipart</code> module to your <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-multipart&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-multipart/dependencies.html" target="_top">jersey-media-multipart</a>) on the
                    class-path.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8924"></a>9.3.1.2.&nbsp;Registration</h4></div></div></div><p>
                    Before you can use capabilities of the <code class="literal">jersey-media-multipart</code> module in your client/server code, you
                    need to register <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/MultiPartFeature.html" target="_top">MultiPartFeature</a>.

                    </p><div class="example"><a name="d0e8935"></a><p class="title"><b>Example&nbsp;9.44.&nbsp;Building client with MultiPart feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
    .register(MultiPartFeature.class)
    .build();</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8941"></a><p class="title"><b>Example&nbsp;9.45.&nbsp;Creating JAX-RS application with MultiPart feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
    .packages("org.glassfish.jersey.examples.multipart")
    .register(MultiPartFeature.class)</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8947"></a>9.3.1.3.&nbsp;Examples</h4></div></div></div><p>Jersey provides a
                    <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/multipart-webapp" target="_top">Multipart Web Application Example</a>
                    on how to use multipart features.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8955"></a>9.3.2.&nbsp;Client</h3></div></div></div><p>
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/MultiPart.html" target="_top">MultiPart</a> class (or it's subclasses) can be used as an entry point to use
                <code class="literal">jersey-media-multipart</code> module on the client side. This class represents a
                <a class="link" href="http://en.wikipedia.org/wiki/MIME#Multipart_messages" target="_top">MIME multipart message</a> and is able
                to hold an arbitrary number of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/BodyPart.html" target="_top">BodyPart</a>s. Default media type is
                <a class="link" href="http://en.wikipedia.org/wiki/MIME#Mixed" target="_top">multipart/mixed</a>
                for <code class="literal">MultiPart</code> entity and <code class="literal">text/plain</code> for
                <code class="literal">BodyPart</code>.

                </p><div class="example"><a name="d0e8984"></a><p class="title"><b>Example&nbsp;9.46.&nbsp;<code class="literal">MultiPart</code> entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final MultiPart multiPartEntity = new MultiPart()
        .bodyPart(new BodyPart().entity("hello"))
        .bodyPart(new BodyPart(new JaxbBean("xml"), MediaType.APPLICATION_XML_TYPE))
        .bodyPart(new BodyPart(new JaxbBean("json"), MediaType.APPLICATION_JSON_TYPE));

final WebTarget target = // Create WebTarget.
final Response response = target
        .request()
        .post(Entity.entity(multiPartEntity, multiPartEntity.getMediaType()));</pre></div></div><p><br class="example-break">

                If you send a <code class="literal">multiPartEntity</code> to the server the entity with <code class="literal">Content-Type</code>
                header in HTTP message would look like (don't forget to register a JSON provider):

                </p><div class="example"><a name="d0e8998"></a><p class="title"><b>Example&nbsp;9.47.&nbsp;<code class="literal">MultiPart</code> entity in HTTP message.</b></p><div class="example-contents"><pre class="screen"><span class="emphasis"><em>Content-Type: multipart/mixed; boundary=Boundary_1_829077776_1369128119878</em></span>

--Boundary_1_829077776_1369128119878
Content-Type: text/plain

hello
--Boundary_1_829077776_1369128119878
Content-Type: application/xml

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;jaxbBean&gt;&lt;value&gt;xml&lt;/value&gt;&lt;/jaxbBean&gt;
--Boundary_1_829077776_1369128119878
Content-Type: application/json

{"value":"json"}
--Boundary_1_829077776_1369128119878--</pre></div></div><p><br class="example-break">
            </p><p>
                When working with forms (e.g. media type <code class="literal">multipart/form-data</code>) and various fields in them,
                there is a more convenient class to be used - <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/FormDataMultiPart.html" target="_top">FormDataMultiPart</a>. It automatically sets
                the media type for the <code class="literal">FormDataMultiPart</code> entity to
                <code class="literal">multipart/form-data</code> and <code class="literal">Content-Disposition</code> header to
                <code class="literal">FormDataBodyPart</code> body parts.

                </p><div class="example"><a name="d0e9028"></a><p class="title"><b>Example&nbsp;9.48.&nbsp;<code class="literal">FormDataMultiPart</code> entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final FormDataMultiPart multipart = new FormDataMultiPart()
    .field("hello", "hello")
    .field("xml", new JaxbBean("xml"))
    .field("json", new JaxbBean("json"), MediaType.APPLICATION_JSON_TYPE);

final WebTarget target = // Create WebTarget.
final Response response = target.request().post(Entity.entity(multipart, multipart.getMediaType()));</pre></div></div><p><br class="example-break">

                To illustrate the difference when using <code class="literal">FormDataMultiPart</code> instead of
                <code class="literal">FormDataBodyPart</code> you can take a look at the
                <code class="literal">FormDataMultiPart</code> entity from HTML message:

                </p><div class="example"><a name="d0e9045"></a><p class="title"><b>Example&nbsp;9.49.&nbsp;<code class="literal">FormDataMultiPart</code> entity in HTTP message.</b></p><div class="example-contents"><pre class="screen"><span class="emphasis"><em>Content-Type: multipart/form-data; boundary=Boundary_1_511262261_1369143433608</em></span>

--Boundary_1_511262261_1369143433608
Content-Type: text/plain
Content-Disposition: form-data; name="hello"

hello
--Boundary_1_511262261_1369143433608
Content-Type: application/xml
Content-Disposition: form-data; name="xml"

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;jaxbBean&gt;&lt;value&gt;xml&lt;/value&gt;&lt;/jaxbBean&gt;
--Boundary_1_511262261_1369143433608
Content-Type: application/json
Content-Disposition: form-data; name="json"

{"value":"json"}
--Boundary_1_511262261_1369143433608--</pre></div></div><p><br class="example-break">
            </p><p>
                A common use-case for many users is sending files from client to server. For this purpose you can use classes from
                <code class="literal">org.glassfish.jersey.jersey.media.multipart</code> package, such as
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/file/FileDataBodyPart.html" target="_top">FileDataBodyPart</a> or <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/file/StreamDataBodyPart.html" target="_top">StreamDataBodyPart</a>.

                </p><div class="example"><a name="d0e9066"></a><p class="title"><b>Example&nbsp;9.50.&nbsp;Multipart - sending files.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// MediaType of the body part will be derived from the file.
final FileDataBodyPart filePart = new FileDataBodyPart("my_pom", new File("pom.xml"));

final FormDataMultiPart multipart = new FormDataMultiPart()
    .field("foo", "bar")
    .bodyPart(filePart);

final WebTarget target = // Create WebTarget.
final Response response = target.request()
    .post(Entity.entity(multipart, multipart.getMediaType()));</pre></div></div><p><br class="example-break">
            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
                    Do not use <code class="literal">ApacheConnectorProvider</code> nor <code class="literal">GrizzlyConnectorProvider</code>
                    neither <code class="literal">JettyConnectorProvider</code> connector implementations with Jersey Multipart
                    features. See <a class="xref" href="#connectors.warning" title="Warning">Header modification issue</a> warning for more details.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9086"></a>9.3.3.&nbsp;Server</h3></div></div></div><p>
                Returning a multipart response from server to client is not much different from the parts described in the client
                section above. To obtain a multipart entity, sent by a client, in the application you can use two approaches:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Injecting the whole <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/MultiPart.html" target="_top">MultiPart</a> entity.</p></li><li class="listitem"><p>
                            Injecting particular parts of a <code class="literal">form-data</code> multipart request via
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/FormDataParam.html" target="_top">@FormDataParam</a> annotation.
                        </p></li></ul></div><p>
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9108"></a>9.3.3.1.&nbsp;Injecting and returning the <code class="literal">MultiPart</code> entity</h4></div></div></div><p>
                    Working with <code class="literal">MultiPart</code> types is no different from injecting/returning other
                    entity types.
                    Jersey provides <code class="literal">MessageBodyReader&lt;T&gt;</code> for reading the request entity and injecting this entity
                    into a method parameter of a resource method and <code class="literal">MessageBodyWriter&lt;T&gt;</code> for writing output entities.
                    You can expect that either <code class="literal">MultiPart</code> or
                    <code class="literal">FormDataMultiPart</code> (<code class="literal">multipart/form-data</code> media type) object
                    to be injected into a resource method.
                </p><div class="example"><a name="d0e9134"></a><p class="title"><b>Example&nbsp;9.51.&nbsp;Resource method using <code class="literal">MultiPart</code> as input parameter / return value.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Produces("multipart/mixed")
public MultiPart post(final FormDataMultiPart multiPart) {
    return multiPart;
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9142"></a>9.3.3.2.&nbsp;Injecting with <code class="literal">@FormDataParam</code></h4></div></div></div><p>
                    If you just need to bind the named body part(s) of a <code class="literal">multipart/form-data</code> request
                    entity body to a resource method parameter you can use <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/FormDataParam.html" target="_top">@FormDataParam</a> annotation.
                </p><p>
                    This annotation in conjunction with the media type <code class="literal">multipart/form-data</code> should be used for
                    submitting and consuming forms that contain files, non-ASCII data, and binary data.
                </p><p>
                    The type of the annotated parameter can be one of the following (for more detailed description see
                    javadoc to <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/FormDataParam.html" target="_top">@FormDataParam</a>):

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <code class="literal">FormDataBodyPart</code> - The value of the parameter will be the first
                                named body part or <code class="literal">null</code> if such a named body part is not present.
                            </p></li><li class="listitem"><p>
                                A <code class="literal">List</code> or <code class="literal">Collection</code> of
                                <code class="literal">FormDataBodyPart</code>.
                                The value of the parameter will be one or more named body parts with the same name or
                                <code class="literal">null</code> if such a named body part is not present.
                            </p></li><li class="listitem"><p>
                                <code class="literal">FormDataContentDisposition</code> - The value of the parameter will be the
                                content disposition of the first named body part part or <code class="literal">null</code> if such a named body part
                                is not present.
                            </p></li><li class="listitem"><p>
                                A <code class="literal">List</code> or <code class="literal">Collection</code> of
                                <code class="literal">FormDataContentDisposition</code>.
                                The value of the parameter will be one or more content dispositions of the named body parts with the
                                same name or <code class="literal">null</code> if such a named body part is not present.
                            </p></li><li class="listitem"><p>
                                A type for which a message body reader is available given the media type of the first named body
                                part. The value of the parameter will be the result of reading using the message body reader given
                                the type <code class="literal">T</code>, the media type of the named part, and the bytes of the named body
                                part as input.
                            </p><p>
                                If there is no named part present and there is a default value present as declared by
                                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/DefaultValue.html" target="_top">@DefaultValue</a> then the media type will be set to <code class="literal">text/plain</code>.
                                The value of the parameter will be the result of reading using the message body reader given the
                                type <code class="literal">T</code>, the media type <code class="literal">text/plain</code>, and the UTF-8 encoded
                                bytes of the default value as input.
                            </p><p>
                                If there is no message body reader available and the type <code class="literal">T</code> conforms
                                to a type specified by <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/FormParam.html" target="_top">@FormParam</a> then processing is performed as specified by
                                <code class="literal">@FormParam</code>, where the values of the form parameter are <code class="literal">String</code>
                                instances produced by reading the bytes of the named body parts utilizing a message body reader
                                for the <code class="literal">String</code> type and the media type <code class="literal">text/plain</code>.
                            </p><p>
                                If there is no named part present then processing is performed as specified by
                                <code class="literal">@FormParam</code>.
                            </p></li></ul></div><p>
                </p><div class="example"><a name="d0e9260"></a><p class="title"><b>Example&nbsp;9.52.&nbsp;Use of <code class="literal">@FormDataParam</code> annotation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes(MediaType.MULTIPART_FORM_DATA)
public String postForm(
    @DefaultValue("true") @FormDataParam("enabled") boolean enabled,
    @FormDataParam("data") FileData bean,
    @FormDataParam("file") InputStream file,
    @FormDataParam("file") FormDataContentDisposition fileDisposition) {

    // ...
}</pre></div></div><br class="example-break"><p>
                    In the example above the server consumes a <code class="literal">multipart/form-data</code> request entity body that
                    contains one optional named body part <code class="literal">enabled</code> and two required named body parts
                    <code class="literal">data</code> and <code class="literal">file</code>.
                </p><p>
                    The optional part <code class="literal">enabled</code> is processed
                    as a <code class="literal">boolean</code> value, if the part is absent then the value will be <code class="literal">true</code>.
                </p><p>
                    The part <code class="literal">data</code> is processed as a JAXB bean and contains some meta-data about the following
                    part.
                </p><p>
                    The part <code class="literal">file</code> is a file that is uploaded, this is processed as an
                    <code class="literal">InputStream</code>. Additional information about the file from the
                    <code class="literal">Content-Disposition</code> header can be accessed by the parameter
                    <code class="literal">fileDisposition</code>.
                </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p><code class="literal">@FormDataParam</code> annotation can be also used on fields.</p></div></div></div></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="filters-and-interceptors"></a>Chapter&nbsp;10.&nbsp;Filters and Interceptors</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e9321">10.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e9326">10.2. Filters</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9355">10.2.1. Server filters</a></span></dt><dt><span class="section"><a href="#d0e9460">10.2.2. Client filters</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e9495">10.3. Interceptors</a></span></dt><dt><span class="section"><a href="#d0e9604">10.4. Filter and interceptor execution order</a></span></dt><dt><span class="section"><a href="#d0e9665">10.5. Name binding</a></span></dt><dt><span class="section"><a href="#d0e9738">10.6. Dynamic binding</a></span></dt><dt><span class="section"><a href="#d0e9806">10.7. Priorities</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9321"></a>10.1.&nbsp;Introduction</h2></div></div></div><p>This chapter describes filters, interceptors and their configuration. Filters and interceptors
            can be used on both sides, on the client and the server side. Filters can modify inbound and outbound requests
            and responses including modification of headers, entity and other request/response parameters. Interceptors
            are used primarily for modification of entity input and output streams. You can use interceptors for example
            to zip and unzip output and input entity streams.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9326"></a>10.2.&nbsp;Filters</h2></div></div></div><p>
            Filters can be used when you want to modify any request or response parameters like headers. For example
            you would like to add a response header "X-Powered-By" to each generated response. Instead of adding this header
            in each resource method you would use a response filter to add this header.
        </p><p>
            There are filters on the server side and the client side.
        </p><p>
            Server filters:
            </p><table border="0" summary="Simple list" class="simplelist"><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerRequestFilter.html" target="_top">ContainerRequestFilter</a>
                </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerResponseFilter.html" target="_top">ContainerResponseFilter</a>
                </td></tr></table><p>
            Client filters:
            </p><table border="0" summary="Simple list" class="simplelist"><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientRequestFilter.html" target="_top">ClientRequestFilter</a>
                </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientResponseFilter.html" target="_top">ClientResponseFilter</a>
                </td></tr></table><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9355"></a>10.2.1.&nbsp;Server filters</h3></div></div></div>
            The following example shows a simple container response filter adding a header to each response.

            <p>
                </p><div class="example"><a name="d0e9361"></a><p class="title"><b>Example&nbsp;10.1.&nbsp;Container response filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import java.io.IOException;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerResponseContext;
import jakarta.ws.rs.container.ContainerResponseFilter;
import jakarta.ws.rs.core.Response;

public class PoweredByResponseFilter implements ContainerResponseFilter {

    @Override
    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext)
        throws IOException {

            responseContext.getHeaders().add("X-Powered-By", "Jersey :-)");
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                In the example above the <code class="literal">PoweredByResponseFilter</code>
                always adds a header "X-Powered-By" to the
                response. The filter must inherit from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerResponseFilter.html" target="_top">ContainerResponseFilter</a> and must be registered
                as a provider. The filter will be executed for every response which is in most cases after the resource method
                is executed. Response filters are executed even if the resource method is not run, for example when
                the resource method is not found and 404 "Not found" response code is returned by the Jersey runtime. In this case
                the filter will be executed and will process the 404 response.
            </p><p>
                The <code class="literal">filter()</code> method has two arguments, the container request and container response. The
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerRequestContext.html" target="_top">ContainerRequestContext</a> is accessible only for read only purposes as the filter is executed already
                in response phase. The modifications can be done in the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerResponseContext.html" target="_top">ContainerResponseContext</a>.
            </p><p>
                The following example shows the usage of a request filter.
            </p><div class="example"><a name="d0e9388"></a><p class="title"><b>Example&nbsp;10.2.&nbsp;Container request filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import java.io.IOException;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;

public class AuthorizationRequestFilter implements ContainerRequestFilter {

    @Override
    public void filter(ContainerRequestContext requestContext)
                    throws IOException {

        final SecurityContext securityContext =
                    requestContext.getSecurityContext();
        if (securityContext == null ||
                    !securityContext.isUserInRole("privileged")) {

                requestContext.abortWith(Response
                    .status(Response.Status.UNAUTHORIZED)
                    .entity("User cannot access the resource.")
                    .build());
        }
    }
}</pre></div></div><br class="example-break"><p>
                The request filter is similar to the response filter but does not have access to the ContainerResponseContext
                as no response is accessible yet. Response filter inherits from <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerResponseFilter.html" target="_top">ContainerResponseFilter</a>.
                Request filter is executed before the resource method is run and before the
                response is created. The filter has possibility to manipulate the request parameters including request
                headers or entity.
            </p><p>
                The <code class="literal">AuthorizationRequestFilter</code> in the example checks whether the
                authenticated user is in the privileged role. If it is not then the request is <span class="emphasis"><em>aborted</em></span>
                by calling <code class="literal">ContainerRequestContext.abortWith(Response response)</code> method. The method
                is intended to be called from the request filter in situation when the request should not be processed further in the standard processing chain.
                When the <code class="literal">filter</code> method is finished the response passed as a parameter to the
                <code class="literal">abortWith</code> method is used to respond to the request. Response filters, if any are registered,
                will be executed and will have possibility to process the aborted response.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9415"></a>10.2.1.1.&nbsp;Pre-matching and post-matching filters</h4></div></div></div></div><p>
                All the request filters shown above was implemented as post-matching filters. It means that the filters
                would be applied only after a suitable resource method has been selected to process the actual request
                i.e. after request matching happens. Request matching is the process of finding a resource method that
                should be executed based on the request path and other request parameters. Since post-matching request
                filters are invoked when a particular resource method has already been selected, such filters can not
                influence the resource method matching process.
            </p><p>
                To overcome the above described limitation, there is a possibility to mark
                a server request filter as a <span class="emphasis"><em>pre-matching</em></span> filter,
                i.e. to annotate the filter class with the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/PreMatching.html" target="_top">@PreMatching</a> annotation.
                Pre-matching filters are request filters that are executed before
                the request matching is started. Thanks to this, pre-matching request filters have
                the possibility to influence which method will be matched. Such a pre-matching request filter example is shown
                here:
            </p><p>
                </p><div class="example"><a name="d0e9430"></a><p class="title"><b>Example&nbsp;10.3.&nbsp;Pre-matching request filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.container.PreMatching;
...

@PreMatching
public class PreMatchingFilter implements ContainerRequestFilter {

    @Override
    public void filter(ContainerRequestContext requestContext)
                        throws IOException {
        // change all PUT methods to POST
        if (requestContext.getMethod().equals("PUT")) {
            requestContext.setMethod("POST");
        }
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                The <code class="literal">PreMatchingFilter</code> is a simple pre-matching filter which changes all PUT HTTP
                methods to POST. This might be useful when you want to always handle these PUT and POST HTTP methods
                with the same Java code. After the <code class="literal">PreMatchingFilter</code> has been invoked, the rest
                of the request processing will behave as if the POST HTTP method was originally used.
                You cannot do this in post-matching filters
                (standard filters without <code class="literal">@PreMatching</code> annotation)
                as the resource method is already matched (selected). An attempt to tweak the original HTTP method in
                a post-matching filter would cause an <code class="literal">IllegalArgumentException</code>.
            </p><p>
                As written above, pre-matching filters can fully influence the request matching process, which means
                you can even modify request URI in a pre-matching filter by invoking
                the <code class="literal">setRequestUri(URI)</code> method of <code class="literal">ContainerRequestFilter</code>
                so that a different resource would be matched.
            </p><p>
                Like in post-matching filters you can abort a response in pre-matching filters too.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9460"></a>10.2.2.&nbsp;Client filters</h3></div></div></div><p>
                Client filters are similar to container filters. The response can also be aborted
                in the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientRequestFilter.html" target="_top">ClientRequestFilter</a> which would cause that no request will actually be sent to the server at all.
                A new response is passed to the <code class="literal">abort</code> method. This response will be used and delivered
                as a result of the request invocation. Such a response goes through the client response filters.
                This is similar to what happens on the server side. The process is shown in the following example:
            </p><p>
                </p><div class="example"><a name="d0e9473"></a><p class="title"><b>Example&nbsp;10.4.&nbsp;Client request filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class CheckRequestFilter implements ClientRequestFilter {

    @Override
    public void filter(ClientRequestContext requestContext)
                        throws IOException {
        if (requestContext.getHeaders(
                        ).get("Client-Name") == null) {
            requestContext.abortWith(
                        Response.status(Response.Status.BAD_REQUEST)
                .entity("Client-Name header must be defined.")
                        .build());
         }
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                The <code class="literal">CheckRequestFilter</code> validates the outgoing request. It is checked for presence of
                a <code class="literal">Client-Name</code> header. If the header is not present the request will be aborted
                with a made up response with an appropriate code and message in the entity body. This will cause that
                the original request will not be effectively sent to the server but the actual invocation
                will still end up with a response as if it would be generated by the
                server side. If there would be any client response filter it would be executed on this response.
            </p><p>
                To summarize the workflow, for any client request invoked from the client API
                the client request filters (<a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientRequestFilter.html" target="_top">ClientRequestFilter</a>)
                are executed that could manipulate the request.
                If not aborted, the outgoing request is then physically sent over to the server side
                and once a response is received back from the server the client response
                filters (<a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientResponseFilter.html" target="_top">ClientResponseFilter</a>)
                are executed that might again manipulate the returned response.
                Finally the response is passed back to the code that invoked the request.
                If the request was aborted in any client request filter then the
                client/server communication is skipped and the aborted response
                is used in the response filters.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9495"></a>10.3.&nbsp;Interceptors</h2></div></div></div><p>
            Interceptors share a common API for the server and the client side. Whereas filters are primarily intended to manipulate
            request and response parameters like HTTP headers, URIs and/or HTTP methods, interceptors are intended to manipulate entities, via manipulating
            entity input/output streams. If you for example need to encode entity body of a client request then you could
            implement an interceptor to do the work for you.
         </p><p>
            There are two kinds of interceptors, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ReaderInterceptor.html" target="_top">ReaderInterceptor</a> and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/WriterInterceptor.html" target="_top">WriterInterceptor</a>.
            Reader interceptors are used to manipulate inbound entity streams. These are the streams coming from
            the "wire". So, using a reader interceptor you
            can manipulate request entity stream on the server side (where
            an entity is read from the client request) and response entity stream on the client side (where an entity
            is read from the server response). Writer interceptors are used for cases where entity is written to the
            "wire" which on the server means when writing out a response entity and on the client side when writing
            request entity for a request to be sent out to the server. Writer and reader interceptors are executed before message body
            readers or writers are executed and their primary intention is to wrap the entity streams that will be used in message body
            reader and writers.
        </p><p>
            The following example shows a writer interceptor that enables GZIP compression of the whole entity body.
        </p><p>
            </p><div class="example"><a name="d0e9512"></a><p class="title"><b>Example&nbsp;10.5.&nbsp;GZIP writer interceptor</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class GZIPWriterInterceptor implements WriterInterceptor {

    @Override
    public void aroundWriteTo(WriterInterceptorContext context)
                    throws IOException, WebApplicationException {
        final OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(new GZIPOutputStream(outputStream));
        context.proceed();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The interceptor gets an output stream from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/WriterInterceptorContext.html" target="_top">WriterInterceptorContext</a> and sets
            a new one which is a GZIP wrapper of the original output stream. After all interceptors are executed the
            output stream lastly set to the <code class="literal">WriterInterceptorContext</code> will be used for serialization of the entity. In the
            example above the entity bytes will be written to the GZIPOutputStream which will compress the stream data
            and write them to the original output stream. The original stream is always the stream which writes the data to
            the "wire". When the interceptor is used on the server, the original output stream is the stream into which writes
            data to the underlying server container stream that sends the response to the client.
        </p><p>
            The interceptors wrap the streams and they itself work as wrappers. This means that each interceptor is a wrapper
            of another interceptor and it is responsibility of each interceptor implementation to call the wrapped interceptor.
            This is achieved by calling the <code class="literal">proceed()</code> method on the <code class="literal">WriterInterceptorContext</code>.
            This method will call the next registered interceptor in the chain, so effectively this will call all remaining
            registered interceptors. Calling <code class="literal">proceed()</code> from the last
            interceptor in the chain will call the appropriate message body reader. Therefore every interceptor must call the
            <code class="literal">proceed()</code> method otherwise the entity would not be written. The wrapping principle is reflected
            also in the method name, aroundWriteTo, which says that the method is wrapping the writing of the entity.
        </p><p>
            The method aroundWriteTo() gets <code class="literal">WriterInterceptorContext</code> as a parameter. This context contains getters
            and setters for header parameters, request properties, entity, entity stream and other properties. These are the
            properties which will be passed to the final <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Interceptors are allowed to modify
            all these properties. This could influence writing of an entity by <code class="literal">MessageBodyWriter&lt;T&gt;</code> and even
            selection of such a writer. By changing media type (<code class="literal">WriterInterceptorContext</code>.setMediaType())
            the interceptor can cause that different message body writer will be chosen. The interceptor can also
            completely replace the entity if it is needed. However, for modification of headers, request
            properties and such, the filters are usually more preferable choice. Interceptors are executed
            only when there is any entity and when the entity is to be written. So, when you always want to add a new
            header to a response no matter what, use filters as interceptors might not be executed when no entity is
            present. Interceptors should modify properties only for entity serialization
            and deserialization purposes.
        </p><p>
            Let's now look at an example of a <code class="literal">ReaderInterceptor</code>
        </p><p>
            </p><div class="example"><a name="d0e9561"></a><p class="title"><b>Example&nbsp;10.6.&nbsp;GZIP reader interceptor</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class GZIPReaderInterceptor implements ReaderInterceptor {

    @Override
    public Object aroundReadFrom(ReaderInterceptorContext context)
                    throws IOException, WebApplicationException {
        final InputStream originalInputStream = context.getInputStream();
        context.setInputStream(new GZIPInputStream(originalInputStream));
        return context.proceed();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The <code class="literal">GZIPReaderInterceptor</code> wraps the original input stream with the
            <code class="literal">GZIPInputStream</code>. All further reads from the entity stream will cause that data will be decompressed
            by this stream. The interceptor method <code class="literal">aroundReadFrom()</code> must return an entity. The entity
            is returned from the <code class="literal">proceed</code> method of the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ReaderInterceptorContext.html" target="_top">ReaderInterceptorContext</a>. The
            <code class="literal">proceed</code> method internally calls the wrapped interceptor which must also return an entity.
            The <code class="literal">proceed</code> method invoked from the last interceptor in the chain calls message body reader which deserializes
            the entity end returns it. Every interceptor can change this entity if there is a need but in the most cases
            interceptors will just return the entity as returned from the <code class="literal">proceed</code> method.
        </p><p>
            As already mentioned above, interceptors should be primarily used to manipulate entity body.
            Similar to methods exposed by <code class="literal">WriterInterceptorContext</code> the <code class="literal">ReaderInterceptorContext</code>
            introduces a set of methods for modification of request/response properties like HTTP headers,
            URIs and/or HTTP methods (excluding getters and setters for entity as entity has not been read yet).
            Again the same rules as for <code class="literal">WriterInterceptor</code> applies for changing these properties (change only
            properties in order to influence reading of an entity).
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9604"></a>10.4.&nbsp;Filter and interceptor execution order</h2></div></div></div><p>
            Let's look closer at the context of execution of filters and interceptors. The following steps describes scenario
            where a JAX-RS client makes a POST request to the server. The server receives an entity and sends a response back
            with the same entity. GZIP reader and writer interceptors are registered on the
            client and the server. Also filters are registered on client and server which change the headers of request
            and response.
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Client request invoked: The POST request with attached entity is built on the client and invoked.</li><li class="listitem">ClientRequestFilters: client request filters are executed on the client and they
                    manipulate the request headers.</li><li class="listitem">Client <code class="literal">WriterInterceptor</code>: As the request contains an entity, writer interceptor registered
                    on the client is executed before
                    a MessageBodyWriter is executed. It wraps the entity output stream with the GZipOutputStream.</li><li class="listitem">Client MessageBodyWriter: message body writer is executed on the client which serializes the entity
                    into the new GZipOutput stream. This stream zips the data and sends it to the "wire".</li><li class="listitem">Server: server receives a request. Data of the entity is compressed which means that pure read from
                    the entity input stream would return compressed data.</li><li class="listitem">Server pre-matching ContainerRequestFilters: ContainerRequestFilters are executed that can manipulate
                    resource method matching process.</li><li class="listitem">Server: matching: resource method matching is done.</li><li class="listitem">Server: post-matching ContainerRequestFilters: ContainerRequestFilters post matching filters are executed.
                    This include execution of all global filters (without name binding) and filters name-bound to the matched
                    method.</li><li class="listitem">Server <code class="literal">ReaderInterceptor</code>: reader interceptors are executed on the server. The GZIPReaderInterceptor
                    wraps the input stream (the stream from the "wire") into the GZipInputStream and set it to context.</li><li class="listitem">Server MessageBodyReader: server message body reader is executed and it deserializes the entity
                    from new GZipInputStream (get from the context). This means the reader will read unzipped data and not
                    the compressed data from the "wire".</li><li class="listitem">Server resource method is executed: the deserialized entity object is passed to the matched resource
                    method as a parameter. The method returns this entity as a response entity.</li><li class="listitem">Server ContainerResponseFilters are executed: response filters are executed on the server and
                    they manipulate the response headers. This include all global bound filters (without name binding) and all filters name-bound to the resource method.</li><li class="listitem">Server <code class="literal">WriterInterceptor</code>: is executed on the server. It wraps the original
                    output stream with a new GZIPOuptutStream. The original stream is the stream that "goes to the wire" (output
                    stream for response from the underlying server container).
                </li><li class="listitem">Server MessageBodyWriter: message body writer is executed on the server which serializes the entity
                    into the GZIPOutputStream. This stream compresses the data and writes it to the original stream which sends
                    this compressed data back to the client.
                </li><li class="listitem">Client receives the response: the response contains compressed entity data.</li><li class="listitem">Client ClientResponseFilters: client response filters are executed and they manipulate the response headers.</li><li class="listitem">Client response is returned: the jakarta.ws.rs.core.Response is returned from the request invocation.</li><li class="listitem">Client code calls response.readEntity(): read entity is executed on the client to extract the entity from the response.</li><li class="listitem">Client <code class="literal">ReaderInterceptor</code>: the client reader interceptor is executed when readEntity(Class) is called. The interceptor
                        wraps the entity input stream with GZIPInputStream. This will decompress the data from the original input stream.
                </li><li class="listitem">Client MessageBodyReaders: client message body reader is invoked which reads decompressed data from
                    GZIPInputStream and deserializes the entity.</li><li class="listitem">Client: The entity is returned from the readEntity().</li></ol></div><p>
            It is worth to mention that in the scenario above the reader and writer interceptors are invoked only if the
            entity is present (it does not make sense to wrap entity stream when no entity will be written). The same behaviour
            is there for message body readers and writers. As mentioned above, interceptors are executed before
            the message body reader/writer as a part of their execution and they can wrap the input/output stream
            before the entity is read/written. There are exceptions when interceptors are not run before message body
            reader/writers but this is not the case of simple scenario above. This happens for example when the entity is
            read many times from client response using internal buffering. Then the data are intercepted only once and kept
            'decoded' in the buffer.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9665"></a>10.5.&nbsp;Name binding</h2></div></div></div><p>
            Filters and interceptors can be <span class="emphasis"><em>name-bound</em></span>. Name binding is a concept that allows to say to a JAX-RS
            runtime that a specific filter or interceptor will be executed only for a specific resource method. When a filter or
            an interceptor is limited only to a specific resource method we say that it is <span class="emphasis"><em>name-bound</em></span>.
            Filters and interceptors that do not have such a limitation are called <span class="emphasis"><em>global</em></span>.
        </p><p>
            Filter or interceptor can be assigned to a resource method using the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/NameBinding.html" target="_top">@NameBinding</a> annotation. The annotation
            is used as meta annotation for other user implemented annotations that are applied to a providers and resource
            methods. See the following example:
        </p><p>
            </p><div class="example"><a name="d0e9686"></a><p class="title"><b>Example&nbsp;10.7.&nbsp;<code class="literal">@NameBinding</code> example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.zip.GZIPInputStream;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.NameBinding;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
...


// @Compress annotation is the name binding annotation
@NameBinding
@Retention(RetentionPolicy.RUNTIME)
public @interface Compress {}


@Path("helloworld")
public class HelloWorldResource {

    @GET
    @Produces("text/plain")
    public String getHello() {
        return "Hello World!";
    }

    @GET
    @Path("too-much-data")
    @Compress
    public String getVeryLongString() {
        String str = ... // very long string
        return str;
    }
}

// interceptor will be executed only when resource methods
// annotated with @Compress annotation will be executed
@Compress
public class GZIPWriterInterceptor implements WriterInterceptor {
    @Override
    public void aroundWriteTo(WriterInterceptorContext context)
                    throws IOException, WebApplicationException {
        final OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(new GZIPOutputStream(outputStream));
        context.proceed();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The example above defines a new <code class="literal">@Compress</code> annotation which is a name binding annotation as
            it is annotated with <code class="literal">@NameBinding</code>. The <code class="literal">@Compress</code> is applied on the
            resource method <code class="literal">getVeryLongString()</code> and on the interceptor
            <code class="literal">GZIPWriterInterceptor</code>. The interceptor will be executed only if any resource method
            with such an annotation will be executed. In our example case the interceptor will be executed only for
            the <code class="literal">getVeryLongString()</code> method. The interceptor will not be executed for method
            <code class="literal">getHello()</code>. In this example the reason is probably clear. We would like to compress
            only long data and we do not need to compress the short response of "Hello World!".
        </p><p>
            Name binding can be applied on a resource class. In the example <code class="literal">HelloWorldResource</code>
            would be annotated with <code class="literal">@Compress</code>. This would mean that all resource
            methods will use compression in this case.
        </p><p>
            There might be many name binding annotations defined in an application. When any provider (filter
            or interceptor) is annotated with more than one name binding annotation, then it will be executed for
            resource methods which contain ALL these annotations. So, for example if our interceptor would be
            annotated with another name binding annotation @GZIP then the resource method would need to have both annotations attached,
            @Compress and @GZIP, otherwise the interceptor would not be executed. Based on the previous paragraph we can
            even use the combination when the
            resource method <code class="literal">getVeryLongString()</code> would be annotated with @Compress and resource class
            <code class="literal">HelloWorldResource</code> would be annotated from with @GZIP. This would also trigger the interceptor as
            annotations of resource methods are aggregated from resource method and from resource class. But this is probably
            just an edge case which will not be used so often.
        </p><p>
            Note that <span class="emphasis"><em>global filters are always executed</em></span>, even for resource methods
            which have any name binding annotations.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9738"></a>10.6.&nbsp;Dynamic binding</h2></div></div></div><p>Dynamic binding is a way how to assign filters and interceptors to the resource methods in a dynamic
        manner. Name binding from the previous chapter uses a static approach and changes to binding require source
        code change and recompilation. With dynamic binding you can implement code which defines bindings during the application
        initialization time. The following example shows how to implement dynamic binding.</p><p>
            </p><div class="example"><a name="d0e9745"></a><p class="title"><b>Example&nbsp;10.8.&nbsp;Dynamic binding example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import jakarta.ws.rs.core.FeatureContext;
import jakarta.ws.rs.container.DynamicFeature;
...

@Path("helloworld")
public class HelloWorldResource {

    @GET
    @Produces("text/plain")
    public String getHello() {
        return "Hello World!";
    }

    @GET
    @Path("too-much-data")
    public String getVeryLongString() {
        String str = ... // very long string
        return str;
    }
}

// This dynamic binding provider registers GZIPWriterInterceptor
// only for HelloWorldResource and methods that contain
// "VeryLongString" in their name. It will be executed during
// application initialization phase.
public class CompressionDynamicBinding implements DynamicFeature {

    @Override
    public void configure(ResourceInfo resourceInfo, FeatureContext context) {
        if (HelloWorldResource.class.equals(resourceInfo.getResourceClass())
                &amp;&amp; resourceInfo.getResourceMethod()
                    .getName().contains("VeryLongString")) {
            context.register(GZIPWriterInterceptor.class);
        }
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The example contains one <code class="literal">HelloWorldResource</code> which is known from the previous name binding example.
            The difference is in the <code class="literal">getVeryLongString</code> method, which now does not define
            the <code class="literal">@Compress</code> name binding annotations. The binding is done
            using the provider which implements <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/DynamicFeature.html" target="_top">DynamicFeature</a> interface. The interface defines
            one <code class="literal">configure</code>
            method with two arguments, <code class="literal">ResourceInfo</code> and <code class="literal">FeatureContext</code>.
            <code class="literal">ResourceInfo</code> contains information about the resource and method to which the binding can be done.
            The <code class="literal">configure</code> method will be executed once for each resource method that is defined in the application.
            In the example above the provider will be executed twice, once for the <code class="literal">getHello()</code> method
            and once for <code class="literal">getVeryLongString()</code> (
            once the resourceInfo will contain information about getHello() method and once it will point to
            getVeryLongString()). If a dynamic binding provider wants to register any provider for the actual resource method
            it will do that using provided <code class="literal">FeatureContext</code> which extends
            JAX-RS <code class="literal">Configurable</code> API. All methods for registration of filter or interceptor classes or instances can be used.
            Such dynamically registered filters or interceptors will be bound only to the actual resource method. In the example above the
            <code class="literal">GZIPWriterInterceptor</code> will be bound only to the method <code class="literal">getVeryLongString()</code>
            which will cause that data will be compressed only for this method and not for the method
            <code class="literal">getHello()</code>. The code of <code class="literal">GZIPWriterInterceptor</code> is in the examples above.
        </p><p>
            Note that filters and interceptors registered using dynamic binding are only additional filters run for the
            resource method. If there are any name bound providers or global providers they will still be executed.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9806"></a>10.7.&nbsp;Priorities</h2></div></div></div><p>In case you register more filters and interceptors you might want to define an exact order in which
            they should be invoked. The order can be controlled by the <code class="literal">@Priority</code> annotation defined
            by the <code class="literal">jakarta.annotation.Priority</code> class. The annotation accepts an integer parameter of priority.
            Providers used in request processing (<code class="literal">ContainerRequestFilter</code>,
            <code class="literal">ClientRequestFilter</code>) as well as entity interceptors (<code class="literal">ReaderInterceptor</code>,
            <code class="literal">WriterInterceptor</code>) are sorted based on the priority in an ascending manner. So, a request filter with
            priority defined with <code class="literal">@Priority(1000)</code>
            will be executed before another request filter with priority  defined as <code class="literal">@Priority(2000)</code>. Providers
            used during response processing (<code class="literal">ContainerResponseFilter</code>,
            <code class="literal">ClientResponseFilter</code>) are executed
            in the reverse order (using descending manner), so a provider with the priority defined with
            <code class="literal">@Priority(2000)</code> will be executed before another provider with
             priority defined with <code class="literal">@Priority(1000)</code>.
        </p><p>
            It's a good practice to assign a priority to filters and interceptors. Use <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Priorities.html" target="_top">Priorities</a> class which
            defines standardized priorities in JAX-RS for different usages, rather than inventing your
            own priorities. For example, when you write an authentication filter you would assign a priority 1000 which
            is the value of <code class="literal">Priorities</code><code class="literal">.AUTHENTICATION</code>. The following example
            shows the filter from the beginning
            of this chapter with a priority assigned.
        </p><p>
            </p><div class="example"><a name="d0e9859"></a><p class="title"><b>Example&nbsp;10.9.&nbsp;Priorities example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import jakarta.annotation.Priority;
import jakarta.ws.rs.Priorities;
...

@Priority(Priorities.HEADER_DECORATOR)
public class ResponseFilter implements ContainerResponseFilter {

    @Override
    public void filter(ContainerRequestContext requestContext,
                    ContainerResponseContext responseContext)
                    throws IOException {

        responseContext.getHeaders().add("X-Powered-By", "Jersey :-)");
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            As this is a response filter and response filters are executed in the reverse order,
            any other filter with priority lower than 3000 (<code class="literal">Priorities.HEADER_DECORATOR</code> is 3000) will be executed after
            this filter. So, for example <code class="literal">AUTHENTICATION</code> filter (priority 1000) would be run after this filter.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="async"></a>Chapter&nbsp;11.&nbsp;Asynchronous Services and Clients</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e9885">11.1. Asynchronous Server API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10006">11.1.1. Asynchronous Server-side Callbacks</a></span></dt><dt><span class="section"><a href="#chunked-output">11.1.2. Chunked Output</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10136">11.2. Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10199">11.2.1. Asynchronous Client Callbacks</a></span></dt><dt><span class="section"><a href="#d0e10275">11.2.2. Chunked input</a></span></dt></dl></dd></dl></div><p>
        This chapter describes the usage of asynchronous API on the client and server side. The term <span class="emphasis"><em>async</em></span>
        will be sometimes used interchangeably with the term <span class="emphasis"><em>asynchronous</em></span> in this chapter.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9885"></a>11.1.&nbsp;Asynchronous Server API</h2></div></div></div><p>
            Request processing on the server works by default in a synchronous processing mode, which means that a client
            connection of a request is processed in a single I/O container thread. Once the thread processing the request
            returns to the I/O container, the container can safely assume that the request processing is finished and that
            the client connection can be safely released including all the resources associated with the connection. This model
            is typically sufficient for processing of requests for which the processing resource method execution takes
            a relatively short time. However, in cases where a resource method execution is known to take a long time to compute
            the result, server-side asynchronous processing model should be used. In this model, the association between a
            request processing thread and client connection is broken. I/O container that handles incoming request may no longer
            assume that a client connection can be safely closed when a request processing thread returns. Instead a facility for
            explicitly suspending, resuming and closing client connections needs to be exposed.
            Note that the use of server-side asynchronous processing model will not improve the request processing time perceived
            by the client. It will however increase the throughput of the server, by releasing the
            initial request processing thread back to the I/O container while the request may still be waiting in a queue for
            processing or the processing may still be running on another dedicated thread. The released I/O container thread
            can be used to accept and process new incoming request connections.
        </p><p>
            The following example shows a simple asynchronous resource method defined using the new JAX-RS async API:
            </p><div class="example"><a name="d0e9892"></a><p class="title"><b>Example&nbsp;11.1.&nbsp;Simple async resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/resource")
public class AsyncResource {
    @GET
    public void asyncGet(@Suspended final AsyncResponse asyncResponse) {

        new Thread(new Runnable() {
            @Override
            public void run() {
                String result = veryExpensiveOperation();
                asyncResponse.resume(result);
            }

            private String veryExpensiveOperation() {
                // ... very expensive operation
            }
        }).start();
    }
}</pre></div></div><p><br class="example-break">
            In the example above, a resource <code class="literal">AsyncResource</code>
            with one <code class="literal">GET</code> method <code class="literal">asyncGet</code> is defined. The <code class="literal">asyncGet</code> method
            injects a JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/AsyncResponse.html" target="_top">AsyncResponse</a> instance using a JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/Suspended.html" target="_top">@Suspended</a> annotation.
            Please note that <code class="literal">AsyncResponse</code> must be injected by the <code class="literal">@Suspended</code>
            annotation and not by <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a> as <code class="literal">@Suspended</code> does not only inject response but also
            says that the method is executed in the asynchronous mode. By the <code class="literal">AsyncResponse</code> parameter into
            a resource method we tell the Jersey runtime that the method is supposed to be invoked using the asynchronous
            processing mode, that is the client connection should not be automatically closed by the underlying I/O container
            when the method returns. Instead, the injected <code class="literal">AsyncResponse</code> instance (that represents the
            suspended client request connection) will be used to explicitly send the response back to the client using some other
            thread. In other words, Jersey runtime knows that when the <code class="literal">asyncGet</code> method completes, the response
            to the client may not be ready yet and the processing must be suspended and wait to be explicitly resumed with a
            response once it becomes available. Note that the method <code class="literal">asyncGet</code> returns <code class="literal">void</code>
            in our example. This is perfectly valid in case of an asynchronous JAX-RS resource method, even for a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a>
            method, as the response is never returned directly from the resource method as its return value. Instead, the response
            is later returned using <code class="literal">AsyncResponse</code> instance as it is demonstrated in the example. The
            <code class="literal">asyncGet</code> resource method starts a new thread and exits from the method. In that state the
            request processing is suspended and the container thread (the one which entered the resource method) is returned back
            to the container's thread pool and it can process other requests. New thread started in the resource method may
            execute an expensive operation which might take a long time to finish. Once a result is ready it is resumed using
            the <code class="literal">resume()</code> method on the <code class="literal">AsyncResponse</code> instance.
            The resumed response is then processed in the new thread by Jersey in a same way as any other synchronous response,
            including execution of filters and interceptors, use of exception mappers as necessary and sending the response
            back to the client.
        </p><p>
            It is important to note that the asynchronous response (<code class="literal">asyncResponse</code> in the example)
            does not need to be resumed from the thread started from the resource method. The asynchronous
            response can be resumed even from different request processing thread as it is shown in the
            the example of the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/AsyncResponse.html" target="_top">AsyncResponse</a> javadoc. In the javadoc example the
            async response suspended from the <code class="literal">GET</code> method is resumed later on from
            the <code class="literal">POST</code> method. The suspended async response is passed between requests using
            a static field and is resumed from the other resource method running on a different request processing thread.
        </p><p>
            Imagine now a situation when there is a long delay between two requests and you would not like to let
            the client wait for the response "forever" or at least for an unacceptable long time. In asynchronous processing
            model, occurrences of such situations should be carefully considered with client connections not being automatically
            closed when the processing method returns and the response needs to be resumed explicitly based on an event that
            may actually even never happen. To tackle these situations asynchronous <span class="emphasis"><em>timeouts</em></span> can be used.
        </p><p>
            The following example shows the usage of timeouts:
            </p><div class="example"><a name="d0e9979"></a><p class="title"><b>Example&nbsp;11.2.&nbsp;Simple async method with timeout</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public void asyncGetWithTimeout(@Suspended final AsyncResponse asyncResponse) {
    asyncResponse.setTimeoutHandler(new TimeoutHandler() {

        @Override
        public void handleTimeout(AsyncResponse asyncResponse) {
            asyncResponse.resume(Response.status(Response.Status.SERVICE_UNAVAILABLE)
                    .entity("Operation time out.").build());
        }
    });
    asyncResponse.setTimeout(20, TimeUnit.SECONDS);

    new Thread(new Runnable() {

        @Override
        public void run() {
            String result = veryExpensiveOperation();
            asyncResponse.resume(result);
        }

        private String veryExpensiveOperation() {
            // ... very expensive operation that typically finishes within 20 seconds
        }
    }).start();
}</pre></div></div><p><br class="example-break">
            By default, there is no timeout defined on the suspended <code class="literal">AsyncResponse</code> instance.
            A custom timeout and timeout event handler may be defined using <code class="literal">setTimeoutHandler(TimeoutHandler)</code>
            and <code class="literal">setTimeout(long, TimeUnit)</code> methods. The <code class="literal">setTimeoutHandler(TimeoutHandler)</code>
            method defines the handler that will be invoked when timeout is reached. The handler resumes the response with the
            response code 503 (from Response.Status.<code class="literal">SERVICE_UNAVAILABLE</code>).
            A timeout interval can be also defined without specifying a custom timeout handler (using just the
            <code class="literal">setTimeout(long, TimeUnit)</code> method).
            In such case the default behaviour of Jersey runtime is to throw a <code class="literal">ServiceUnavailableException</code>
            that gets mapped into 503, "Service Unavailable" HTTP error response, as defined by the JAX-RS specification.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10006"></a>11.1.1.&nbsp;Asynchronous Server-side Callbacks</h3></div></div></div><p>
                As operations in asynchronous cases might take long time and they are not always finished within
                a single resource method invocation, JAX-RS offers facility to register callbacks to be invoked
                based on suspended async response state changes. In Jersey you can register two JAX-RS callbacks:
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                        <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/CompletionCallback.html" target="_top">CompletionCallback</a> that is executed when request finishes or fails, and
                    </li><li class="listitem">
                        <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ConnectionCallback.html" target="_top">ConnectionCallback</a> executed when a connection to a client is closed or lost.
                    </li></ul></div><p>
                </p><div class="example"><a name="d0e10025"></a><p class="title"><b>Example&nbsp;11.3.&nbsp;CompletionCallback example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/resource")
public class AsyncResource {
    private static int numberOfSuccessResponses = 0;
    private static int numberOfFailures = 0;
    private static Throwable lastException = null;

    @GET
    public void asyncGetWithTimeout(@Suspended final AsyncResponse asyncResponse) {
        asyncResponse.register(new CompletionCallback() {
            @Override
            public void onComplete(Throwable throwable) {
                if (throwable == null) {
                    // no throwable - the processing ended successfully
                    // (response already written to the client)
                    numberOfSuccessResponses++;
                } else {
                    numberOfFailures++;
                    lastException = throwable;
                }
            }
        });

        new Thread(new Runnable() {
            @Override
            public void run() {
                String result = veryExpensiveOperation();
                asyncResponse.resume(result);
            }

            private String veryExpensiveOperation() {
                // ... very expensive operation
            }
        }).start();
    }
}</pre></div></div><p><br class="example-break">
                A completion callback is registered using <code class="literal">register(...)</code> method
                on the <code class="literal">AsyncResponse</code> instance. A registered completion callback is bound only
                to the response(s) to which it has been registered. In the example the <code class="literal">CompletionCallback</code>
                is used to calculate successfully processed responses, failures and to store last exception. This is only a
                simple case demonstrating the usage of the callback. You can use completion callback to release the resources,
                change state of internal resources or representations or handle failures. The method has an argument
                <code class="literal">Throwable</code> which is set only in case of an error. Otherwise the parameter
                will be <code class="literal">null</code>, which means that the response was successfully written. The callback is executed
                only after the response is written to the client (not immediately after the response is resumed).
            </p><p>
                The <code class="literal">AsyncResponse</code> <code class="literal">register(...)</code> method is overloaded and offers options
                to register a single callback as an <code class="literal">Object</code> (in the example), as a <code class="literal">Class</code> or
                multiple callbacks using varags.
            </p><p>
                As some async requests may take long time to process the client may decide to terminate its connection to the
                server before the response has been resumed or before it has been fully written to the client. To deal with these
                use cases a <code class="literal">ConnectionCallback</code> can be used. This callback will be executed only if the
                connection was prematurely terminated or lost while the response is being written to the back client. Note that
                this callback will not be invoked when a response is written successfully and the client connection is closed
                as expected. See javadoc of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ConnectionCallback.html" target="_top">ConnectionCallback</a> for more information.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="chunked-output"></a>11.1.2.&nbsp;Chunked Output</h3></div></div></div><p>Jersey offers a facility for sending response to the client in multiple more-or-less independent chunks using a
                <span class="emphasis"><em>chunked output</em></span>. Each response chunk usually takes some (longer) time to prepare before
                sending it to the client. The most important fact about response chunks is that you want
                to send them to the client immediately as they become available without waiting for the remaining chunks to become
                available too. The first bytes of each chunked response consists of the HTTP headers that are sent to the client.
                As noted above, the entity of the response is then sent in chunks as they become available.
                Client knows that the response is going to be chunked, so it reads each chunk of the response separately,
                processes it, and waits for more chunks to arrive on the same connection. After some time, the server generates
                another response chunk and send it again to the client. Server keeps on sending response chunks until
                it closes the connection after sending the last chunk when the response processing is finished.
            </p><p>
                In Jersey you can use <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ChunkedOutput.html" target="_top">ChunkedOutput</a> to send response to a client in chunks. Chunks are strictly
                defined pieces of a response body can be marshalled as a separate entities using Jersey/JAX-RS
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> providers. A chunk can be String, Long or JAXB bean serialized to XML or JSON or
                any other defined custom type for which a <code class="literal">MessageBodyWriter&lt;T&gt;</code> is available.
            </p><p>
                The resource method
                that returns <code class="literal">ChunkedOutput</code> informs the Jersey runtime that the response will be chunked
                and that the processing works asynchronously as such. You do not need to inject
                <code class="literal">AsyncResponse</code> to start the asynchronous processing mode in this case.
                Returning a <code class="literal">ChunkedOutput</code> instance from the method is enough to indicate the asynchronous
                processing. Response headers will be sent to a client when the resource method returns and the client will wait
                for the stream of chunked data which you will be able to write from different thread using the same
                <code class="literal">ChunkedOutput</code> instance returned from the resource method earlier. The following example
                demonstrates this use case:
                </p><div class="example"><a name="d0e10101"></a><p class="title"><b>Example&nbsp;11.4.&nbsp;ChunkedOutput example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/resource")
public class AsyncResource {
    @GET
    public ChunkedOutput&lt;String&gt; getChunkedResponse() {
        final ChunkedOutput&lt;String&gt; output = new ChunkedOutput&lt;String&gt;(String.class);

        new Thread() {
            public void run() {
                try {
                    String chunk;

                    while ((chunk = getNextString()) != null) {
                        output.write(chunk);
                    }
                } catch (IOException e) {
                    // IOException thrown when writing the
                    // chunks of response: should be handled
                } finally {
                    output.close();
                        // simplified: IOException thrown from
                        // this close() should be handled here...
                }
            }
        }.start();

        // the output will be probably returned even before
        // a first chunk is written by the new thread
        return output;
    }

    private String getNextString() {
        // ... long running operation that returns
        //     next string or null if no other string is accessible
    }
}</pre></div></div><p><br class="example-break">
                The example above defines a <code class="literal">GET</code> method that returns a <code class="literal">ChunkedOutput</code> instance.
                The generic type of <code class="literal">ChunkedOutput</code> defines the chunk types (in this case chunks are Strings).
                Before the instance is returned a new thread is started that writes individual chunks into
                the chunked output instance named <code class="literal">output</code>. Once the original
                thread returns from the resource method, Jersey runtime writes headers to the container response but does not
                close the client connection yet and waits for the response data to be written to the chunked
                <code class="literal">output</code>.
                New thread in a loop calls the method <code class="literal">getNextString()</code> which returns a
                next String or <code class="literal">null</code> if no other String exists (the method could for example load latest data
                from the database). Returned Strings are written to the chunked <code class="literal">output</code>. Such a written
                chunks are internally written to the container response and client can read them. At the end the
                chunked output is closed which determines the end of the chunked response. Please note that you must close
                the output explicitly in order to close the client connection as Jersey does not implicitly know when
                you are finished with writing the chunks.
            </p><p>
                A chunked output can be processed also from threads created from another request as it is explained in the
                sections above. This means that one resource method may e.g. only return a <code class="literal">ChunkedOutput</code>
                instance and other resource method(s) invoked from another request thread(s) can write data into the chunked
                output and/or close the chunked response.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10136"></a>11.2.&nbsp;Client API</h2></div></div></div><p>The client API supports asynchronous processing too. Simple usage of asynchronous client API is shown in the
        following example:
            </p><div class="example"><a name="d0e10141"></a><p class="title"><b>Example&nbsp;11.5.&nbsp;Simple client async invocation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final AsyncInvoker asyncInvoker = target().path("http://example.com/resource/")
        .request().async();
final Future&lt;Response&gt; responseFuture = asyncInvoker.get();
System.out.println("Request is being processed asynchronously.");
final Response response = responseFuture.get();
    // get() waits for the response to be ready
System.out.println("Response received.");</pre></div></div><p><br class="example-break">
            The difference against synchronous invocation is that the http method call <code class="literal">get()</code>
            is not called on <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/SyncInvoker.html" target="_top">SyncInvoker</a> but on <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/AsyncInvoker.html" target="_top">AsyncInvoker</a>. The
            <code class="literal">AsyncInvoker</code> is returned from the call of method
            <code class="literal">Invocation.Builder.async()</code> as shown above. <code class="literal">AsyncInvoker</code>
            offers methods similar to <code class="literal">SyncInvoker</code> only these methods do not return a response
            synchronously. Instead a <code class="literal">Future&lt;...&gt;</code> representing response data is returned.
            These method calls also return immediately without waiting for the actual request to complete.
            In order to get the response of the invoked <code class="literal">get()</code> method, the
            <code class="literal">responseFuture.get()</code> is invoked which waits for the response to be finished
            (this call is blocking as defined by the Java SE <code class="literal">Future</code> contract).
        </p><p>
            Asynchronous Client API in JAX-RS is fully integrated in the fluent JAX-RS Client API flow, so that
            the async client-side invocations can be written fluently just like in the following example:
            </p><div class="example"><a name="d0e10182"></a><p class="title"><b>Example&nbsp;11.6.&nbsp;Simple client fluent async invocation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Future&lt;Response&gt; responseFuture = target().path("http://example.com/resource/")
        .request().async().get();</pre></div></div><p><br class="example-break">
        </p><p>
            To work with asynchronous results on the client-side, all standard <code class="literal">Future</code> API facilities
            can be used. For example, you can use the <code class="literal">isDone()</code> method
            to determine whether a response has finished to avoid the use of a blocking call to <code class="literal">Future.get()</code>.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10199"></a>11.2.1.&nbsp;Asynchronous Client Callbacks</h3></div></div></div><p>Similarly to the server side, in the client API you can register asynchronous callbacks too. You can use
                these callbacks to be notified when a response arrives instead of waiting for the
                response on <code class="literal">Future.get()</code> or checking the status by <code class="literal">Future.isDone()</code> in
                a loop.
                A client-side asynchronous invocation callback can be registered as shown in the following example:
                </p><div class="example"><a name="d0e10210"></a><p class="title"><b>Example&nbsp;11.7.&nbsp;Client async callback</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Future&lt;Response&gt; responseFuture = target().path("http://example.com/resource/")
        .request().async().get(new InvocationCallback&lt;Response&gt;() {
            @Override
            public void completed(Response response) {
                System.out.println("Response status code "
                        + response.getStatus() + " received.");
            }

            @Override
            public void failed(Throwable throwable) {
                System.out.println("Invocation failed.");
                throwable.printStackTrace();
            }
        });</pre></div></div><p><br class="example-break">

                The registered callback is expected to implement the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/InvocationCallback.html" target="_top">InvocationCallback</a> interface that defines
                two methods.
                First method <code class="literal">completed(Response)</code> gets invoked when an invocation successfully
                finishes. The result response is passed as a parameter to the callback method. The second method
                <code class="literal">failed(Throwable)</code> is invoked in case the invocation fails and the exception describing
                the failure is passed to the method as a parameter. In this case since the callback generic type is
                <code class="literal">Response</code>, the <code class="literal">failed(Throwable)</code> method would  only invoked in case
                the invocation fails because of an internal client-side processing error. It would not be invoked
                in case a server responds with an HTTP error code, for example if the requested resource
                is not found on the server and HTTP <code class="literal">404</code> response code is returned. In such case
                <code class="literal">completed(Response)</code> callback method would be invoked and the response passed to the method
                would contain the returned error response with HTTP <code class="literal">404</code> error code. This is a special
                behavior in case the generic callback return type is <code class="literal">Response</code>. In the next example an
                exception is thrown (or <code class="literal">failed(Throwable)</code> method on the invocation callback is invoked)
                even in case a non-<code class="literal">2xx</code> HTTP error code is returned.
            </p><p>
                As with the synchronous client API, you can retrieve the response entity as a Java type directly without
                requesting a <code class="literal">Response</code> first. In case of an <code class="literal">InvocationCallback</code>, you need
                to set its generic type to the expected response entity type instead of using the <code class="literal">Response</code>
                type as demonstrated in the example below:
                </p><div class="example"><a name="d0e10260"></a><p class="title"><b>Example&nbsp;11.8.&nbsp;Client async callback for specific entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Future&lt;String&gt; entityFuture = target().path("http://example.com/resource/")
        .request().async().get(new InvocationCallback&lt;String&gt;() {
            @Override
            public void completed(String response) {
                System.out.println("Response entity '" + response + "' received.");
            }

            @Override
            public void failed(Throwable throwable) {
                System.out.println("Invocation failed.");
                throwable.printStackTrace();
            }
        });
System.out.println(entityFuture.get());</pre></div></div><p><br class="example-break">
                Here, the generic type of the invocation callback information is used to unmarshall the HTTP response content
                into a desired Java type.
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    Please note that in this case the method <code class="literal">failed(Throwable throwable)</code> would be invoked even
                    for cases when a server responds with a non HTTP-<code class="literal">2xx</code> HTTP error code. This is because in this
                    case the user does not have any other means of finding out that the server returned an error response.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10275"></a>11.2.2.&nbsp;Chunked input</h3></div></div></div><p>
                In an <a class="link" href="#chunked-output" title="11.1.2.&nbsp;Chunked Output">earlier section</a> the <code class="literal">ChunkedOutput</code> was
                described. It was shown how to use a chunked output on the server. In order to read chunks on the client the
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ChunkedInput.html" target="_top">ChunkedInput</a> can be used to complete the story.
            </p><p>
                You can, of course, process input on the client as a standard input stream but if you would like to
                leverage Jersey infrastructure to provide support of translating message chunk data into Java types
                using a <code class="literal">ChunkedInput</code> is much more straightforward. See the usage of the
                <code class="literal">ChunkedInput</code> in the following example:

                </p><div class="example"><a name="d0e10297"></a><p class="title"><b>Example&nbsp;11.9.&nbsp;ChunkedInput example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Response response = target().path("http://example.com/resource/")
        .request().get();
final ChunkedInput&lt;String&gt; chunkedInput =
        response.readEntity(new GenericType&lt;ChunkedInput&lt;String&gt;&gt;() {});
String chunk;
while ((chunk = chunkedInput.read()) != null) {
    System.out.println("Next chunk received: " + chunk);
}
</pre></div></div><p><br class="example-break">

                The response is retrieved in a standard way from the server. The entity is read as a
                <code class="literal">ChunkedInput</code> entity. In order to do that the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/GenericEntity.html" target="_top">GenericEntity&lt;T&gt;</a> is used to preserve
                a generic information at run time. If you would not use <code class="literal">GenericEntity&lt;T&gt;</code>, Java language generic type
                erasure would cause that the generic information would get lost at compile time and an exception would be thrown
                at run time complaining about the missing chunk type definition.
            </p><p>
                In the next lines in the example, individual chunks are being read from the response. Chunks can come with some
                delay, so they will be written to the console as they come from the server. After receiving last chunk the
                <code class="literal">null</code> will be returned from the <code class="literal">read()</code> method. This will mean that the server has sent
                the last chunk and closed the connection. Note that the <code class="literal">read()</code> is a blocking operation and the
                invoking thread is blocked until a new chunk comes.
            </p><p>
                Writing chunks with <code class="literal">ChunkedOutput</code> is simple, you only call method <code class="literal">write()</code>
                which writes exactly one chunk to the output. With the input reading it is slightly more complicated. The
                <code class="literal">ChunkedInput</code> does not know how to distinguish chunks in the byte stream unless being told by
                the developer. In order to define custom chunks boundaries,
                the <code class="literal">ChunkedInput</code> offers possibility to register a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ChunkParser.html" target="_top">ChunkParser</a> which
                reads chunks from the input stream and separates them. Jersey provides several chunk parser implementations and
                you can implement your own parser to separate your chunks if you need. In our example above the default parser
                provided by Jersey is used that separates chunks based on presence of a <code class="literal">\r\n</code> delimiting
                character sequence.
            </p><p>
                Each incoming input stream is firstly parsed by the <code class="literal">ChunkParser</code>, then each chunk is processed
                by the proper <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>.
                You can define the media type of chunks to aid the selection of a proper <code class="literal">MessageBodyReader&lt;T&gt;</code> in
                order to read chunks correctly into the requested entity types (in our case into Strings).
            </p></div></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="uris-and-links"></a>Chapter&nbsp;12.&nbsp;URIs and Links</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e10358">12.1. Building URIs</a></span></dt><dt><span class="section"><a href="#d0e10432">12.2. Resolve and Relativize</a></span></dt><dt><span class="section"><a href="#d0e10475">12.3. Link</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10358"></a>12.1.&nbsp;Building URIs</h2></div></div></div><p>
            A very important aspect of REST is hyperlinks, URIs, in representations that clients can use to transition the
            Web service to new application states (this is otherwise known as "hypermedia as the engine of application state").
            HTML forms present a good example of this in practice.
        </p><p>
            Building URIs and building them safely is not easy with <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/net/URI.html" target="_top">URI</a>, which is why JAX-RS has the
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriBuilder.html" target="_top">UriBuilder</a> class that makes it simple and easy to build URIs safely.
            <code class="literal">UriBuilder</code> can be used to build new URIs or build from existing URIs. For resource
            classes it is more than likely that URIs will be built from the base URI the web service is deployed at
            or from the request URI. The class <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriInfo.html" target="_top">UriInfo</a> provides such information (in addition to further
            information, see next section).
        </p><p>The following example shows URI building with <code class="literal">UriInfo</code> and <code class="literal">UriBuilder</code>
            from the bookmark example:

            </p><div class="example"><a name="d0e10385"></a><p class="title"><b>Example&nbsp;12.1.&nbsp;URI building</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/users/")
public class UsersResource {

    @Context
    UriInfo uriInfo;

    ...

    @GET
    @Produces("application/json")
    public JSONArray getUsersAsJsonArray() {
        JSONArray uriArray = new JSONArray();
        for (UserEntity userEntity : getUsers()) {
            UriBuilder ub = uriInfo.getAbsolutePathBuilder();
            URI userUri = ub.
                    path(userEntity.getUserId()).
                    build();
            uriArray.put(userUri.toASCIIString());
        }
        return uriArray;
    }
}</pre></div></div><p><br class="example-break">

            <code class="literal">UriInfo</code> is obtained using the @Context annotation, and in this particular example injection onto
            the field of the root resource class is performed, previous examples showed the use of @Context on resource method
            parameters.
        </p><p>
            <code class="literal">UriInfo</code> can be used to obtain URIs and associated <code class="literal">UriBuilder</code> instances for
            the following URIs: the base URI the application is deployed at; the request URI; and the absolute path URI, which
            is the request URI minus any query components.
        </p><p>
            The <code class="literal">getUsersAsJsonArray</code> method constructs a <code class="literal">JSONArray</code>, where each element
            is a URI identifying a specific user resource. The URI is built from the absolute path of the request URI by
            calling
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriInfo.html#getAbsolutePathBuilder()" target="_top">UriInfo.getAbsolutePathBuilder()</a>.
            A new path segment is added, which is the user ID, and then the URI is built. Notice that it is not necessary to
            worry about the inclusion of <code class="literal">'/'</code> characters or that the user ID may contain characters that need
            to be percent encoded. <code class="literal">UriBuilder</code> takes care of such details.
        </p><p><code class="literal">UriBuilder</code> can be used to build/replace query or matrix parameters. URI templates can also be
            declared, for example the following will build the URI <code class="literal">"http://localhost/segment?name=value"</code>:

            </p><div class="example"><a name="d0e10426"></a><p class="title"><b>Example&nbsp;12.2.&nbsp;Building URIs using query parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">UriBuilder.fromUri("http://localhost/")
    .path("{a}")
    .queryParam("name", "{value}")
    .build("segment", "value");</pre></div></div><p><br class="example-break">
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10432"></a>12.2.&nbsp;Resolve and Relativize</h2></div></div></div><p>JAX-RS 2.0 introduced additional URI resolution and relativization methods in the <code class="literal">UriBuilder</code>:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriInfo.html#resolve(java.net.URI)" target="_top">UriInfo.resolve(java.net.URI)</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriInfo.html#relativize(java.net.URI)" target="_top">UriInfo.relativize(java.net.URI)</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriBuilder.html#resolveTemplate(java.lang.String, java.lang.Object)" target="_top">UriBuilder.resolveTemplate(...)</a> (various arguments)</p></li></ul></div><p>

            Resolve and relativize methods in <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriInfo.html" target="_top">UriInfo</a> are essentially counterparts to the methods listed above -
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriInfo.html#resolve(java.net.URI)" target="_top">UriInfo.resolve(java.net.URI)</a>
            resolves given relative URI to an absolute URI using application context URI as the base URI;
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriInfo.html#relativize(java.net.URI)" target="_top">UriInfo.relativize(java.net.URI)</a>
            then transforms an absolute URI to a relative one, using again the applications context URI as the base URI.
        </p><p>
            <code class="literal">UriBuilder</code> also introduces a set of methods that provide ways of resolving URI templates by replacing
            individual templates with a provided value(s). A short example:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final URI uri = UriBuilder.fromUri("http://{host}/{path}?q={param}")
    .resolveTemplate("host", "localhost")
    .resolveTemplate("path", "myApp")
    .resolveTemplate("param", "value").build();

uri.toString(); // returns "http://localhost/myApp?q=value"</pre><p>

            See the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriBuilder.html" target="_top">UriBuilder</a> javadoc for more details.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10475"></a>12.3.&nbsp;Link</h2></div></div></div><p>
            JAX-RS 2.0 introduces <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Link.html" target="_top">Link</a> class, which serves as a representation of Web Link defined in
            <a class="link" href="http://tools.ietf.org/html/rfc5988" target="_top">RFC 5988</a>.
            The JAX-RS <code class="literal">Link</code> class adds API support for providing additional metadata in HTTP messages,
            for example, if you are consuming a REST interface of a public library, you might have a resource returning
            description of a single book. Then you can include links to related resources, such as a book category,
            author, etc. to make the produced response concise but complete at the same time. Clients are then able to
            query all the additional information they are interested in and are not forced to consume details they are
            not interested in. At the same time, this approach relieves the server resources as only the information that
            is truly requested is being served to the clients.
        </p><p>
            A <code class="literal">Link</code> can be serialized to an HTTP message (typically a response) as additional HTTP header
            (there might be multiple <code class="literal">Link</code> headers provided, thus multiple links can be served in a single
            message). Such HTTP header may look like:
            </p><pre class="screen">Link: &lt;http://example.com/TheBook/chapter2&gt;; rel="prev"; title="previous chapter"</pre><p>
        </p><p>
            Producing and consuming Links with JAX-RS API is demonstrated in the following example:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">// server side - adding links to a response:
Response r = Response.ok().
    link("http://oracle.com", "parent").
    link(new URI("http://eclipse-ee4j.github.io/jersey"), "framework").
    build();

...

// client-side processing:
final Response response = target.request().get();

URI u = response.getLink("parent").getUri();
URI u = response.getLink("framework").getUri();</pre><p>
        </p><p>
            Instances of <code class="literal">Link</code> can be also created directly by invoking one of the factory methods on the
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Link.html" target="_top">Link</a> API that returns a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Link.Builder.html" target="_top">Link.Builder</a> that can be used to configure and produce new
            links.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="declarative-linking"></a>Chapter&nbsp;13.&nbsp;Declarative Hyperlinking</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e10531">13.1. Dependency</a></span></dt><dt><span class="section"><a href="#d0e10554">13.2. Links in Representations</a></span></dt><dt><span class="section"><a href="#d0e10590">13.3. List of Link Injection</a></span></dt><dt><span class="section"><a href="#d0e10598">13.4. Links from Resources</a></span></dt><dt><span class="section"><a href="#d0e10626">13.5. Binding Template Parameters</a></span></dt><dt><span class="section"><a href="#d0e10698">13.6. Conditional Link Injection</a></span></dt><dt><span class="section"><a href="#d0e10720">13.7. Link Headers</a></span></dt><dt><span class="section"><a href="#d0e10761">13.8. Prevent Recursive Injection</a></span></dt><dt><span class="section"><a href="#d0e10781">13.9. Meta-annotation support</a></span></dt><dt><span class="section"><a href="#d0e10836">13.10. Configure and register</a></span></dt></dl></div><p>
        <a class="link" href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_top">RESTful APIs must be
            hypertext-driven</a>. JAX-RS currently offers <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/UriBuilder.html" target="_top">UriBuilder</a> to simplify URI
        creation but Jersey adds an additional annotation-based alternative that is described here.
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
            This API is currently under development and experimental so it is subject to change at any time.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10531"></a>13.1.&nbsp;Dependency</h2></div></div></div><p>
            To use Declarative Linking you need to add <code class="literal">jersey-declarative-linking</code> module to your <code class="literal">pom.xml</code> file:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-declarative-linking&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

            Additionally you will need to add the following dependencies, if you are not deploying
            into a container that is already including them:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;jakarta.el&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.el-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.0&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.el&lt;/artifactId&gt;
    &lt;version&gt;4.0.0&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

            If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-declarative-linking/dependencies.html" target="_top">jersey-declarative-linking</a>) on
            the classpath.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10554"></a>13.2.&nbsp;Links in Representations</h2></div></div></div><p>
            Links are added to representations using the <code class="literal">@InjectLink</code> annotation on
            entity class fields. The Jersey runtime is responsible for injecting the appropriate URI
            into the field prior to serialization by a message body writer. E.g. consider the
            following resource and entity classes:
        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("widgets")
public class WidgetsResource {
    @GET
    public Widgets get() {
        return new Widgets();
    }
}

public class Widgets {
    @InjectLink(resource=WidgetsResource.class)
    URI u;
}</pre><p>
            After a call to <code class="literal">WidgetsResource#get</code>, the Jersey runtime will inject the value
            <code class="literal">"/context/widgets"</code>
            <a href="#ftn.d0e10572" class="footnote" name="d0e10572"><sup class="footnote">[1]</sup></a>
            into the returned <code class="literal">Widgets</code> instance. If an absolute URI is
            desired instead of an absolute path then the annotation can be changed to
            <code class="literal">@InjectLink(resource=WidgetsResource.class, style=ABSOLUTE)</code>.
        </p><p>
            The above usage works nicely when there's already a URI template on a class that you
            want to reuse. If there's no such template available then you can use a literal value
            instead of a reference. E.g. the following is equivalent to the earlier example:
            <code class="literal">@InjectLink(value="widgets", style=ABSOLUTE)</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10590"></a>13.3.&nbsp;List of Link Injection</h2></div></div></div><p>
            You can inject multiple links into an array or a List collection type. E.g.:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@InjectLinks({@InjectLink(resource=WidgetsResource.class, rel = "self")})
List&lt;Link&gt; links</pre><p>

            The field doesn't need to be initialized. However, if it already contains a collection with manually created links,
            then it will merge those with the generated links into a new collection which then replaces the field value.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10598"></a>13.4.&nbsp;Links from Resources</h2></div></div></div><p>
            As an alternative to defining the links in the entity class, they can also be defined in the resource classes by
            annotating the resource methods with <code class="literal">@ProvideLink</code>. This has the benefit, that the target
            method is already known and doesn't need to be referenced. Other than that it has the same parameters and behaviors
            as <code class="literal">@InjectLink</code>. The entity classes need to have a field annotated with
            <code class="literal">@InjectLinks</code>, which can be empty.
        </p><p>
            The <code class="literal">@ProvideLink</code> annotation can be repeated to add links to different entities using different
            options. Entities are defined via the <code class="literal">value</code> property. If the entities are similar in structure they
            can also be declared as an array. <code class="literal">@ProvideLink</code> also works with class hierarchies, e.g., contributions
            defined for a superclass will also be injected into the derived classes (interfaces are not supported).

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@ProvideLink(value = Order.class,rel = "self",
     bindings = @Binding(name = "orderId", value = "${instance.id}"))
@ProvideLink(value = PaymentConfirmation.class, rel = "order",
     bindings = @Binding(name = "orderId", value = "${instance.orderId}"))
@GET
@Path("/{orderId}")
public Response get(@PathParam("orderId") String orderId)</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10626"></a>13.5.&nbsp;Binding Template Parameters</h2></div></div></div><p>
            Referenced or literal templates may contain parameters. Two forms of parameters are
            supported:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                    URI template parameters, e.g. <code class="literal">widgets/{id}</code> where <code class="literal">{id}</code> represents
                    a variable part of the URI.
                </p></li><li class="listitem"><p>
                    EL expressions, e.g. <code class="literal">widgets/${instance.id}</code> where <code class="literal">${instance.id}</code>
                    is an EL expression.
                </p></li></ul></div><p>
        </p><p>
            Parameter values can be extracted from three implicit beans:
            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
                        <code class="literal">instance</code>
                    </span></dt><dd><p>Represents the instance of the class that contains the annotated field.</p></dd><dt><span class="term">
                        <code class="literal">entity</code>
                    </span></dt><dd><p>Represents the entity class instance returned by the resource method.</p></dd><dt><span class="term">
                        <code class="literal">resource</code>
                    </span></dt><dd><p>Represents the resource class instance that returned the entity.</p></dd></dl></div><p>
        </p><p>
            By default URI template parameter values are extracted from the implicit <code class="literal">instance</code> bean,
            i.e. the following two annotations are equivalent:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@InjectLink("widgets/{id}")

@InjectLink("widgets/${instance.id}")</pre><p>
        </p><p>
            The source for URI template parameter values can be changed using the <code class="literal">@Binding</code>
            annotation, E.g. the following three annotations are equivalent:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@InjectLink(value="widgets/{id}", bindings={
    @Binding(name="id" value="${resource.id}"}
)

@InjectLink(value="widgets/{value}", bindings={
    @Binding("${resource.id}")})
@InjectLink("widgets/${resource.id}")</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10698"></a>13.6.&nbsp;Conditional Link Injection</h2></div></div></div><p>
            Link value injection can be made conditional by use of the <code class="literal">condition</code> property.
            The value of this property is a boolean EL expression and a link will only be injected if the condition
            expression evaluates to true. E.g.:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@InjectLink(value="widgets/${instance.id}/offers",
    condition="${instance.offers}")
URI offers;</pre><p>
        </p><p>
            In the above, a URI will only be injected into the <code class="literal">offers</code> field if the
            <code class="literal">offers</code> property of the instance is <code class="literal">true</code>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10720"></a>13.7.&nbsp;Link Headers</h2></div></div></div><p>
            <a class="link" href="http://tools.ietf.org/html/rfc5988#section-5" target="_top">HTTP Link headers</a> can also be added
            to responses using annotations. Instead of annotating the fields of an entity class with
            <code class="literal">@InjectLink</code>, you instead annotate the entity class itself with
            <code class="literal">@InjectLinks</code>. E.g.:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@InjectLinks(
    @InjectLink(value="widgets/${resource.nextId}", rel="next")
)</pre><p>
        </p><p>
            The above would insert a HTTP Link header into any response whose entity was thus annotated.
            The <code class="literal">@InjectLink</code> annotation contains properties that map to the parameters
            of the HTTP Link header. The above specifies the link relation as <code class="literal">next</code>.
            All properties of the <code class="literal">@InjectLink</code> annotation may be used as described above.
        </p><p>
            Multiple link headers can be added by use of the <code class="literal">@InjectLinks</code> annotation
            which can contain multiple <code class="literal">@InjectLink</code> annotations.
        </p><p>
            Resource links via <code class="literal">@ProvideLink</code> are currently not supported for link headers.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10761"></a>13.8.&nbsp;Prevent Recursive Injection</h2></div></div></div><p>
            By default, Jersey will try to recursively find all <code class="literal">@InjectionLink</code> annotations in
            the members of your object unless this member is annotated with <code class="literal">@XmlTransient</code>.

            But in some cases, you might want to control which member will be introspected regardless of the
            <code class="literal">@XmlTransient</code> annotation.

            You can prevent Jersey to look into an object by adding <code class="literal">@InjectLinkNoFollow</code> to a field.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@InjectLinkNoFollow
Context context;</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10781"></a>13.9.&nbsp;Meta-annotation support</h2></div></div></div><p>
            The <code class="literal">@ProvideLink</code> annotation can be used as a meta-annotation, i.e., annotating your own annotation.
            This enables you to create custom annotations to reuse <code class="literal">@ProvideLink</code> configurations instead of
            copy pasting them on each method. There is a special marker class <code class="literal">ProvideLink.InheritFromAnnotation</code>
            that can be used in place of the actual entity class, this indicates that the <code class="literal">Class&lt;?&gt; value()</code>
            from the custom annotation should be used instead.

            Repeated annotations are currently unsupported for this feature. Also the  <code class="literal">Class&lt;?&gt; value()</code>
            method must return a single class and not an array of classes.
        </p><p>

            Here is an example (getter/setter omitted for brevity) of how a meta annotation can be used.
            The example app uses a <code class="literal">Page</code> class as a base class for all entities that contain paged data.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Page {
    private int number;

    private int size;

    private boolean isPreviousPageAvailable;

    private boolean isNextPageAvailable;

    @InjectLinks
    private List&lt;Link&gt; links;
}</pre><p>

            Instead of duplicating the <code class="literal">@ProvideLink</code> annotations for the  next and previous links on every
            method, we create the following <code class="literal">@PageLinks</code> annotation.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@ProvideLink(value = ProvideLink.InheritFromAnnotation.class, rel = "next",
    bindings = {
        @Binding(name = "page", value = "${instance.number + 1}"),
        @Binding(name = "size", value = "${instance.size}"),
    }, condition = "${instance.nextPageAvailable}")
@ProvideLink(value = ProvideLink.InheritFromAnnotation.class, rel = "prev",
    bindings = {
        @Binding(name = "page", value = "${instance.number - 1}"),
        @Binding(name = "size", value = "${instance.size}"),
    }, condition = "${instance.previousPageAvailable}")
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface PageLinks {
  Class&lt;?&gt; value();
}</pre><p>

            The annotation can the then be used on the resource methods with the actual entity class as <code class="literal">value</code>.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@PageLinks(OrderPage.class)
@GET
public Response list(@QueryParam("page") @DefaultValue("0") int page,
                     @QueryParam("size") @DefaultValue("20") int size)</pre><p>

            The entity just extends from <code class="literal">Page</code> and declares its content. It is necessary to use distinct classes
            instead of just a generic page to have a unique target for <code class="literal">@ProvideLink</code>, otherwise every method
            annotated with <code class="literal">@ProvideLink(value=Page.class)</code> would contribute to the entity.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class OrderPage extends Page {
    private List&lt;Order&gt; orders;
}</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10836"></a>13.10.&nbsp;Configure and register</h2></div></div></div><p>
            In order to add the Declarative Linking feature register <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/linking/DeclarativeLinkingFeature.html" target="_top">DeclarativeLinkingFeature</a>

            </p><div class="example"><a name="d0e10844"></a><p class="title"><b>Example&nbsp;13.1.&nbsp;Creating JAX-RS application with Declarative Linking feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        .packages("org.glassfish.jersey.examples.linking")
        .register(DeclarativeLinkingFeature.class);</pre></div></div><p><br class="example-break">
        </p></div><div class="footnotes"><br><hr style="width:100; text-align:left;margin-left: 0"><div id="ftn.d0e10572" class="footnote"><p><a href="#d0e10572" class="para"><sup class="para">[1] </sup></a>
                    Where <code class="literal">/context</code> is the application deployment context.
                </p></div></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="resource-builder"></a>Chapter&nbsp;14.&nbsp;Programmatic API for Building Resources</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e10854">14.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e10899">14.2. Programmatic Hello World example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10971">14.2.1. Deployment of programmatic resources</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11033">14.3. Additional examples</a></span></dt><dt><span class="section"><a href="#d0e11093">14.4. Model processors</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10854"></a>14.1.&nbsp;Introduction</h2></div></div></div><p>A standard approach of developing JAX-RS application is to implement resource classes annotated with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a>
            with resource methods annotated with HTTP method annotations like <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a> or <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/POST.html" target="_top">@POST</a> and
            implement needed functionality. This approach is described in the chapter
            <a class="link" href="jaxrs-resources.html" target="_top">JAX-RS Application, Resources and Sub-Resources</a>. Besides this standard
            JAX-RS approach, Jersey offers an API for constructing resources programmatically.
            </p><p>
            Imagine a situation where a deployed JAX-RS application consists of many resource classes. These resources implement
            standard HTTP methods like  <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/POST.html" target="_top">@POST</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/DELETE.html" target="_top">@DELETE</a>. In some situations it would be useful to add
            an <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/OPTIONS.html" target="_top">@OPTIONS</a> method which would return some kind of meta data about the deployed resource. Ideally, you would
            want to expose the functionality as an additional feature and you want to decide at the deploy time whether you want
            to add your custom <code class="literal">OPTIONS</code> method. However, when custom <code class="literal">OPTIONS</code> method are not
            enabled you would like to be <code class="literal">OPTIONS</code> requests handled in the standard way by JAX-RS runtime. To
            achieve this you would need to modify the code to add or remove custom <code class="literal">OPTIONS</code> methods before
            deployment. Another way would be to use programmatic API to build resource according to your needs.
        </p><p>
            Another use case of programmatic resource builder API is when you build any generic RESTful interface which
            depends on lot of configuration parameters or for example database structure. Your resource classes would
            need to have different methods, different structure for every new application deploy. You could use more solutions
            including approaches where your resource classes would be built using Java byte code manipulation.
            However, this is exactly the case when you can solve the problem cleanly with the programmatic resource builder API.
            Let's have a closer look at how the API can be utilized.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10899"></a>14.2.&nbsp;Programmatic Hello World example</h2></div></div></div><p>
            Jersey Programmatic API was designed to fully support JAX-RS resource model. In other words, every resource that can
            be designed using standard JAX-RS approach via annotated resource classes can be also modelled using Jersey
            programmatic API. Let's try to build simple hello world resource using standard approach first and
            then using the Jersey programmatic resource builder API.
        </p><p>
            The following example shows standard JAX-RS "Hello world!" resource class.
            </p><div class="example"><a name="d0e10906"></a><p class="title"><b>Example&nbsp;14.1.&nbsp;A standard resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    @Path("helloworld")
                    public class HelloWorldResource {

                        @GET
                        @Produces("text/plain")
                        public String getHello() {
                            return "Hello World!";
                        }
                    }
                </pre></div></div><p><br class="example-break">
            This is just a simple resource class with one GET method returning "Hello World!" string that will be serialized
            as text/plain media type.
        </p><p>
            Now we will design this simple resource using programmatic API.
            </p><div class="example"><a name="d0e10914"></a><p class="title"><b>Example&nbsp;14.2.&nbsp;A programmatic resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    package org.glassfish.jersey.examples.helloworld;

                    import jakarta.ws.rs.container.ContainerRequestContext;
                    import jakarta.ws.rs.core.Application;
                    import jakarta.ws.rs.core.Response;
                    import org.glassfish.jersey.process.Inflector;
                    import org.glassfish.jersey.server.ResourceConfig;
                    import org.glassfish.jersey.server.model.Resource;
                    import org.glassfish.jersey.server.model.ResourceMethod;


                    public static class MyResourceConfig extends ResourceConfig {

                        public MyResourceConfig() {
                            final Resource.Builder resourceBuilder = Resource.builder();
                            resourceBuilder.path("helloworld");

                            final ResourceMethod.Builder methodBuilder = resourceBuilder.addMethod("GET");
                            methodBuilder.produces(MediaType.TEXT_PLAIN_TYPE)
                                    .handledBy(new Inflector&lt;ContainerRequestContext, String&gt;() {

                                @Override
                                public String apply(ContainerRequestContext containerRequestContext) {
                                    return "Hello World!";
                                }
                            });

                            final Resource resource = resourceBuilder.build();
                            registerResources(resource);
                        }
                    }
                </pre></div></div><p><br class="example-break">
            First, focus on the content of the <code class="literal">MyResourceConfig</code> constructor in the example.
            The Jersey programmatic resource model is constructed from <code class="literal">Resource</code>s that contain
            <code class="literal">ResourceMethod</code>s. In the example, a single resource would be constructed from a
            <code class="literal">Resource</code> containing one <code class="literal">GET</code> resource method that returns "Hello World!".
            The main entry point for building programmatic resources in Jersey is the
            <span class="emphasis"><em><code class="literal">Resource.Builder</code></em></span> class. <code class="literal">Resource.Builder</code> contains just
            a few methods like the <code class="literal">path</code> method used in the example, which sets the name of the path. Another
            useful method is a <code class="literal">addMethod(String path)</code> which adds a new method to the resource builder and
            returns a resource method builder for the new method. Resource method builder contains methods which
            set consumed and produced media type, define name bindings, timeout for asynchronous executions, etc. It is always
            necessary to define a resource method handler (i.e. the code of the resource method that will return "Hello World!").
            There are more options how a resource method can be handled. In the example the implementation of
            <code class="literal">Inflector</code> is used. The Jersey <code class="literal">Inflector</code> interface defines a simple contract for
            transformation of a request into a response. An inflector can either return a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a> or directly
            an entity object, the way it is shown in the example. Another option is to setup a Java method handler using
            <code class="literal">handledBy(Class&lt;?&gt; handlerClass, Method method)</code> and pass it the chosen
            <code class="literal">java.lang.reflect.Method</code> instance together with the enclosing class.
        </p><p>
            A resource method model construction can be explicitly completed by invoking <code class="literal">build()</code> on the
            resource method builder. It is however not necessary to do so as the new resource method model will be built
            automatically once the parent resource is built. Once a resource model is built, it is registered
            into the resource config at the last line of the <code class="literal">MyResourceConfig</code> constructor in the example.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10971"></a>14.2.1.&nbsp;Deployment of programmatic resources</h3></div></div></div><p>
                Let's now look at how a programmatic resources are deployed.
                The easiest way to setup your application as well as register any programmatic resources in Jersey
                is to use a Jersey <code class="literal">ResourceConfig</code> utility class, an extension of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a>
                class.
                If you deploy your Jersey application into a Servlet container you will need to provide a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a>
                subclass that will be used for configuration. You may use a <code class="literal">web.xml</code> where you would define a
                <code class="literal">org.glassfish.jersey.servlet.ServletContainer</code> Servlet entry there and specify initial parameter
                <code class="literal">jakarta.ws.rs.Application</code> with the class name of your JAX-RS Application that you
                wish to deploy. In the example above, this application will be <code class="literal">MyResourceConfig</code> class. This is
                the reason why <code class="literal">MyResourceConfig</code> extends the <code class="literal">ResourceConfig</code> (which, if you
                remember extends the <code class="literal">jakarta.ws.rs.Application</code>).
            </p><p>
                The following example shows a fragment of <code class="literal">web.xml</code> that can be used to deploy the
                <code class="literal">ResourceConfig</code> JAX-RS application.
                </p><div class="example"><a name="d0e11014"></a><p class="title"><b>Example&nbsp;14.3.&nbsp;A programmatic resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">
                        ...
                        &lt;servlet&gt;
                            &lt;servlet-name&gt;org.glassfish.jersey.examples.helloworld.MyApplication&lt;/servlet-name&gt;
                            &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt;
                            &lt;init-param&gt;
                                &lt;param-name&gt;jakarta.ws.rs.Application&lt;/param-name&gt;
                                &lt;param-value&gt;org.glassfish.jersey.examples.helloworld.MyResourceConfig&lt;/param-value&gt;
                            &lt;/init-param&gt;
                            &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
                        &lt;/servlet&gt;
                        &lt;servlet-mapping&gt;
                            &lt;servlet-name&gt;org.glassfish.jersey.examples.helloworld.MyApplication&lt;/servlet-name&gt;
                            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
                        &lt;/servlet-mapping&gt;
                        ...
                    </pre></div></div><p><br class="example-break">
            </p><p>
                If you use another deployment options and you have accessible instance of ResourceConfig which you use
                for configuration, you can register programmatic resources directly by <code class="literal">registerResources()</code>
                method called on the ResourceConfig. Please note that the method registerResources() replaces all the previously
                registered resources.
            </p><p>
                Because Jersey programmatic API is not a standard JAX-RS feature the <code class="literal">ResourceConfig</code> must be
                used to register programmatic resources as shown above. See <a class="link" href="#deployment" title="Chapter&nbsp;4.&nbsp;Application Deployment and Runtime Environments">deployment chapter</a>
                for more information.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11033"></a>14.3.&nbsp;Additional examples</h2></div></div></div><p>
            </p><div class="example"><a name="d0e11038"></a><p class="title"><b>Example&nbsp;14.4.&nbsp;A programmatic resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    final Resource.Builder resourceBuilder = Resource.builder(HelloWorldResource.class);
                    resourceBuilder.addMethod("OPTIONS")
                        .handledBy(new Inflector&lt;ContainerRequestContext, Response&gt;() {
                            @Override
                            public Response apply(ContainerRequestContext containerRequestContext) {
                                return Response.ok("This is a response to an OPTIONS method.").build();
                            }
                        });
                    final Resource resource = resourceBuilder.build();
                </pre></div></div><p><br class="example-break">
        </p><p>
            In the example above the <code class="literal">Resource</code> is built from
            a <code class="literal">HelloWorldResource</code> resource class. The resource model built this way
            contains a <code class="literal">GET</code> method producing <code class="literal">'text/plain'</code> responses with "Hello World!" entity.
            This is quite important as it allows you to build whatever Resource objects based on introspecting
            existing JAX-RS resources and use builder API to enhance such these standard resources.
            In the example we used already implemented <code class="literal">HelloWorldResource</code> resource class
            and enhanced it by <code class="literal">OPTIONS</code> method. The <code class="literal">OPTIONS</code> method is handled by an Inflector which
            returns <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a>.
         </p><p>
            The following sample shows how to define sub-resource methods (methods that contains sub-path).
        </p><p>
            </p><div class="example"><a name="d0e11074"></a><p class="title"><b>Example&nbsp;14.5.&nbsp;A programmatic resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    final Resource.Builder resourceBuilder = Resource.builder("helloworld");

                    final Resource.Builder childResource = resourceBuilder.addChildResource("subresource");
                    childResource.addMethod("GET").handledBy(new GetInflector());

                    final Resource resource = resourceBuilder.build();
                </pre></div></div><p><br class="example-break">
        </p><p>
            Sub-resource methods are defined using so called <span class="emphasis"><em>child resource models</em></span>. Child
            resource models (or child resources) are programmatic resources build in the same way as any other
            programmatic resource but they are registered as a child resource of a parent resource. The child resource
            in the example is build directly from the parent builder using method
            <code class="literal">addChildResource(String path)</code>.
            However, there is also an option to build a child resource model separately as a standard resource and then
            add it as a child resource to a selected parent resource. This means that child resource objects
            can be reused to define child resources in different parent resources (you just build a single child resource
            and then register it in multiple parent resources). Each child resource groups methods with the same sub-resource
            path. Note that a child resource cannot have any child resources as there is nothing like sub-sub-resource
            method concept in JAX-RS. For example if a sub resource method contains more path segments in its path
            (e.g. "/root/sub/resource/method" where "root" is a path of the resource and "sub/resource/method" is the sub
            resource method path) then parent resource will have path "root" and child resource will have path
            "sub/resource/method" (so, there will not be any separate nested sub-resources for "sub", "resource" and "method").
        </p><p>
            See the javadocs of the resource builder API for more information.
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/model/Resource.Builder.html" target="_top">Resource.Builder</a>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11093"></a>14.4.&nbsp;Model processors</h2></div></div></div><p>
            Jersey gives you an option to register so called <span class="emphasis"><em>model processor providers</em></span>. These providers
            are able to modify or enhance the application resource model during application deployment. This is an advanced
            feature and will not be needed in most use cases. However, imagine you would like to add <code class="literal">OPTIONS</code> resource
            method to each deployed resource as it is described at the top of this chapter. You would want to do it for every
            programmatic resource that is registered as well as for all standard JAX-RS resources.
        </p><p>
            To do that, you first need to register a model processor provider in your application, which implements
            <code class="literal">org.glassfish.jersey.server.model.ModelProcessor</code> extension contract. An example of
            a model processor implementation is shown here:
            </p><div class="example"><a name="d0e11109"></a><p class="title"><b>Example&nbsp;14.6.&nbsp;A programmatic resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    import jakarta.ws.rs.GET;
                    import jakarta.ws.rs.Path;
                    import jakarta.ws.rs.Produces;
                    import jakarta.ws.rs.container.ContainerRequestContext;
                    import jakarta.ws.rs.core.Application;
                    import jakarta.ws.rs.core.Configuration;
                    import jakarta.ws.rs.core.MediaType;
                    import jakarta.ws.rs.core.Response;
                    import jakarta.ws.rs.ext.Provider;

                    import org.glassfish.jersey.process.Inflector;
                    import org.glassfish.jersey.server.model.ModelProcessor;
                    import org.glassfish.jersey.server.model.Resource;
                    import org.glassfish.jersey.server.model.ResourceMethod;
                    import org.glassfish.jersey.server.model.ResourceModel;

                    @Provider
                    public static class MyOptionsModelProcessor implements ModelProcessor {

                        @Override
                        public ResourceModel processResourceModel(ResourceModel resourceModel, Configuration configuration) {
                            // we get the resource model and we want to enhance each resource by OPTIONS method
                            ResourceModel.Builder newResourceModelBuilder = new ResourceModel.Builder(false);
                            for (final Resource resource : resourceModel.getResources()) {
                                // for each resource in the resource model we create a new builder which is based on the old resource
                                final Resource.Builder resourceBuilder = Resource.builder(resource);

                                // we add a new OPTIONS method to each resource
                                // note that we should check whether the method does not yet exist to avoid failures
                                resourceBuilder.addMethod("OPTIONS")
                                    .handledBy(new Inflector&lt;ContainerRequestContext, String&gt;() {
                                        @Override
                                        public String apply(ContainerRequestContext containerRequestContext) {
                                            return "On this path the resource with " + resource.getResourceMethods().size()
                                                + " methods is deployed.";
                                        }
                                        }).produces(MediaType.TEXT_PLAIN)
                                          .extended(true); // extended means: not part of core RESTful API

                                // we add to the model new resource which is a combination of the old resource enhanced
                                // by the OPTIONS method
                                newResourceModelBuilder.addResource(resourceBuilder.build());
                            }

                            final ResourceModel newResourceModel = newResourceModelBuilder.build();
                            // and we return new model
                            return newResourceModel;
                        };

                        @Override
                        public ResourceModel processSubResource(ResourceModel subResourceModel, Configuration configuration) {
                            // we just return the original subResourceModel which means we do not want to do any modification
                            return subResourceModel;
                        }
                    }
                </pre></div></div><p><br class="example-break">
            The <code class="literal">MyOptionsModelProcessor</code> from the example is a relatively simple model processor which
            iterates over all registered resources and for all of them builds a new resource that is equal to the old resource
            except it is enhanced with a new <code class="literal">OPTIONS</code> method.
        </p><p>
            Note that you only need to register such a ModelProcessor as your custom extension provider in the same way as you
            would register any standard JAX-RS extension provider. During an application deployment, Jersey will look for any
            registered model processor and execute them. As you can see, model processors are very powerful as they can do
            any manipulations with the resource models. A model processor can even, for example, completely ignore
            the old resource model and return a new custom resource model with a single "Hello world!" resource, which would
            result in only the "Hello world!" resource being deployed in your application. Of course, it would not not make
            much sense to implement such model processor, but the scenario demonstrates how powerful the model processor concept
            is. A better, real-life use case scenario would, for example, be to always add some custom new resource to each
            application that might return additional metadata about the deployed application. Or, you might want to
            filter out particular resources or resource methods, which is another situation where a model processor could
            be used successfully.
        </p><p>
            Also note that <code class="literal">processSubResource(ResourceModel subResourceModel, Configuration configuration)</code>
            method is executed for each sub resource returned from the sub resource locator. The example is simplified and does
            not do any manipulation but probably in such a case you would want to enhance all sub resources with
            a new <code class="literal">OPTIONS</code> method handlers too.
        </p><p>
            It is important to remember that any model processor must always return valid resource model. As you might have
            already noticed, in the example above this important rule is not followed. If any of the resources in the original
            resource model would already have an <code class="literal">OPTIONS</code> method handler defined, adding another handler would cause
            the application fail during the deployment in the resource model validation phase. In order to retain the consistency
            of the final model, a model processor implementation would have to be more robust than what is shown in the example.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="jersey-configuration"></a>Chapter&nbsp;15.&nbsp;Jersey configuration</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#default-config">15.1. Jersey default configuration provider</a></span></dt><dt><span class="section"><a href="#mp-config">15.2. Micro profile configuration provider</a></span></dt></dl></div><p>
        This chapter provides Jersey configuration basics which includes configuration using default configuration
        provider (included in Jersey by default) using system properties, and micro-profile configuration extension
        which allows plugging-in of configuration modules based on micro profile configuration specification.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="default-config"></a>15.1.&nbsp;Jersey default configuration provider</h2></div></div></div><p>
            Since Jersey 2.29 it is possible to turn on the ability to convert the System properties into
            Configuration properties. That can be done by using the System property, too:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">java -Djersey.config.allowSystemPropertiesProvider=true -DNAME=VALUE
            </pre><p>
            Note that with the security manager turned on, write access permission is required to execute
            System.getProperties(). With insufficient permissions, the warning message is logged (with Level.FINER) and
            only <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html" target="_top">CommonProperties</a>, <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html" target="_top">ClientProperties</a>,
            and <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html" target="_top">ServerProperties</a>
            properties are used, as the property names are known and System.getProperty(name) method can be used,
            which does not require the write access permission.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mp-config"></a>15.2.&nbsp;Micro profile configuration provider</h2></div></div></div><p>
            Microprofile platform became very popular lately and <a class="link" href="https://microprofile.io/project/eclipse/microprofile-config" target="_top">Microprofile Config Specification</a>
            is a recommended way in the Jakarta EE world to configure the specifications under the Jakarta EE umbrella.
        </p><p>
            Jersey 2.29 comes with support for Microprofile Config implementation such as <a class="link" href="https://helidon.io/" target="_top">Helidon</a> or <a class="link" href="https://smallrye.io/" target="_top">SmallRye</a>.
            To configure the Jersey application, the microprofile-config.properties file needs to be created in the
            META-INF folder. The required properties are then simply set in the microprofile-config.properties:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">
                NAME=VALUE
            </pre><p>
        </p><p>
            Then Jersey Microprofile Config extension is needed to be added:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">
                &lt;dependency&gt;
                    &lt;groupId&gt;org.glassfish.jersey.ext.microprofile&lt;/groupId&gt;
                    &lt;artifactId&gt;jersey-mp-config&lt;/artifactId&gt;
                    &lt;version&gt;3.0.2&lt;/scope&gt;
                &lt;/dependency&gt;
            </pre><p>
            And the Microprofile Config implementation, such as Helidon:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">
                &lt;dependency&gt;
                    &lt;groupId&gt;io.helidon.microprofile.config&lt;/groupId&gt;
                    &lt;artifactId&gt;helidon-microprofile-config&lt;/artifactId&gt;
                    &lt;version&gt;2.1.0&lt;/version&gt;
                &lt;/dependency&gt;
            </pre><p>
            Or SmallRye:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">
                &lt;dependency&gt;
                    &lt;groupId&gt;io.smallrye&lt;/groupId&gt;
                    &lt;artifactId&gt;smallrye-config&lt;/artifactId&gt;
                    &lt;version&gt;1.5.0&lt;/version&gt;
                &lt;/dependency&gt;
            </pre><p>
            or any other suitable Microprofile Config implementation.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="sse"></a>Chapter&nbsp;16.&nbsp;Server-Sent Events (SSE) Support</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e11193">16.1. What are Server-Sent Events</a></span></dt><dt><span class="section"><a href="#d0e11236">16.2. When to use Server-Sent Events</a></span></dt><dt><span class="section"><a href="#jaxrs-sse-api-overview">16.3. Server-Sent Events API</a></span></dt><dt><span class="section"><a href="#d0e11298">16.4. Implementing SSE support in a JAX-RS resource (with JAX-RS SSE API)</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11301">16.4.1. Simple SSE resource method</a></span></dt><dt><span class="section"><a href="#d0e11477">16.4.2. Broadcasting with Jersey SSE</a></span></dt></dl></dd><dt><span class="section"><a href="#sse-client-jaxrs">16.5. Consuming SSE events within Jersey clients</a></span></dt><dd><dl><dt><span class="section"><a href="#sse-event-source-reconnect">16.5.1. 
                <code class="literal">SseEventSource</code>
                reconnect support
            </a></span></dt></dl></dd><dt><span class="section"><a href="#overview-jersey-specific">16.6. Jersey-specific Server-Sent Events API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11913">16.6.1. Implementing SSE support in a JAX-RS resource</a></span></dt><dt><span class="section"><a href="#d0e12102">16.6.2. Consuming SSE events with Jersey clients</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11193"></a>16.1.&nbsp;What are Server-Sent Events</h2></div></div></div><p>
            In a standard HTTP request-response scenario a client opens a connection, sends a HTTP request to the server (for
            example a HTTP <code class="literal">GET</code> request), then receives a HTTP response back and the server closes the connection once
            the response is fully sent/received. The initiative <span class="emphasis"><em>always</em></span> comes from a client when the client
            requests all the data. In contrast, <span class="emphasis"><em>Server-Sent Events (SSE)</em></span> is a mechanism that allows server
            to asynchronously push the data from the server to the client once the client-server connection is established by the
            client. Once the connection is established by the client, it is the server who provides the data and decides
            to send it to the client whenever new "chunk" of data is available. When a new data event occurs on the server,
            the data event is sent by the server to the client. Thus the name Server-Sent Events. Note that at high level there
            are more technologies working on this principle, a short overview of the technologies supporting server-to-client
            communication is in this list:

            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Polling</span></dt><dd><p>
                            With polling a client repeatedly sends new requests to a server. If the server has no new data,
                            then it send appropriate indication and closes the connection. The client then waits a bit and sends
                            another request after some time (after one second, for example).
                        </p></dd><dt><span class="term">Long-polling</span></dt><dd><p>
                            With long-polling a client sends a request to a server. If the server has no new data,
                            it just holds the connection open and waits until data is available. Once the server has data
                            (message) for the client, it uses the connection and sends it back to the client. Then the connection
                            is closed.
                        </p></dd><dt><span class="term">Server-Sent events</span></dt><dd><p>
                            SSE is similar to the long-polling mechanism, except it does not send only one message per connection.
                            The client sends a request and server holds a connection until a new message is ready, then it sends
                            the message back to the client while still keeping the connection open so that it can be used
                            for another message once it becomes available. Once a new message is ready, it is sent back to the
                            client on the same initial connection. Client processes the messages sent back from the server
                            individually without closing the connection after processing each message.
                            So, SSE typically reuses one connection for more messages (called events). SSE also defines a
                            dedicated media type that describes a simple format of individual events sent from the server to the
                            client. SSE also offers standard javascript client API implemented most modern browsers. For more
                            information about SSE, see the
                            <a class="link" href="https://www.w3.org/TR/eventsource/" target="_top">SSE API specification</a>.
                        </p></dd><dt><span class="term">WebSocket</span></dt><dd><p>
                            WebSocket technology is different from previous technologies as it provides a real full duplex
                            connection. The initiator is again a client which sends a request to a server with a special HTTP
                            header that informs the server that the HTTP connection may be "upgraded" to a full duplex TCP/IP
                            WebSocket connection. If server supports WebSocket, it may choose to do so. Once a WebSocket
                            connection is established, it can be used for bi-directional communication between the client and the
                            server. Both client and server can then send data to the other party at will whenever it is needed.
                            The communication on the new WebSocket connection is no longer based on HTTP protocol and can be
                            used for example for for online gaming or any other applications that require fast exchange of small
                            chunks of data in flowing in both directions.
                        </p></dd></dl></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11236"></a>16.2.&nbsp;When to use Server-Sent Events</h2></div></div></div><p>
            As explained above, SSE is a technology that allows clients to subscribe to event notifications that originate on
            a server. Server generates new events and sends these events back to the clients subscribed to receive the
            notifications. In other words, SSE offers a solution for a one-way publish-subscribe model.
        </p><p>
            A good example of the use case where SSE can be used is a simple message exchange RESTful service. Clients
            <code class="literal">POST</code> new messages to the service and subscribe to receive messages from other clients.
            Let's call the resource <code class="literal">messages</code>. While <code class="literal">POST</code>ing a new message to this resource involves
            a typical HTTP request-response communication between a client and the <code class="literal">messages</code> resource,
            subscribing to receive all new message notifications would be hard and impractical to model with a sequence of
            standard request-response message exchanges. Using Server-sent events provides a much more practical approach here.
            You can use SSE to let clients subscribe to the <code class="literal">messages</code> resource via standard <code class="literal">GET</code>
            request (use a SSE client API, for example javascript API or Jersey Client SSE API) and let the server broadcast
            new messages to all connected clients in the form of individual events (in our case using Jersey Server SSE API).
            Note that with Jersey a SSE support is implemented as an usual JAX-RS resource method. There's no need to do anything
            special to provide a SSE support in your Jersey/JAX-RS applications, your SSE-enabled resources are a standard part of
            your RESTful Web application that defines the REST API of your application. The following chapters describes SSE
            support in Jersey in more details.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jaxrs-sse-api-overview"></a>16.3.&nbsp;Server-Sent Events API</h2></div></div></div><p>
            In previous JAX-RS versions, no standard API for server-sent events was defined. The SSE support bundled with
            Jersey was Jersey-specific. With JAX-RS 2.1 (with respect to namespace change after jakartification),
            situation changed and SSE API is well defined in the <code class="literal">jakarta.ws.rs.sse</code> package.
        </p><p>Following chapters will describe the new SSE API. For backwards compatibility reasons, the original
            Jersey-specific API remains valid and will be described in
            <a class="xref" href="#overview-jersey-specific" title="16.6.&nbsp;Jersey-specific Server-Sent Events API">Section&nbsp;16.6, &#8220;Jersey-specific Server-Sent Events API&#8221;</a>
        </p><p>
            Jersey contains support for SSE for both - server and client. SSE in Jersey is implemented as an extension
            supporting a new media type using existing "chunked" messages support. However, in contrast to the original API,
            the instances of SSE related classes are not to be obtained manually by invoking constructors, nor to be directly
            returned from the resource methods.
            Actually, the implementing classes in the <code class="literal">jersey.media.sse.internal</code> package should never be needed
            to be imported. The only API to be used is directly in the JAX-RS package (<code class="literal">jakarta.ws.rs.sse</code>).
            Only builders in the API along with dependency injection should be used and provides access to the entire
            functionality.
        </p><p>
            In order to take advantage of the SSE support, the <code class="literal">jersey-media-sse</code> module has to be on classpath.
            In maven, this can be achieved by adding the dependency to the <span class="emphasis"><em>SSE media type module</em></span>:
            </p><div class="example"><a name="sse-dependency-jaxrs"></a><p class="title"><b>Example&nbsp;16.1.&nbsp;Adding the SSE dependency</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-sse&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></div></div><p><br class="example-break">
            The <code class="literal">Feature</code> defined in the module is (forced) auto-discoverable, which means having the module on
            classpath is sufficient, no need to further register it in the code.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11298"></a>16.4.&nbsp;Implementing SSE support in a JAX-RS resource (with JAX-RS SSE API)</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11301"></a>16.4.1.&nbsp;Simple SSE resource method</h3></div></div></div><div class="example"><a name="example-simple-sse-jaxrs"></a><p class="title"><b>Example&nbsp;16.2.&nbsp;Simple SSE resource method</b></p><div class="example-contents">
                As mentioned above, the SSE related are not instantiated directly. In this case, Jersey takes care of the
                dependencies and injects the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSink.html" target="_top">SseEventSink</a> (represents the output) and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/Sse.html" target="_top">Sse</a> (provides
                factory methods for other SSE related types, in this case it is used to retrieve the event builder).
                <pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import jakarta.ws.rs.sse.Sse;
import jakarta.ws.rs.sse.SseEventSink;
import jakarta.ws.rs.sse.OutboundSseEvent;
...

@Path("events")
public static class SseResource {

    @GET
    @Produces(MediaType.SERVER_SENT_EVENTS)
    public void getServerSentEvents(@Context SseEventSink eventSink, @Context Sse sse) {
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                // ... code that waits 1 second
                final OutboundSseEvent event = sse.newEventBuilder()
                    .name("message-to-client")
                    .data(String.class, "Hello world " + i + "!")
                    .build();
                eventSink.send(event);
            }
        }).start();
    }
}
                </pre></div></div><br class="example-break"><p>
                The code above defines the resource deployed on URI "/events". This resource has a single
                <code class="literal">@GET</code>
                resource method which <span class="emphasis"><em>returns void</em></span>. This is an imported difference
                against the original API. It is Jersey's responsibility to bind the injected <code class="literal">SseEventSink</code> to
                the output chain.
            </p><p>
                After the <code class="literal">SseEventInput</code> is "returned" from the method, the Jersey runtime recognizes that this
                is a <code class="literal">ChunkedOutput</code> extension and does not close the client connection immediately. Instead, it
                writes the HTTP headers to the response stream and waits for more chunks (SSE events) to be sent. At this point
                the client can read headers and starts listening for individual events.
            </p><p>
                In the <a class="xref" href="#example-simple-sse-jaxrs" title="Example&nbsp;16.2.&nbsp;Simple SSE resource method">Example&nbsp;16.2, &#8220;Simple SSE resource method&#8221;</a>, the resource method creates a new thread that sends a
                sequence of 10 events. There is a 1 second delay between two subsequent events as indicated in a comment. Each
                event is represented by <code class="literal">jakarta.ws.rs.sse.OutboundSseEvent</code> type and is built with a help of a
                provided <code class="literal">Builder</code>. The <code class="literal">Builder</code> is obtain via the injected instance
                (actually, it is a singleton) of <code class="literal">jakarta.ws.rs.sse.Sse</code> (the
                <code class="literal">newEventBuilder()</code>
                method). The <code class="literal">OutboundSseEvent</code> implementation reflects the standardized format of
                SSE messages and contains properties that represent <code class="literal">name</code> (for named events),
                <code class="literal">comment</code>, <code class="literal">data</code> or <code class="literal">id</code>. The code also sets the
                event data media type using the <code class="literal">mediaType(MediaType)</code> method on the
                <code class="literal">eventBuilder</code>. The media type, together with the data type set by the
                <code class="literal">data(Class, Object)</code>
                method (in our case <code class="literal">String.class</code>), is used
                for serialization of the event data. Note that the event data media type will not be written to any headers as
                the response <code class="literal">Content-type</code> header is already defined by the <code class="literal">@Produces</code> and set to
                <code class="literal">"text/event-stream"</code>
                using constant from the <code class="literal">MediaType</code>.
                The event media type is used for serialization of event <code class="literal">data</code>. Event data media type and Java
                type are used to select the proper <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for event data serialization and are passed
                to the selected writer that serializes the event <code class="literal">data</code> content. In our case the string
                <code class="literal">"Hello world " + i + "!"</code>
                is serialized as <code class="literal">"text/plain"</code>. In event
                <code class="literal">data</code>
                you can send any Java entity and associate it with any media type that you would be able
                to serialize with an available <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Typically, you may want to send e.g. JSON data,
                so you would fill the <code class="literal">data</code> with a JAXB annotated bean instance and define media type to JSON.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If the event media type is not set explicitly, the <code class="literal">"text/plain"</code> media type is used
                        by default.
                    </p></div><p>
            </p><p>
                Once an outbound event is ready, it can be written to the <code class="literal">EventSink</code>. At that point the event
                is serialized by internal <code class="literal">OutboundEventWriter</code> which uses an appropriate
                <code class="literal">MessageBodyWriter&lt;T&gt;</code> to serialize the <code class="literal">"Hello world " + i + "!"</code> string. You can
                send as many messages as you like. At the end of the thread execution the response is closed which also closes
                the connection to the client. After that, no more messages can be sent to the client on this connection. If the
                client would like to receive more messages, it would have to send a new request to the server to initiate a
                new SSE streaming connection.
            </p><p>
                A client connecting to our SSE-enabled resource will receive the following data from the entity stream:

                </p><pre class="screen">event: message-to-client
data: Hello world 0!

event: message-to-client
data: Hello world 1!

event: message-to-client
data: Hello world 2!

event: message-to-client
data: Hello world 3!

event: message-to-client
data: Hello world 4!

event: message-to-client
data: Hello world 5!

event: message-to-client
data: Hello world 6!

event: message-to-client
data: Hello world 7!

event: message-to-client
data: Hello world 8!

event: message-to-client
data: Hello world 9!
                </pre><p>

                Each message is received with a delay of one second.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    If you have worked with streams in JAX-RS, you may wonder what is the difference between
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ChunkedOutput.html" target="_top">ChunkedOutput</a> and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/StreamingOutput.html" target="_top">StreamingOutput</a>.
                </p><p>
                    <code class="literal">ChunkedOutput</code> is Jersey-specific API. It lets you send "chunks" of data without closing
                    the client connection using series of convenient calls to <code class="literal">ChunkedOutput.write</code> methods
                    that take POJO + chunk media type as an input and then use the configured JAX-RS
                    <code class="literal">MessageBodyWriter&lt;T&gt;</code> providers to figure out the proper way of serializing each chunk POJO
                    to bytes. Additionally, <code class="literal">ChunkedOutput</code> writes can be invoked multiple times on the same
                    outbound response connection, i.e. individual chunks are written in each write, not the full response entity.
                </p><p>
                    <code class="literal">StreamingOutput</code> is, on the other hand, a low level JAX-RS API that works with bytes
                    directly. You have to implement <code class="literal">StreamingOutput</code> interface yourself. Also, its
                    <code class="literal">write(OutputStream)</code>
                    method will be invoked by JAX-RS runtime only once per response
                    and the call to this method is blocking, i.e. the method is expected to write the entire entity body
                    before returning.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11477"></a>16.4.2.&nbsp;Broadcasting with Jersey SSE</h3></div></div></div><p>
                JAX-RS SSE API defines <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseBroadcaster.html" target="_top">SseBroadcaster</a> which allows to broadcast individual events to multiple
                clients. A simple broadcasting implementation is shown in the following example:

                </p><div class="example"><a name="d0e11485"></a><p class="title"><b>Example&nbsp;16.3.&nbsp;Broadcasting SSE messages (with JAX-RS 3.0 API)</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import jakarta.ws.rs.sse.Sse;
import jakarta.ws.rs.sse.SseEventSink;
import jakarta.ws.rs.sse.SseBroadcaster;
...

@Singleton
@Path("broadcast")
public static class BroadcasterResource {
    private Sse sse;
    private SseBroadcaster broadcaster;

    public BroadcasterResource(@Context final Sse sse) {
        this.sse = sse;
        this.broadcaster = sse.newBroadcaster();
    }

    @POST
    @Produces(MediaType.TEXT_PLAIN)
    @Consumes(MediaType.TEXT_PLAIN)
    public String broadcastMessage(String message) {
        final OutboundSseEvent event = sse.newEventBuilder()
            .name("message")
            .mediaType(MediaType.TEXT_PLAIN_TYPE)
            .data(String.class, message)
            .build();

        broadcaster.broadcast(event);

        return "Message '" + message + "' has been broadcast.";
    }

    @GET
    @Produces(MediaType.SERVER_SENT_EVENTS)
    public void listenToBroadcast(@Context SseEventSink eventSink) {
        this.broadcaster.register(eventSink);
    }
}
                    </pre></div></div><p><br class="example-break">
                Let's explore the example together. The <code class="literal">BroadcasterResource</code> resource class is annotated with
                <a class="link" href="https://jakarta.ee/specifications//dependency-injection/2.0/apidocs/jakarta/inject/singleton" target="_top">@Singleton</a> annotation which tells Jersey runtime that only a single instance of the resource
                class should be used to serve all the incoming requests to <code class="literal">/broadcast</code> path. This is needed as
                we want to keep an application-wide single reference to the private <code class="literal">broadcaster</code> field so
                we can use the same instance for all requests. Clients that want to listen to SSE events first send a
                <code class="literal">GET</code> request to the <code class="literal">BroadcasterResource</code>, that is handled by the
                <code class="literal">listenToBroadcast()</code>
                resource method.
                The method is injected with a new <code class="literal">SseEventSink</code> representing the connection to the
                requesting client and registers this <code class="literal">eventSink</code> instance with the singleton
                <code class="literal">broadcaster</code>
                by calling its <code class="literal">subscribe()</code> method.
                The method then, as already explained returns <code class="literal">void</code> and Jersey runtime is responsible for
                binding the injected <code class="literal">EventSink</code> instance so as it would have been returned from the resource
                method (note that really returning the <code class="literal">EventSink</code> from the resource method will cause
                failure) and to bind the <code class="literal">eventSink</code> instance with the requesting client and send the
                response HTTP headers to the client. The client connection remains open and the client is now waiting ready to
                receive new SSE events. All the events are written to the <code class="literal">eventSink</code> by
                <code class="literal">broadcaster</code>
                later on. This way developers can conveniently handle sending new events to
                all the clients that subscribe to them.
            </p><p>
                When a client wants to broadcast new message to all the clients listening on their SSE connections,
                it sends a <code class="literal">POST</code> request to <code class="literal">BroadcasterResource</code> resource with the message content.
                The method <code class="literal">broadcastMessage(String)</code> is invoked on
                <code class="literal">BroadcasterResource</code>
                resource with the message content as an input parameter. A new SSE outbound event is built in the standard way
                and passed to the broadcaster. The broadcaster internally invokes <code class="literal">write(OutboundEvent)</code> on all
                registered <code class="literal">EventSink</code>s. After that the method just returns a standard text response
                to the <code class="literal">POST</code>ing client to inform the client that the message was successfully broadcast. As you can see,
                the <code class="literal">broadcastMessage(String)</code> resource method is just a simple JAX-RS resource method.
            </p><p>
                In order to implement such a scenario, you may have noticed, that the
                <code class="literal">SseBroadcaster</code>
                is not mandatory to complete the use case. Individual <code class="literal">EventSink</code>s can be just stored in
                a collection and iterated over in the <code class="literal">broadcastMessage</code> method. However, the
                <code class="literal">SseBroadcaster</code>
                internally identifies and handles also client disconnects. When a client
                closes the connection, the broadcaster detects this and removes the stale connection from the internal collection
                of the registered <code class="literal">EventSink</code>s as well as it frees all the server-side resources associated with
                the stale connection.
                Additionally, the <code class="literal">SseBroadcaster</code> is implemented to be thread-safe, so that clients can connect
                and disconnect at any time and <code class="literal">SseBroadcaster</code> will always broadcast messages to the most recent
                collection of registered and active set of clients.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sse-client-jaxrs"></a>16.5.&nbsp;Consuming SSE events within Jersey clients</h2></div></div></div><p>
            On the client side, push programming model is used (event consumer / client) gets asynchronously notified about
            incoming events by subscribing custom listener to <code class="literal">jakarta.ws.rs.sse.SseEventSource</code>. This happens by
            invoking one of its <code class="literal">subscribe()</code> methods.
        </p><p>
            The usage of <code class="literal">SseEventSource</code> is shown in the following example.
            </p><div class="example"><a name="sse-event-source-example"></a><p class="title"><b>Example&nbsp;16.4.&nbsp;Consuming SSE events with SseEventSource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import jakarta.ws.rs.sse.SseEventSource;
...
Client client = ClientBuilder.newBuilder().build();
WebTarget target = client.target("http://example.com/events");
SseEventSource sseEventSource = SseEventSource.target(target).build();
sseEventSource.register(event -&gt; System.out.println(event.getName() + "; "
    + event.readData(String.class)));
sseEventSource.open();

// do other stuff, block here and continue when done

sseEventSource.close();
                </pre></div></div><p><br class="example-break">
            In this example, the client code connects to the server where the <code class="literal">SseResource</code> from the
            <a class="xref" href="#example-simple-sse-jaxrs" title="Example&nbsp;16.2.&nbsp;Simple SSE resource method">Example&nbsp;16.2, &#8220;Simple SSE resource method&#8221;</a>
            is deployed. The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a> instance
            is created (and initialized with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a> automatically). Then the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> is built.
            In this case a request to the web target is not made directly in the code, instead, the web target instance
            is used to initialize a new <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.Builder.html" target="_top">SseEventSource.Builder</a> instance that is used to build a new
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.html" target="_top">SseEventSource</a>. The choice of <code class="literal">build()</code> method is important, as it tells
            the <code class="literal">SseEventSource.Builder</code> to create a new <code class="literal">SseEventSource</code> that is not
            automatically connected to the <code class="literal">target</code>. The connection is established only later by manually
            invoking the <code class="literal">sseEventSource.open()</code> method. A custom
            <code class="literal">java.util.function.Consumer&lt;InboundSseEvent&gt;</code>
            implementation is used to listen to and
            process incoming SSE events. The method readData(Class) says that the
            event data should be de-serialized from a received <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/InboundSseEvent.html" target="_top">InboundSseEvent</a> instance into a
            <code class="literal">String</code>
            Java type. This method call internally executes <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> which
            de-serializes the event data. This is similar to reading an entity from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a> by
            <code class="literal">readEntity(Class)</code>. The method <code class="literal">readData</code> can throw a
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ProcessingException.html" target="_top">ProcessingException</a>.
        </p><p>
            After a connection to the server is opened by calling the <code class="literal">open()</code> method on the event source,
            the <code class="literal">eventSource</code> starts listening to events. When an event comes, the listener will be executed
            by the event source. Once the client is done with processing and does not want to receive events the connection by
            calling the <code class="literal">close()</code> method on the event source.
        </p><p>
            The listener from the example above will print the following output:
            </p><pre class="screen">message-to-client; Hello world 0!
message-to-client; Hello world 1!
message-to-client; Hello world 2!
message-to-client; Hello world 3!
message-to-client; Hello world 4!
message-to-client; Hello world 5!
message-to-client; Hello world 6!
message-to-client; Hello world 7!
message-to-client; Hello world 8!
message-to-client; Hello world 9!
            </pre><p>
        </p><p>
            There are other events than the incoming data that also may occur. The <code class="literal">SseEventSource</code> for
            instance always signals, that it has finished processing events, or there might also be an error while processing the
            messages. <code class="literal">SseEventSource</code>. There are total of four overloaded
            <code class="literal">subscribe()</code>
            methods defined in the API.
        </p><p>
            </p><div class="example"><a name="sse-event-source-subscribe-methods"></a><p class="title"><b>Example&nbsp;16.5.&nbsp;SseEventSource subscribe() methods</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// 1. basic one - the one we used in the example
void subscribe(Consumer&lt;InboundSseEvent&gt; onEvent);

// 2. with an error callback
void subscribe(Consumer&lt;InboundSseEvent&gt; onEvent, Consumer&lt;Throwable&gt; onError);

// 3. with an error callback and completion callback
void subscribe(Consumer&lt;InboundSseEvent&gt; onEvent, Consumer&lt;Throwable&gt; onError, Runnable onComplete)

// 4. complete one - with error callback, completion callback an onSubscribe callback
void subscribe(Consumer&lt;SseSubscription&gt; onSubscribe, Consumer&lt;InboundSseEvent&gt; onEvent, Consumer&lt;Throwable&gt;
onError,
Runnable
onComplete);
                </pre></div></div><p><br class="example-break">

                Few notes to the <code class="literal">subscribe()</code> methods:
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            All the overloaded methods have the <code class="literal">onEvent</code> handler. As shown in the example,
                            this parameter is used to consume the SSE events with data.
                        </p></li><li class="listitem"><p>
                            Except the basic one-arg method, all the others contain an <code class="literal">onError</code> handler. In
                            case of error, the <code class="literal">SseEventSource</code> invokes the <code class="literal">onError</code> method
                            of all its subscribers, that registered the handler. This makes it possible to react to the error
                            conditions in a custom manner.
                        </p></li><li class="listitem"><p>
                            Another possible argument is the <code class="literal">onComplete</code> handler. If registered (used an
                            appropriate <code class="literal">subscribe()</code> method, that has the
                            <code class="literal">onComplete</code>
                            argument), it is invoked (for all the subscribers) every time when the
                            <code class="literal">SseEventSource</code>
                            terminates normally. Either <code class="literal">onComplete</code> or
                            <code class="literal">onError</code>
                            should be called every time.
                        </p></li><li class="listitem"><p>
                            The complete <code class="literal">subscribe()</code> method adds the <code class="literal">onSubscribe()</code> callback.
                            This gives the subscriber a tool to manage the load and do a back-pressure by incrementally
                            requesting only certain amount of items. When <code class="literal">SseEventSource</code> registers a new
                            subscriber, it calls its <code class="literal">onSubscribe</code> handler and hands over the
                            <code class="literal">jakarta.ws.rs.sse.SseSubscription</code>
                            instance. This class only has two methods -
                            <code class="literal">request(long)</code>
                            for asking for a certain amount of events (often used as
                            <code class="literal">request(Long.MAX_VALUE)</code>
                            when no back-pressure is needed) and
                            <code class="literal">cancel()</code>
                            to stop receiving further events.
                        </p></li><li class="listitem"><p>
                            When using the full-arg version of <code class="literal">subscribe()</code>, it is the caller's
                            responsibility to manage the amount of data it can handle. The
                            <code class="literal">sseSubscription.request()</code>
                            method <span class="emphasis"><em>MUST</em></span> be called, otherwise
                            the subscriber will not receive ANY data. Furthermore, in the current
                            <code class="literal">SseEventSource</code>
                            implementation, such a subscriber will block a thread and will
                            occasionally lead to overflow of an internal buffer in <code class="literal">SseEventSource</code>. As
                            mentioned, calling <code class="literal">subscription.request(Long.MAX_VALUE)</code>, e.g. in the registered
                            <code class="literal">onSubscribe</code>
                            handler is sufficient (and is also a default behaviour for all the
                            other overloaded methods).
                        </p></li></ul></div><p>



        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sse-event-source-reconnect"></a>16.5.1.&nbsp;
                <code class="literal">SseEventSource</code>
                reconnect support
            </h3></div></div></div><p>
                The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.html" target="_top">SseEventSource</a> implementation supports automated recuperation
                from a connection loss, including negotiation of delivery of any missed events based on the last received
                SSE event <code class="literal">id</code> field value, provided this field is set by the server and the negotiation
                facility is supported by the server. In case of a connection loss, the last received SSE event
                <code class="literal">id</code>
                field value is sent in the <code class="literal">Last-Event-ID</code> HTTP request
                header as part of a new connection request sent to the SSE endpoint. Upon a receipt of such reconnect request,
                the SSE endpoint that supports this negotiation facility is expected to replay all missed events.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Note, that SSE lost event negotiation facility is a best-effort mechanism which does not provide
                    any guarantee that all events would be delivered without a loss. You should therefore not
                    rely on receiving every single event and design your client application code accordingly.
                </p></div><p>
                By default, when a connection to the SSE endpoint is lost, the event source will use a default delay
                before attempting to reconnect to the SSE endpoint. The SSE endpoint can however control the client-side
                retry delay by including a special <code class="literal">retry</code> field value in any event sent to the client.
                Jersey <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.html" target="_top">SseEventSource</a> implementation automatically tracks any received SSE event
                <code class="literal">retry</code>
                field values set by the endpoint and adjusts the reconnect delay accordingly,
                using the last received <code class="literal">retry</code> field value as the new reconnect delay.
            </p><p>
                In addition to handling the standard connection losses, Jersey <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.html" target="_top">SseEventSource</a> automatically
                deals with any <code class="literal">HTTP 503 Service Unavailable</code> responses received from the SSE endpoint,
                that include a <code class="literal">Retry-After</code> HTTP header with a valid value. The
                <code class="literal">HTTP 503 + Retry-After</code>
                technique is often used by HTTP endpoints as a means of
                connection and traffic throttling. In case a <code class="literal">HTTP 503 + Retry-After</code> response is received
                in return to a connection request from SSE endpoint, Jersey <code class="literal">SseEventSource</code> will automatically
                schedule a reconnect attempt and use the received <code class="literal">Retry-After</code> HTTP header value as a
                one-time override of the reconnect delay.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-jersey-specific"></a>16.6.&nbsp;Jersey-specific Server-Sent Events API</h2></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                Prior to JAX-RS 2.1, server-sent events was not standardized and was optional and implementation-specific.
                Jersey provided its own, specific version of SSE implementation, that remains valid and functional to achieve
                backwards compatibility. This implementation is a Jersey-specific extension of JAX-RS (2.0) standard. It works
                with common JAX-RS resources the same way as the JAX-RS 2.1 based implementation does.
            </p><p>
                After the jakartification Jersey complies with JAX-RS 3.0 and SSE implementation may not be backward compatible due to
                namespace change. When the 3.x version is being used, it's required to comply with JAX-RS 3.0 SSE spec.
            </p></div><p>
            This chapter briefly describes the Jersey-specific support for SSE, focusing on the differences against the new SSE
            implementation described in
            <a class="xref" href="#">???</a>
        </p><p>
            The API contains SSE support for both - server and client. To use the Jersey-specific SSE API, you need to
            add the dependency to the
        </p><p>
            In order to add support for this SSE implementation, you also need to include the dependency to the
            <span class="emphasis"><em>SSE media type module</em></span>
            the same way as for the JAX-RS SSE implementation.
            </p><div class="example"><a name="sse.dependency"></a><p class="title"><b>Example&nbsp;16.6.&nbsp;Add <code class="literal">jersey-media-sse</code> dependency.
                </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-sse&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></div></div><p><br class="example-break">
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Prior to Jersey 2.8, you had to manually register <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a> in your application.
                    (The <code class="literal">SseFeature</code> is a feature that can be registered for both, the client and the server.)
                    Since Jersey 2.8, the feature gets automatically discovered and registered when Jersey SSE module is
                    put on the application's classpath. The automatic discovery and registration of SSE feature can be suppressed
                    by setting <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html#DISABLE_SSE" target="_top">DISABLE_SSE</a> property to <code class="literal">true</code>.
                    The behavior can also be selectively suppressed in either client or server runtime by setting
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html#DISABLE_SSE_CLIENT" target="_top">DISABLE_SSE_CLIENT</a> or <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html#DISABLE_SSE_SERVER" target="_top">DISABLE_SSE_SERVER</a> property
                    respectively.
                </p></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11913"></a>16.6.1.&nbsp;Implementing SSE support in a JAX-RS resource</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11916"></a>16.6.1.1.&nbsp;Simple SSE resource method</h4></div></div></div><p>
                    </p><div class="example"><a name="example-simple-sse"></a><p class="title"><b>Example&nbsp;16.7.&nbsp;Simple SSE resource method</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import org.glassfish.jersey.media.sse.EventOutput;
import org.glassfish.jersey.media.sse.OutboundEvent;
import org.glassfish.jersey.media.sse.SseFeature;
...

@Path("events")
public static class SseResource {

    @GET
    @Produces(SseFeature.SERVER_SENT_EVENTS)
    public EventOutput getServerSentEvents() {
        final EventOutput eventOutput = new EventOutput();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    for (int i = 0; i &lt; 10; i++) {
                        // ... code that waits 1 second
                        final OutboundEvent.Builder eventBuilder = new OutboundEvent.Builder();
                        eventBuilder.name("message-to-client");
                        eventBuilder.data(String.class, "Hello world " + i + "!");
                        final OutboundEvent event = eventBuilder.build();
                        eventOutput.write(event);
                    }
                } catch (IOException e) {
                    throw new RuntimeException("Error when writing the event.", e);
                } finally {
                    try {
                        eventOutput.close();
                    } catch (IOException ioClose) {
                        throw new RuntimeException("Error when closing the event output.", ioClose);
                    }
                }
            }
        }).start();
        return eventOutput;
    }
}
                        </pre></div></div><p><br class="example-break">

                    The code above defines the resource deployed on URI <code class="literal">"/events"</code>. This resource has a single
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a> resource method which returns as an entity <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a> - an extension of generic
                    Jersey
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ChunkedOutput.html" target="_top">ChunkedOutput</a> API for output chunked message processing.
                </p><p>
                    In the <a class="xref" href="#example-simple-sse" title="Example&nbsp;16.7.&nbsp;Simple SSE resource method">Example&nbsp;16.7, &#8220;Simple SSE resource method&#8221;</a>, the resource method creates a new thread that sends a sequence of
                    10 events. There is a 1 second delay between two subsequent events as indicated in a comment. Each event is
                    represented by <code class="literal">OutboundEvent</code> type and is built with a help of an outbound event
                    <code class="literal">Builder</code>. The <code class="literal">OutboundEvent</code> reflects the standardized format of SSE
                    messages
                    and contains properties that represent <code class="literal">name</code> (for named
                    events), <code class="literal">comment</code>, <code class="literal">data</code> or <code class="literal">id</code>. The code also sets the
                    event data media type using the <code class="literal">mediaType(MediaType)</code> method on the
                    <code class="literal">eventBuilder</code>. The media type, together with the data type set by the
                    <code class="literal">data(Class, Object&gt;</code>
                    method (in our case <code class="literal">String.class</code>), is used
                    for serialization of the event data. Note that the event data media type will not be written to any headers as
                    the response <code class="literal">Content-type</code> header is already defined by the <code class="literal">@Produces</code> and set to
                    <code class="literal">"text/event-stream"</code>
                    using constant from the <code class="literal">SseFeature</code>.
                    The event media type is used for serialization of event <code class="literal">data</code>. Event data media type and
                    Java
                    type are used to select the proper <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for event data serialization and are passed
                    to the selected writer that serializes the event <code class="literal">data</code> content. In our case the string
                    <code class="literal">"Hello world " + i + "!"</code>
                    is serialized as <code class="literal">"text/plain"</code>. In event
                    <code class="literal">data</code>
                    you can send any Java entity and associate it with any media type that you would be able
                    to serialize with an available <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Typically, you may want to send e.g. JSON
                    data,
                    so you would fill the <code class="literal">data</code> with a JAXB annotated bean instance and define media type to
                    JSON.
                    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                            If the event media type is not set explicitly, the <code class="literal">"text/plain"</code> media type is used
                            by default.
                        </p></div><p>
                </p><p>
                    Once an outbound event is ready, it can be written to the <code class="literal">eventOutput</code>. At that point the
                    event
                    is serialized by internal <code class="literal">OutboundEventWriter</code> which uses an appropriate
                    <code class="literal">MessageBodyWriter&lt;T&gt;</code> to serialize the <code class="literal">"Hello world " + i + "!"</code> string. You can
                    send as many messages as you like. At the end of the thread execution the response is closed which also closes
                    the connection to the client. After that, no more messages can be sent to the client on this connection. If
                    the
                    client would like to receive more messages, it would have to send a new request to the server to initiate a
                    new SSE streaming connection.
                </p><p>
                    A client connecting to our SSE-enabled resource will receive the exact same output as in the corresponding
                    example
                    in the JAX-RS implementation example.

                    </p><pre class="screen">event: message-to-client
data: Hello world 0!

event: message-to-client
data: Hello world 1!

...
                    </pre><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12038"></a>16.6.1.2.&nbsp;Broadcasting</h4></div></div></div><p>
                    Jersey SSE server API defines <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseBroadcaster.html" target="_top">SseBroadcaster</a> which allows to broadcast individual events to
                    multiple
                    clients. A simple broadcasting implementation is shown in the following example:

                    </p><div class="example"><a name="d0e12046"></a><p class="title"><b>Example&nbsp;16.8.&nbsp;Broadcasting SSE messages</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import org.glassfish.jersey.media.sse.SseBroadcaster;
...

@Singleton
@Path("broadcast")
public static class BroadcasterResource {

    private SseBroadcaster broadcaster = new SseBroadcaster();

    @POST
    @Produces(MediaType.TEXT_PLAIN)
    @Consumes(MediaType.TEXT_PLAIN)
    public String broadcastMessage(String message) {
        OutboundEvent.Builder eventBuilder = new OutboundEvent.Builder();
        OutboundEvent event = eventBuilder.name("message")
            .mediaType(MediaType.TEXT_PLAIN_TYPE)
            .data(String.class, message)
            .build();

        broadcaster.broadcast(event);
        return "Message '" + message + "' has been broadcast.";
    }

    @GET
    @Produces(SseFeature.SERVER_SENT_EVENTS)
    public EventOutput listenToBroadcast() {
        final EventOutput eventOutput = new EventOutput();
        this.broadcaster.add(eventOutput);
        return eventOutput;
    }
}
                        </pre></div></div><p><br class="example-break">
                    The example is similar to its relevant JAX-RS counterpart. The <code class="literal">listenToBroadcast()</code> resource
                    method creates a new <code class="literal">EventOutput</code> representing the connection to the requesting client
                    and registers this <code class="literal">eventOutput</code> instance with the singleton <code class="literal">broadcaster</code>,
                    using its <code class="literal">add(EventOutput)</code> method. The method then returns the
                    <code class="literal">eventOutput</code>
                    which causes Jersey to bind the <code class="literal">eventOutput</code> instance with the requesting client and send
                    the
                    response HTTP headers to the client. The client connection remains open and the client is now waiting ready to
                    receive new SSE events. All the events are written to the <code class="literal">eventOutput</code> by
                    <code class="literal">broadcaster</code>
                    later on.
                </p><p>
                    When a client wants to broadcast new message to all the clients listening on their SSE connections,
                    it sends a <code class="literal">POST</code> request to <code class="literal">BroadcasterResource</code> resource with the message
                    content.
                    The method <code class="literal">broadcastMessage(String)</code> is invoked on
                    <code class="literal">BroadcasterResource</code>
                    resource with the message content as an input parameter. A new SSE outbound event is built in the standard way
                    and passed to the broadcaster. The broadcaster internally invokes <code class="literal">write(OutboundEvent)</code> on
                    all
                    registered <code class="literal">EventOutput</code>s. After that the method just return a standard text response
                    to the <code class="literal">POST</code>ing client to inform the client that the message was successfully broadcast.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12102"></a>16.6.2.&nbsp;Consuming SSE events with Jersey clients</h3></div></div></div><p>
                On the client side, Jersey exposes APIs that support receiving and processing SSE events using two programming
                models:

                </p><table border="0" summary="Simple list" class="simplelist"><tr><td>Pull model - pulling events from a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventInput.html" target="_top">EventInput</a>, or
                    </td></tr><tr><td>Push model - listening for asynchronous notifications of <code class="literal">EventSource</code>
                    </td></tr></table><p>
                The push model is similar to what is implemented in the JAX-RS SSE API. The pull model does not have a direct
                counterpart in the JAX-RS API and has to be implemented by the developer, if required.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12119"></a>16.6.2.1.&nbsp;Reading SSE events with <code class="literal">EventInput</code>
                </h4></div></div></div><p>
                    The events can be read on the client side from a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventInput.html" target="_top">EventInput</a>. See the following code:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
        .register(SseFeature.class).build();
WebTarget target = client.target("http://localhost:9998/events");

EventInput eventInput = target.request().get(EventInput.class);
while (!eventInput.isClosed()) {
    final InboundEvent inboundEvent = eventInput.read();
    if (inboundEvent == null) {
        // connection has been closed
        break;
    }
    System.out.println(inboundEvent.getName() + "; " + inboundEvent.readData(String.class));
}
                    </pre><p>

                    In this example, a client connects to the server where the <code class="literal">SseResource</code> from the
                    <a class="xref" href="#example-simple-sse" title="Example&nbsp;16.7.&nbsp;Simple SSE resource method">Example&nbsp;16.7, &#8220;Simple SSE resource method&#8221;</a>
                    is deployed. At first, a new JAX-RS/Jersey
                    <code class="literal">client</code>
                    instance is created with a <code class="literal">SseFeature</code> registered. Then a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> instance is
                    retrieved from the <code class="literal">client</code> and is used to invoke a HTTP request. The returned response
                    entity
                    is directly read as a <code class="literal">EventInput</code> Java type, which is an extension of Jersey
                    <code class="literal">ChunkedInput</code> that provides generic support for consuming chunked message payloads. The
                    code in the example then process starts a loop to process the inbound SSE events read from the
                    <code class="literal">eventInput</code>
                    response stream. Each chunk read from the input is a <code class="literal">InboundEvent</code>.
                    The method <code class="literal">InboundEvent.readData(Class)</code> provides a way for the client to indicate what Java
                    type
                    should be used for the event data de-serialization. In our example, individual events are de-serialized as
                    <code class="literal">String</code>
                    Java type instances. This method internally finds and executes a proper
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> which is the used to do the actual de-serialization. This is similar to reading
                    an
                    entity from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a> by <code class="literal">readEntity(Class)</code>. The method
                    <code class="literal">readData</code>
                    can also throw a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ProcessingException.html" target="_top">ProcessingException</a>.
                </p><p>
                    The <code class="literal">null</code> check on <code class="literal">inboundEvent</code> is necessary to make sure that the chunk was properly
                    read and connection has not been closed by the server. Once the connection is closed, the loop terminates and
                    the program completes execution. The client code produces the following console output:

                    </p><pre class="screen">message-to-client; Hello world 0!
message-to-client; Hello world 1!
message-to-client; Hello world 2!
message-to-client; Hello world 3!
message-to-client; Hello world 4!
message-to-client; Hello world 5!
message-to-client; Hello world 6!
message-to-client; Hello world 7!
message-to-client; Hello world 8!
message-to-client; Hello world 9!
                    </pre><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12194"></a>16.6.2.2.&nbsp;Asynchronous SSE processing with <code class="literal">EventSource</code>
                </h4></div></div></div><p>
                    The main Jersey-specific SSE client API component used to read SSE events asynchronously is
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventSource.html" target="_top">EventSource</a>. The usage of the <code class="literal">EventSource</code> is shown on the following example.
                    </p><div class="example"><a name="sse.ex.client.eventListener"></a><p class="title"><b>Example&nbsp;16.9.&nbsp;Registering <code class="literal">EventListener</code> with <code class="literal">EventSource</code>
                        </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
        .register(SseFeature.class).build();
WebTarget target = client.target("http://example.com/events");
EventSource eventSource = EventSource.target(target).build();
EventListener listener = new EventListener() {
    @Override
    public void onEvent(InboundEvent inboundEvent) {
        System.out.println(inboundEvent.getName() + "; " + inboundEvent.readData(String.class));
    }
};
eventSource.register(listener, "message-to-client");
eventSource.open();
...
eventSource.close();
                        </pre></div></div><p><br class="example-break">

                    In this example, the client code again connects to the server where the <code class="literal">SseResource</code> from
                    the
                    <a class="xref" href="#example-simple-sse" title="Example&nbsp;16.7.&nbsp;Simple SSE resource method">Example&nbsp;16.7, &#8220;Simple SSE resource method&#8221;</a>
                    is deployed. The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a> instance
                    is again created and initialized with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a>. Then the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> is built.
                    In this case a request to the web target is not made directly in the code, instead, the web target instance
                    is used to initialize a new <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventSource.Builder.html" target="_top">EventSource.Builder</a> instance that is used to build a new
                    <code class="literal">EventSource</code>. The choice of <code class="literal">build()</code> method is important, as it tells
                    the <code class="literal">EventSource.Builder</code> to create a new <code class="literal">EventSource</code> that is not
                    automatically
                    connected to the <code class="literal">target</code>. The connection is established only later by manually invoking
                    the <code class="literal">eventSource.open()</code> method. A custom <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventListener.html" target="_top">EventListener</a>
                    implementation is used to listen to and process incoming SSE events. The method readData(Class) says that the
                    event data should be de-serialized from a received <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/InboundEvent.html" target="_top">InboundEvent</a> instance into a
                    <code class="literal">String</code>
                    Java type. This method call internally executes <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> which
                    de-serializes the event data. This is similar to reading an entity from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a> by
                    <code class="literal">readEntity(Class)</code>. The method <code class="literal">readData</code> can throw a
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ProcessingException.html" target="_top">ProcessingException</a>.
                </p><p>
                    The custom event source listener is registered in the event source via
                    <code class="literal">EventSource</code><code class="literal">.register(EventListener, String)</code>
                    method. The next method
                    arguments define the names of the events to receive and can be omitted. If names are defined, the listener
                    will be associated with the named events and will only be invoked for events with a name from the set of defined
                    event names. It will not be invoked for events with any other names or for events without a name.

                    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                            It is a common mistake to think that unnamed events will be processed by listeners that are registered
                            to process events from a particular name set. That is NOT the case! Unnamed events are only processed
                            by listeners that are not name-bound. The same limitation applied to HTML5 Javascript SSE Client API
                            supported by modern browsers.
                        </p></div><p>

                    After a connection to the server is opened by calling the <code class="literal">open()</code> method on the event
                    source,
                    the <code class="literal">eventSource</code> starts listening to events. When an event named
                    <code class="literal">"message-to-client"</code>
                    comes, the listener will be executed by the event source. If any other
                    event comes (with a name different from <code class="literal">"message-to-client"</code>), the registered listener is
                    not
                    invoked. Once the client is done with processing and does not want to receive events anymore, it closes the
                    connection by calling the <code class="literal">close()</code> method on the event source.
                </p><p>
                    The listener from the example above will print the following output:
                    </p><pre class="screen">message-to-client; Hello world 0!
message-to-client; Hello world 1!
message-to-client; Hello world 2!
message-to-client; Hello world 3!
message-to-client; Hello world 4!
message-to-client; Hello world 5!
message-to-client; Hello world 6!
message-to-client; Hello world 7!
message-to-client; Hello world 8!
message-to-client; Hello world 9!
                    </pre><p>
                </p><p>
                    When browsing through the Jersey SSE API documentation, you may have noticed that the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventSource.html" target="_top">EventSource</a>
                    implements <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventListener.html" target="_top">EventListener</a> and provides an empty implementation for the
                    <code class="literal">onEvent(InboundEvent inboundEvent)</code>
                    listener method. This adds more flexibility to the
                    Jersey client-side SSE API. Instead of defining and registering a separate event listener, in simple scenarios
                    you can also choose to derive directly from the <code class="literal">EventSource</code> and override the empty listener
                    method to handle the incoming events. This programming model is shown in the following example:

                    </p><div class="example"><a name="d0e12324"></a><p class="title"><b>Example&nbsp;16.10.&nbsp;Overriding <code class="literal">EventSource.onEvent(InboundEvent)</code> method
                        </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
        .register(SseFeature.class).build();
WebTarget target = client.target("http://example.com/events");
EventSource eventSource = new EventSource(target) {
    @Override
    public void onEvent(InboundEvent inboundEvent) {
        if ("message-to-client".equals(inboundEvent.getName())) {
            System.out.println(inboundEvent.getName() + "; " + inboundEvent.readData(String.class));
        }
    }
};
...
eventSource.close();
                        </pre></div></div><p><br class="example-break">

                    The code above is very similar to the code in <a class="xref" href="#sse.ex.client.eventListener" title="Example&nbsp;16.9.&nbsp;Registering EventListener with EventSource">Example&nbsp;16.9, &#8220;Registering <code class="literal">EventListener</code> with <code class="literal">EventSource</code>
                        &#8221;</a>. In this example
                    however, the <code class="literal">EventSource</code> is constructed directly using a single-parameter constructor.
                    This way, the connection to the SSE endpoint is by default automatically opened at the event source
                    creation. The implementation of the <code class="literal">EventListener</code> has been moved into the overridden
                    <code class="literal">EventSource.onEvent(...)</code>
                    method. However, this time, the listener method will be executed for
                    all events - unnamed as well as with any <code class="literal">name</code>. Therefore the code checks the name whether
                    it is
                    an event with the name "message-to-client" that we want to handle. Note that you can still register
                    additional <code class="literal">EventListener</code>s later on. The overridden method on the event source allows you to
                    handle messages even when no additional listeners are registered yet.
                </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d0e12350"></a>16.6.2.2.1.&nbsp;<code class="literal">EventSource</code> reconnect support
                    </h5></div></div></div><p>
                        Reconnect support in Jersey-specific <code class="literal">EventSource</code> works the same way as in the
                        implementation of the JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.html" target="_top">SseEventSource</a>.
                    </p></div></div></div></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="security"></a>Chapter&nbsp;17.&nbsp;Security</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e12367">17.1. Securing server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12370">17.1.1. SecurityContext</a></span></dt><dt><span class="section"><a href="#d0e12476">17.1.2. Authorization - securing resources</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e12599">17.2. Client Security</a></span></dt><dt><span class="section"><a href="#d0e12616">17.3. OAuth Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12678">17.3.1. OAuth 1</a></span></dt><dt><span class="section"><a href="#d0e13009">17.3.2. OAuth 2 Support</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12367"></a>17.1.&nbsp;Securing server</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12370"></a>17.1.1.&nbsp;SecurityContext</h3></div></div></div><p>
                Security information of a request is available by injecting a JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/SecurityContext.html" target="_top">SecurityContext</a> instance
                using <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a>
                annotation. The injected security context instance provides the equivalent of the functionality available on
                <a class="link" href="https://jakarta.ee/specifications//servlet/5.0/apidocs/jakarta/servlet/http/httpservletrequest" target="_top">HttpServletRequest</a> API.
                The injected security context depends on the actual Jersey application deployment. For example, for a
                Jersey application deployed in a Servlet container, the Jersey <code class="literal">SecurityContext</code> will
                encapsulate information from a security context retrieved from the Servlet request.
                In case of a Jersey application deployed on a Grizzly server,
                the <code class="literal">SecurityContext</code> will return information retrieved from the Grizzly request.
            </p><p>
                <code class="literal">SecurityContext</code> can be used in conjunction with sub-resource locators to return different
                resources based on the specific roles a user principal is included in. For example, a sub-resource locator could
                return a different resource if a user is a preferred customer:

                </p><div class="example"><a name="d0e12395"></a><p class="title"><b>Example&nbsp;17.1.&nbsp;Using <code class="literal">SecurityContext</code> for a Resource Selection</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("basket")
public ShoppingBasketResource get(@Context SecurityContext sc) {
    if (sc.isUserInRole("PreferredCustomer") {
        return new PreferredCustomerShoppingBasketResource();
    } else {
        return new ShoppingBasketResource();
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                <code class="literal">SecurityContext</code> is inherently request-scoped, yet can be also injected into fields of singleton
                resources and JAX-RS providers. In such case the proxy of the request-scoped <code class="literal">SecurityContext</code>
                will be injected.

                </p><div class="example"><a name="d0e12412"></a><p class="title"><b>Example&nbsp;17.2.&nbsp;Injecting <code class="literal">SecurityContext</code> into a singleton resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
@Singleton
public static class MyResource {
    // Jersey will inject proxy of Security Context
    @Context
    SecurityContext securityContext;

    @GET
    public String getUserPrincipal() {
        return securityContext.getUserPrincipal().getName();
    }
}</pre></div></div><p><br class="example-break">
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12421"></a>17.1.1.1.&nbsp;Initializing Security Context with Servlets</h4></div></div></div><p>
                    As described above, the <code class="literal">SecurityContext</code> by default (if not overwritten by
                    a request filter) only exposes security information from the underlying container.
                    In the case you deploy a Jersey application in a Servlet container, you need to configure the
                    Servlet container security aspects (<code class="literal">&lt;security-constraint&gt;</code>,
                    <code class="literal">&lt;auth-constraint&gt;</code> and user to roles mappings)
                    in order to be able to secure requests via calls to to the JAX-RS <code class="literal">SecurityContext</code>.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12438"></a>17.1.1.2.&nbsp;Using Security Context in Container Request Filters</h4></div></div></div><p>
                    The <code class="literal">SecurityContext</code> can be directly retrieved from <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerRequestContext.html" target="_top">ContainerRequestContext</a> via
                    <code class="literal">getSecurityContext()</code> method. You can also replace the default
                    <code class="literal">SecurityContext</code> in a request context with a custom one using the
                    <code class="literal">setSecurityContext(SecurityContext)</code> method. If you set a custom
                    <code class="literal">SecurityContext</code> instance in your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerRequestFilter.html" target="_top">ContainerRequestFilter</a>,
                    this security context instance will be used for injection into JAX-RS resource class fields.
                    This way you can implement a custom authentication filter that may setup your own
                    <code class="literal">SecurityContext</code> to be used. To ensure the early execution of your custom
                    authentication request filter, set the filter priority to <code class="literal">AUTHENTICATION</code>
                    using constants from <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Priorities.html" target="_top">Priorities</a>. An early execution of you authentication filter will ensure that
                    all other filters, resources, resource methods and sub-resource locators will execute with your custom
                    <code class="literal">SecurityContext</code> instance.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12476"></a>17.1.2.&nbsp;Authorization - securing resources</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12479"></a>17.1.2.1.&nbsp;Security resources with <code class="literal">web.xml</code></h4></div></div></div><p>
                    In cases where a Jersey application is deployed in a Servlet container you can rely only on
                    the standard Java/Jakarta EE Web application security mechanisms offered by the Servlet container and
                    configurable via application's <code class="literal">web.xml</code> descriptor.
                    You need to define the <code class="literal">&lt;security-constraint&gt;</code> elements in the
                    <code class="literal">web.xml</code> and assign roles which are able to access these resources. You can also
                    define HTTP methods that are allowed to be executed. See the following example.

                    </p><div class="example"><a name="d0e12495"></a><p class="title"><b>Example&nbsp;17.3.&nbsp;Securing resources using <code class="literal">web.xml</code>
                        </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;url-pattern&gt;/rest/admin/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
        &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;
&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;url-pattern&gt;/rest/orders/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
        &lt;role-name&gt;customer&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;
&lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
    &lt;realm-name&gt;my-default-realm&lt;/realm-name&gt;
&lt;/login-config&gt;</pre></div></div><p><br class="example-break">

                    The example secures two kinds of URI namespaces using the HTTP Basic Authentication.
                    <code class="literal">rest/admin/*</code> will be accessible only for user group "admin" and
                    <code class="literal">rest/orders/*</code> will be accessible for "customer" user group. This security configuration
                    does not use JAX-RS or Jersey features at all as it is enforced by the Servlet container even before
                    a request reaches the Jersey application. Keeping these security constrains up to date with your
                    JAX-RS application might not be easy as whenever you change the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Path.html" target="_top">@Path</a> annotations on your resource
                    classes you may need to update also the <code class="literal">web.xml</code>
                    security configurations to reflect the changed JAX-RS resource paths. Therefore Jersey offers a
                    <a class="link" href="#annotation-based-security" title="17.1.2.2.&nbsp;Securing JAX-RS resources with standard jakarta.annotation.security annotations">more flexible solution</a>
                    based on placing standard Java/Jakarta EE security annotations directly on JAX-RS resource classes and methods.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="annotation-based-security"></a>17.1.2.2.&nbsp;Securing JAX-RS resources with standard <code class="literal">jakarta.annotation.security</code> annotations</h4></div></div></div><p>
                    With Jersey you can define the access to resources based on the user group using annotations. You
                    can, for example, define that only a user group "admin" can execute specific resource method. To do that you
                    firstly need to register <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/filter/RolesAllowedDynamicFeature.html" target="_top">RolesAllowedDynamicFeature</a> as a provider. The following example
                    shows how to register the feature if your deployment is based on a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a>.

                    </p><div class="example"><a name="d0e12533"></a><p class="title"><b>Example&nbsp;17.4.&nbsp;Registering RolesAllowedDynamicFeature using ResourceConfig</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final ResourceConfig resourceConfig = new ResourceConfig(MyResource.class);
resourceConfig.register(RolesAllowedDynamicFeature.class);
                        </pre></div></div><p><br class="example-break">

                    Alternatively, typically when deploying your application to a Servlet container, you can implement your JAX-RS
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a> subclass by extending from the Jersey <code class="literal">ResourceConfig</code> and
                    registering the <code class="literal">RolesAllowedDynamicFeature</code> in the constructor:

                    </p><div class="example"><a name="d0e12548"></a><p class="title"><b>Example&nbsp;17.5.&nbsp;Registering RolesAllowedDynamicFeature by extending ResourceConfig</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyApplication extends ResourceConfig {
    public MyApplication() {
        super(MyResource.class);
        register(RolesAllowedDynamicFeature.class);
    }
}</pre></div></div><p><br class="example-break">
                </p><p>
                    Once the feature is registered, you can use annotations from package
                    <code class="literal">jakarta.annotation.security</code> defined by JSR-250. See the following example.

                    </p><div class="example"><a name="d0e12559"></a><p class="title"><b>Example&nbsp;17.6.&nbsp;Applying <code class="literal">jakarta.annotation.security</code> to JAX-RS resource methods.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
@PermitAll
public class Resource {
    @RolesAllowed("user")
    @GET
    public String get() { return "GET"; }

    @RolesAllowed("admin")
    @POST
    public String post(String content) { return content; }

    @Path("sub")
    public SubResource getSubResource() {
        return new SubResource();
    }
}</pre></div></div><p><br class="example-break">

                    The resource class <code class="literal">Resource</code> defined in the example is annotated with a
                    <a class="link" href="https://jakarta.ee/specifications/annotations/2.0/apidocs/jakarta.annotation/jakarta/annotation/security/permitall" target="_top">@PermitAll</a> annotation. This means that all methods in the class which do not
                    override this
                    annotation will be permitted for all user groups (no restrictions are defined). In our example, the
                    annotation will only apply to the <code class="literal">getSubResource()</code> method as it is the only method
                    that does not override the annotation by defining custom role-based security settings using the
                    <a class="link" href="https://jakarta.ee/specifications/annotations/2.0/apidocs/jakarta.annotation/jakarta/annotation/security/rolesallowed" target="_top">@RolesAllowed</a> annotation.
                    <code class="literal">@RolesAllowed</code> annotations present on the other methods define a role or a set of
                    roles that are allowed to execute a particular method.
                </p><p>
                    These Java/Jakarta EE security annotations are processed internally in the request filter registered using
                    the Jersey <code class="literal">RolesAllowedDynamicFeature</code>. The roles defined in the annotations are
                    tested against current roles set in the <code class="literal">SecurityContext</code> using
                    the <code class="literal">SecurityContext</code><code class="literal">.isUserInRole(String role)</code> method. In case the caller
                    is not in the role specified by the annotation, the HTTP <code class="literal">403 (Forbidden)</code>
                    error response is returned.
                </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12599"></a>17.2.&nbsp;Client Security</h2></div></div></div><p>
            For details about client security please see the <a class="link" href="#client" title="Chapter&nbsp;5.&nbsp;Client API">Client chapter</a>. Jersey
            client allows to define parameters of SSL communication using <code class="literal">HTTPS</code> protocol.
            You can also use jersey built-in authentication filters which perform <span class="emphasis"><em>HTTP Basic Authentication</em></span>
            or <span class="emphasis"><em>HTTP Digest Authentication</em></span>. See the client chapter for more details.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12616"></a>17.3.&nbsp;OAuth Support</h2></div></div></div><p>
            OAuth is a specification that defines secure authentication model on behalf of another user.
            Two versions of OAuth exists at the moment - <span class="emphasis"><em>OAuth 1</em></span> defined by <a class="link" href="http://tools.ietf.org/html/rfc5849" target="_top">OAuth 1.0 specification</a> and
            <span class="emphasis"><em>OAuth 2</em></span> defined by <a class="link" href="http://tools.ietf.org/html/rfc6749" target="_top">OAuth 2.0 specification</a>.
            OAuth 2 is the latest version and it is not backward compatible with
            OAuth 1 specification. OAuth in general is widely used in popular social Web sites in order to grant access
            to a user account and associated resources for a third party consumer (application). The consumer then usually
            uses RESTful Web Services to access the user data.
            The following example describes a use case of the OAuth (similar for OAuth 1 and OAuth 2). The example is simple
            and probably obvious for many developers but introduces terms that are used in this
            documentation as well as in Jersey OAuth API documentation.
        </p><p>
            Three parties act in an OAuth scenario.
        </p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="80%"><tr><td align="center"><img src="images/oauth-parties.png" align="middle" width="100%"></td></tr></table></div><p>
            The first party represents a user, in our case Adam,
            who is called in the OAuth terminology a <span class="emphasis"><em>Resource Owner</em></span>. Adam has an account on
            Twitter. Twitter represents the second party. This party is called a
            <span class="emphasis"><em>Service Provider</em></span>. Twitter offers a web interface
            that Adam uses to create new tweets, read tweets of others etc. Now, Adam uses our new web site,
            HelloWorldWeb, which is a very simple web site that says <code class="literal">Hello World</code> but it additionally
            displays the last tweet of the logged in user.
            To do so, our web site needs to have access to the Twitter account of Adam. Our web site is a 3rd party
            application that wants to connect to Twitter and get Adam's tweets. In OAuth, such party is called
            <span class="emphasis"><em>Consumer</em></span>.
            Our Consumer would like to use Twitter's RESTful APIs to get some data associated with Adam's Twitter account.
            In order to solve this situation Adam could directly give his Twitter password to the HelloWorldWeb.
            This would however be rather unsafe, especially if we do not know much about the authors of the application.
            If Adam would give his password to HelloWorldWeb, he would have to deal with the associated security risks.
            First of all, Adam would have to fully trust HelloWorldWeb
            that it will not misuse the full access to his Twitter account. Next, if Adam would change his password,
            he would need to remember to give the new password also to the HelloWorldWeb application.
            And at last, if Adam would like to revoke the HelloWorldWeb's access to his Twitter account,
            he would need to change his password again. The OAuth protocol has been devised to address all these challenges.
        </p><p>
            With OAuth, a resource owner (Adam) grants an access to a consumer (HelloWorldWeb) without giving it
            his password. This access grant is achieved by a procedure called
            <span class="emphasis"><em>authorization flow</em></span>. Authorization flow is out of the scope of this
            documentation and its description can be found in the OAuth specification linked above.
            The result of the authorization flow is an <span class="emphasis"><em>Access Token</em></span> which is later
            used by the consumer to authenticate against the service provider.
            While this brief description applies to both OAuth 1 and 2, note that there are some differences in details
            between these two specifications.
        </p><p>
            Jersey OAuth is currently supported for the following use cases and OAuth versions:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        OAuth 1: Client (consumer) and server (service provider)
                    </p></li><li class="listitem"><p>
                        OAuth 2: Client (consumer)
                    </p></li></ul></div><p>

            With client and server support there are two supported scenarios:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Authorization flow
                    </p></li><li class="listitem"><p>
                        Authentication with Access Token (support for authenticated requests)
                    </p></li></ul></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12678"></a>17.3.1.&nbsp;OAuth 1</h3></div></div></div><p>
                OAuth 1 protocol is based on message signatures that are calculated using specific
                signature methods. Signatures are quite complex and therefore are implemented in a separate
                module. The OAuth 1 Jersey modules are (<code class="literal">groupId:artifactId:description</code>):
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">org.glassfish.jersey.security:oauth1-client</code>: provides client
                            OAuth 1 support for authorization flow and authentication
                        </p></li><li class="listitem"><p>
                            <code class="literal">org.glassfish.jersey.security:oauth1-server</code>: provides server
                            OAuth 1 support for authorization flow, SPI for token management including authentication
                            filter.
                        </p></li><li class="listitem"><p>
                            <code class="literal">org.glassfish.jersey.security:oauth1-signature</code>
                            : provides support for OAuth1 request signatures. This module is a dependency of previous two
                            modules and as such it will be implicitly included in your maven project.
                            The module can be used as a standalone module but this will not be needed in most of the use cases.
                            You would do that if you wanted to implement your own OAuth support and would not want to deal with
                            implementing the complex signature algorithms.
                        </p></li></ul></div><p>
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12706"></a>17.3.1.1.&nbsp;Server</h4></div></div></div><p>
                    To add support for OAuth into your server-side application, add the following dependency to your<code class="literal">
                    pom.xml</code>:
                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.security&lt;/groupId&gt;
    &lt;artifactId&gt;oauth1-server&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    Again, there is no need to add a direct dependency to the signature module, it will be transitively included.
                </p><p>
                    Let's now briefly go over the most important server Jersey OAuth APIs and SPIs:
                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/oauth1/OAuth1ServerFeature.html" target="_top">OAuth1ServerFeature</a>: The feature which enables the
                                OAuth 1 support on the server and registers <code class="literal">OAuth1Provider</code>
                                explained in the following point.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/oauth1/OAuth1Provider.html" target="_top">OAuth1Provider</a>: Implementation of this SPI must be
                                registered to the server runtime as a standard provider. The implementation will be used
                                to create request and access token, get consumer by consumer key, etc. You can either
                                implement your provider or use the default implementation provided by Jersey by
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/oauth1/DefaultOAuth1Provider.html" target="_top">DefaultOAuth1Provider</a>.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/oauth1/OAuth1ServerProperties.html" target="_top">OAuth1ServerProperties</a>: properties that can be used
                                to configure the OAuth 1 support.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/oauth1/OAuth1Consumer.html" target="_top">OAuth1Consumer</a>, <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/oauth1/OAuth1Token.html" target="_top">OAuth1Token</a>: classes
                                that contain consumer key, request and access tokens. You need to
                                implement them only if you also implement the interface
                                <code class="literal">OAuth1Provider</code>.
                            </p></li></ul></div><p>
                </p><p>
                    First step in enabling Jersey OAuth 1 support is to register a
                    <code class="literal">OAuth1ServerFeature</code> instance
                    initialized with an instance of <code class="literal">OAuth1Provider</code>. Additionally, you may
                    configure the <span class="emphasis"><em>Request Token URI</em></span> and <span class="emphasis"><em>Access Token URI</em></span> -
                    the endpoints accessible on the OAuth server that issue Request and Access Tokens. These endpoints
                    are defined in the OAuth 1 specification and are contacted as part of the OAuth authorization flow.
                </p><p>
                    Next, when a client initiates the OAuth authorization flow, the provided implementation of
                    <code class="literal">OAuth1Provider</code> will be invoked as to create new tokens,
                    get tokens and finally to store the issued Access Token. If a consumer already has a valid Access Token
                    and makes Authenticated Requests (with OAuth 1 Authorization information in the HTTP header),
                    the provider will be invoked to provide the <code class="literal">OAuth1Token</code> for the
                    Access Token information in the header.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="oauth1-client"></a>17.3.1.2.&nbsp;Client</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        OAuth client support in Jersey is almost identical for OAuth 1 and OAuth 2. As such, this chapter
                        provides useful information even for users that use OAuth 2 client support.
                    </p></div><p>
                    To add support for OAuth into your Jersey client application, add the following dependency to your
                    <code class="literal">pom.xml</code>:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.security&lt;/groupId&gt;
    &lt;artifactId&gt;oauth1-client&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    As mentioned earlier, there is no need to add a direct dependency to the signature module,
                    it will be transitively included.
                </p><p>
                    OAuth 1 client support initially started as a code migration from Jersey 1.x.
                    During the migration however the API of was significantly revised.
                    The high level difference compared to Jersey 1.x OAuth client API is that the authorization flow
                    is no longer part of a client OAuth filter. Authorization flow is now a standalone utility
                    and can be used without a support for subsequent authenticated requests.
                    The support for authenticated requests stays in the
                    <code class="literal">ClientRequestFilter</code> but is not part of a public API
                    anymore and is registered by a Jersey OAuth <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Feature.html" target="_top">Feature</a>.
                </p><p>
                    The most important parts of the Jersey client OAuth API and SPI are explained here:

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth1/OAuth1ClientSupport.html" target="_top">OAuth1ClientSupport</a>: The main class which contains builder
                                methods to build features that enable the OAuth 1 support. Start with this class every time
                                you need to add any OAuth 1 support to the Jersey Client (build an Authorization flow
                                or initialize client to perform authenticated requests). The class contains a
                                static method that returns an instance of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth1/OAuth1Builder.html" target="_top">OAuth1Builder</a> and also
                                the class defines request properties to influence behaviour of the authenticated
                                request support.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth1/OAuth1AuthorizationFlow.html" target="_top">OAuth1AuthorizationFlow</a>: API that allows to perform the
                                Authorization flow against service provider. Implementation of this interface is a
                                class that is used as a standalone utility and is not part of the JAX-RS client. In
                                other words, this is not a feature that should be registered into the client.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth1/AccessToken.html" target="_top">AccessToken</a>, <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth1/ConsumerCredentials.html" target="_top">ConsumerCredentials</a>:
                                Interfaces that define Access Token classes and Consumer Credentials. Interfaces contain
                                getters for public keys and secret keys of token and credentials.
                            </p></li></ul></div><p>

                    An example of how Jersey OAuth 1 client API is used was in
                    the <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/oauth-client-twitter" target="_top">OAuth 1 Twitter Client Example</a> but for now it's temporally removed from examples.
                    The following code snippets are extracted from the
                    example and explain how to use the Jersey OAuth client API.
                </p><p>
                    Before we start with any interaction with Twitter, we need to register our application
                    on Twitter. See the example <code class="literal">README.TXT</code> file for the instructions.
                    As a result of the registration, we get the consumer credentials that identify our application.
                    Consumer credentials consist of <code class="literal">consumer key</code> and <code class="literal">consumer secret</code>.
                </p><p>
                    As a first step in our code, we need to perform the authorization flow, where the user grants us an access to
                    his/her Twitter client.
                </p><p>
                    </p><div class="example"><a name="d0e12846"></a><p class="title"><b>Example&nbsp;17.7.&nbsp;Build the authorization flow utility</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ConsumerCredentials consumerCredentials = new ConsumerCredentials(
                "a846d84e68421b321a32d, "f13aed84190bc");
OAuth1AuthorizationFlow authFlow = OAuth1ClientSupport.builder(consumerCredentials)
    .authorizationFlow(
        "http://api.twitter.com/oauth/request_token",
        "http://api.twitter.com/oauth/access_token",
        "http://api.twitter.com/oauth/authorize")
    .build();</pre></div></div><p><br class="example-break">
                </p><p>
                    Here we have built a <code class="literal">OAuth1AuthorizationFlow</code> utility component representing the
                    OAuth 1 authorization flow, using <code class="literal">OAuth1ClientSupport</code> and
                    <code class="literal">OAuth1Builder</code> API. The static <code class="literal">builder</code> method accepts
                    mandatory parameter with <code class="literal">ConsumerCredentials</code>. These
                    are credentials earlier issued by Twitter for our application.
                    We have specified the Twitter OAuth endpoints where Request Token, Access Token will be retrieved and
                    Authorization URI to which we will redirect the user in order to grant user's consent.
                    Twitter will present an HTML page on this URI and it will ask the user whether he/she would like us
                    to access his/her account.
                </p><p>
                    Now we can proceed with the OAuth authorization flow.

                    </p><div class="example"><a name="d0e12871"></a><p class="title"><b>Example&nbsp;17.8.&nbsp;Perform the OAuth Authorization Flow</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">String authorizationUri = authFlow.start();
// here we must direct the user to authorization uri to approve
// our application. The result will be verifier code (String).
AccessToken accessToken = authFlow.finish(verifier);</pre></div></div><p><br class="example-break">

                    In the first line, we start the authorization flow. The method internally makes a request to the
                    <code class="literal">http://api.twitter.com/oauth/request_token</code> URL
                    and retrieves a Request Token. Details of this request can be found in the OAuth 1 specification.
                    It then constructs a URI to which we must redirect the user. The URI is based on Twitter's
                    authorization URI (<code class="literal">http://api.twitter.com/oauth/authorize</code>) and contains
                    a Request Token as a query parameter. In the Twitter example, we have a simple console application therefore
                    we print the URL to the console and ask the user to open the URL in a browser to approve the authorization
                    of our application.
                    Then the user gets a verifier and enters it back to the console. However, if our application would be a
                    web application, we would need to return a redirection response to the user in order to redirect the user
                    automatically to the <code class="literal">authorizationUri</code>. 
                </p><p>
                    Once we have a verifier, we invoke the method <code class="literal">finish()</code>
                    on our <code class="literal">OAuth1AuthorizationFlow</code> instance, which internally
                    sends a request to an access token service URI (<code class="literal">http://api.twitter.com/oauth/access_token</code>)
                    and exchanges the supplied verifier for a new valid Access Token.
                    At this point the authorization flow is finished and we can start using the retrieved
                    <code class="literal">AccessToken</code> to make authenticated requests.
                    We can now create an instance of an OAuth 1 client <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Feature.html" target="_top">Feature</a> using
                    <code class="literal">OAuth1ClientSupport</code> and pass it our <code class="literal">accessToken</code>.
                    Another way is to use <code class="literal">authFlow</code> that already contains the information about access token
                    to create the feature instance for us:

                    </p><div class="example"><a name="d0e12914"></a><p class="title"><b>Example&nbsp;17.9.&nbsp;Authenticated requests</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Feature feature = authFlow.getOAuth1Feature();
Client client = ClientBuilder.newBuilder()
    .register(feature)
    .build();</pre></div></div><p><br class="example-break">

                    Once the feature is configured in the JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a> (or <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a>),
                    all requests invoked from such <code class="literal">Client</code> (or <code class="literal">WebTarget</code>) instance
                    will automatically include an OAuth Authorization HTTP header (that contains also the OAuth signature).
                </p><p>
                    Note that if you already have a valid Access Token (for example stored in the database for each of your users),
                    then you can skip the authorization flow steps and directly create the OAuth <code class="literal">Feature</code>
                    configured to use your Access Token.

                    </p><div class="example"><a name="d0e12937"></a><p class="title"><b>Example&nbsp;17.10.&nbsp;Build feature from Access Token</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">AccessToken storedToken = ...;
Feature filterFeature = OAuth1ClientSupport.builder(consumerCredentials)
    .feature()
    .accessToken(storedToken)
    .build();</pre></div></div><p><br class="example-break">

                    Here, the <code class="literal">storedToken</code> represents an <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth1/AccessToken.html" target="_top">AccessToken</a> that your client
                    application keeps stored e.g. in a database.
                </p><p>
                    Note that the OAuth feature builder API does not require the access token to be set.
                    The reason for it is that you might want to build a feature which would register the internal Jersey
                    OAuth <code class="literal">ClientRequestFilter</code> and other related providers but which would not
                    initialize the OAuth providers with a single fixed <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth1/AccessToken.html" target="_top">AccessToken</a> instance.
                    In such case you would need to specify a token for every single request in the request properties.
                    Key names and API documentation of these properties can be found in
                    <code class="literal">OAuth1ClientSupport</code>.
                    Using this approach, you can have a single, OAuth enabled instance of a JAX-RS <code class="literal">Client</code>
                    (or <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a>) and use it to make authenticated requests on behalf of multiple users.
                    Note that you can use the aforementioned request properties even if the feature has been initialized
                    with an <code class="literal">AccessToken</code> to override the default access token information for
                    particular requests, even though it is probably not a common use case.
                </p><p>
                    The following code shows how to set an access token on a single request using the Jersey OAuth properties.

                    </p><div class="example"><a name="d0e12971"></a><p class="title"><b>Example&nbsp;17.11.&nbsp;Specifying Access Token on a Request.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Response resp =
    client.target("http://my-serviceprovider.org/rest/foo/bar")
        .request()
        .property(OAuth1ClientSupport.OAUTH_PROPERTY_ACCESS_TOKEN, storedToken)
        .get();</pre></div></div><p><br class="example-break">

                    <code class="literal">OAuth1AuthorizationFlow</code> internally uses
                    a <code class="literal">Client</code> instance to communicate with the OAuth server. For this a
                    new client instance is automatically created by default. You can supply your instance of
                    a <code class="literal">Client</code> to be used for the authorization flow requests (for performance
                    and/or resource management reasons) using <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth1/OAuth1Builder.html" target="_top">OAuth1Builder</a> methods.
                </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="oauth1-client-signatures"></a>17.3.1.2.1.&nbsp;Public/Private Keys for RSA-SHA1 signature method</h5></div></div></div><p>
                        Follow the steps below in case the outgoing requests sent from client to server have to be signed with
                        RSA-SHA1 signature method instead of the default one (HMAC-SHA1).
                    </p><div class="example"><a name="d0e12994"></a><p class="title"><b>Example&nbsp;17.12.&nbsp;Creating Public/Private RSA-SHA1 keys</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    ">$ # Create the private key.
$ openssl genrsa -out private.key 2048
$ # Convert the key into PKCS8 format.
$ openssl pkcs8 -topk8 -in private.key -nocrypt
$ # Extract the public key.
$ openssl rsa -in private.key -pubout</pre></div></div><br class="example-break"><p>
                        The output of the second command can be used as a consumer secret to sign the outgoing request:
                        <code class="literal">new ConsumerCredentials("consumer-key", CONSUMER_PRIVATE_KEY)</code>. Public key obtained from
                        the third command can be then used on the service provider to verify the signed data.
                    </p><p>
                        For more advanced cases (i.e. other formats of keys) a custom <code class="literal">OAuth1SignatureMethod</code>
                        should be implemented and used.
                    </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13009"></a>17.3.2.&nbsp;OAuth 2 Support</h3></div></div></div><p>At the moment Jersey supports OAuth 2 only on the client side.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e13014"></a>17.3.2.1.&nbsp;Client</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Note: It is suggested to read the section <a class="xref" href="#oauth1-client" title="17.3.1.2.&nbsp;Client">Section&nbsp;17.3.1.2, &#8220;Client&#8221;</a>
                        before this section. Support for OAuth on the client is very similar for both
                        OAuth 1 and OAuth 2 and general principles are valid for both OAuth versions as such.
                    </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        OAuth 2 support is in a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/Beta.html" target="_top">Beta</a> state and as such the API is subject
                        to change.
                    </p></div><p>
                    To add support for Jersey OAuth 2 Client API into your application, add the following dependency
                    to your <code class="literal">pom.xml</code>:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.security&lt;/groupId&gt;
    &lt;artifactId&gt;oauth2-client&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                </p><p>
                    OAuth 2, in contrast with OAuth 1, is not a strictly defined protocol, rather a framework.
                    OAuth 2 specification defines many extension points and it is up to service providers to
                    implement these details and document these implementations for the service consumers.
                    Additionally, OAuth 2 defines more than one authorization flow.
                    The authorization flow similar to the flow from OAuth 1 is called
                    the <span class="emphasis"><em>Authorization Code Grant Flow</em></span>.
                    This is the flow currently supported by Jersey (Jersey currently does not support other flows).
                    Please refer to the <a class="link" href="http://tools.ietf.org/html/rfc6749" target="_top">OAuth 2.0 specification</a> for more details about authorization flows.
                    Another significant change compared to OAuth 1 is that OAuth 2 is not based on signatures and
                    secret keys and therefore for most of the communication SSL needs to be used
                    (i.e. the requests must be made through HTTPS). This means that all OAuth 2 endpoint URIs must use
                    the <code class="literal">https</code> scheme.
                </p><p>
                    Due to the fact that OAuth 2 does not define a strict protocol, it is not possible to provide a
                    single, universal pre-configured tool interoperable with all providers.
                    Jersey OAuth 2 APIs allows a lot of extensibility via parameters sent in each requests. Jersey
                    currently provides two pre-configured authorization flow providers - for Google and Facebook.
                </p><p>
                    The most important entry points of Jersey client OAuth 2 API and SPI are explained below:

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth2/OAuth2ClientSupport.html" target="_top">OAuth2ClientSupport</a>: The main class which contains builder
                                methods to build features that enable the OAuth 2 support. Start with this class every time
                                you need to add any OAuth 2 support to the Jersey Client (build an Authorization flow
                                or initialize client to perform authenticated requests). The class contains also
                                methods to get authorization flow utilities adjusted for Facebook or Google.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth2/OAuth2CodeGrantFlow.html" target="_top">OAuth2CodeGrantFlow</a>: API that allows to perform the
                                authorization flow defined as Authorization Code Grant Flow in the OAuth 2 specification.
                                Implementation of this interface is a
                                class that is used as a standalone utility and is not part of the JAX-RS client. In
                                other words, this is not a feature that should be registered into the client.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth2/ClientIdentifier.html" target="_top">ClientIdentifier</a>: Identifier of the client issued by the Service
                                Provider for the client. Similar to <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth1/ConsumerCredentials.html" target="_top">ConsumerCredentials</a>
                                from OAuth 1 client support.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth2/OAuth2Parameters.html" target="_top">OAuth2Parameters</a>: Defines parameters that are used in requests
                                during the authorization flow. These parameters can be used to override some of the
                                parameters used in different authorization phases.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/oauth2/TokenResult.html" target="_top">TokenResult</a>:
                                Contains result of the authorization flow. One of the result values is the Access
                                Token. It can additionally contain the expiration time of the Access Token and
                                Refresh Token that can be used to get new Access Token.
                            </p></li></ul></div><p>
                </p><p>
                    The principle of performing the authorization flow with Jersey is similar to OAuth 1.
                    Check the <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/oauth-client-twitter" target="_top">OAuth 1 Twitter Client Example</a> which utilizes Jersey client
                    support for OAuth 2 to get Google Tasks of the user. The application is a web application
                    that uses redirection to forward the user to the authorization URI.
                </p><p>
                    The following code is an example of how to build and use OAuth 2 authorization flow.

                    </p><div class="example"><a name="d0e13093"></a><p class="title"><b>Example&nbsp;17.13.&nbsp;Building OAuth 2 Authorization Flow.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">OAuth2CodeGrantFlow.Builder builder =
    OAuth2ClientSupport.authorizationCodeGrantFlowBuilder(clientId,
                            "https://example.com/oauth/authorization",
                            "https://example.com/oauth/token");
OAuth2CodeGrantFlow flow = builder
    .property(OAuth2CodeGrantFlow.Phase.AUTHORIZATION, "readOnly", "true")
    .scope("contact")
    .build();
String authorizationUri = flow.start();

// Here we must redirect the user to the authorizationUri
// and let the user approve an access for our app.

...

// We must handle redirection back to our web resource
// and extract code and state from the request
final TokenResult result = flow.finish(code, state);
System.out.println("Access Token: " + result.get);</pre></div></div><p><br class="example-break">

                    In the code above we create an <code class="literal">OAuth2CodeGrantFlow</code> from an
                    authorization URI and an access token URI. We have additionally set a
                    <code class="literal">readOnly</code> parameter to <code class="literal">true</code> and assigned the parameter
                    to the authorization phase. This is the way, how you can extend the standard flow with
                    additional service provider-specific parameters. In this case, the <code class="literal">readOnly=true</code>
                    parameter will be added as a query parameter to the authorization uri returned from the method
                    <code class="literal">flow.start()</code>.
                    If we would specify <code class="literal">ACCESS_TOKEN_REQUEST</code> as a phase, then the parameter
                    would have been added to the request when <code class="literal">flow.finish()</code>
                    is invoked. See javadocs for more information. The parameter <code class="literal">readOnly</code>
                    is not part of the OAuth 2 specification and is used in the example
                    for demonstration of how to configure the flow for needs of specific service providers (in this
                    case, the <code class="literal">readOnly</code>
                    param would be described in the service provider's documentation).
                </p><p>
                    Between the calls to <code class="literal">flow.start()</code> and <code class="literal">flow.finish()</code>, a user
                    must be redirected to the authorization URI. This means that the code will not be executed in
                    a single method and the finish part will be invoked as a handler of redirect request back to our web from
                    authorization URI. 
                </p></div></div></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="wadl"></a>Chapter&nbsp;18.&nbsp;WADL Support</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e13140">18.1. WADL introduction</a></span></dt><dt><span class="section"><a href="#d0e13435">18.2. Configuration</a></span></dt><dt><span class="section"><a href="#d0e13490">18.3. Extended WADL support</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13140"></a>18.1.&nbsp;WADL introduction</h2></div></div></div><p>
            Jersey contains support for
            <a class="link" href="https://javaee.github.io/wadl/" target="_top">Web Application Description Language (WADL)</a>. WADL is
            a XML description of a deployed RESTful web application. It contains model of the deployed resources, their
            structure, supported media types, HTTP methods and so on. In a sense, WADL is similar to the WSDL
            (Web Service Description Language) which describes SOAP web services. WADL is however specifically designed
            to describe RESTful Web resources.
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                Since Jersey 2.5.1 the WADL generated by default is WADL in shorter form without
                additional extension resources (OPTIONS methods, WADL resource).
                In order to get full WADL use the query parameter <code class="literal">detail=true</code>.
            </p></div><p>
            Let's start with the simple WADL example. In the example there is a simple <code class="literal">CountryResource</code>
            deployed and we request a wadl of this resource. The context root path of the application is
            <code class="literal">http://localhost:9998</code>.
            </p><div class="example"><a name="d0e13162"></a><p class="title"><b>Example&nbsp;18.1.&nbsp;A simple WADL example - JAX-RS resource definition</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("country/{id}")
public static class CountryResource {

    private CountryService countryService;

    public CountryResource() {
        // init countryService
    }

    @GET
    @Produces(MediaType.APPLICATION_XML)
    public Country getCountry(@PathParam("countryId") int countryId) {
        return countryService.getCountry(countryId);
    }
}</pre></div></div><p><br class="example-break">



            The WADL of a Jersey application that contains the resource above can be requested by a
            HTTP <code class="literal">GET</code> request to <code class="literal">http://localhost:9998/application.wadl</code>.
            Jersey will return a response with a WADL content similar to the one in the following example:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
    &lt;doc xmlns:jersey="http://jersey.java.net/" jersey:generatedBy="Jersey: 3.0.0 2020-12-16 13:49:07"/&gt;
    &lt;grammars/&gt;
    &lt;resources base="http://localhost:9998/"&gt;
        &lt;resource path="country/{id}"&gt;
            &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema" type="xs:int" style="template" name="countryId"/&gt;
            &lt;method name="GET" id="getCountry"&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/application&gt;</pre><p>
        </p><p>
            The returned WADL is a XML that contains element <code class="literal">resource</code>
            with path <code class="literal">country/{id}</code>. This resource has one inner <code class="literal">method</code> element
            with http method as attribute, name of java method and its produced representation. This description
            corresponds to defined java resource. Now let's look at more complex example.
        </p><p>
            The previous WADL does not actually contain all resources exposed in our API. There are other
            resources that are available and are hidden in the previous WADL. The previous WADL shows only resources
            that are provided by the user. In the following example, the WADL
            is generated using query parameter <code class="literal">detail</code>:
            <code class="literal">http://localhost:9998/application.wadl?detail</code>. Note that usage of
            <code class="literal">http://localhost:9998/application.wadl?detail=true</code> is also valid.
            This will produce the WADL with all resource available in the application:
        </p><div class="example"><a name="d0e13199"></a><p class="title"><b>Example&nbsp;18.2.&nbsp;A simple WADL example - WADL content</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
    &lt;doc xmlns:jersey="http://jersey.java.net/" jersey:generatedBy="Jersey: 3.0.0 2020-12-16 13:49:07"/&gt;
    &lt;doc xmlns:jersey="http://jersey.java.net/" jersey:hint="To get simplified WADL with user's resources only do not use the query parameter detail. Link: http://localhost:9998/application.wadl"/&gt;
    &lt;grammars/&gt;
    &lt;resources base="http://localhost:9998/"&gt;
        &lt;resource path="country/{id}"&gt;
            &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema" type="xs:int" style="template" name="countryId"/&gt;
            &lt;method name="GET" id="getCountry"&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/vnd.sun.wadl+xml"/&gt;
                &lt;/response&gt;
                &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="text/plain"/&gt;
                &lt;/response&gt;
                &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/response&gt;
                &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
            &lt;/method&gt;
        &lt;/resource&gt;
        &lt;resource path="application.wadl"&gt;
            &lt;method name="GET" id="getWadl"&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/vnd.sun.wadl+xml"/&gt;
                    &lt;representation mediaType="application/xml"/&gt;
                &lt;/response&gt;
                &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="text/plain"/&gt;
                &lt;/response&gt;
                &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/response&gt;
                &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
            &lt;/method&gt;
            &lt;resource path="{path}"&gt;
                &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema" type="xs:string" style="template" name="path"/&gt;
                &lt;method name="GET" id="geExternalGrammar"&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="application/xml"/&gt;
                    &lt;/response&gt;
                    &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
                &lt;/method&gt;
                &lt;method name="OPTIONS" id="apply"&gt;
                    &lt;request&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/request&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="text/plain"/&gt;
                    &lt;/response&gt;
                    &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
                &lt;/method&gt;
                &lt;method name="OPTIONS" id="apply"&gt;
                    &lt;request&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/request&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/response&gt;
                    &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
                &lt;/method&gt;
                &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
            &lt;/resource&gt;
            &lt;jersey:extended xmlns:jersey="http://jersey.java.net/"&gt;true&lt;/jersey:extended&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/application&gt;
</pre></div></div><br class="example-break"><p>
            In the example above the returned application WADL is shown in full. WADL schema is defined by the
            WADL specification, so let's look at it in more details. The root WADL document element is
            the <code class="literal">application</code>. It contains global
            information about the deployed JAX-RS application. Under this element there is a nested element
            <code class="literal">resources</code> which contains zero or more <code class="literal">resource</code> elements. Each
            <code class="literal">resource</code> element describes a single deployed resource. In our example, there are only two root
            resources - <code class="literal">"country/{id}"</code> and <code class="literal">"application.wadl"</code>. The
            <code class="literal">"application.wadl"</code> resource is the resource that was just requested in order to receive the
            application WADL document. Even though WADL support is an additional feature in Jersey it is still
            a resource deployed in the resource model and therefore it is itself present in the returned WADL document.
            The first resource element with the <code class="literal">path="country/{id}"</code> is the element that describes our
            custom deployed resource.
            This resource contains a <code class="literal">GET</code> method and three <code class="literal">OPTIONS</code> methods.
            The <code class="literal">GET</code> method is our getCountry() method defined in the sample. There is a method name
            in the <code class="literal">id</code> attribute and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> is described in the
            <code class="literal">response/representation</code> WADL element. <code class="literal">OPTIONS</code> methods are the methods that
            are automatically added by Jersey to each resource. There is an <code class="literal">OPTIONS</code> method
            returning <code class="literal">"text/plain"</code> media type, that will return a response with a string entity containing
            the list of methods deployed on this resource (this means that instead of WADL you can use this <code class="literal">OPTIONS</code>
            method to get similar information in a textual representation).
            Another <code class="literal">OPTIONS</code> method returning <code class="literal">*/*</code> will return a response with no entity
            and <code class="literal">Allow</code> header that will contain list of methods as a String.
            The last <code class="literal">OPTIONS</code> method producing <code class="literal">"application/vnd.sun.wadl+xml"</code> returns a
            WADL description of the resource <code class="literal">"country/{id}"</code>. As you can see, all <code class="literal">OPTIONS</code> methods
            return information about the resource to which the HTTP <code class="literal">OPTIONS</code> request is made.
        </p><p>
            Second resource with a path "application.wadl" has, again, similar <code class="literal">OPTIONS</code> methods
            and one <code class="literal">GET</code> method which return this WADL. There is also
            a sub-resource with a path defined by path param <code class="literal">{path}</code>. This means that you can request
            a resource on the URI <code class="literal">http://localhost:9998/application.wadl/something</code>.
            This is used only to return an external grammar if there is any attached. Such an external grammar can be
            for example an <code class="literal">XSD</code> schema of the response entity which if the response entity is a JAXB bean.
            An external grammar support via Jersey <span class="emphasis"><em>extended WADL support</em></span> is described in sections below.
        </p><p>
            All resource that were added in this second example into the WADL contains
            element <code class="literal">extended</code>. This means that this resource is not a part of a core RESTful API and
            is rather a helper resource. If you need to mark any your own resource are extended, annotate
            is with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/model/ExtendedResource.html" target="_top">@ExtendedResource</a>. Note that there might be methods visible in the default simple
            WADL even the user has not added them. This is for example the case of MVC added methods which were added
            by <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/model/ModelProcessor.html" target="_top">ModelProcessor</a> but are still intended to be used by the client to achieve their
            primary use case of getting formatted data.
        </p><p>
            Let's now send a HTTP <code class="literal">OPTIONS</code> request to <code class="literal">"country/{id}"</code> resource using the the
            <code class="literal">curl</code> command:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    gutter: false;">curl -X OPTIONS -H "Allow: application/vnd.sun.wadl+xml" \
    -v http://localhost:9998/country/15</pre><p>

            We should see a WADL returned similar to this one:

            </p><div class="example"><a name="d0e13329"></a><p class="title"><b>Example&nbsp;18.3.&nbsp;OPTIONS method returning WADL</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
    &lt;doc xmlns:jersey="http://jersey.java.net/"
        jersey:generatedBy="Jersey: 3.0.0 ${buildNumber}"/&gt;
    &lt;grammars/&gt;
    &lt;resources base="http://localhost:9998/"&gt;
        &lt;resource path="country/15"&gt;
            &lt;method name="GET" id="getCountry"&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/vnd.sun.wadl+xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="text/plain"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/application&gt;</pre></div></div><p><br class="example-break">
            The returned WADL document has the standard WADL structure that we saw in the WADL document returned for the
            whole Jersey application earlier. The main difference here is that the only <code class="literal">resource</code> is the
            resource to which the <code class="literal">OPTIONS</code> HTTP request was sent. The resource has now path
            <code class="literal">"country/15"</code> and not <code class="literal">"country/{id}"</code> as the path parameter
            <code class="literal">{id}</code> was already specified in the request to this concrete resource.
        </p><p>
            Another, a more complex WADL example is shown in the next example.

            </p><div class="example"><a name="d0e13352"></a><p class="title"><b>Example&nbsp;18.4.&nbsp;More complex WADL example - JAX-RS resource definition</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("customer/{id}")
public static class CustomerResource {
    private CustomerService customerService;

    @GET
    public Customer get(@PathParam("id") int id) {
        return customerService.getCustomerById(id);
    }

    @PUT
    public Customer put(Customer customer) {
        return customerService.updateCustomer(customer);
    }

    @Path("address")
    public CustomerAddressSubResource getCustomerAddress(@PathParam("id") int id) {
        return new CustomerAddressSubResource(id);
    }

    @Path("additional-info")
    public Object getAdditionalInfoSubResource(@PathParam("id") int id) {
        return new CustomerAddressSubResource(id);
    }

}


public static class CustomerAddressSubResource {
    private final int customerId;
    private CustomerService customerService;

    public CustomerAddressSubResource(int customerId) {
        this.customerId = customerId;
        this.customerService = null; // init customer service here
    }

    @GET
    public String getAddress() {
        return customerService.getAddressForCustomer(customerId);
    }

    @PUT
    public void updateAddress(String address) {
        customerService.updateAddressForCustomer(customerId, address);
    }

    @GET
    @Path("sub")
    public String getDeliveryAddress() {
        return customerService.getDeliveryAddressForCustomer(customerId);
    }
}</pre></div></div><p><br class="example-break">

            The <code class="literal">GET</code> request to <code class="literal">http://localhost:9998/application.wadl</code> will
            return the following WADL document:

            </p><div class="example"><a name="d0e13364"></a><p class="title"><b>Example&nbsp;18.5.&nbsp;More complex WADL example - WADL content</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
    &lt;doc xmlns:jersey="http://jersey.java.net/"
        jersey:generatedBy="Jersey: 3.0.0 ${buildNumber}"/&gt;
    &lt;grammars/&gt;
    &lt;resources base="http://localhost:9998/"&gt;
        &lt;resource path="customer/{id}"&gt;
            &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                type="xs:int" style="template" name="id"/&gt;
            &lt;method name="GET" id="get"&gt;
                &lt;response/&gt;
            &lt;/method&gt;
            &lt;method name="PUT" id="put"&gt;
                &lt;response/&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/vnd.sun.wadl+xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="text/plain"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;resource path="additional-info"&gt;
                &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                    type="xs:int" style="template" name="id"/&gt;
            &lt;/resource&gt;
            &lt;resource path="address"&gt;
                &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                    type="xs:int" style="template" name="id"/&gt;
                &lt;method name="GET" id="getAddress"&gt;
                    &lt;response/&gt;
                &lt;/method&gt;
                &lt;method name="PUT" id="updateAddress"/&gt;
                &lt;resource path="sub"&gt;
                    &lt;method name="GET" id="getDeliveryAddress"&gt;
                        &lt;response/&gt;
                    &lt;/method&gt;
                &lt;/resource&gt;
            &lt;/resource&gt;
        &lt;/resource&gt;
        &lt;resource path="application.wadl"&gt;
            &lt;method name="GET" id="getWadl"&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/vnd.sun.wadl+xml"/&gt;
                    &lt;representation mediaType="application/xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="text/plain"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;resource path="{path}"&gt;
                &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                    type="xs:string" style="template" name="path"/&gt;
                &lt;method name="GET" id="geExternalGrammar"&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="application/xml"/&gt;
                    &lt;/response&gt;
                &lt;/method&gt;
                &lt;method name="OPTIONS" id="apply"&gt;
                    &lt;request&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/request&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="text/plain"/&gt;
                    &lt;/response&gt;
                &lt;/method&gt;
                &lt;method name="OPTIONS" id="apply"&gt;
                    &lt;request&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/request&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/response&gt;
                &lt;/method&gt;
            &lt;/resource&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/application&gt;</pre></div></div><p><br class="example-break">

            The <code class="literal">resource</code> with <code class="literal">path="customer/{id}"</code> is similar to the
            country resource from the previous example. There is a path parameter which identifies the customer
            by <code class="literal">id</code>. The resource contains 2 user-declared methods and again auto-generated
            <code class="literal">OPTIONS</code> methods added by Jersey. The resource declares 2 sub-resource locators which are
            represented in the returned WADL document as nested <code class="literal">resource</code> elements. Note that the sub-resource
            locator <code class="literal">getCustomerAddress()</code> returns a type CustomerAddressSubResource in the
            method declaration and also in the WADL there is a <code class="literal">resource</code> element for such
            a sub resource with full internal description. The second method
            <code class="literal">getAdditionalInfoSubResource()</code> returns only an <code class="literal">Object</code> in the method declaration.
            While this is correct from the JAX-RS perspective as the real returned type can be computed from a request
            information, it creates a problem for WADL generator because WADL is generated based on the static configuration
            of the JAX-RS application resources. The WADL generator does not know what type would be actually returned to
            a request at run time.
            That is the reason why the nested <code class="literal">resource</code> element with <code class="literal">path="additional-info"</code>
            does not contain any information about the supported resource representations.
        </p><p>
            The <code class="literal">CustomerAddressSubResource</code> sub-resource described in the nested element
            <code class="literal">&lt;resource path="address"&gt;</code> does not contain an <code class="literal">OPTIONS</code> method.
            While these methods are in fact generated by Jersey for the sub-resource, Jersey WADL generator does not currently
            support adding these methods to the sub-resource description. This should be addressed in the near future.
            Still, there are two user-defined resource methods handling HTTP <code class="literal">GET</code> and <code class="literal">PUT</code> requests.
            The sub-resource method <code class="literal">getDeliveryAddress()</code> is represented as a separate nested resource with
            <code class="literal">path="sub"</code>. Should there be more sub-resource methods defined with <code class="literal">path="sub"</code>,
            then all these method descriptions would be placed into the same <code class="literal">resource</code> element.
            In other words, sub-resource methods are grouped in WADL as sub-resources based on their <code class="literal">path</code>
            value.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13435"></a>18.2.&nbsp;Configuration</h2></div></div></div><p>
            WADL generation is enabled in Jersey by default. This means that <code class="literal">OPTIONS</code>
            methods are added by default to each resource and an auto-generated <code class="literal">/application.wadl</code>
            resource is deployed too. To override this default behavior and disable WADL generation in Jersey, setup the
            configuration property in your application:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">jersey.config.server.wadl.disableWadl=true</pre><p>

            This property can be setup in a <code class="literal">web.xml</code> if the Jersey application is deployed
            in the servlet with <code class="literal">web.xml</code> or the property can be returned from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a>.
            <code class="literal">getProperties()</code>. See <a class="link" href="#deployment" title="Chapter&nbsp;4.&nbsp;Application Deployment and Runtime Environments">Deployment chapter</a> for more information
            on setting the application configuration properties in various deployments.
        </p><p>
            WADL support in Jersey is implemented via <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/model/ModelProcessor.html" target="_top">ModelProcessor</a> extension. This implementation enhances
            the application resource model by adding the WADL providing resources. WADL <code class="literal">ModelProcessor</code>
            priority value is high (i.e. the priority is low) as it should be executed as one of the last model processors.
            Therefore, any <code class="literal">ModelProcessor</code> executed before will not see WADL extensions in the resource model.
            WADL handling resource model extensions (resources and <code class="literal">OPTIONS</code> resource methods) are not added to the
            application resource model if there is already a matching resource or a resource method detected in the model.
            In other words, if you define for example your own <code class="literal">OPTIONS</code> method that would produce
            <code class="literal">"application.wadl"</code> response content, this method will not be overridden by WADL model processor.
            See <a class="link" href="#resource-builder" title="Chapter&nbsp;14.&nbsp;Programmatic API for Building Resources">Resource builder chapter</a> for more information on
            <code class="literal">ModelProcessor</code> extension mechanism.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13490"></a>18.3.&nbsp;Extended WADL support</h2></div></div></div><p>
            <span class="strong"><strong>Please note that the API of extended WADL support is going to be changed in one of the future
            releases of Jersey 3.x (see below).</strong></span>
        </p><p>
            Jersey supports extension of WADL generation called <span class="emphasis"><em>extended WADL</em></span>. Using the extended WADL
            support you can enhance the generated WADL document with additional information, such as
            resource method javadoc-based documentation of your REST APIs, adding general documentation,
            adding external grammar support, or adding any custom WADL extension information.
        </p><p>
            <span class="strong"><strong>Again, note that the extended WADL in Jersey 3.x is NOT the intended final version and
            API is going to be changed.</strong></span> The existing set of features and functionality will be preserved but the
            APIs will be significantly re-designed to support additional use cases. This impacts mainly the APIs of
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/wadl/WadlGenerator.html" target="_top">WadlGenerator</a>, <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/wadl/config/WadlGeneratorConfig.html" target="_top">WadlGeneratorConfig</a> as well as any related classes. The API changes
            may impact your code if you are using a custom <code class="literal">WadlGenerator</code> or plan to implement one.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="bean-validation"></a>Chapter&nbsp;19.&nbsp;Bean Validation Support</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e13529">19.1. Bean Validation Dependencies</a></span></dt><dt><span class="section"><a href="#d0e13555">19.2. Enabling Bean Validation in Jersey</a></span></dt><dt><span class="section"><a href="#d0e13589">19.3. Configuring Bean Validation Support</a></span></dt><dt><span class="section"><a href="#d0e13694">19.4. Validating JAX-RS resources and methods</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e13723">19.4.1. Constraint Annotations</a></span></dt><dt><span class="section"><a href="#d0e13809">19.4.2. Annotation constraints and Validators</a></span></dt><dt><span class="section"><a href="#d0e13859">19.4.3. Entity Validation</a></span></dt><dt><span class="section"><a href="#d0e13940">19.4.4. Annotation Inheritance</a></span></dt></dl></dd><dt><span class="section"><a href="#bv.ValidateOnExecution">19.5. @ValidateOnExecution</a></span></dt><dt><span class="section"><a href="#bv.injecting">19.6. Injecting</a></span></dt><dt><span class="section"><a href="#d0e14064">19.7. Error Reporting</a></span></dt><dd><dl><dt><span class="section"><a href="#bv.ValidationError">19.7.1. ValidationError</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e14222">19.8. Example</a></span></dt></dl></div><p>
        Validation is a process of verifying that some data obeys one or more pre-defined constraints. This chapter describes
        support for <a class="link" href="http://beanvalidation.org/" target="_top">Bean Validation</a> in Jersey in terms of the needed dependencies, configuration, registration and usage.
        For more detailed description on how JAX-RS provides native support for validating resource classes based on the
        Bean Validation refer to the chapter in the <a class="link" href="http://jcp.org/en/jsr/detail?id=339" target="_top">JAX-RS spec</a>.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13529"></a>19.1.&nbsp;Bean Validation Dependencies</h2></div></div></div><p>
            Bean Validation support in Jersey is provided as an extension module and needs to be mentioned explicitly in your
            <code class="literal">pom.xml</code> file (in case of using Maven):

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-bean-validation&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    If you're not using Maven make sure to have also all the transitive dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-bean-validation/dependencies.html" target="_top">jersey-bean-validation</a>) on
                    the classpath.
                </p></div><p>

            This module depends directly on
            <a class="link" href="http://hibernate.org/validator/" target="_top">Hibernate Validator</a>
            which provides a most commonly used implementation of the Bean Validation API spec.
        </p><p>
            If you want to use a different implementation of the Bean Validation API, use standard Maven mechanisms to exclude
            Hibernate Validator from the modules dependencies and add a dependency of your own.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-bean-validation&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13555"></a>19.2.&nbsp;Enabling Bean Validation in Jersey</h2></div></div></div><p>
            As stated in <a class="xref" href="#deployment.autodiscoverable" title="4.3.&nbsp;Auto-Discoverable Features">Section&nbsp;4.3, &#8220;Auto-Discoverable Features&#8221;</a>, Jersey Bean Validation is one of the modules where you
            don't need to explicitly register its <code class="literal">Feature</code>s (<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/validation/ValidationFeature.html" target="_top">ValidationFeature</a>) on the
            server as its features are automatically discovered and registered when you add the
            <code class="literal">jersey-bean-validation</code> module to your classpath.
            There are three Jersey specific properties that could disable automatic discovery and registration of Jersey Bean
            Validation integration module:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">ServerProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_FEATURE_DISABLE" target="_top">ServerProperties.BV_FEATURE_DISABLE</a></p></li></ul></div><p>

            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Jersey does not support Bean Validation on the client at the moment.</p></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13589"></a>19.3.&nbsp;Configuring Bean Validation Support</h2></div></div></div><p>
            Configuration of Bean Validation support in Jersey is twofold - there are few specific properties that affects Jersey
            behaviour (e.g. sending validation error entities to the client) and then there is <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/validation/ValidationConfig.html" target="_top">ValidationConfig</a> class
            that configures <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/validator" target="_top">Validator</a> used for validating resources in JAX-RS application.
        </p><p>
            To configure Jersey specific behaviour you can use the following properties:

            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK" target="_top">ServerProperties.BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK</a></span></dt><dd><p>
                            Disables <code class="literal">@ValidateOnExecution</code> check. More on this is described in
                            <a class="xref" href="#bv.ValidateOnExecution" title="19.5.&nbsp;@ValidateOnExecution">Section&nbsp;19.5, &#8220;@ValidateOnExecution&#8221;</a>.
                        </p></dd><dt><span class="term"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_SEND_ERROR_IN_RESPONSE" target="_top">ServerProperties.BV_SEND_ERROR_IN_RESPONSE</a></span></dt><dd><p>
                            Enables sending validation errors in response entity to the client. More on this in
                            <a class="xref" href="#bv.ValidationError" title="19.7.1.&nbsp;ValidationError">Section&nbsp;19.7.1, &#8220;ValidationError&#8221;</a>.
                        </p></dd></dl></div><p>

            </p><div class="example"><a name="bv.example.jersey.properties"></a><p class="title"><b>Example&nbsp;19.1.&nbsp;Configuring Jersey specific properties for Bean Validation.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    // Now you can expect validation errors to be sent to the client.
    .property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true)
    // @ValidateOnExecution annotations on subclasses won't cause errors.
    .property(ServerProperties.BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK, true)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            Customization of the <code class="literal">Validator</code> used in validation of resource classes/methods can be done using
            <code class="literal">ValidationConfig</code> class and exposing it via <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ContextResolver.html" target="_top">ContextResolver&lt;T&gt;</a> mechanism as shown in
            <a class="xref" href="#bv.example.ValidationConfig" title="Example&nbsp;19.2.&nbsp;Using ValidationConfig to configure Validator.">Example&nbsp;19.2, &#8220;Using <code class="literal">ValidationConfig</code> to configure <code class="literal">Validator</code>.&#8221;</a>. You can set custom instances for the following interfaces from
            the Bean Validation API:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/messageinterpolator" target="_top">MessageInterpolator</a> - interpolates a given constraint violation message.
                    </p></li><li class="listitem"><p>
                        <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/traversableresolver" target="_top">TraversableResolver</a> - determines if a property can be accessed by the Bean Validation provider.
                    </p></li><li class="listitem"><p>
                        <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/constraintvalidatorfactory" target="_top">ConstraintValidatorFactory</a> - instantiates a <code class="literal">ConstraintValidator</code> instance based
                        off its class. Note that by setting a custom <code class="literal">ConstraintValidatorFactory</code> you may loose
                        injection of available resources/providers at the moment. See <a class="xref" href="#bv.injecting" title="19.6.&nbsp;Injecting">Section&nbsp;19.6, &#8220;Injecting&#8221;</a> how to
                        handle this.
                    </p></li><li class="listitem"><p><a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/parameternameprovider" target="_top">ParameterNameProvider</a> - provides names for method and constructor parameters.</p></li></ul></div><p>

            </p><div class="example"><a name="bv.example.ValidationConfig"></a><p class="title"><b>Example&nbsp;19.2.&nbsp;Using <code class="literal">ValidationConfig</code> to configure <code class="literal">Validator</code>.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">/**
 * Custom configuration of validation. This configuration defines custom:
 * &lt;ul&gt;
 *     &lt;li&gt;ConstraintValidationFactory - so that validators are able to inject Jersey providers/resources.&lt;/li&gt;
 *     &lt;li&gt;ParameterNameProvider - if method input parameters are invalid, this class returns actual parameter names
 *     instead of the default ones ({@code arg0, arg1, ..})&lt;/li&gt;
 * &lt;/ul&gt;
 */
public class ValidationConfigurationContextResolver implements ContextResolver&lt;ValidationConfig&gt; {

    @Context
    private ResourceContext resourceContext;

    @Override
    public ValidationConfig getContext(final Class&lt;?&gt; type) {
        final ValidationConfig config = new ValidationConfig();
        config.setConstraintValidatorFactory(resourceContext.getResource(InjectingConstraintValidatorFactory.class));
        config.setParameterNameProvider(new CustomParameterNameProvider());
        return config;
    }

    /**
     * See ContactCardTest#testAddInvalidContact.
     */
    private class CustomParameterNameProvider implements ParameterNameProvider {

        private final ParameterNameProvider nameProvider;

        public CustomParameterNameProvider() {
            nameProvider = Validation.byDefaultProvider().configure().getDefaultParameterNameProvider();
        }

        @Override
        public List&lt;String&gt; getParameterNames(final Constructor&lt;?&gt; constructor) {
            return nameProvider.getParameterNames(constructor);
        }

        @Override
        public List&lt;String&gt; getParameterNames(final Method method) {
            // See ContactCardTest#testAddInvalidContact.
            if ("addContact".equals(method.getName())) {
                return Arrays.asList("contact");
            }
            return nameProvider.getParameterNames(method);
        }
    }
}</pre><p>Register this class in your app:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Application application = new ResourceConfig()
        // Validation.
        .register(ValidationConfigurationContextResolver.class)
        // Further configuration.
        .register( ... );</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This code snippet is based on CustomConfigValidationTest (from Jersey's source codes)</p></div></div></div><p><br class="example-break">
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13694"></a>19.4.&nbsp;Validating JAX-RS resources and methods</h2></div></div></div><p>
            JAX-RS specification states that constraint annotations are allowed in the same locations as the following
            annotations: <code class="literal">@MatrixParam</code>, <code class="literal">@QueryParam</code>, <code class="literal">@PathParam</code>, <code class="literal">@CookieParam</code>,
            <code class="literal">@HeaderParam</code> and <code class="literal">@Context</code>, <span class="emphasis"><em>except</em></span> in class constructors and property
            setters. Specifically, they are allowed in resource method parameters, fields and property getters as well as
            resource classes, entity parameters and resource methods (return values).
            Jersey provides support for validation (see following sections) annotated input parameters and return value of the
            invoked resource method as well as validation of resource class (class constraints, field constraints) where this
            resource method is placed.
            Jersey does not support, and doesn't validate, constraints placed on constructors and Bean Validation groups (only
            <code class="literal">Default</code> group is supported at the moment).
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13723"></a>19.4.1.&nbsp;Constraint Annotations</h3></div></div></div><p>
                The JAX-RS Server API provides support for extracting request values and mapping them into Java fields,
                properties and parameters using annotations such as <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/HeaderParam.html" target="_top">@HeaderParam</a>, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/QueryParam.html" target="_top">@QueryParam</a>, etc. It also
                supports mapping of the request entity bodies into Java objects via non-annotated parameters (i.e., parameters
                without any JAX-RS annotations).
            </p><p>
                The Bean Validation specification supports the use of <span class="emphasis"><em>constraint annotations</em></span>
                as a way of declarative validating beans, method parameters and method returned values. For example, consider
                resource class from <a class="xref" href="#bv.example.constraints" title="Example&nbsp;19.3.&nbsp;Constraint annotations on input parameters">Example&nbsp;19.3, &#8220;Constraint annotations on input parameters&#8221;</a> augmented with constraint annotations.

                </p><div class="example"><a name="bv.example.constraints"></a><p class="title"><b>Example&nbsp;19.3.&nbsp;Constraint annotations on input parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
class MyResourceClass {

    @POST
    @Consumes("application/x-www-form-urlencoded")
    public void registerUser(
            @NotNull @FormParam("firstName") String firstName,
            @NotNull @FormParam("lastName") String lastName,
            @Email @FormParam("email") String email) {
        ...
    }
}</pre></div></div><p><br class="example-break">

                The annotations <code class="literal">@NotNull</code> and <code class="literal">@Email</code> impose additional constraints on the form parameters
                <code class="literal">firstName</code>, <code class="literal">lastName</code> and <code class="literal">email</code>. The <code class="literal">@NotNull</code>
                constraint is built-in to the Bean Validation API; the <code class="literal">@Email</code>
                constraint is assumed to be user defined in the example above. These constraint annotations are not restricted to
                method parameters, they can be used in any location in which JAX-RS binding annotations are allowed with the
                exception of constructors and property setters.
            </p><p>
                Rather than using method parameters, the <code class="literal">MyResourceClass</code> shown above could have been written
                as in <a class="xref" href="#bv.example.constraints.fields" title="Example&nbsp;19.4.&nbsp;Constraint annotations on fields">Example&nbsp;19.4, &#8220;Constraint annotations on fields&#8221;</a>.

                </p><div class="example"><a name="bv.example.constraints.fields"></a><p class="title"><b>Example&nbsp;19.4.&nbsp;Constraint annotations on fields</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
class MyResourceClass {

    @NotNull
    @FormParam("firstName")
    private String firstName;

    @NotNull
    @FormParam("lastName")
    private String lastName;

    private String email;

    @FormParam("email")
    public void setEmail(String email) {
        this.email = email;
    }

    @Email
    public String getEmail() {
        return email;
    }

    ...
}</pre></div></div><p><br class="example-break">

                Note that in this version, <code class="literal">firstName</code> and <code class="literal">lastName</code> are fields initialized
                via injection and <code class="literal">email</code> is a resource class property. Constraint annotations on properties are
                specified in their corresponding getters.
            </p><p>
                Constraint annotations are also allowed on resource classes. In addition to annotating fields and properties, an
                annotation can be defined for the entire class. Let us assume that <code class="literal">@NonEmptyNames</code> validates
                that one of the two <span class="emphasis"><em>name</em></span> fields in <code class="literal">MyResourceClass</code> is provided. Using
                such an annotation, the example above can be extended to look like <a class="xref" href="#bv.example.constraints.class" title="Example&nbsp;19.5.&nbsp;Constraint annotations on class">Example&nbsp;19.5, &#8220;Constraint annotations on class&#8221;</a>

                </p><div class="example"><a name="bv.example.constraints.class"></a><p class="title"><b>Example&nbsp;19.5.&nbsp;Constraint annotations on class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
@NonEmptyNames
class MyResourceClass {

    @NotNull
    @FormParam("firstName")
    private String firstName;

    @NotNull
    @FormParam("lastName")
    private String lastName;

    private String email;

    ...
}</pre></div></div><p><br class="example-break">

                Constraint annotations on resource classes are useful for defining cross-field and cross-property constraints.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13809"></a>19.4.2.&nbsp;Annotation constraints and Validators</h3></div></div></div><p>
                Annotation constraints and validators are defined in accordance with the Bean Validation specification.
                The <code class="literal">@Email</code> annotation used in <a class="xref" href="#bv.example.constraints.fields" title="Example&nbsp;19.4.&nbsp;Constraint annotations on fields">Example&nbsp;19.4, &#8220;Constraint annotations on fields&#8221;</a> is defined using the
                Bean Validation <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/constraint" target="_top">@Constraint</a> meta-annotation, see <a class="xref" href="#bv.example.constraints.definition" title="Example&nbsp;19.6.&nbsp;Definition of a constraint annotation">Example&nbsp;19.6, &#8220;Definition of a constraint annotation&#8221;</a>.

                </p><div class="example"><a name="bv.example.constraints.definition"></a><p class="title"><b>Example&nbsp;19.6.&nbsp;Definition of a constraint annotation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Target({ METHOD, FIELD, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = EmailValidator.class)
public @interface Email {

    String message() default "{com.example.validation.constraints.email}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div></div><p><br class="example-break">

                The <code class="literal">@Constraint</code> annotation must include a reference to the validator class that will be used to validate
                decorated values. The <code class="literal">EmailValidator</code> class must implement
                <code class="literal">ConstraintValidator&lt;Email, T&gt;</code> where <code class="literal">T</code> is the type of values being
                validated, as described in <a class="xref" href="#bv.example.validator.definition" title="Example&nbsp;19.7.&nbsp;Validator implementation.">Example&nbsp;19.7, &#8220;Validator implementation.&#8221;</a>.

                </p><div class="example"><a name="bv.example.validator.definition"></a><p class="title"><b>Example&nbsp;19.7.&nbsp;Validator implementation.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class EmailValidator implements ConstraintValidator&lt;Email, String&gt; {

    public void initialize(Email email) {
        ...
    }

    public boolean isValid(String value, ConstraintValidatorContext context) {
        ...
    }
}</pre></div></div><p><br class="example-break">

                Thus, <code class="literal">EmailValidator</code> applies to values annotated with <code class="literal">@Email</code> that are of type
                <code class="literal">String</code>. Validators for other Java types can be defined for the same constraint annotation.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13859"></a>19.4.3.&nbsp;Entity Validation</h3></div></div></div><p>
                Request entity bodies can be mapped to resource method parameters. There are two ways in which these entities can
                be validated. If the request entity is mapped to a Java bean whose class is decorated with Bean Validation
                annotations, then validation can be enabled using <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/valid" target="_top">@Valid</a> as in <a class="xref" href="#bv.example.constraints.entity" title="Example&nbsp;19.8.&nbsp;Entity validation">Example&nbsp;19.8, &#8220;Entity validation&#8221;</a>.

                </p><div class="example"><a name="bv.example.constraints.entity"></a><p class="title"><b>Example&nbsp;19.8.&nbsp;Entity validation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@StandardUser
class User {

    @NotNull
    private String firstName;

    ...
}


@Path("/")
class MyResourceClass {

    @POST
    @Consumes("application/xml")
    public void registerUser(@Valid User user) {
        ...
    }
}</pre></div></div><p><br class="example-break">

                In this case, the validator associated with <code class="literal">@StandardUser</code> (as well as those for non-class
                level constraints like <code class="literal">@NotNull</code>) will be called to verify the request entity mapped to
                <code class="literal">user</code>.
            </p><p>
                Alternatively, a new annotation can be defined and used directly on the resource
                method parameter (<a class="xref" href="#bv.example.constraints.entity2" title="Example&nbsp;19.9.&nbsp;Entity validation 2">Example&nbsp;19.9, &#8220;Entity validation 2&#8221;</a>).

                </p><div class="example"><a name="bv.example.constraints.entity2"></a><p class="title"><b>Example&nbsp;19.9.&nbsp;Entity validation 2</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
class MyResourceClass {

    @POST
    @Consumes("application/xml")
    public void registerUser(@PremiumUser User user) {
        ...
    }
}</pre></div></div><p><br class="example-break">

                In the example above, <code class="literal">@PremiumUser</code> rather than <code class="literal">@StandardUser</code> will be used
                to validate the request entity. These two ways in which validation of entities can be triggered can also be
                combined by including <code class="literal">@Valid</code> in the list of constraints. The presence of <code class="literal">@Valid</code> will trigger
                validation of <span class="emphasis"><em>all</em></span> the constraint annotations decorating a Java bean class.
            </p><p>
                Response entity bodies returned from resource methods can be validated in a similar manner by annotating the
                resource method itself. To exemplify, assuming both <code class="literal">@StandardUser</code> and
                <code class="literal">@PremiumUser</code> are required to be checked before returning a user, the
                <code class="literal">getUser</code> method can be annotated as shown in
                <a class="xref" href="#bv.example.constraints.entity.response" title="Example&nbsp;19.10.&nbsp;Response entity validation">Example&nbsp;19.10, &#8220;Response entity validation&#8221;</a>.
                </p><div class="example"><a name="bv.example.constraints.entity.response"></a><p class="title"><b>Example&nbsp;19.10.&nbsp;Response entity validation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
class MyResourceClass {

    @GET
    @Path("{id}")
    @Produces("application/xml")
    @Valid @PremiumUser
    public User getUser(@PathParam("id") String id) {
        User u = findUser(id);
        return u;
    }

    ...
}</pre></div></div><p><br class="example-break">

                Note that <code class="literal">@PremiumUser</code> is explicitly listed and <code class="literal">@StandardUser</code> is triggered
                by the presence of the <code class="literal">@Valid</code> annotation - see definition of <code class="literal">User</code> class earlier in
                this section.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13940"></a>19.4.4.&nbsp;Annotation Inheritance</h3></div></div></div><p>
                The rules for inheritance of constraint annotation are defined in Bean Validation specification. It is worth
                noting that these rules are incompatible with those defined by JAX-RS. Generally speaking, constraint
                annotations in Bean Validation are cumulative (can be strengthen) across a given type hierarchy while JAX-RS
                annotations are inherited or, overridden and ignored.
            </p><p>
                For Bean Validation annotations Jersey follows the constraint annotation rules defined in the Bean Validation
                specification.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bv.ValidateOnExecution"></a>19.5.&nbsp;@ValidateOnExecution</h2></div></div></div><p>
            According to Bean Validation specification, validation is enabled by default only for the so called
            <span class="emphasis"><em>constrained</em></span> methods. Getter
            methods as defined by the Java Beans specification are not constrained methods, so they will not be validated by
            default. The special annotation <code class="literal">@ValidateOnExecution</code> can be used to selectively enable
            and disable validation. For example, you can enable validation on method <code class="literal">getEmail</code> shown in
            <a class="xref" href="#bv.example.validateonexecution" title="Example&nbsp;19.11.&nbsp;Validate getter on execution">Example&nbsp;19.11, &#8220;Validate getter on execution&#8221;</a>.
            </p><div class="example"><a name="bv.example.validateonexecution"></a><p class="title"><b>Example&nbsp;19.11.&nbsp;Validate getter on execution</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
class MyResourceClass {

    @Email
    @ValidateOnExecution
    public String getEmail() {
        return email;
    }

    ...
}</pre></div></div><p><br class="example-break">

            The default value for the <code class="literal">type</code> attribute of <code class="literal">@ValidateOnExecution</code> is
            <code class="literal">IMPLICIT</code> which results in method <code class="literal">getEmail</code> being validated.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    According to Bean Validation specification <code class="literal">@ValidateOnExecution</code> cannot be overridden once is
                    declared on a method (i.e. in subclass/sub-interface) and in this situations a
                    <code class="literal">ValidationException</code> should be raised. This default behaviour can be suppressed by
                    setting <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK" target="_top">ServerProperties.BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK</a>
                    property (Jersey specific) to <code class="literal">true</code>.
                </p></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bv.injecting"></a>19.6.&nbsp;Injecting</h2></div></div></div><p>
            Jersey allows you to inject registered resources/providers into your <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/constraintvalidator" target="_top">ConstraintValidator</a> implementation and you
            can inject <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/configuration" target="_top">Configuration</a>, <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/validatorfactory" target="_top">ValidatorFactory</a> and <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/validator" target="_top">Validator</a> as required by Bean Validation spec.

            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Injected <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/configuration" target="_top">Configuration</a>, <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/validatorfactory" target="_top">ValidatorFactory</a> and <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/validator" target="_top">Validator</a> do not inherit configuration provided
                    by <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/validation/ValidationConfig.html" target="_top">ValidationConfig</a> and need to be configured manually.
                </p></div><p>

            Injection of JAX-RS components into <code class="literal">ConstraintValidator</code>s is supported via a custom
            <code class="literal">ConstraintValidatorFactory</code> provided by Jersey. An example is shown in
            <a class="xref" href="#bv.examples.injecting" title="Example&nbsp;19.12.&nbsp;Injecting UriInfo into a ConstraintValidator">Example&nbsp;19.12, &#8220;Injecting UriInfo into a ConstraintValidator&#8221;</a>.

            </p><div class="example"><a name="bv.examples.injecting"></a><p class="title"><b>Example&nbsp;19.12.&nbsp;Injecting UriInfo into a ConstraintValidator</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class EmailValidator implements ConstraintValidator&lt;Email, String&gt; {

    @Context
    private UriInfo uriInfo;

    public void initialize(Email email) {
        ...
    }

    public boolean isValid(String value, ConstraintValidatorContext context) {
        // Use UriInfo.

        ...
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            Using a custom <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/constraintvalidatorfactory" target="_top">ConstraintValidatorFactory</a> of your own disables registration of the one provided by Jersey
            and injection support for resources/providers (if needed) has to be provided by this new implementation.
            <a class="xref" href="#bv.examples.injecting.factory" title="Example&nbsp;19.13.&nbsp;Support for injecting Jersey's resources/providers via ConstraintValidatorFactory.">Example&nbsp;19.13, &#8220;Support for injecting Jersey's resources/providers via ConstraintValidatorFactory.&#8221;</a> shows how this can be achieved.

            </p><div class="example"><a name="bv.examples.injecting.factory"></a><p class="title"><b>Example&nbsp;19.13.&nbsp;Support for injecting Jersey's resources/providers via ConstraintValidatorFactory.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class InjectingConstraintValidatorFactory implements ConstraintValidatorFactory {

    @Context
    private ResourceContext resourceContext;

    @Override
    public &lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; T getInstance(final Class&lt;T&gt; key) {
        return resourceContext.getResource(key);
    }

    @Override
    public void releaseInstance(final ConstraintValidator&lt;?, ?&gt; instance) {
        // NOOP
    }
}</pre></div></div><p><br class="example-break">
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    This behaviour may likely change in one of the next version of Jersey to remove the need of
                    manually providing support for injecting resources/providers from Jersey in your own
                    <code class="literal">ConstraintValidatorFactory</code> implementation code.
                </p></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14064"></a>19.7.&nbsp;Error Reporting</h2></div></div></div><p>
            Bean Validation specification defines a small hierarchy of exceptions (they all inherit from
            <a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/validationexception" target="_top">ValidationException</a>) that could be thrown during initialization of validation engine or (for our case more
            importantly) during validation of input/output values (<a class="link" href="https://jakarta.ee/specifications/bean-validation/3.0/apidocs//jakarta/validation/constraintviolationexception" target="_top">ConstraintViolationException</a>).
            If a thrown exception is a subclass of <code class="literal">ValidationException</code> <span class="emphasis"><em>except</em></span>
            <code class="literal">ConstraintViolationException</code> then this exception is mapped to a HTTP response with status code 500
            (Internal Server Error).
            On the other hand, when a <code class="literal">ConstraintViolationException</code> is throw two different status code would be returned:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>500 (Internal Server Error)</p><p>If the exception was thrown while validating a method return type.</p></li><li class="listitem"><p>400 (Bad Request)</p><p>Otherwise.</p></li></ul></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="bv.ValidationError"></a>19.7.1.&nbsp;ValidationError</h3></div></div></div><p>
                By default, (during mapping <code class="literal">ConstraintViolationException</code>s) Jersey doesn't return any entities that would
                include validation errors to the client. This default behaviour could be changed by enabling
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_SEND_ERROR_IN_RESPONSE" target="_top">ServerProperties.BV_SEND_ERROR_IN_RESPONSE</a> property in your application
                (<a class="xref" href="#bv.example.jersey.properties" title="Example&nbsp;19.1.&nbsp;Configuring Jersey specific properties for Bean Validation.">Example&nbsp;19.1, &#8220;Configuring Jersey specific properties for Bean Validation.&#8221;</a>).
                When this property is enabled then our custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ExceptionMapper.html" target="_top">ExceptionMapper&lt;E extends Throwable&gt;</a> (that is handling
                <code class="literal">ValidationException</code>s) would transform <code class="literal">ConstraintViolationException</code>(s) into
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/validation/ValidationError.html" target="_top">ValidationError</a>(s) and set this object (collection) as the new response entity which Jersey is
                able to sent to the client.
                Four <code class="literal">MediaType</code>s are currently supported when sending <code class="literal">ValidationError</code>s to the
                client:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">text/plain</code></p></li><li class="listitem"><p><code class="literal">text/html</code></p></li><li class="listitem"><p><code class="literal">application/xml</code></p></li><li class="listitem"><p><code class="literal">application/json</code></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                                Note: You need to register one of the JSON (JAXB) providers (e.g.
                                <a class="link" href="#json.moxy" title="9.1.2.&nbsp;MOXy">MOXy</a>) to marshall validation errors to JSON.
                            </p></div></li></ul></div><p>
            </p><p>
                Let's take a look at <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/validation/ValidationError.html" target="_top">ValidationError</a> class to see which properties are send to the client:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public final class ValidationError {

    private String message;

    private String messageTemplate;

    private String path;

    private String invalidValue;

    ...
}</pre><p>

                The <code class="literal">message</code> property is the interpolated error message, <code class="literal">messageTemplate</code>
                represents a non-interpolated error message (or key from your constraint definition e.g.
                <code class="literal">{jakarta.validation.constraints.NotNull.message}</code>), <code class="literal">path</code> contains information
                about the path in the validated object graph to the property holding invalid value and
                <code class="literal">invalidValue</code> is the string representation of the invalid value itself.
            </p><p>
                Here are few examples of <code class="literal">ValidationError</code> messages sent to client:

                </p><div class="example"><a name="d0e14182"></a><p class="title"><b>Example&nbsp;19.14.&nbsp;<code class="literal">ValidationError</code> to <code class="literal">text/plain</code></b></p><div class="example-contents"><pre class="screen">HTTP/1.1 500 Internal Server Error
Content-Length: 114
Content-Type: text/plain
Vary: Accept
Server: Jetty(11.0.0.beta3)

Contact with given ID does not exist. (path = ContactCardResource.getContact.&lt;return value&gt;, invalidValue = null)</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e14192"></a><p class="title"><b>Example&nbsp;19.15.&nbsp;<code class="literal">ValidationError</code> to <code class="literal">text/html</code></b></p><div class="example-contents"><pre class="screen">HTTP/1.1 500 Internal Server Error
Content-Length: ...
Content-Type: text/plain
Vary: Accept
Server: Jetty(11.0.0.beta3)

&lt;div class="validation-errors"&gt;
    &lt;div class="validation-error"&gt;
        &lt;span class="message"&gt;Contact with given ID does not exist.&lt;/span&gt;
        (
        &lt;span class="path"&gt;
            &lt;strong&gt;path&lt;/strong&gt;
            = ContactCardResource.getContact.&lt;return value&gt;
        &lt;/span&gt;
        ,
        &lt;span class="invalid-value"&gt;
            &lt;strong&gt;invalidValue&lt;/strong&gt;
            = null
        &lt;/span&gt;
        )
    &lt;/div&gt;
&lt;/div&gt;</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e14202"></a><p class="title"><b>Example&nbsp;19.16.&nbsp;<code class="literal">ValidationError</code> to <code class="literal">application/xml</code></b></p><div class="example-contents"><pre class="screen">HTTP/1.1 500 Internal Server Error
Content-Length: ...
Content-Type: text/plain
Vary: Accept
Server: Jetty(11.0.0.beta3)

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validationErrors&gt;
    &lt;validationError&gt;
        &lt;message&gt;Contact with given ID does not exist.&lt;/message&gt;
        &lt;messageTemplate&gt;{contact.does.not.exist}&lt;/messageTemplate&gt;
        &lt;path&gt;ContactCardResource.getContact.&amp;lt;return value&amp;gt;&lt;/path&gt;
    &lt;/validationError&gt;
&lt;/validationErrors&gt;</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e14212"></a><p class="title"><b>Example&nbsp;19.17.&nbsp;<code class="literal">ValidationError</code> to <code class="literal">application/json</code></b></p><div class="example-contents"><pre class="screen">HTTP/1.1 500 Internal Server Error
Content-Length: 174
Content-Type: application/json
Vary: Accept
Server: Jetty(11.0.0.beta3)

[ {
   "message" : "Contact with given ID does not exist.",
   "messageTemplate" : "{contact.does.not.exist}",
   "path" : "ContactCardResource.getContact.&lt;return value&gt;"
} ]</pre></div></div><p><br class="example-break">
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14222"></a>19.8.&nbsp;Example</h2></div></div></div><p>Examples are being processed to comply with Jakarta EE standards.</p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="entity-filtering"></a>Chapter&nbsp;20.&nbsp;Entity Data Filtering</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e14258">20.1. Enabling and configuring Entity Filtering in your application</a></span></dt><dt><span class="section"><a href="#d0e14371">20.2. Components used to describe Entity Filtering concepts</a></span></dt><dt><span class="section"><a href="#ef.annotations">20.3. Using custom annotations to filter entities</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14526">20.3.1. Server-side Entity Filtering</a></span></dt><dt><span class="section"><a href="#d0e14644">20.3.2. Client-side Entity Filtering</a></span></dt></dl></dd><dt><span class="section"><a href="#ef.security.annotations">20.4. Role-based Entity Filtering using (<code class="literal">jakarta.annotation.security</code>) annotations</a></span></dt><dt><span class="section"><a href="#ef.selectable.annotations">20.5. Entity Filtering based on dynamic and configurable query parameters</a></span></dt><dt><span class="section"><a href="#ef.custom.annotations">20.6. Defining custom handling for entity-filtering annotations</a></span></dt><dt><span class="section"><a href="#ef.custom.providers">20.7. Supporting Entity Data Filtering in custom entity providers or frameworks</a></span></dt><dt><span class="section"><a href="#ef.modules">20.8. Modules with support for Entity Data Filtering</a></span></dt><dt><span class="section"><a href="#d0e14845">20.9. Examples</a></span></dt></dl></div><p>
        Support for Entity Filtering in Jersey introduces a convenient facility for reducing the amount of data exchanged over
        the wire between client and server without a need to create specialized data view components. The main idea behind this
        feature is to give you APIs that will let you to selectively filter out any non-relevant data from the marshalled object
        model before sending the data to the other party based on the context of the particular message exchange.
        This way, only the necessary or relevant portion of the data is transferred over the network with each client request
        or server response, without a need to create special facade models for transferring these limited subsets of the model
        data.
    </p><p>
        Entity filtering feature allows you to define your own entity-filtering rules for your entity classes based on the
        current context (e.g. matched resource method) and keep these rules in one place (directly in your domain model).
        With Jersey entity filtering facility it is also possible to assign security access rules to entity classes properties
        and property accessors.
    </p><p>
        We will first explain the main concepts and then we will explore the entity filtering feature topics from a perspective
        of basic use-cases,

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="#ef.annotations" title="20.3.&nbsp;Using custom annotations to filter entities">Section&nbsp;20.3, &#8220;Using custom annotations to filter entities&#8221;</a></p></li><li class="listitem"><p><a class="xref" href="#ef.security.annotations" title="20.4.&nbsp;Role-based Entity Filtering using (jakarta.annotation.security) annotations">Section&nbsp;20.4, &#8220;Role-based Entity Filtering using (<code class="literal">jakarta.annotation.security</code>) annotations&#8221;</a></p></li><li class="listitem"><p><a class="xref" href="#ef.selectable.annotations" title="20.5.&nbsp;Entity Filtering based on dynamic and configurable query parameters">Section&nbsp;20.5, &#8220;Entity Filtering based on dynamic and configurable query parameters&#8221;</a></p></li></ul></div><p>

        as well as some more complex ones.

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="#ef.custom.annotations" title="20.6.&nbsp;Defining custom handling for entity-filtering annotations">Section&nbsp;20.6, &#8220;Defining custom handling for entity-filtering annotations&#8221;</a></p></li></ul></div><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            Jersey entity filtering feature is supported via Jersey extension modules listed in <a class="xref" href="#ef.modules" title="20.8.&nbsp;Modules with support for Entity Data Filtering">Section&nbsp;20.8, &#8220;Modules with support for Entity Data Filtering&#8221;</a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14258"></a>20.1.&nbsp;Enabling and configuring Entity Filtering in your application</h2></div></div></div><p>
            Entity Filtering support in Jersey is provided as an extension module and needs to be mentioned explicitly in your
            <code class="literal">pom.xml</code> file (in case of using Maven):

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-entity-filtering&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    If you're not using Maven make sure to have also all the transitive dependencies
                    (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-entity-filtering/dependencies.html" target="_top">jersey-entity-filtering</a>) on the classpath.
                </p></div><p>
        </p><p>
            The entity-filtering extension module provides three <code class="literal">Feature</code>s which you can register into server/client
            runtime in prior to use Entity Filtering in an application:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/EntityFilteringFeature.html" target="_top">EntityFilteringFeature</a></p><p>
                        Filtering based on entity-filtering annotations (or i.e. external configuration file) created using
                        <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/EntityFiltering.html" target="_top">@EntityFiltering</a> meta-annotation.
                    </p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/SecurityEntityFilteringFeature.html" target="_top">SecurityEntityFilteringFeature</a></p><p>Filtering based on security (<code class="literal">jakarta.annotation.security</code>) and entity-filtering
                        annotations.</p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/SelectableEntityFilteringFeature.html" target="_top">SelectableEntityFilteringFeature</a></p><p>Filtering based on dynamic and configurable query parameters.</p></li></ul></div><p>

            If you want to use both entity-filtering annotations and security annotations for entity data filtering it is enough
            to register <code class="literal">SecurityEntityFilteringFeature</code> as this feature registers also
            <code class="literal">EntityFilteringFeature</code>.
        </p><p>
            Entity-filtering currently recognizes one property that can be passed into the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configuration.html" target="_top">Configuration</a> instance
            (client/server):

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/EntityFilteringFeature.html#ENTITY_FILTERING_SCOPE" target="_top">EntityFilteringFeature.ENTITY_FILTERING_SCOPE</a> - "<code class="literal">jersey.config.entityFiltering.scope</code>"</p><p>
                        Defines one or more annotations that should be used as entity-filtering scope when reading/writing an
                        entity.
                    </p></li></ul></div><p>

            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Processing of entity-filtering annotations to create an entity-filtering scope is defined by
                    following: "<code class="literal">Request/Resource entity annotations</code>" &gt;
                    "<code class="literal">Configuration</code>" &gt; "<code class="literal">Resource method/class annotations</code>"
                    (on server).
                </p></div><p>
        </p><p>
            You can configure entity-filtering on server (basic + security examples) as follows:

            </p><div class="example"><a name="ef.example.server.registration"></a><p class="title"><b>Example&nbsp;20.1.&nbsp;Registering and configuring entity-filtering feature on server.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    // Set entity-filtering scope via configuration.
    .property(EntityFilteringFeature.ENTITY_FILTERING_SCOPE, new Annotation[] {ProjectDetailedView.Factory.get()})
    // Register the EntityFilteringFeature.
    .register(EntityFilteringFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="ef.example.server.security.registration"></a><p class="title"><b>Example&nbsp;20.2.&nbsp;Registering and configuring entity-filtering feature with security annotations on server.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    // Set entity-filtering scope via configuration.
    .property(EntityFilteringFeature.ENTITY_FILTERING_SCOPE, new Annotation[] {SecurityAnnotations.rolesAllowed("manager")})
    // Register the SecurityEntityFilteringFeature.
    .register(SecurityEntityFilteringFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="ef.example.server.selectable.registration"></a><p class="title"><b>Example&nbsp;20.3.&nbsp;Registering and configuring entity-filtering feature based on dynamic and configurable query parameters.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    // Set query parameter name for dynamic filtering
    .property(SelectableEntityFilteringFeature.QUERY_PARAM_NAME, "select")
    // Register the SelectableEntityFilteringFeature.
    .register(SelectableEntityFilteringFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">
        </p><p>
            Use similar steps to register entity-filtering on client:

            </p><div class="example"><a name="ef.example.client.registration"></a><p class="title"><b>Example&nbsp;20.4.&nbsp;Registering and configuring entity-filtering feature on client.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final ClientConfig config = new ClientConfig()
    // Set entity-filtering scope via configuration.
    .property(EntityFilteringFeature.ENTITY_FILTERING_SCOPE, new Annotation[] {ProjectDetailedView.Factory.get()})
    // Register the EntityFilteringFeature.
    .register(EntityFilteringFeature.class)
    // Further configuration of ClientConfig.
    .register( ... );

// Create new client.
final Client client = ClientClientBuilder.newClient(config);

// Use the client.</pre></div></div><p><br class="example-break">
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14371"></a>20.2.&nbsp;Components used to describe Entity Filtering concepts</h2></div></div></div><p>
            In the next section the entity-filtering features will be illustrated on a project-tracking application that
            contains three classes in its domain model and few resources (only <code class="literal">Project</code> resource will be
            shown in this chapter). The full source code for the example application can be found in Jersey
            <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/entity-filtering" target="_top">Entity Filtering example</a>.
        </p><p>
            Suppose there are three domain model classes (or entities) in our model:
            <code class="literal">Project</code>, <code class="literal">User</code> and <code class="literal">Task</code> (getters/setter are omitted for
            brevity).

            </p><div class="example"><a name="d0e14393"></a><p class="title"><b>Example&nbsp;20.5.&nbsp;Project</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Project {

    private Long id;

    private String name;

    private String description;

    private List&lt;Task&gt; tasks;

    private List&lt;User&gt; users;

    // getters and setters
}</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e14399"></a><p class="title"><b>Example&nbsp;20.6.&nbsp;User</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class User {

    private Long id;

    private String name;

    private String email;

    private List&lt;Project&gt; projects;

    private List&lt;Task&gt; tasks;

    // getters and setters
}</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e14405"></a><p class="title"><b>Example&nbsp;20.7.&nbsp;Task</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Task {

    private Long id;

    private String name;

    private String description;

    private Project project;

    private User user;

    // getters and setters
}</pre></div></div><p><br class="example-break">
        </p><p>
            To retrieve the entities from server to client, we have created also a couple of JAX-RS resources from whose the
            <code class="literal">ProjectsResource</code> is shown as example.

            </p><div class="example"><a name="d0e14416"></a><p class="title"><b>Example&nbsp;20.8.&nbsp;ProjectsResource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("projects")
@Produces("application/json")
public class ProjectsResource {

    @GET
    @Path("{id}")
    public Project getProject(@PathParam("id") final Long id) {
        return getDetailedProject(id);
    }

    @GET
    public List&lt;Project&gt; getProjects() {
        return getDetailedProjects();
    }
}</pre></div></div><p><br class="example-break">
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.annotations"></a>20.3.&nbsp;Using custom annotations to filter entities</h2></div></div></div><p>
            Entity filtering via annotations is based on an <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/EntityFiltering.html" target="_top">@EntityFiltering</a> meta-annotation.
            This meta-annotation is used to identify entity-filtering annotations that can be then attached to

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>domain model classes (supported on both, server and client sides), and</p></li><li class="listitem"><p>resource methods / resource classes (only on server side)</p></li></ul></div><p>

            An example of entity-filtering annotation applicable to a class, field or method can be seen in
            <a class="xref" href="#ef.annotations.sample.annotation" title="Example&nbsp;20.9.&nbsp;ProjectDetailedView">Example&nbsp;20.9, &#8220;ProjectDetailedView&#8221;</a> below.

            </p><div class="example"><a name="ef.annotations.sample.annotation"></a><p class="title"><b>Example&nbsp;20.9.&nbsp;ProjectDetailedView</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@EntityFiltering
public @interface ProjectDetailedView {

    /**
     * Factory class for creating instances of {@code ProjectDetailedView} annotation.
     */
    public static class Factory
                        extends AnnotationLiteral&lt;ProjectDetailedView&gt;
                        implements ProjectDetailedView {

        private Factory() {
        }

        public static ProjectDetailedView get() {
            return new Factory();
        }
    }
}</pre></div></div><p><br class="example-break">

        </p><p>
            Since creating annotation instances directly in Java code is not trivial, it is a good practice to provide an inner
            annotation <code class="literal">Factory</code> class in each custom filtering annotation, through which new instances of
            the annotation can be directly created. The annotation factory class can be created by extending the HK2
            <code class="literal">AnnotationLiteral</code> class and implementing the annotation interface itself. It should also provide
            a static factory method that will create and return a new instance of the <code class="literal">Factory</code> class when
            invoked. Such annotation instances can be then passed to the client and server run-times to define or override
            entity-filtering scopes.
        </p><p>
            By placing an entity-filtering annotation on an entity (class, fields, getters or setters) we define a so-called
            <span class="emphasis"><em>entity-filtering scope</em></span> for the entity. The purpose of entity-filtering scope is to identify
            parts of the domain model that should be processed when the model is to be sent over the wire in a particular
            entity-filtering scope. We distinguish between:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        global entity-filtering scope (defined by placing filtering annotation on a class itself), and
                    </p></li><li class="listitem"><p>
                        local entity-filtering scope (defined by placing filtering annotation on a field, getter or setter)
                    </p></li></ul></div><p>

            Unannotated members of a domain model class are automatically added to all existing global entity-filtering scopes.
            If there is no explicit global entity-filtering scope defined on a class a default scope is created for this class
            to group these members.
        </p><p>
            Creating entity-filtering scopes using custom entity-filtering annotations in domain model classes is illustrated
            in the following examples.

            </p><div class="example"><a name="d0e14472"></a><p class="title"><b>Example&nbsp;20.10.&nbsp;Annotated Project</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Project {

    private Long id;

    private String name;

    private String description;

    @ProjectDetailedView
    private List&lt;Task&gt; tasks;

    @ProjectDetailedView
    private List&lt;User&gt; users;

    // getters and setters
}</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e14478"></a><p class="title"><b>Example&nbsp;20.11.&nbsp;Annotated User</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class User {

    private Long id;

    private String name;

    private String email;

    @UserDetailedView
    private List&lt;Project&gt; projects;

    @UserDetailedView
    private List&lt;Task&gt; tasks;

    // getters and setters
}</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e14484"></a><p class="title"><b>Example&nbsp;20.12.&nbsp;Annotated Task</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Task {

    private Long id;

    private String name;

    private String description;

    @TaskDetailedView
    private Project project;

    @TaskDetailedView
    private User user;

    // getters and setters
}</pre></div></div><p><br class="example-break">

            As you can see in the examples above, we have defined 3 separate scopes using <code class="literal">@ProjectDetailedView</code>,
            <code class="literal">@UserDetailedView</code> and <code class="literal">@TaskDetailedView</code> annotations and we have applied
            these scopes selectively to certain fields in the domain model classes.
        </p><p>
            Once the entity-filtering scopes are applied to the parts of a domain model, the entity filtering facility (when
            enabled) will check the active scopes when the model is being sent over the wire, and filter out all parts from
            the model for which there is no active scope set in the given context. Therefore, we need a way how to control
            the scopes active in any given context in order to process the model data in a certain way (e.g. expose the detailed
            view). We need to tell the server/client runtime which entity-filtering scopes we want to apply. There are 2 ways
            how to do this for client-side and 3 ways for server-side:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Outbound client request or server response programmatically created with entity-filtering annotations
                        that identify the scopes to be applied (available on both, client and server)</p></li><li class="listitem"><p>Property identifying the applied scopes passed through <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configuration.html" target="_top">Configuration</a>
                        (available on both, client and server)</p></li><li class="listitem"><p>Entity-filtering annotations identifying the applied scopes attached to a resource method or class
                        (server-side only)</p></li></ul></div><p>

            When the multiple approaches are combined, the priorities of calculating the applied scopes are as follows:
            <code class="literal">Entity annotations in request or response</code> &gt;
            <code class="literal">Property passed through Configuration</code> &gt;
            <code class="literal">Annotations applied to a resource method or class</code>.
        </p><p>
            In a graph of domain model objects, the entity-filtering scopes are applied to the root node as well as transitively
            to all the child nodes. Fields and child nodes that do not match at least a single active scope are filtered out.
            When the scope matching is performed, annotations applied to the domain model classes and fields
            are used to compute the scope for each particular component of the model. If there are no annotations on the class
            or its fields, the default scope is assumed. During the filtering, first, the annotations on root model class
            and its fields are considered. For all composite fields that have not been filtered out, the annotations on the
            referenced child class and its fields are considered next, and so on.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14526"></a>20.3.1.&nbsp;Server-side Entity Filtering</h3></div></div></div><p>
                To pass entity-filtering annotations via <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a> returned from a resource method you can leverage the
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.ResponseBuilder.html#entity(java.lang.Object, java.lang.annotation.Annotation[])" target="_top">Response.ResponseBuilder#entity(Object, Annotation[])</a>
                method. The next example illustrates this approach. You will also see why every custom entity-filtering
                annotation should contain a factory for creating instances of the annotation.

                </p><div class="example"><a name="d0e14537"></a><p class="title"><b>Example&nbsp;20.13.&nbsp;ProjectsResource - Response entity-filtering annotations</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("projects")
@Produces("application/json")
public class ProjectsResource {

    @GET
    public Response getProjects(@QueryParam("detailed") final boolean isDetailed) {
        return Response
                .ok()
                .entity(new GenericEntity&lt;List&lt;Project&gt;&gt;(EntityStore.getProjects()) {},
                        isDetailed ? new Annotation[]{ProjectDetailedView.Factory.get()} : new Annotation[0])
                .build();
    }
}</pre></div></div><p><br class="example-break">

                Annotating a resource method / class is typically easier although it is less flexible and may require more
                resource methods to be created to cover all the alternative use case scenarios. For example:

                </p><div class="example"><a name="d0e14543"></a><p class="title"><b>Example&nbsp;20.14.&nbsp;ProjectsResource - Entity-filtering annotations on methods</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("projects")
@Produces("application/json")
public class ProjectsResource {

    @GET
    public List&lt;Project&gt; getProjects() {
        return getDetailedProjects();
    }

    @GET
    @Path("detailed")
    @ProjectDetailedView
    public List&lt;Project&gt; getDetailedProjects() {
        return EntityStore.getProjects();
    }
}</pre></div></div><p><br class="example-break">

                To see how entity-filtering scopes can be applied using a <code class="literal">Configuration</code> property,
                see the <a class="xref" href="#ef.example.server.registration" title="Example&nbsp;20.1.&nbsp;Registering and configuring entity-filtering feature on server.">Example&nbsp;20.1, &#8220;Registering and configuring entity-filtering feature on server.&#8221;</a> example.
            </p><p>
                When a <code class="literal">Project</code> model from the example above is requested in a scope represented by
                <code class="literal">@ProjectDetailedView</code> entity-filtering annotation, the <code class="literal">Project</code> model
                data sent over the wire would contain:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">Project</code> - <code class="literal">id</code>, <code class="literal">name</code>,
                            <code class="literal">description</code>, <code class="literal">tasks</code>, <code class="literal">users</code>
                        </p></li><li class="listitem"><p>
                            <code class="literal">Task</code> - <code class="literal">id</code>, <code class="literal">name</code>,
                            <code class="literal">description</code>
                        </p></li><li class="listitem"><p>
                            <code class="literal">User</code> - <code class="literal">id</code>, <code class="literal">name</code>, <code class="literal">email</code>
                        </p></li></ul></div><p>

                Or, to illustrate this in JSON format:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "description" : "Jersey is the open source (under dual EPL+GPL license) JAX-RS 3.0 production quality Reference Implementation for building RESTful Web services.",
   "id" : 1,
   "name" : "Jersey",
   "tasks" : [ {
      "description" : "Entity Data Filtering",
      "id" : 1,
      "name" : "ENT_FLT"
   }, {
      "description" : "OAuth 1 + 2",
      "id" : 2,
      "name" : "OAUTH"
   } ],
   "users" : [ {
      "email" : "very@secret.com",
      "id" : 1,
      "name" : "Jersey Robot"
   } ]
}</pre><p>

                For the <span class="emphasis"><em>default entity-filtering scope</em></span> the filtered model would look like:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">Project</code> - <code class="literal">id</code>, <code class="literal">name</code>, <code class="literal">description</code>
                        </p></li></ul></div><p>

                Or in JSON format:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "description" : "Jersey is the open source (under dual EPL+GPL license) JAX-RS 3.0 production quality Reference Implementation for building RESTful Web services.",
   "id" : 1,
   "name" : "Jersey"
}</pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14644"></a>20.3.2.&nbsp;Client-side Entity Filtering</h3></div></div></div><p>
                As mentioned above you can define applied entity-filtering scopes using a property set either in the client
                run-time <code class="literal">Configuration</code> (see <a class="xref" href="#ef.example.client.registration" title="Example&nbsp;20.4.&nbsp;Registering and configuring entity-filtering feature on client.">Example&nbsp;20.4, &#8220;Registering and configuring entity-filtering feature on client.&#8221;</a>) or by
                passing the entity-filtering annotations during a creation of an individual request to be sent to the server.

                </p><div class="example"><a name="d0e14654"></a><p class="title"><b>Example&nbsp;20.15.&nbsp;Client - Request entity-filtering annotations</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientBuilder.newClient(config)
    .target(uri)
    .request()
    .post(Entity.entity(project, new Annotation[] {ProjectDetailedView.Factory.get()}));</pre></div></div><p><br class="example-break">

                You can use the mentioned method with client injected into a resource as well.

                </p><div class="example"><a name="d0e14660"></a><p class="title"><b>Example&nbsp;20.16.&nbsp;Client - Request entity-filtering annotations</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("clients")
@Produces("application/json")
public class ClientsResource {

    @Uri("projects")
    private WebTarget target;

    @GET
    public List&lt;Project&gt; getProjects() {
        return target.request()
            .post(Entity.entity(project, new Annotation[] {ProjectDetailedView.Factory.get()}));
    }
}</pre></div></div><p><br class="example-break">
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.security.annotations"></a>20.4.&nbsp;Role-based Entity Filtering using (<code class="literal">jakarta.annotation.security</code>) annotations</h2></div></div></div><p>
            Filtering the content sent to the client (or server) based on the authorized security roles is a commonly
            required use case. By registering <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/SecurityEntityFilteringFeature.html" target="_top">SecurityEntityFilteringFeature</a> you can
            leverage the Jersey Entity Filtering facility in connection with standard
            <code class="literal">jakarta.annotation.security</code> annotations exactly the same way as you would with custom
            entity-filtering annotations described in previous chapters. Supported security annotations are:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://jakarta.ee/specifications/annotations/2.0/apidocs/jakarta.annotation/jakarta/annotation/security/permitall" target="_top">@PermitAll</a>,</p></li><li class="listitem"><p><a class="link" href="https://jakarta.ee/specifications/annotations/2.0/apidocs/jakarta.annotation/jakarta/annotation/security/rolesallowed" target="_top">@RolesAllowed</a>, and</p></li><li class="listitem"><p><a class="link" href="https://jakarta.ee/specifications//annotations/2.0/apidocs/jakarta.annotation/jakarta/annotation/security/denyall" target="_top">@DenyAll</a></p></li></ul></div><p>
        </p><p>
            Although the mechanics of the Entity Data Filtering feature used for the security annotation-based filtering is
            the same as with the entity-filtering annotations, the processing of security annotations differs in a few important
            aspects:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/SecurityContext.html" target="_top">SecurityContext</a> should be set by a container request filter in order to use
                        <code class="literal">@RolesAllowed</code> for role-based filtering of domain model data (server-side)
                    </p></li><li class="listitem"><p>
                        There is no need to provide entity-filtering (or security) annotations on resource methods in order to
                        define entity-filtering scopes for <code class="literal">@RolesAllowed</code> that is applied to the domain model
                        components, as all the available roles for the current user are automatically determined using
                        the information from the provided <code class="literal">SecurityContext</code> (server-side only).
                    </p></li></ul></div><p>

            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Instances of security annotations (to be used for programmatically defined scopes either on client or server)
                    can be created using one of the methods in the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/SecurityAnnotations.html" target="_top">SecurityAnnotations</a> factory class
                    that is part of the Jersey Entity Filtering API.
                </p></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.selectable.annotations"></a>20.5.&nbsp;Entity Filtering based on dynamic and configurable query parameters</h2></div></div></div><p>
            Filtering the content sent to the client (or server) dynamically based on query parameters is another commonly
            required use case. By registering <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/SelectableEntityFilteringFeature.html" target="_top">SelectableEntityFilteringFeature</a> you can
            leverage the Jersey Entity Filtering facility in connection with query parameters exactly the same way as you would with custom
            entity-filtering annotations described in previous chapters.
        </p><p>
            </p><div class="example"><a name="d0e14735"></a><p class="title"><b>Example&nbsp;20.17.&nbsp;Sever - Query Parameter driven entity-filtering</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class Address {

    private String streetAddress;

    private String region;

    private PhoneNumber phoneNumber;
}</pre></div></div><p><br class="example-break">
        </p><p>
            Query parameters are supported in comma delimited "dot notation" style similar to <code class="literal">BeanInfo</code> objects
            and Spring path expressions. As an example, the following URL:
            <code class="literal">http://jersey.example.com/addresses/51234?select=region,streetAddress</code> may render only the address's
            region and street address properties as in the following example:
        </p><div class="example"><a name="d0e14749"></a><p class="title"><b>Example&nbsp;20.18.&nbsp;</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "region" : "CA",
   "streetAddress" : "1234 Fake St."
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.custom.annotations"></a>20.6.&nbsp;Defining custom handling for entity-filtering annotations</h2></div></div></div><p>
            To create a custom entity-filtering annotation with special handling, i.e. an field aggregator annotation used
            to annotate classes like the one in <a class="xref" href="#ef.custom.annotations.annotation" title="Example&nbsp;20.19.&nbsp;Entity-filtering annotation with custom meaning">Example&nbsp;20.19, &#8220;Entity-filtering annotation with custom meaning&#8221;</a> it is, in most cases,
            sufficient to implement and register the following SPI contracts:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/spi/EntityProcessor.html" target="_top">EntityProcessor</a></p><p>Implementations of this SPI are invoked to process entity class and its members. Custom
                        implementations can extend from <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/spi/AbstractEntityProcessor.html" target="_top">AbstractEntityProcessor</a>.</p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/spi/ScopeResolver.html" target="_top">ScopeResolver</a></p><p>Implementations of this SPI are invoked to retrieve entity-filtering scopes from an array of
                        provided annotations.</p></li></ul></div><p>

            </p><div class="example"><a name="ef.custom.annotations.annotation"></a><p class="title"><b>Example&nbsp;20.19.&nbsp;Entity-filtering annotation with custom meaning</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@EntityFiltering
public @interface FilteringAggregator {

    /**
     * Entity-filtering scope to add given fields to.
     */
    Annotation filteringScope();

    /**
     * Fields to be a part of the entity-filtering scope.
     */
    String[] fields();
}</pre></div></div><p><br class="example-break">
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.custom.providers"></a>20.7.&nbsp;Supporting Entity Data Filtering in custom entity providers or frameworks</h2></div></div></div><p>
            To support Entity Data Filtering in custom entity providers (e.g. as in <a class="xref" href="#ef.modules.custom" title="Example&nbsp;20.20.&nbsp;Entity Data Filtering support in MOXy JSON binding provider">Example&nbsp;20.20, &#8220;Entity Data Filtering support in MOXy JSON binding provider&#8221;</a>),
            it is sufficient in most of the cases to implement and register the following SPI contracts:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/spi/ObjectProvider.html" target="_top">ObjectProvider</a></p><p>
                        To be able to obtain an instance of a filtering object model your provider understands and can act on.
                        The implementations can extend <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/spi/AbstractObjectProvider.html" target="_top">AbstractObjectProvider</a>.
                    </p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/spi/ObjectGraphTransformer.html" target="_top">ObjectGraphTransformer</a></p><p>
                        To transform a read-only generic representation of a domain object model graph to be processed into
                        an entity-filtering object model your provider understands and can act on. The implementations can
                        extend <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/spi/AbstractObjectProvider.html" target="_top">AbstractObjectProvider</a>.
                    </p></li></ul></div><p>

            </p><div class="example"><a name="ef.modules.custom"></a><p class="title"><b>Example&nbsp;20.20.&nbsp;Entity Data Filtering support in MOXy JSON binding provider</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Singleton
public class FilteringMoxyJsonProvider extends ConfigurableMoxyJsonProvider {

    @Inject
    private Provider&lt;ObjectProvider&lt;ObjectGraph&gt;&gt; provider;

    @Override
    protected void preWriteTo(final Object object, final Class&lt;?&gt; type, final Type genericType, final Annotation[] annotations,
                              final MediaType mediaType, final MultivaluedMap&lt;String, Object&gt; httpHeaders,
                              final Marshaller marshaller) throws JAXBException {
        super.preWriteTo(object, type, genericType, annotations, mediaType, httpHeaders, marshaller);

        // Entity Filtering.
        if (marshaller.getProperty(MarshallerProperties.OBJECT_GRAPH) == null) {
            final Object objectGraph = provider.get().getFilteringObject(genericType, true, annotations);

            if (objectGraph != null) {
                marshaller.setProperty(MarshallerProperties.OBJECT_GRAPH, objectGraph);
            }
        }
    }

    @Override
    protected void preReadFrom(final Class&lt;Object&gt; type, final Type genericType, final Annotation[] annotations,
                               final MediaType mediaType, final MultivaluedMap&lt;String, String&gt; httpHeaders,
                               final Unmarshaller unmarshaller) throws JAXBException {
        super.preReadFrom(type, genericType, annotations, mediaType, httpHeaders, unmarshaller);

        // Entity Filtering.
        if (unmarshaller.getProperty(MarshallerProperties.OBJECT_GRAPH) == null) {
            final Object objectGraph = provider.get().getFilteringObject(genericType, false, annotations);

            if (objectGraph != null) {
                unmarshaller.setProperty(MarshallerProperties.OBJECT_GRAPH, objectGraph);
            }
        }
    }
}</pre></div></div><p><br class="example-break">
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.modules"></a>20.8.&nbsp;Modules with support for Entity Data Filtering</h2></div></div></div><p>
            List of modules from Jersey workspace that support Entity Filtering:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="#json.moxy" title="9.1.2.&nbsp;MOXy">MOXy</a>
                    </p></li><li class="listitem"><p>
                        <a class="link" href="#json.jackson" title="9.1.4.&nbsp;Jackson (2.x)">Jackson (2.x)</a>
                    </p></li></ul></div><p>
        </p><p>
            In order to use Entity Filtering in mentioned modules you need to explicitly register either
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/EntityFilteringFeature.html" target="_top">EntityFilteringFeature</a>, <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/SecurityEntityFilteringFeature.html" target="_top">SecurityEntityFilteringFeature</a>
            or <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/filtering/SelectableEntityFilteringFeature.html" target="_top">SelectableEntityFilteringFeature</a> to activate Entity Filtering for particular module.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14845"></a>20.9.&nbsp;Examples</h2></div></div></div><p>
            To see a complete working examples of entity-filtering feature refer to the:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/entity-filtering" target="_top">Entity Filtering example</a></p></li><li class="listitem"><p><a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/entity-filtering-security" target="_top">Entity Filtering example (with security annotations)</a></p></li><li class="listitem"><p><a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/entity-filtering-selectable" target="_top">Entity Filtering example (based on dynamic and configurable query parameters)</a></p></li></ul></div><p>
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="mvc"></a>Chapter&nbsp;21.&nbsp;MVC Templates</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e14884">21.1. Viewable</a></span></dt><dt><span class="section"><a href="#d0e14929">21.2. @Template</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e14932">21.2.1. Annotating Resource methods</a></span></dt><dt><span class="section"><a href="#d0e14988">21.2.2. Annotating Resource classes</a></span></dt></dl></dd><dt><span class="section"><a href="#mvc.references">21.3. Absolute vs. Relative template reference</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15084">21.3.1. Relative template reference</a></span></dt><dt><span class="section"><a href="#d0e15128">21.3.2. Absolute template reference</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e15174">21.4. Handling errors with MVC</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15228">21.4.1. MVC &amp; Bean Validation</a></span></dt></dl></dd><dt><span class="section"><a href="#mvc.registration">21.5. Registration and Configuration</a></span></dt><dt><span class="section"><a href="#d0e15358">21.6. Supported templating engines</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15363">21.6.1. Mustache</a></span></dt><dt><span class="section"><a href="#d0e15465">21.6.2. Freemarker</a></span></dt><dt><span class="section"><a href="#d0e15581">21.6.3. JSP</a></span></dt></dl></dd><dt><span class="section"><a href="#mvc.spi">21.7. Writing Custom Templating Engines</a></span></dt><dt><span class="section"><a href="#d0e15728">21.8. Other Examples</a></span></dt></dl></div><p>
        Jersey provides an extension to support the Model-View-Controller (MVC) design pattern.
        In the context of Jersey components, the Controller from the MVC pattern corresponds to a resource class or method,
        the View to a template bound to the resource class or method, and the model to a Java object (or a Java bean) returned
        from a resource method (Controller).
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            Some of the passages/examples from this chapter have been created by Paul Sandoz.
        </p></div><p>
        In Jersey 2, the base MVC API consists of two classes (<code class="literal">org.glassfish.jersey.server.mvc</code> package)
        that can be used to bind model to view (template), namely <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Viewable.html" target="_top">Viewable</a> and <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Template.html" target="_top">@Template</a>.
        These classes determine which approach (explicit/implicit) you would be taking when working with Jersey MVC
        templating support.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14884"></a>21.1.&nbsp;Viewable</h2></div></div></div><p>
            In this approach a resource method explicitly returns a reference to a view template and the data model to be
            used. For this purpose the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Viewable.html" target="_top">Viewable</a> class has been introduced in Jersey 1 and is also
            present (under a different package) in Jersey 2 and 3. A simple example of usage can be seen in
            <a class="xref" href="#mvc.example.viewable.simple" title="Example&nbsp;21.1.&nbsp;Using Viewable in a resource class">Example&nbsp;21.1, &#8220;Using <code class="literal">Viewable</code> in a resource class&#8221;</a>.

            </p><div class="example"><a name="mvc.example.viewable.simple"></a><p class="title"><b>Example&nbsp;21.1.&nbsp;Using <code class="literal">Viewable</code> in a resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">package com.example;

@Path("foo")
public class Foo {

    @GET
    public Viewable get() {
        return new Viewable("index.foo", "FOO");
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            In this example, the <code class="literal">Foo</code> JAX-RS resource class is the controller and the
            <code class="literal">Viewable</code> instance encapsulates the provided data model (<code class="literal">FOO</code> string)
            and a named reference to the associated view template (<code class="literal">index.foo</code>).
        </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                All HTTP methods may return <code class="literal">Viewable</code> instances. Thus a <code class="literal">POST</code> method may
                return a template reference to a template that produces a view as a result of processing an
                HTML <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Form.html" target="_top">Form</a>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14929"></a>21.2.&nbsp;@Template</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14932"></a>21.2.1.&nbsp;Annotating Resource methods</h3></div></div></div><p>
                There is no need to use <code class="literal">Viewable</code> every time you want to bind a model to a template. To
                make the resource method more readable (and to avoid verbose wrapping of a template reference and model into
                <code class="literal">Viewable</code>) you can simply annotate a resource method with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Template.html" target="_top">@Template</a>
                annotation. An updated example, using <code class="literal">@Template</code>, from previous section is shown in
                <a class="xref" href="#mvc.example.template.simple" title="Example&nbsp;21.2.&nbsp;Using @Template on a resource method">Example&nbsp;21.2, &#8220;Using <code class="literal">@Template</code> on a resource method&#8221;</a> example.

                </p><div class="example"><a name="mvc.example.template.simple"></a><p class="title"><b>Example&nbsp;21.2.&nbsp;Using <code class="literal">@Template</code> on a resource method</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">package com.example;

@Path("foo")
public class Foo {

    @GET
    @Template(name = "index.foo")
    public String get() {
        return "FOO";
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                In this example, the <code class="literal">Foo</code> JAX-RS resource class is still the controller as in previous
                section but the MVC model is now represented by the return value of annotated resource method.
            </p><p>
                The processing of such a method is then essentially the same as if the return type of the method was an
                instance of the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Viewable.html" target="_top">Viewable</a> class. If a method is annotated with
                <code class="literal">@Template</code> and is also returning a
                <code class="literal">Viewable</code> instance then the values from the
                <code class="literal">Viewable</code> instance take precedence over those defined in the annotation. Producible
                media types are for both cases, <code class="literal">Viewable</code> and <code class="literal">@Template</code>,
                determined by the method or class level <code class="literal">@Produces</code> annotation.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14988"></a>21.2.2.&nbsp;Annotating Resource classes</h3></div></div></div><p>
                A resource class can have templates implicitly associated with it via <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Template.html" target="_top">@Template</a> annotation.
                For example, take a look at the resource class listing in <a class="xref" href="#mvc.example.implicit.class" title="Example&nbsp;21.3.&nbsp;Using @Template on a resource class">Example&nbsp;21.3, &#8220;Using <code class="literal">@Template</code> on a resource class&#8221;</a>.

                </p><div class="example"><a name="mvc.example.implicit.class"></a><p class="title"><b>Example&nbsp;21.3.&nbsp;Using <code class="literal">@Template</code> on a resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("foo")
@Template
public class Foo {

    public String getFoo() {
        return "FOO";
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                The example relies on Jersey MVC conventions a lot and requires more explanation as such. First of all, you may
                have noticed that there is no resource method defined in this JAX-RS resource. Also, there is no template
                reference defined.
                In this case, since the <code class="literal">@Template</code> annotation placed on the resource class does not
                contain any information, the default relative template reference <code class="literal">index</code> will be used (for more
                on this topic see <a class="xref" href="#mvc.references" title="21.3.&nbsp;Absolute vs. Relative template reference">Section&nbsp;21.3, &#8220;Absolute vs. Relative template reference&#8221;</a>).
                As for the missing resource methods, a default <code class="literal">@GET</code> method will be automatically generated by Jersey
                for the <code class="literal">Foo</code> resource (which is the MVC Controller now). The implementation of the generated
                resource method performs the equivalent of the following explicit resource method:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public Viewable get() {
    return new Viewable("index", this);
}</pre><p>

                You can see that the resource class serves in this case also as the model. Producible media types are determined
                based on the <code class="literal">@Produces</code> annotation declared on the resource class, if any.

                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        In case of "resource class"-based implicit MVC view templates, the controller is also the model. In such
                        case the template reference <code class="literal">index</code> is special, it is the template reference
                        associated with the controller instance itself.
                    </p></div><p>
            </p><p>
                In the following example, the MVC controller represented by a JAX-RS <code class="literal">@GET</code> sub-resource method,
                is also generated in the resource class annotated with <code class="literal">@Template</code>:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Path("{implicit-view-path-parameter}")
public Viewable get(@PathParameter("{implicit-view-path-parameter}") String template) {
    return new Viewable(template, this);
}</pre><p>

                This allows Jersey to support also implicit sub-resource templates. For example, a JAX-RS resource at path
                <code class="literal">foo/bar</code> will try to use relative template reference <code class="literal">bar</code> that resolves to an
                absolute template reference <code class="literal">/com/foo/Foo/bar</code>.
            </p><p>
                In other words, a HTTP <code class="literal">GET</code> request to a <code class="literal">/foo/bar</code> would be handled by this
                auto-generated method in the <code class="literal">Foo</code> resource and would delegate the request to a registered
                template processor supports processing of the absolute template reference
                <code class="literal">/com/foo/Foo/bar</code>, where the model is still an instance of the same JAX-RS resource class
                <code class="literal">Foo</code>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc.references"></a>21.3.&nbsp;Absolute vs. Relative template reference</h2></div></div></div><p>
            As discussed in the previous section, both <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Template.html" target="_top">@Template</a> and <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Viewable.html" target="_top">Viewable</a> provide means
            to define a reference to a template. We will now discuss how these values are interpreted and how the concrete
            template is found.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15084"></a>21.3.1.&nbsp;Relative template reference</h3></div></div></div><p>
                Relative reference is any path that does not start with a leading '<code class="literal">/</code>' (slash) character (i.e.
                <code class="literal">index.foo</code>). This kind of references is resolved into absolute ones by pre-pending a given value
                with a fully qualified name of the last matched resource.
            </p><p>
                Consider the <a class="xref" href="#mvc.example.implicit.class" title="Example&nbsp;21.3.&nbsp;Using @Template on a resource class">Example&nbsp;21.3, &#8220;Using <code class="literal">@Template</code> on a resource class&#8221;</a> from the previous section,
                the template name reference <code class="literal">index</code> is a relative value that Jersey will resolve to its
                absolute template reference using a fully qualified class name of <code class="literal">Foo</code> (more on resolving
                relative template name to the absolute one can be found in the JavaDoc of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Viewable.html" target="_top">Viewable</a> class),
                which, in our case, is:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">"/com/foo/Foo/index"</pre><p>
            </p><p>
                Jersey will then search all the registered template processors (see <a class="xref" href="#mvc.spi" title="21.7.&nbsp;Writing Custom Templating Engines">Section&nbsp;21.7, &#8220;Writing Custom Templating Engines&#8221;</a>) to find a template
                processor that can resolve the absolute template reference further to a "processable" template reference. If
                a template processor is found then the "processable" template is processed using the supplied data model.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    If none or empty template reference is provided (either in <code class="literal">Viewable</code> or via
                    <code class="literal">@Template</code>) then the <code class="literal">index</code> reference is assumed and all further
                    processing is done for this value.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15128"></a>21.3.2.&nbsp;Absolute template reference</h3></div></div></div><p>
                Let's change the resource <code class="literal">GET</code> method in our <code class="literal">Foo</code> resource a little:

                </p><div class="example"><a name="mvc.example.viewable.absolutePath"></a><p class="title"><b>Example&nbsp;21.4.&nbsp;Using absolute path to template in <code class="literal">Viewable</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public Viewable get() {
    return new Viewable("/index", "FOO");
}</pre></div></div><p><br class="example-break">

                In this case, since the template reference begins with <code class="literal">"/"</code>, Jersey will consider the reference
                to be absolute already and will not attempt to absolutize it again. The reference will be used "as is" when
                resolving it to a "processable" template reference as described earlier.
            </p><p>
                Absolute template references start with leading '<code class="literal">/</code>' (i.e. <code class="literal">/com/example/index.foo</code>)
                character and are not further resolved (with respect to the resolving resource class) which means that the
                template is looked for at the provided path directly.
            </p><p>
                Note, however, that template processors for custom templating engines may modify (and the supported ones do)
                absolute template reference by pre-pending 'base template path' (if defined) and appending template suffix (i.e.
                <code class="literal">foo</code>) if the suffix is not provided in the reference.
            </p><p>
                For example assume that we want to use Mustache templates for our views and we have defined 'base template path'
                as <code class="literal">pages</code>. For the absolute template reference <code class="literal">/com/example/Foo/index</code> the template
                processor will transform the reference into the following path: <code class="literal">/pages/com/example/Foo/index.mustache</code>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15174"></a>21.4.&nbsp;Handling errors with MVC</h2></div></div></div><p>
            In addition to <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Template.html" target="_top">@Template</a> an <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/ErrorTemplate.html" target="_top">@ErrorTemplate</a> annotation has been introduced in
            Jersey 2.3 (valid for Jersey 3.x as well). The purpose of this annotation is to bind the model to an error view in
            case an exception has been raised during processing of a request. This is true for any exception thrown after the
            resource matching phase (i.e. this not only applies to JAX-RS resources but providers and even Jersey runtime as
            well). The model in this case is the thrown exception itself.
        </p><p>
            <a class="xref" href="#mvc.example.error.simple" title="Example&nbsp;21.5.&nbsp;Using @ErrorTemplate on a resource method">Example&nbsp;21.5, &#8220;Using <code class="literal">@ErrorTemplate</code> on a resource method&#8221;</a> shows how to use <code class="literal">@ErrorTemplate</code> on a resource method.
            If all goes well with the method processing, then the <code class="literal">/short-link</code> template is used as page sent
            to the user. Otherwise if an exception is raised then the <code class="literal">/error-form</code> template is shown to the user.
        </p><div class="example"><a name="mvc.example.error.simple"></a><p class="title"><b>Example&nbsp;21.5.&nbsp;Using <code class="literal">@ErrorTemplate</code> on a resource method</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Produces({"text/html&#8221;})
@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
@Template(name = "/short-link")
@ErrorTemplate(name = "/error-form")
public ShortenedLink createLink(@FormParam("link") final String link) {
    // ...
}</pre></div></div><br class="example-break"><p>
            Note that <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/ErrorTemplate.html" target="_top">@ErrorTemplate</a> can be used on a resource class or a resource method to merely handle
            error states. There is no need to use <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Template.html" target="_top">@Template</a> or <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/Viewable.html" target="_top">Viewable</a> with it.
        </p><p>
            The annotation is handled by custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ExceptionMapper.html" target="_top">ExceptionMapper&lt;E extends Throwable&gt;</a> which creates an instance of
            <code class="literal">Viewable</code> that is further processed by Jersey. This exception mapper is registered automatically
            with a <code class="literal">MvcFeature</code>.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15228"></a>21.4.1.&nbsp;MVC &amp; Bean Validation</h3></div></div></div><p>
                <code class="literal">@ErrorTemplate</code> can also be used with Bean Validation to display specific error pages in
                case the validation of input/output values fails for some reason. Everything works as described above except the
                model is not the thrown exception but rather a list of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/validation/ValidationError.html" target="_top">ValidationError</a>s. This list can be iterated in
                the template and all the validation errors can be shown to the user in a desirable way.
            </p><div class="example"><a name="mvc.example.error.bv"></a><p class="title"><b>Example&nbsp;21.6.&nbsp;Using <code class="literal">@ErrorTemplate</code> with Bean Validation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Produces({"text/html&#8221;})
@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
@Template(name = "/short-link&#8221;) @ErrorTemplate(name = "/error-form")
@Valid
public ShortenedLink createLink(@NotEmpty @FormParam("link") final String link) {
    // ...
}</pre></div></div><br class="example-break"><div class="example"><a name="mvc.example.error.bv.jsp"></a><p class="title"><b>Example&nbsp;21.7.&nbsp;Iterating through <code class="literal">ValidationError</code> in JSP</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;c:forEach items="${model}" var="error"&gt;
    ${error.message} "&lt;strong&gt;${error.invalidValue}&lt;/strong&gt;"&lt;br/&gt;
&lt;/c:forEach&gt;</pre></div></div><br class="example-break"><p>
                Support for Bean Validation in Jersey MVC Templates is provided by a <code class="literal">jersey-mvc-bean-validation</code>
                extension module. The JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Feature.html" target="_top">Feature</a> provided by this module
                (<code class="literal">MvcBeanValidationFeature</code>) has to be registered in order to use this
                functionality (see <a class="xref" href="#mvc.registration" title="21.5.&nbsp;Registration and Configuration">Section&nbsp;21.5, &#8220;Registration and Configuration&#8221;</a>).
            </p><p>
                Maven users can find this module at coordinates

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-mvc-bean-validation&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                and for non-Maven users the list of dependencies is available at <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-mvc-bean-validation/dependencies.html" target="_top">jersey-mvc-bean-validation</a>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc.registration"></a>21.5.&nbsp;Registration and Configuration</h2></div></div></div><p>
            To use the capabilities of Jersey MVC templating support in your JAX-RS/Jersey application you need to register
            specific JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Feature.html" target="_top">Feature</a>s provided by the MVC modules. For <code class="literal">jersey-mvc</code> module it is
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/MvcFeature.html" target="_top">MvcFeature</a> for others it could be, for example, <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/freemarker/FreemarkerMvcFeature.html" target="_top">FreemarkerMvcFeature</a>
            (<code class="literal">jersey-mvc-freemarker</code>).

            </p><div class="example"><a name="d0e15296"></a><p class="title"><b>Example&nbsp;21.8.&nbsp;Registering <code class="literal">MvcFeature</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    .register(org.glassfish.jersey.server.mvc.MvcFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e15304"></a><p class="title"><b>Example&nbsp;21.9.&nbsp;Registering <code class="literal">FreemarkerMvcFeature</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    .register(org.glassfish.jersey.server.mvc.freemarker.FreemarkerMvcFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Modules that uses capabilities of the base Jersey MVC module register <code class="literal">MvcFeature</code>
                    automatically, so you don't need to register this feature explicitly in your code.
                </p></div><p>
        </p><p>
            Almost all of the MVC modules are further configurable and either contain a <code class="literal">*Properties</code>
            (e.g. <code class="literal">FreemarkerMvcProperties</code>) class describing all the available properties which could be
            set in a JAX-RS <code class="literal">Application</code> / <code class="literal">ResourceConfig</code>. Alternatively, the properties
            are listed directly in the module <code class="literal">*Feature</code> class.

            </p><div class="example"><a name="mvc.ex.rc.properties"></a><p class="title"><b>Example&nbsp;21.10.&nbsp;Setting <code class="literal">MvcFeature.TEMPLATE_BASE_PATH</code> value in <code class="literal">ResourceConfig</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    .property(MvcFeature.TEMPLATE_BASE_PATH, "templates")
    .register(MvcFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="mvc.ex.web.xml.properties"></a><p class="title"><b>Example&nbsp;21.11.&nbsp;Setting <code class="literal">FreemarkerMvcProperties.TEMPLATE_BASE_PATH</code> value in <code class="literal">web.xml</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;servlet&gt;
    &lt;servlet-name&gt;org.glassfish.jersey.examples.freemarker.MyApplication&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;jakarta.ws.rs.Application&lt;/param-name&gt;
        &lt;param-value&gt;org.glassfish.jersey.examples.freemarker.MyApplication&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;jersey.config.server.mvc.templateBasePath.freemarker&lt;/param-name&gt;
        &lt;param-value&gt;freemarker&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;</pre></div></div><p><br class="example-break">
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15358"></a>21.6.&nbsp;Supported templating engines</h2></div></div></div><p>
            Jersey provides extension modules that enable support for several templating engines. This section lists all the
            supported engines and their modules as well as discusses any module-specific details.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15363"></a>21.6.1.&nbsp;Mustache</h3></div></div></div><p>
                An integration module for <a class="link" href="https://github.com/spullara/mustache.java" target="_top">Mustache</a>-based
                templating engine.
            </p><p>
                Mustache template processor resolves absolute template references to processable template references represented
                as Mustache templates as follows:
            </p><div class="procedure"><a name="d0e15373"></a><p class="title"><b>Procedure&nbsp;21.1.&nbsp;Resolving Mustache template reference</b></p><ol class="procedure" type="1"><li class="step"><p>
                        if the absolute template reference does not end in <code class="literal">.mustache</code> append this suffix to the
                        reference; and
                    </p></li><li class="step"><p>
                        if <code class="literal">ServletContext.getResource</code>, <code class="literal">Class.getResource</code> or
                        <code class="literal">File.exists</code> returns a non-<code class="literal">null</code> value for the reference then
                        return the reference as the processable template reference otherwise return <code class="literal">null</code>
                        (to indicate the absolute reference has not been resolved by the Mustache template processor).
                    </p></li></ol></div><p>
                Thus the absolute template reference <code class="literal">/com/foo/Foo/index</code> would be resolved as
                <code class="literal">/com/foo/Foo/index.mustache</code>, provided there exists a
                <code class="literal">/com/foo/Foo/index.mustache</code>
                Mustache template in the application.
            </p><p>
                Available configuration properties:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">MustacheMvcFeature.TEMPLATE_BASE_PATH</code> -
                            <code class="literal">jersey.config.server.mvc.templateBasePath.mustache</code></p><p>The base path where Mustache templates are located.</p></li><li class="listitem"><p><code class="literal">MustacheMvcFeature.CACHE_TEMPLATES</code> -
                            <code class="literal">jersey.config.server.mvc.caching.mustache</code></p><p>Enables caching of Mustache templates to avoid multiple compilation.</p></li><li class="listitem"><p><code class="literal">MustacheMvcFeature.TEMPLATE_OBJECT_FACTORY</code> -
                            <code class="literal">jersey.config.server.mvc.factory.mustache</code></p><p>Property used to pass user-configured <code class="literal">MustacheFactory</code>.</p></li><li class="listitem"><p><code class="literal">MustacheMvcFeature.ENCODING</code> -
                            <code class="literal">jersey.config.server.mvc.encoding.mustache</code></p><p>Property used to configure a default encoding that will be used
                            if none is specified in <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> annotation. If property is not defined
                            the UTF-8 encoding will be used as a default value.</p></li></ul></div><p>
            </p><p>
                Maven users can find this module at coordinates

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-mvc-mustache&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                and for non-Maven users the list of dependencies is available at <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-mvc-mustache/dependencies.html" target="_top">jersey-mvc-mustache</a>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15465"></a>21.6.2.&nbsp;Freemarker</h3></div></div></div><p>
                An integration module for <a class="link" href="https://freemarker.apache.org/" target="_top">Freemarker</a>-based templating engine.
            </p><p>
                Freemarker template processor resolves absolute template references to processable template references represented
                as Freemarker templates as follows:
            </p><div class="procedure"><a name="d0e15475"></a><p class="title"><b>Procedure&nbsp;21.2.&nbsp;Resolving Freemarker template reference</b></p><ol class="procedure" type="1"><li class="step"><p>
                        if the absolute template reference does not end in <code class="literal">.ftl</code> append this suffix to the
                        reference; and
                    </p></li><li class="step"><p>
                        if <code class="literal">ServletContext.getResource</code>, <code class="literal">Class.getResource</code> or
                        <code class="literal">File.exists</code> returns a non-<code class="literal">null</code> value for the reference then
                        return the reference as the processable template reference otherwise return <code class="literal">null</code>
                        (to indicate the absolute reference has not been resolved by the Freemarker template processor).
                    </p></li></ol></div><p>
                Thus the absolute template reference <code class="literal">/com/foo/Foo/index</code> would be resolved to
                <code class="literal">/com/foo/Foo/index.ftl</code>, provided there exists a <code class="literal">/com/foo/Foo/index.ftl</code>
                Freemarker template in the application.
            </p><p>
                Jersey will assign the model instance to an attribute named <code class="literal">model</code>.
                So it is possible to reference the <code class="literal">foo</code> key from the provided <code class="literal">Map</code> (MVC Model)
                resource from the Freemarker template as follows:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;h1&gt;${model.foo}&lt;/h1&gt;</pre><p>
            </p><p>
                Available configuration properties:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">FreemarkerMvcFeature.TEMPLATE_BASE_PATH</code> -
                            <code class="literal">jersey.config.server.mvc.templateBasePath.freemarker</code></p><p>The base path where Freemarker templates are located.</p></li><li class="listitem"><p><code class="literal">FreemarkerMvcFeature.CACHE_TEMPLATES</code> -
                            <code class="literal">jersey.config.server.mvc.caching.freemarker</code></p><p>Enables caching of Freemarker templates to avoid multiple compilation.</p></li><li class="listitem"><p><code class="literal">FreemarkerMvcFeature.TEMPLATE_OBJECT_FACTORY</code> -
                            <code class="literal">jersey.config.server.mvc.factory.freemarker</code></p><p>Property used to pass user-configured <code class="literal">FreemarkerFactory</code>.</p></li><li class="listitem"><p><code class="literal">FreemarkerMvcFeature.ENCODING</code> -
                            <code class="literal">jersey.config.server.mvc.encoding.freemarker</code></p><p>Property used to configure a default encoding that will be used
                            if none is specified in <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> annotation. If property is not defined
                            the UTF-8 encoding will be used as a default value.</p></li></ul></div><p>
            </p><p>
                Maven users can find this module at coordinates

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-mvc-freemarker&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                and for non-Maven users the list of dependencies is available at <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-mvc-freemarker/dependencies.html" target="_top">jersey-mvc-freemarker</a>.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15581"></a>21.6.3.&nbsp;JSP</h3></div></div></div><p>
                An integration module for JSP-based templating engine.
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Limitations of Jersey JSP MVC Templates</h3><p>
                    Jersey web applications that want to use JSP templating support should be registered as Servlet
                    filters rather than Servlets in the application's <code class="literal">web.xml</code>. The
                    <code class="literal">web.xml</code>-less deployment style introduced in Servlet 3.0 is not supported at the moment
                    for web applications that require use of Jersey MVC templating support.
                </p></div><p>
                JSP template processor resolves absolute template references to processable template references represented as JSP
                pages as follows:
            </p><div class="procedure"><a name="d0e15599"></a><p class="title"><b>Procedure&nbsp;21.3.&nbsp;Resolving JSP template reference</b></p><ol class="procedure" type="1"><li class="step"><p>
                        if the absolute template reference does not end in <code class="literal">.jsp</code> append this suffix to the
                        reference; and
                    </p></li><li class="step"><p>
                        if <code class="literal">ServletContext.getResource</code> returns a non-<code class="literal">null</code> value for the reference then
                        return the reference as the processable template reference otherwise return <code class="literal">null</code>
                        (to indicate the absolute reference has not been resolved by the JSP template processor).
                    </p></li></ol></div><p>
                Thus the absolute template reference <code class="literal">/com/foo/Foo/index</code> would be resolved to
                <code class="literal">/com/foo/Foo/index.jsp</code>, provided there exists a <code class="literal">/com/foo/Foo/index.jsp</code>
                JSP page in the web application.
            </p><p>
                Jersey will assign the model instance to the attribute named <code class="literal">model</code> or <code class="literal">it</code>.
                So it is possible to reference the <code class="literal">foo</code> property on the <code class="literal">Foo</code> resource
                from the JSP template as follows:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;h1&gt;${model.foo}&lt;/h1&gt;</pre><p>

                or

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;h1&gt;${it.foo}&lt;/h1&gt;</pre><p>
            </p><p>
                To include another JSP page in the currently processed one a custom <code class="literal">include</code> tag can be used.
                Mandatory parameter <code class="literal">page</code> represents a relative template name which would be absolutized using
                the same resolving resource class as the parent JSP page template.

                </p><div class="example"><a name="d0e15659"></a><p class="title"><b>Example&nbsp;21.12.&nbsp;Including JSP page into JSP page</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;%@page contentType="text/html"%&gt;
&lt;%@page pageEncoding="UTF-8"%&gt;

&lt;%@taglib prefix="rbt" uri="urn:org:glassfish:jersey:servlet:mvc" %&gt;

&lt;html&gt;
    &lt;body&gt;

    &lt;rbt:include page="include.jsp"/&gt;

    &lt;/body&gt;
&lt;/html&gt;</pre></div></div><p><br class="example-break">
            </p><p>
                Available configuration properties:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">JspMvcFeature.TEMPLATE_BASE_PATH</code> -
                            <code class="literal">jersey.config.server.mvc.templateBasePath.jsp</code></p><p>The base path where JSP templates are located.</p></li></ul></div><p>
            </p><p>
                Maven users can find this module at coordinates

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-mvc-jsp&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                and for non-Maven users the list of dependencies is available at <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-mvc-jsp/dependencies.html" target="_top">jersey-mvc-jsp</a>.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc.spi"></a>21.7.&nbsp;Writing Custom Templating Engines</h2></div></div></div><p>
            To add support for other (custom) templating engines into Jersey MVC Templating facility, you need to implement the
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/spi/TemplateProcessor.html" target="_top">TemplateProcessor</a> and register this class into your application.

            </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                    When writing template processors it is recommend that you use an appropriate unique suffix for the
                    processable template references, in which case it is then possible to easily support mixing of multiple
                    templating engines in a single application without conflicts.
                </p></div><p>

            </p><div class="example"><a name="d0e15698"></a><p class="title"><b>Example&nbsp;21.13.&nbsp;Custom <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/spi/TemplateProcessor.html" target="_top">TemplateProcessor</a></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
class MyTemplateProcessor implements TemplateProcessor&lt;String&gt; {

    @Override
    public String resolve(String path, final MediaType mediaType) {
        final String extension = ".testp";

        if (!path.endsWith(extension)) {
            path = path + extension;
        }

        final URL u = this.getClass().getResource(path);
        return u == null ? null : path;
    }

    @Override
    public void writeTo(String templateReference,
                        Viewable viewable,
                        MediaType mediaType,
                        OutputStream out) throws IOException {
        final PrintStream ps = new PrintStream(out);
        ps.print("path=");
        ps.print(templateReference);
        ps.println();
        ps.print("model=");
        ps.print(viewable.getModel().toString());
        ps.println();
    }

}</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e15706"></a><p class="title"><b>Example&nbsp;21.14.&nbsp;Registering custom <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/mvc/spi/TemplateProcessor.html" target="_top">TemplateProcessor</a></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    .register(MyTemplateProcessor.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                In a typical set-up projects using the Jersey MVC templating support would depend on the base module that
                provides the API and SPI and a single templating engine module for the templating engine of your choice.
                These modules need to be mentioned explicitly in your <code class="literal">pom.xml</code> file.
            </p></div><p>
            If you want to use just templating API infrastructure provided by Jersey for the MVC templating support in order to
            implement your custom support for a templating engine other than the ones provided by Jersey,
            you will need to add the base <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-mvc/dependencies.html" target="_top">jersey-mvc</a> module into the list of your dependencies:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-mvc&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15728"></a>21.8.&nbsp;Other Examples</h2></div></div></div><p>To see an example of MVC (JSP) templating support in Jersey refer to the
            <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/bookstore-webapp" target="_top">MVC (Bookstore) Example</a>.</p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="logging_chapter"></a>Chapter&nbsp;22.&nbsp;Logging</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#logging">22.1. Logging traffic</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15743">22.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e15768">22.1.2. Configuration and registering</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="logging"></a>22.1.&nbsp;Logging traffic</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15743"></a>22.1.1.&nbsp;Introduction</h3></div></div></div><p>
                Jersey Logging supports the logging request and response via internal client and server filters, which are
                configured and registered by <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html" target="_top">LoggingFeature</a> 's properties. <code class="literal">LoggingFeature</code>
                has been introduced in Jersey 2.23 version and deprecates an older <code class="literal">LoggingFilter</code>.
                Jersey of version 3.x fully support all logging features of Jersey 2.x.
            </p><p>
                <code class="literal">LoggingFeature</code> might be discovered by
                <a class="link" href="#deployment.autodiscoverable" title="4.3.&nbsp;Auto-Discoverable Features">auto-discoverable mechanism</a>
                or initialized by registering on client or server components. Client or server logging filter is initialized
                depending on which context is <code class="literal">LoggingFeature</code> registered with.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15768"></a>22.1.2.&nbsp;Configuration and registering</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e15771"></a>22.1.2.1.&nbsp;Configuration options</h4></div></div></div><p>
                    </p><div class="itemizedlist"><p class="title"><b>Configurable options</b></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <code class="literal">Logger name</code>
                            </p><p>
                                Defines a logger used to log request and response messages.
                            </p><p>Default value is <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#DEFAULT_LOGGER_NAME" target="_top">LoggingFeature.DEFAULT_LOGGER_NAME</a>.
                            </p></li><li class="listitem"><p>
                                <code class="literal">Logger level</code>
                            </p><p>
                                Defines level that will be used to log messages by logging filters. Messages will be logged only
                                if the effective level of the logger allows it.
                            </p><p>Default value is <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#DEFAULT_LOGGER_LEVEL" target="_top">LoggingFeature.DEFAULT_LOGGER_LEVEL</a>.
                            </p></li><li class="listitem"><p>
                                <code class="literal">Verbosity</code>
                            </p><p>
                                Verbosity determines how detailed message will be logged.
                                See <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.Verbosity.html" target="_top">LoggingFeature.Verbosity</a> javadoc.
                                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                            The lowest verbosity <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.Verbosity.html#HEADERS_ONLY" target="_top">LoggingFeature.Verbosity.HEADERS_ONLY</a> will log
                                            only request/response headers.
                                        </p></li><li class="listitem"><p>
                                            The medium verbosity (<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.Verbosity.html#PAYLOAD_TEXT" target="_top">LoggingFeature.Verbosity.PAYLOAD_TEXT</a>) will log
                                            request/response headers, as well as an entity if considered a readable text. The
                                            entity is considered a readable text, if <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/MediaType.html" target="_top">MediaType</a> is
                                            <code class="literal">text/*</code>
                                            or is one of
                                            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><p>
                                                        <code class="literal">application/atom+xml</code>
                                                    </p></li><li class="listitem"><p>
                                                        <code class="literal">application/json</code>
                                                    </p></li><li class="listitem"><p>
                                                        <code class="literal">application/svg+xml</code>
                                                    </p></li><li class="listitem"><p>
                                                        <code class="literal">application/x-www-form-urlencoded</code>
                                                    </p></li><li class="listitem"><p>
                                                        <code class="literal">application/xhtml+xml</code>
                                                    </p></li><li class="listitem"><p>
                                                        <code class="literal">application/xml</code>
                                                    </p></li></ul></div><p>
                                        </p></li><li class="listitem"><p>
                                            The highest verbosity <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.Verbosity.html#PAYLOAD_ANY" target="_top">LoggingFeature.Verbosity.PAYLOAD_ANY</a>
                                            will log all types of an entity (besides the request/response headers.
                                        </p></li></ul></div><p>
                                Note that the entity is logged up to the specified maximum number of bytes
                                (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_MAX_ENTITY_SIZE" target="_top">LoggingFeature.LOGGING_FEATURE_MAX_ENTITY_SIZE</a>).
                            </p><p>
                                Default value is <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#DEFAULT_VERBOSITY" target="_top">LoggingFeature.DEFAULT_VERBOSITY</a>.
                            </p></li><li class="listitem"><p>
                                <code class="literal">Maximum entity size</code>
                            </p><p>
                                Maximum number of entity bytes to be logged (and buffered) - if the entity is larger, logging
                                filter will print (and buffer in memory) only the specified number of bytes and print "...more..."
                                string at the end. Negative values are interpreted as zero.
                            </p><p>Default value <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#DEFAULT_MAX_ENTITY_SIZE" target="_top">LoggingFeature.DEFAULT_MAX_ENTITY_SIZE</a>.
                            </p></li></ul></div><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e15902"></a>22.1.2.2.&nbsp;Configuration properties</h4></div></div></div><p>
                    The feature is enabled on when auto-discoverable mechanism is not disabled and at least one of the feature's
                    property is set. For enabling client or server logging filter one of the
                    <a class="link" href="#appendix-properties-common" title="A.1.&nbsp;Common (client/server) configuration properties">common properties</a> or
                    <code class="literal">_CLIENT</code>
                    suffixed <a class="link" href="#appendix-properties-client" title="A.4.&nbsp;Client configuration properties">properties</a>, or
                    <code class="literal">_SERVER</code> <a class="link" href="#appendix-properties-server" title="A.2.&nbsp;Server configuration properties">properties</a>
                    respectively.
                </p><p>
                    An example of initializing server-side logging with the highest verbosity.
                    </p><div class="example"><a name="d0e15924"></a><p class="title"><b>Example&nbsp;22.1.&nbsp;Logging on the client side</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">    ClientConfig clientConfig = new ClientConfig();
    clientConfig.property(LoggingFeature.LOGGING_FEATURE_VERBOSITY_CLIENT, LoggingFeature.Verbosity.PAYLOAD_ANY);
    Client client = ClientBuilder.newClient(clientConfig);
                        </pre></div></div><p><br class="example-break">
                </p><p>
                    The <code class="literal">LoggingFeature</code> might be registered explicitly on <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> for
                    server-side logging or on <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a> for client-side logging.
                </p><div class="example"><a name="d0e15941"></a><p class="title"><b>Example&nbsp;22.2.&nbsp;Register <code class="literal">LoggingFeature</code> via constructor
                    </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">        ResourceConfig config = new ResourceConfig(HelloWorldResource.class);
        config.register(new LoggingFeature(LOGGER, LoggingFeature.Verbosity.PAYLOAD_ANY));
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"></div><p>
                    Following examples demonstrate registering <code class="literal">LoggingFeature</code> on server-side with default
                    values and values defined by one of the public constructors (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html" target="_top">LoggingFeature</a>).
                </p><div class="example"><a name="d0e15958"></a><p class="title"><b>Example&nbsp;22.3.&nbsp;Register <code class="literal">LoggingFeature</code> class
                    </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">        ResourceConfig config = new ResourceConfig(HelloWorldResource.class);
        config.register(LoggingFeature.class);
</pre></div></div><br class="example-break"><p>An example of server-side logging with entity
                    <code class="literal">Hello World!</code>
                </p><pre class="screen">&nbsp;&nbsp;1 May 09, 2020 2:55:33 PM org.glassfish.jersey.logging.LoggingInterceptor log
&nbsp;&nbsp;2 INFO: 1 * Server has received a request on thread grizzly-http-server-0
&nbsp;&nbsp;3 1 &gt; GET http://localhost:9998/helloworld
&nbsp;&nbsp;4 1 &gt; accept: text/plain
&nbsp;&nbsp;5 1 &gt; accept-encoding: gzip,deflate
&nbsp;&nbsp;6 1 &gt; connection: Keep-Alive
&nbsp;&nbsp;7 1 &gt; host: localhost:9998
&nbsp;&nbsp;8 1 &gt; user-agent: Jersey/3.0.0 (Apache HttpClient 4.5.9)
&nbsp;&nbsp;9 
&nbsp;10 May 09, 2020 2:55:33 PM org.glassfish.jersey.logging.LoggingInterceptor log
&nbsp;11 INFO: 1 * Server responded with a response on thread grizzly-http-server-0
&nbsp;12 1 &lt; 200
&nbsp;13 1 &lt; Content-Type: text/plain
&nbsp;14 Hello World!</pre></div></div></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="monitoring_tracing"></a>Chapter&nbsp;23.&nbsp;Monitoring and Diagnostics</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#monitoring">23.1. Monitoring Jersey Applications</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15980">23.1.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e16031">23.1.2. Event Listeners</a></span></dt></dl></dd><dt><span class="section"><a href="#tracing">23.2. Tracing Support</a></span></dt><dd><dl><dt><span class="section"><a href="#tracing.configuration">23.2.1. Configuration options</a></span></dt><dt><span class="section"><a href="#d0e16762">23.2.2. Tracing Log</a></span></dt><dt><span class="section"><a href="#d0e16776">23.2.3. Configuring tracing support via HTTP request headers</a></span></dt><dt><span class="section"><a href="#d0e16819">23.2.4. Format of the HTTP response headers</a></span></dt><dt><span class="section"><a href="#d0e16976">23.2.5. Tracing Examples</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="monitoring"></a>23.1.&nbsp;Monitoring Jersey Applications</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15980"></a>23.1.1.&nbsp;Introduction</h3></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    Jersey monitoring support has been released as a <span class="emphasis"><em>beta release</em></span> in Jersey 2.1 version.
                    As such, the exposed monitoring public APIs and functionality described in this section may change in the
                    future Jersey releases.
                </p></div><p>
                Jersey provides functionality for monitoring JAX-RS/Jersey applications. Application monitoring is useful
                when you need to identify the performance hot-spots in your JAX-RS application, observe
                execution statistics of particular resources or listen to application
                or request lifecycle events. Note that this functionality is Jersey-specific extension to JAX-RS API.
            </p><p>
                Jersey monitoring support is divided into three functional areas:

                </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Event Listeners</span></dt><dd><p>
                                Event listeners allow users to receive and process a predefined set of events that occur during
                                an application lifecycle (such as application initialization, application destroy) as well as
                                request processing lifecycle events (request started, resource method finished, exception thrown,
                                etc.). This feature is always enabled in Jersey server runtime and is leveraged by the other
                                monitoring features.
                            </p></dd><dt><span class="term">Monitoring Statistics</span></dt><dd><p>
                                Jersey can be configured to process lifecycle events in order to expose a wide range of
                                runtime monitoring statistics to the end user. The statistics are accessible trough an injectable
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a> interface. The statistics provide general information
                                about the application as well as fine-grained execution statistics on particular resources and sub
                                resources and exposed URIs. For performance reasons, this functionality must be explicitly enabled
                                prior using.
                            </p></dd><dt><span class="term">JMX MBeans with statistics</span></dt><dd><p>
                                In addition to the injectable <code class="literal">MonitoringStatistics</code> data, Jersey
                                is able to expose the statistics as JMX MBeans (for example
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ApplicationMXBean.html" target="_top">ApplicationMXBean</a>).
                                Jersey monitoring MXBeans can be accessed programmatically using JMX APIs or browsed via JMX-enabled
                                tool (<code class="literal">JConsole</code> for example). This functionality is also disabled by default for
                                performance reasons and must be enabled if needed.
                            </p></dd></dl></div><p>

                All monitoring related APIs (beta!) can be found in the <code class="literal">jersey-server</code> module in
                <code class="literal">org.glassfish.jersey.server.monitoring</code> package. Monitoring in Jersey is currently supported on
                the server side.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e16031"></a>23.1.2.&nbsp;Event Listeners</h3></div></div></div><p>
                Jersey defines two types of event listeners that you can implement and register with your application:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ApplicationEventListener.html" target="_top">ApplicationEventListener</a> for listening to application events, and</p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/RequestEventListener.html" target="_top">RequestEventListener</a> for listening to events of request processing.</p></li></ul></div><p>

                Only the first type, <code class="literal">ApplicationEventListener</code>
                can be directly registered as an application-wide provider. The <code class="literal">RequestEventListener</code>
                is designed to be specific to every request and can be only returned from the
                <code class="literal">ApplicationEventListener</code> as such.
            </p><p>
                Let's start with an example. The following examples show simple implementations of Jersey event listeners as well
                as a test JAX-RS resource that will be monitored.

                </p><div class="example"><a name="d0e16059"></a><p class="title"><b>Example&nbsp;23.1.&nbsp;Application event listener</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyApplicationEventListener
            implements ApplicationEventListener {
    private volatile int requestCnt = 0;

    @Override
    public void onEvent(ApplicationEvent event) {
        switch (event.getType()) {
            case INITIALIZATION_FINISHED:
                System.out.println("Application "
                        + event.getResourceConfig().getApplicationName()
                        + " was initialized.");
                break;
            case DESTROY_FINISHED:
                System.out.println("Application "
                    + event.getResourceConfig().getApplicationName() destroyed.");
                break;
        }
    }

    @Override
    public RequestEventListener onRequest(RequestEvent requestEvent) {
        requestCnt++;
        System.out.println("Request " + requestCnt + " started.");
        // return the listener instance that will handle this request.
        return new MyRequestEventListener(requestCnt);
    }
}</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e16065"></a><p class="title"><b>Example&nbsp;23.2.&nbsp;Request event listener</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyRequestEventListener implements RequestEventListener {
    private final int requestNumber;
    private final long startTime;

    public MyRequestEventListener(int requestNumber) {
        this.requestNumber = requestNumber;
        startTime = System.currentTimeMillis();
    }

    @Override
    public void onEvent(RequestEvent event) {
        switch (event.getType()) {
            case RESOURCE_METHOD_START:
                System.out.println("Resource method "
                    + event.getUriInfo().getMatchedResourceMethod()
                        .getHttpMethod()
                    + " started for request " + requestNumber);
                break;
            case FINISHED:
                System.out.println("Request " + requestNumber
                    + " finished. Processing time "
                    + (System.currentTimeMillis() - startTime) + " ms.");
                break;
        }
    }
}</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e16071"></a><p class="title"><b>Example&nbsp;23.3.&nbsp;Event listener test resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public class TestResource {
    @GET
    public String getSomething() {
        return "get";
    }

    @POST
    public String postSomething(String entity) {
        return "post";
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                Once the listeners and the monitored resource are defined, it's time to initialize our application. The following
                piece of code shows a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> that is used to initialize the application (please
                note that only <code class="literal">ApplicationEventListener</code> is registered as provider).

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ResourceConfig resourceConfig =
            new ResourceConfig(TestResource.class, MyApplicationEventListener.class)
            .setApplicationName("my-monitored-application");</pre><p>

                Our example application now contains a simple resource <code class="literal">TestResource</code> that defines resource methods
                for <code class="literal">GET</code> and <code class="literal">POST</code> and a custom <code class="literal">MyApplicationEventListener</code> event listener.
            </p><p>
                The registered <code class="literal">MyApplicationEventListener</code> implements two methods defined by the
                <code class="literal">ApplicationEventListener</code> interface. A method <code class="literal">onEvent()</code> handles
                all application lifecycle events. In our case the method handles only 2 application events - initialization
                and destroy. Other event types are ignored. All application event types are defined
                in <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ApplicationEvent.html" target="_top">ApplicationEvent</a><code class="literal">.Type</code>. The second method <code class="literal">onRequest</code>
                is invoked by Jersey runtime every time a new request is received. The request event type passed to the method
                is always <code class="literal">START</code>. If you want to listen to any other request lifecycle events for the new request,
                you are expected to return an instance of <code class="literal">RequestEventListener</code> that will handle the
                request. It is important to understand, that the instance will handle only the request for which it has been returned
                from an <code class="literal">ApplicationEventListener.onRequest</code> method and not any other requests. In our case the
                returned request event listener keeps information about the request number of the current request and a start time of
                the request which is later used to print out the request processing times statistics. This demonstrates the principle
                of listening to request events: for one request there is one instance which can be used to hold all the information
                about the particular request. In other words, <code class="literal">RequestEventListener</code> is designed to be
                implicitly request-scoped.
            </p><p>
                Jersey represents lifecycle events via <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/RequestEvent.html" target="_top">RequestEvent</a> and
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ApplicationEvent.html" target="_top">ApplicationEvent</a> types. Instances of these classes contain information
                about respective events. The most important information is the event type <code class="literal">Type</code> retrievable via
                <code class="literal">getType()</code> method,
                which identifies the type of the event. Events contain also additional information that is dependent on a particular
                event type. This information can be retrieved via event getters. Again, some getters return valid information for all
                event types, some are specific to a sub-set of event types. For example, in the
                <code class="literal">RequestEvent</code>, the <code class="literal">getExceptionCause()</code> method returns valid
                information only when event type is <code class="literal">ON_EXCEPTION</code>. On the other hand,
                a <code class="literal">getContainerRequest()</code> can be used to return current request context for any request event type.
                See javadoc of events and event types to get familiar with event types and information valid for each event type.
            </p><p>
                Our <code class="literal">MyRequestEventListener</code> implementation is focused on processing 2 request events. First,
                it listens for an event that is triggered before a resource method is executed. Also, it hooks to a "request finished"
                event. As mentioned earlier, the request event <code class="literal">START</code> is handled only in the
                <code class="literal">MyApplicationEventListener</code>. The <code class="literal">START</code> event type will never be invoked on
                <code class="literal">RequestEventListener</code>. Therefore the logic for measuring the <code class="literal">startTime</code> is in the
                constructor which is invoked from <code class="literal">MyApplicationEventListener.onRequest()</code>. An attempt to handling
                the request <code class="literal">START</code> event in a <code class="literal">RequestEventListener.onEvent()</code> method would be a
                mistake.
            </p><p>
                Let's deploy the application and use a simple test client code to produce some activity in order to spawn new events:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">target.path("resource").request()
        .post(Entity.entity("post", MediaType.TEXT_PLAIN_TYPE));
    target.path("resource").request().get();</pre><p>

                In the code above, the <code class="literal">target</code> is a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> instance pointing to the application
                context root path. Using the <a class="xref" href="#client" title="Chapter&nbsp;5.&nbsp;Client API">Chapter&nbsp;5, <i>Client API</i></a>, we invoke <code class="literal">GET</code> and <code class="literal">POST</code> methods
                on the <code class="literal">MyResource</code> JAX-RS resource class that we implemented earlier.
            </p><p>
                When we start the application, run the test client and then stop the application, the console output for the
                deployed server-side application would contain the following output:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: text;&#xA;    gutter: false;">Application my-monitored-application was initialized.
Request 1 started.
Resource method POST started for request 1
Request 1 finished. Processing time 330 ms.
Request 2 started.
Resource method GET started for request 2
Request 2 finished. Processing time 4 ms.
Application my-monitored-application destroyed.</pre><p>
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e16213"></a>23.1.2.1.&nbsp;Guidelines for implementing Jersey event listeners</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Implement event listeners as thread safe. While individual events will be arriving serially,
                        individual listener invocations may occur from different threads. Thus make sure that your listeners
                        are processing data safely with respect to their
                        <a class="link" href="http://en.wikipedia.org/wiki/Java_Memory_Model" target="_top">Java Memory Model</a> visibility (in the example
                        above the fields <code class="literal">requestNumber</code>, <code class="literal">startTime</code> of
                        <code class="literal">MyRequestEventListener</code> are final and therefore the same value is
                        visible for all threads executing the <code class="literal">onEvent()</code> method).
                    </p></li><li class="listitem"><p>
                        Do not block the thread executing the event listeners by performing long-running tasks. Execution of event
                        listeners is a part of the standard application and request processing and as such needs to finish as quickly
                        as possible to avoid negative impact on overall application performance.
                    </p></li><li class="listitem"><p>
                        Do not try to modify mutable objects returned from <code class="literal">ApplicationEvent</code> and
                        <code class="literal">RequestEvent</code> getters to avoid experiencing undefined behavior.
                        Events listeners should use the information for read only purposes only. Use different techniques like
                        filters, interceptors or other providers to modify the processing of requests and applications. Even though
                        modification might be possible and might work as desired now, your code is in risk of producing intermittent
                        failures or unexpected behaviour (for example after migrating to new Jersey version).
                    </p></li><li class="listitem"><p>
                        If you do not want to listen to request events, do not return an empty listener in the
                        <code class="literal">onRequest()</code> method. Return <code class="literal">null</code> instead. Returning empty listener
                        might have a negative performance impact. Do not rely on JIT optimizing out the empty listener invocation
                        code.
                    </p></li><li class="listitem"><p>
                        If you miss any event type or any detail in the events, let us know via Jersey user mailing list.
                    </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e16259"></a>23.1.2.2.&nbsp;Monitoring Statistics</h4></div></div></div><p>
                    Event listeners described in the previous section are all-purpose facility. For example, you may decide to
                    use them to measure various execution statistics of your application. While this might be an easy task for simple
                    statistics like "how much time was spent on execution of each Java method?", nevertheless, if you want to measure
                    statistics based on URIs and individual resources, the implementation might get rather complex soon, especially
                    when considering sub-resources and sub-resource locators. To save you the trouble, Jersey provides feature for
                    collecting events and calculating a pre-defined set of monitoring and execution statistics, including
                    application configuration, exception mappers execution, minimum/maximum/average execution times for individual
                    resource methods as well as entire request processing etc.
                </p><p>
                    Calculating the monitoring statistics has obviously a performance impact, therefore this feature is
                    disabled by default. To enable the feature, set the following configuration property to <code class="literal">true</code>:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">jersey.config.server.monitoring.statistics.enabled=true</pre><p>
                    The property description can be found in <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_ENABLED" target="_top">ServerProperties.MONITORING_STATISTICS_ENABLED</a>
                    This will calculate the statistics. The easiest way how to get statistics is to let Jersey
                    to inject them. See the following example:
                </p><div class="example"><a name="d0e16276"></a><p class="title"><b>Example&nbsp;23.4.&nbsp;Injecting MonitoringStatistics</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public static class StatisticsResource {
    @Inject
    Provider&lt;MonitoringStatistics&gt; monitoringStatisticsProvider;

    @GET
    public String getSomething() {
        final MonitoringStatistics snapshot
            = monitoringStatisticsProvider.get().snapshot();

        final TimeWindowStatistics timeWindowStatistics
            = snapshot.getRequestStatistics()
              .getTimeWindowStatistics().get(0l);

        return "request count: " + timeWindowStatistics.getRequestCount()
            + ", average request processing [ms]: "
            + timeWindowStatistics.getAverageDuration();
    }
}}</pre></div></div><br class="example-break"><p>
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a> are
                    injected into the resource using an <a class="link" href="https://jakarta.ee/specifications//dependency-injection/2.0/apidocs/jakarta/inject/inject" target="_top">@Inject</a> annotation.
                    Please note the usage of the <a class="link" href="https://jakarta.ee/specifications//dependency-injection/2.0/apidocs/jakarta/inject/provider" target="_top">Provider</a> for injection (it will be discussed later).
                    Firstly, the snapshot of statistics is retrieved by the <code class="literal">snapshot()</code> method.
                    The snapshot of statistics is an immutable copy of statistics which does not change over the time.
                    Additionally, data in a snapshot are consistent. It's recommended to create snapshots before working with
                    the statistics data and then process the snapshot data.
                    Working with original non-snapshot data makes sense when data consistency is not important and
                    performance is of highest concern. While it is currently not the case, the injected non-snapshot data may
                    be implemented as mutable for performance reasons in a future release of Jersey.
                </p><p>
                    The injected monitoring statistics represent the root of the collected statistics hierarchy. The hierarchy
                    can be traversed to retrieve any partial statistics data. In the example, we retrieve certain request
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/TimeWindowStatistics.html" target="_top">TimeWindowStatistics</a> data. In our case, those are the request execution statistics
                    for a time window defined by long value 0 which means unlimited time window. This means we are retrieving
                    the global request execution statistics measured since a start of the application.
                    Finally, request count and average duration from the statistics are used to produce the String response.
                    When we invoke few <code class="literal">GET</code> requests on the <code class="literal">StatisticsResource</code>, we get the
                    following console output:
                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: text;&#xA;    gutter: false;">request count: 1, average request processing [ms]: 260
request count: 2, average request processing [ms]: 135
request count: 3, average request processing [ms]: 93
request count: 4, average request processing [ms]: 73</pre><p>
                </p><p>
                    Let's look closer at <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a> interface.
                    <code class="literal">MonitoringStatistics</code> interface defines getters by which other nested
                    statistics can be retrieved. All statistics are in the same package and ends with
                    <code class="literal">Statistics</code> postfix. Statistics interfaces are the following:
                    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a></span></dt><dd><p>main top level statistics</p></dd><dt><span class="term"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ResponseStatistics.html" target="_top">ResponseStatistics</a></span></dt><dd><p>response statistics (eg. response status codes and their count)</p></dd><dt><span class="term"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ResourceStatistics.html" target="_top">ResourceStatistics</a></span></dt><dd><p>statistics of execution of resources (resource classes or resource URIs)</p></dd><dt><span class="term"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ResourceMethodStatistics.html" target="_top">ResourceMethodStatistics</a></span></dt><dd><p>statistics of execution of resource methods</p></dd><dt><span class="term"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ExecutionStatistics.html" target="_top">ExecutionStatistics</a></span></dt><dd><p>statistic of execution of a target (resource, request, resource method)</p></dd><dt><span class="term"><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/TimeWindowStatistics.html" target="_top">TimeWindowStatistics</a></span></dt><dd><p>statistics of execution time in specific interval (eg. executions in last 5 minutes)</p></dd></dl></div><p>
                </p><p>
                    Each time-monitored target contains <code class="literal">ExecutionStatistics</code>. So, for example
                    resource method contains execution statistics of its execution. Each
                    <code class="literal">ExecutionStatistics</code> contains multiple
                    <code class="literal">TimeWindowStatistics</code>. Currently, each
                    <code class="literal">ExecutionStatistics</code> contains
                    <code class="literal">TimeWindowStatistics</code> for these time windows:

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>0: unlimited=&gt; all execution since start of the application</p></li><li class="listitem"><p>1000: 1s =&gt; stats measured in last 1 second</p></li><li class="listitem"><p>15000: 15s =&gt; stats measured in last 15 seconds</p></li><li class="listitem"><p>60000: 1min =&gt; stats measured in last 1 minute</p></li><li class="listitem"><p>900000: 15min =&gt; stats measured in last 15 minutes</p></li><li class="listitem"><p>3600000: 1hour =&gt; stats measured in last hour minutes</p></li></ul></div><p>

                    All the time window statistics can be retrieved from a <code class="literal">Map&lt;Long, TimeWindowStatistics&gt;</code>
                    map returned from <code class="literal">ExecutionStatistics.getTimeWindowStatistics()</code>. Key of the map
                    is the number of milliseconds of interval (so, for example key 60000 points
                    to statistics for last one minute).
                </p><p>
                    Note, that <code class="literal">snapshot()</code> method was called in the example only on the top level
                    <code class="literal">MonitoringStatistics</code>. This produced a snapshot of the entire
                    tree of statistics and therefore we do not need to call <code class="literal">snapshot()</code>
                    on <code class="literal">TimeWindowStatistics</code> again.
                </p><p>
                    Statistics are injected using the <a class="link" href="https://jakarta.ee/specifications//dependency-injection/2.0/apidocs/jakarta/inject/provider" target="_top">Provider</a>. This is preferred way of
                    injecting statistics. The reason is simple. Statistics might change over time and contract
                    of <code class="literal">MonitoringStatistics</code> does not make any assumptions about mutability of
                    monitoring statistics instances (to allow future optimizations and changes in implementation strategy). In
                    order to get always latest statistics, we recommend injecting a <a class="link" href="https://jakarta.ee/specifications//dependency-injection/2.0/apidocs/jakarta/inject/provider" target="_top">Provider</a> rather than a
                    direct reference and use its <code class="literal">get()</code> method to retrieve the latest statistics. For example,
                    in singleton resources the use of the technique is very important otherwise statistics might correspond
                    to the time when singleton was firstly created and might not update since that time.
                </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d0e16435"></a>23.1.2.2.1.&nbsp;Listening to statistics changes</h5></div></div></div><p>
                        Statistics are not calculated for each request or each change. Statistics are calculated only
                        from the collected data in regular intervals for performance reasons (for example once per second).
                        If you want to be notified about new statistics, register an implementation of
                        <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatisticsListener.html" target="_top">MonitoringStatisticsListener</a> as one of your custom application providers.
                        Your listener will be called every time the new statistics are calculated and the updated statistics
                        data will be passed to the listener method. This is another way of receiving statistics.
                        See the linked listener API documentation for more information.
                    </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e16443"></a>23.1.2.3.&nbsp;Monitoring Statistics as MBeans</h4></div></div></div><p>
                    Jersey provides feature to expose monitoring statistics as JMX MXBeans.
                    In order to enable monitoring statistics MXBeans exposure, the
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_MBEANS_ENABLED" target="_top">ServerProperties.MONITORING_STATISTICS_MBEANS_ENABLED</a> must be set to <code class="literal">true</code>.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">jersey.config.server.monitoring.statistics.mbeans.enabled=true</pre><p>
                    Note that enabling exposure of monitoring MXBeans causes that also the calculation of
                    <code class="literal">MonitoringStatistics</code> is automatically enabled as the exposed
                    MXBean statistics are extracted from <code class="literal">MonitoringStatistics</code>.
                </p><p>
                    The easiest way is to browse the MXBeans in the JConsole. Open the JConsole
                    (<code class="literal">$JAVA_HOME/bin/jconsole</code>). Then connect to the process where JAX-RS application is running
                    (server on which the application is running). Switch to a MBean tab and in the MBean tree on the left side
                    find a group <code class="literal">org.glassfish.jersey</code>. All deployed Jersey applications are located under this
                    group. If you don't see such this group, then MBeans are not exposed (check the configuration property and
                    logs if they not contain any exceptions or errors). The following figure is an example of an output from the
                    JConsole:
                </p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="100%"><tr><td align="center"><img src="images/monitoring-jsconsole.png" align="middle" width="100%"></td></tr></table></div><p>
                    Under the root <code class="literal">org.glassfish.jersey</code> Jersey MBean group you can find your application.
                    If the server contains more Jersey application, all will be present under the root Jersey the group. In the
                    screen-shot, the deployed JAX-RS application is named <code class="literal">myApplication</code> (the name can be defined
                    via <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> directly or by setting the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#APPLICATION_NAME" target="_top">ServerProperties.APPLICATION_NAME</a>
                    property).
                    Each application contains <code class="literal">Global</code>, <code class="literal">Resource</code> and
                    <code class="literal">Uris</code> sub-groups. The <code class="literal">Global</code> group contains all global
                    statistics like overall requests statistics of the entire application (<code class="literal">AllRequestTimes</code>),
                    configuration of the JAX-RS application (<code class="literal">Configuration</code>), statistics about
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ExceptionMapper.html" target="_top">ExceptionMapper&lt;E extends Throwable&gt;</a> execution (<code class="literal">ExceptionMapper</code>) and statistics about
                    produced responses (<code class="literal">Responses</code>).
                </p><p>
                    <code class="literal">Resources</code> and <code class="literal">Uris</code> groups contains monitoring statistics specific to
                    individual resources.
                    Statistics in <code class="literal">Resources</code> are bound to the JAX-RS resource Java classes loaded by the
                    application. <code class="literal">Uris</code> contains statistics of resources based on the matched application Uris
                    (one URI entry represents all methods bound to the particular URI, e.g. <code class="literal">/resource/exception</code>).
                    As Jersey provides programmatic resource builders (described in the chapter
                    <a class="link" href="#resource-builder" title="Chapter&nbsp;14.&nbsp;Programmatic API for Building Resources">"Programmatic API for Building Resources"</a>), one Java resource class
                    can be an endpoint for resource methods on many different URIs. And also one URI can be served by method from
                    many different Java classes. Therefore both views are not to be compared 1:1. Instead they provide
                    different logical views on your JAX-RS application. This monitoring feature can also be helpful when designing
                    the JAX-RS APIs as it provides nice view on available root application URIs.
                </p><p>
                    Both logical views on the resources exposed by application share few common principles. A single resource entry
                    is always a set of resource methods which are available under the <code class="literal">methods</code> sub-group. Statistics
                    can be found in MBeans <code class="literal">MethodTimes</code> and <code class="literal">RequestTimes</code>.
                    <code class="literal">MethodTimes</code> contains statistics measured on resource methods (duration of execution of a
                    code of the a resource method), whereas <code class="literal">RequestTimes</code> contains statistics of an entire request
                    execution (not only a time of the execution of the resource method but the overall time of the execution of whole
                    request by Jersey runtime). Another useful information is that statistics directly under resource (not under
                    the <code class="literal">methods</code> sub-group) contains summary of statistics for all resource methods grouped in the
                    resource entry.
                </p><p>Additional useful details about statistics</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">Global-&gt;Configuration-&gt;Registered(Classes/Instances)</code>:
                        registered resource classes and instances by the user (i.e., not added by <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/model/ModelProcessor.html" target="_top">ModelProcessor</a>
                        during deployment for example).
                    </p></li><li class="listitem"><p><code class="literal">Global-&gt;ExceptionMapper-&gt;ExceptionMapperCount</code>:
                        map that contains exception mapper classes as keys and number of their execution as values.
                    </p></li><li class="listitem"><p>
                        <code class="literal">Global-&gt;Responses-&gt;ResponseCodesToCountMap</code>:
                        map that contains response codes as keys and their total occurrence in responses as values.
                    </p></li><li class="listitem"><p>
                        Resource groups contain also entries for resources that were added by Jersey at deployment time using
                        <code class="literal">ModelProcessor</code> (for example all <code class="literal">OPTIONS</code> methods, <code class="literal">WADL</code>).
                        <code class="literal">HEAD</code> methods are not present in the MXBeans view (even HEAD methods are in resources).
                    </p></li><li class="listitem"><p>
                        Execution statistics for different time windows have different update intervals. The shorter the time window,
                        the shorter the update interval. This causes that immediately after the application start, the shorter time
                        windows (such as 15 seconds) may contain higher values than longer ones (e.g. 1 hour time window). The reason
                        is that 1 hour interval will show information that is not up to date and therefore has smaller value. This
                        inconsistency is not so much significant when application is running longer time. Total unlimited time windows
                        contains always up-to-date data. This inconsistency will get fixed in a future Jersey release.
                    </p></li></ul></div><p>
                    MXBeans can be also accessed using JMX. To do so, you would need to use the interfaces of MXBeans.
                    These interfaces are even useful when working with MXBeans only trough <code class="literal">JConsole</code> as
                    they contain Javadocs for each MXBean and attribute. Monitoring MBeans are defined by following interfaces:

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ApplicationMXBean.html" target="_top">ApplicationMXBean</a>: contains configuration statistics
                        </p></li><li class="listitem"><p>
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ExceptionMapperMXBean.html" target="_top">ExceptionMapperMXBean</a>: contains statistics of exception mappers
                        </p></li><li class="listitem"><p>
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ResourceMethodMXBean.html" target="_top">ResourceMethodMXBean</a>: contains statistics of resource method
                        </p></li><li class="listitem"><p>
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ResourceMXBean.html" target="_top">ResourceMXBean</a>: contains statistics of resource
                        </p></li><li class="listitem"><p>
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ResponseMXBean.html" target="_top">ResponseMXBean</a>: contains statistics of responses
                        </p></li></ul></div><p>

                    The list does not contain MXBean for the execution and time window statistics. The reason is that
                    this bean is defined as a <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/management/DynamicMBean.html" target="_top">DynamicMBean</a>. Attributes of this dynamic MBean contains
                    statistics for all time windows available.
                </p><p>
                    MXBeans do not reference each other but can be retrieved by their <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/management/ObjectName.html" target="_top">ObjectName</a>s which
                    are designed in the way, that final MBean tree looks nicely organized in <span class="emphasis"><em>JConsole</em></span>.
                    Each MXBean is uniquely identified by its <code class="literal">ObjectName</code> and properties of
                    <code class="literal">ObjectName</code> are structured hierarchically, so that each MXBean can be identified to which
                    parent it belong to (e.g. execution statistics dynamic MXBean belongs to resource method MXBean, which
                    belongs to resource and which belongs to application). Check the <code class="literal">ObjectName</code>s of
                    exposed MXBeans to investigate the structure (for example through JConsole).
                </p><p>
                    To reiterate, exposing Jersey MXBeans and the calculating monitoring statistics may have an performance impact
                    on your application and therefore should be enabled only when needed. Also, please note, that Jersey
                    monitoring is exposing quite a lot of information about the monitored application which might be viewed as
                    problematic in some cases (e.g. in production server deployments).
                </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tracing"></a>23.2.&nbsp;Tracing Support</h2></div></div></div><p>
            Apart from monitoring and collecting application statistics described in <a class="xref" href="#monitoring" title="23.1.&nbsp;Monitoring Jersey Applications">Section&nbsp;23.1, &#8220;Monitoring Jersey Applications&#8221;</a>, Jersey
            can also provide tracing or diagnostic information about server-side processing of individual requests.
            This facility may provide vital information when troubleshooting your misbehaving Jersey or JAX-RS application.
            When enabled, Jersey tracing facility collects useful information from all parts of JAX-RS server-side request
            processing pipeline:
            <code class="literal">PreMatchRequestFilter</code>, <code class="literal">ResourceMatching</code>, <code class="literal">RequestFilter</code>,
            <code class="literal">ReadIntercept</code>, <code class="literal">MBR</code>, <code class="literal">Invoke</code>,
            <code class="literal">ResponseFilter</code>, <code class="literal">WriteIntercept</code>, <code class="literal">MBW</code>, as well as
            <code class="literal">ExceptionHandling</code>.
        </p><p>
            The collected tracing information related to a single request is returned to the requesting client in the HTTP
            headers of a response for the request. The information is also logged on the server side using a dedicated Java
            Logger instance.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tracing.configuration"></a>23.2.1.&nbsp;Configuration options</h3></div></div></div><p>
                Tracing support is disabled by default. You can enable it either "globally" for all application requests
                or selectively per request. The tracing support activation is controlled by setting the
                <code class="literal">jersey.config.server.tracing.type</code> application configuration property. The property value
                is expected to be one of the following:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">OFF</code> - tracing support is disabled (default value).
                        </p></li><li class="listitem"><p>
                            <code class="literal">ON_DEMAND</code> - tracing support is in a stand-by mode; it is enabled selectively
                            per request, via a special <code class="literal">X-Jersey-Tracing-Accept</code> HTTP request header.
                        </p></li><li class="listitem"><p>
                            <code class="literal">ALL</code> - tracing support is enabled for all request.
                        </p></li></ul></div><p>
            </p><p>
                The level of detail of the information provided by Jersey tracing facility - the tracing threshold - can be
                customized. The tracing threshold can be set at the application level via
                <code class="literal">jersey.config.server.tracing.threshold</code> application configuration property,
                or at a request level, via <code class="literal">X-Jersey-Tracing-Threshold</code> HTTP request header. The request level
                configuration overrides any application level setting. There are 3 supported levels of detail for Jersey tracing:
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">SUMMARY</code> - very basic summary information about the main request processing stages.
                        </p></li><li class="listitem"><p>
                            <code class="literal">TRACE</code> - detailed information about activities in all the main request processing
                            stages (default threshold value).
                        </p></li><li class="listitem"><p>
                            <code class="literal">VERBOSE</code> - most verbose mode that provides extended information similar to
                            <code class="literal">TRACE</code> level, however with details on entity providers
                            (<code class="literal">MBR</code>/<code class="literal">MBW</code>) that were skipped during the provider selection
                            phase for any reason (lower priority, pattern matching, etc). Additionally, in this mode all
                            received request headers are echoed as part of the tracing information.
                        </p></li></ul></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e16762"></a>23.2.2.&nbsp;Tracing Log</h3></div></div></div><p>
                As mentioned earlier, all tracing information is also logged using a dedicated Java Logger. The individual
                tracing messages are logged immediately as the tracing events occur. The default name of the tracing logger
                is prefixed <code class="literal">org.glassfish.jersey.tracing.</code> with a default suffix <code class="literal">general</code>.
                This logger name can be customized per request by including a <code class="literal">X-Jersey-Tracing-Logger</code>
                HTTP request header as will be shown later.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e16776"></a>23.2.3.&nbsp;Configuring tracing support via HTTP request headers</h3></div></div></div><p>
                Whenever the tracing support is active (<code class="literal">ON_DEMAND</code> or <code class="literal">ALL</code>) you
                can customize the tracing behaviour by including one or more of the following request HTTP headers in your
                individual requests:
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">X-Jersey-Tracing-Accept</code> - used to enable the tracing support for the particular
                            request. It is applied only when the application-level tracing support is configured to
                            <code class="literal">ON_DEMAND</code> mode. The value of the header is not used by the Jersey tracing
                            facility and as such it can be any arbitrary (even empty) string.
                        </p></li><li class="listitem"><p>
                            <code class="literal">X-Jersey-Tracing-Threshold</code> - used to override the tracing level of detail.
                            Allowed values are: <code class="literal">SUMMARY</code>, <code class="literal">TRACE</code>, <code class="literal">VERBOSE</code>.
                        </p></li><li class="listitem"><p>
                            <code class="literal">X-Jersey-Tracing-Logger</code> - used to override the tracing Java logger name suffix.
                        </p></li></ul></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e16819"></a>23.2.4.&nbsp;Format of the HTTP response headers</h3></div></div></div><p>
                At the end of request processing all tracing messages are appended to the HTTP response as individual
                headers named <code class="literal">X-Jersey-Tracing-</code><span class="emphasis"><em><code class="literal">nnn</code></em></span> where
                <span class="emphasis"><em><code class="literal">nnn</code></em></span> is index number of message starting at <code class="literal">0</code>.
            </p><p>
                Each tracing message is in the following format: <code class="literal">CATEGORY [TIME] TEXT</code>, e.g.
                </p><pre class="screen">X-Jersey-Tracing-007: WI          [85.95 / 183.69 ms | 46.77 %] WriteTo summary: 4 interceptors</pre><p>
            </p><p>
                The <code class="literal">CATEGORY</code> is used to categorize tracing events according to the following
                event types:
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <code class="literal">START</code> - start of request processing information
                        </p></li><li class="listitem"><p>
                            <code class="literal">PRE-MATCH</code> - pre-matching request filter processing
                        </p></li><li class="listitem"><p>
                            <code class="literal">MATCH</code> - matching request URI to a resource method
                        </p></li><li class="listitem"><p>
                            <code class="literal">REQ-FILTER</code> - request filter processing
                        </p></li><li class="listitem"><p>
                            <code class="literal">RI</code> - entity reader interceptor processing
                        </p></li><li class="listitem"><p>
                            <code class="literal">MBR</code> - message body reader selection and invocation
                        </p></li><li class="listitem"><p>
                            <code class="literal">INVOKE</code> - resource method invocation
                        </p></li><li class="listitem"><p>
                            <code class="literal">RESP-FILTER</code> - response filter processing
                        </p></li><li class="listitem"><p>
                            <code class="literal">WI</code> - write interceptor processing
                        </p></li><li class="listitem"><p>
                            <code class="literal">MBW</code> - message body writer selection and invocation
                        </p></li><li class="listitem"><p>
                            <code class="literal">MVC</code> - template engine integration
                        </p></li><li class="listitem"><p>
                            <code class="literal">EXCEPTION</code> - exception mapping
                        </p></li><li class="listitem"><p>
                            <code class="literal">FINISHED</code> - processing finish summary
                        </p></li></ul></div><p>
            </p><p>
                The <code class="literal">TIME</code>, if present, is a composite value that consists of 3 parts
                <code class="literal">[ duration / time_from_start | total_req_ratio ]</code>:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                            <code class="literal">duration</code> - the duration of the current trace event [milliseconds];
                            e.g. duration of filter processing
                        </p></li><li class="listitem"><p>
                            <code class="literal">time_from_start</code> - the end time of the current event with respect to
                            the request processing start time [milliseconds]
                        </p></li><li class="listitem"><p>
                            <code class="literal">total_req_ratio</code> - the duration of the current event with respect to
                            the total request processing time [percentage]; this value tells you how significant part
                            of the whole request processing time has been spent in the processing phase described by
                            the current event
                        </p></li></ol></div><p>
                There are certain tracing events that do not have any duration. In such case, duration values are not set
                (<code class="literal">----</code> literal).
            </p><p>
                The tracing event <code class="literal">TEXT</code> is a free-form detailed text information about the
                current diagnostic event.
                </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                        For better identification, instances of JAX-RS components are represented by class name,
                        identity hash code and <code class="literal">@Priority</code> value if set, e.g.
                        <code class="literal">[org.glassfish.jersey.tests.integration.tracing.ContainerResponseFilter5001 @494a8227 #5001]</code>.
                    </p></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e16976"></a>23.2.5.&nbsp;Tracing Examples</h3></div></div></div><p>
                Example of <code class="literal">SUMMARY</code> level messages
                from <code class="literal">tests/integration/tracing-support</code> module:
                </p><div class="example"><a name="d0e16987"></a><p class="title"><b>Example&nbsp;23.5.&nbsp;Summary level messages</b></p><div class="example-contents"><pre class="screen">&nbsp;&nbsp;1 $ curl -i http://localhost:9998/ALL/root/sub-resource-locator/sub-resource-method -H content-type:application/x-jersey-test --data '-=#[LKR]#=-' -H X-Jersey-Tracing-Threshold:SUMMARY -H accept:application/x-jersey-test -X POST
&nbsp;&nbsp;2 
&nbsp;&nbsp;3 X-Jersey-Tracing-000: START       [ ---- /  ---- ms |  ---- %] baseUri=[http://localhost:9998/ALL/] requestUri=[http://localhost:9998/ALL/root/sub-resource-locator/sub-resource-method] method=[POST] authScheme=[n/a] accept=[application/x-jersey-test] accept-encoding=n/a accept-charset=n/a accept-language=n/a content-type=[application/x-jersey-test] content-length=[11]
&nbsp;&nbsp;4 X-Jersey-Tracing-001: PRE-MATCH   [ 0.01 /  0.68 ms |  0.01 %] PreMatchRequest summary: 2 filters
&nbsp;&nbsp;5 X-Jersey-Tracing-002: MATCH       [ 8.44 /  9.15 ms |  4.59 %] RequestMatching summary
&nbsp;&nbsp;6 X-Jersey-Tracing-003: REQ-FILTER  [ 0.01 /  9.20 ms |  0.00 %] Request summary: 2 filters
&nbsp;&nbsp;7 X-Jersey-Tracing-004: RI          [86.14 / 95.49 ms | 46.87 %] ReadFrom summary: 3 interceptors
&nbsp;&nbsp;8 X-Jersey-Tracing-005: INVOKE      [ 0.04 / 95.70 ms |  0.02 %] Resource [org.glassfish.jersey.tests.integration.tracing.SubResource @901a4f3] method=[public org.glassfish.jersey.tests.integration.tracing.Message org.glassfish.jersey.tests.integration.tracing.SubResource.postSub(org.glassfish.jersey.tests.integration.tracing.Message)]
&nbsp;&nbsp;9 X-Jersey-Tracing-006: RESP-FILTER [ 0.01 / 96.55 ms |  0.00 %] Response summary: 2 filters
&nbsp;10 X-Jersey-Tracing-007: WI          [85.95 / 183.69 ms | 46.77 %] WriteTo summary: 4 interceptors
&nbsp;11 X-Jersey-Tracing-008: FINISHED    [ ---- / 183.79 ms |  ---- %] Response status: 200/SUCCESSFUL|OK</pre></div></div><p><br class="example-break">
            </p><p>
                Example <code class="literal">TRACE</code> level messages of <code class="literal">jersey-mvc-jsp</code> integration,
                from <code class="literal">examples/bookstore-webapp</code> module:
                </p><div class="example"><a name="d0e17004"></a><p class="title"><b>Example&nbsp;23.6.&nbsp;On demand request, snippet of MVC JSP forwarding</b></p><div class="example-contents"><pre class="screen">&nbsp;&nbsp;1 $ curl -i http://localhost:9998/items/3/tracks/0 -H X-Jersey-Tracing-Accept:whatever
&nbsp;&nbsp;2 
&nbsp;&nbsp;3 ...
&nbsp;&nbsp;4 X-Jersey-Tracing-033: WI          [ 0.00 / 23.39 ms |  0.02 %] [org.glassfish.jersey.server.mvc.internal.TemplateMethodInterceptor @141bcd49 #4000] BEFORE context.proceed()
&nbsp;&nbsp;5 X-Jersey-Tracing-034: WI          [ 0.01 / 23.42 ms |  0.02 %] [org.glassfish.jersey.filter.LoggingFilter @2d427def #-2147483648] BEFORE context.proceed()
&nbsp;&nbsp;6 X-Jersey-Tracing-035: MBW         [ ---- / 23.45 ms |  ---- %] Find MBW for type=[org.glassfish.jersey.server.mvc.internal.ImplicitViewable] genericType=[org.glassfish.jersey.server.mvc.internal.ImplicitViewable] mediaType=[[jakarta.ws.rs.core.MediaType @7bfbfeae]] annotations=[]
&nbsp;&nbsp;7 X-Jersey-Tracing-036: MBW         [ ---- / 23.52 ms |  ---- %] [org.glassfish.jersey.server.mvc.internal.ViewableMessageBodyWriter @78b353d4] IS writeable
&nbsp;&nbsp;8 X-Jersey-Tracing-037: MVC         [ ---- / 24.05 ms |  ---- %] Forwarding view to JSP page [/org/glassfish/jersey/examples/bookstore/webapp/resource/Track/index.jsp], model [org.glassfish.jersey.examples.bookstore.webapp.resource.Track @3937f594]
&nbsp;&nbsp;9 X-Jersey-Tracing-038: MBW         [ 1.09 / 24.63 ms |  4.39 %] WriteTo by [org.glassfish.jersey.server.mvc.internal.ViewableMessageBodyWriter @78b353d4]
&nbsp;10 X-Jersey-Tracing-039: WI          [ 0.00 / 24.67 ms |  0.01 %] [org.glassfish.jersey.filter.LoggingFilter @2d427def #-2147483648] AFTER context.proceed()
&nbsp;11 X-Jersey-Tracing-040: WI          [ 0.00 / 24.70 ms |  0.01 %] [org.glassfish.jersey.server.mvc.internal.TemplateMethodInterceptor @141bcd49 #4000] AFTER context.proceed()
&nbsp;12 ...</pre></div></div><p><br class="example-break">
            </p></div></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="ioc"></a>Chapter&nbsp;24.&nbsp;Custom Injection and Lifecycle Management</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e17051">24.1. Implementing Custom Injection Provider</a></span></dt><dt><span class="section"><a href="#d0e17152">24.2. Defining Custom Injection Annotation</a></span></dt><dt><span class="section"><a href="#d0e17220">24.3. Custom Life Cycle Management</a></span></dt></dl></div><p>
        Since version 2.0, Jersey uses <a class="link" href="https://github.com/eclipse-ee4j/glassfish-hk2" target="_top">Glassfish-HK2</a> library for component life cycle management and dependency injection.
        Rather than spending a lot of effort in maintaining Jersey specific API (as it used to be before Jersey 2.0 version),
        Jersey defines several extension points where end-user application can directly manipulate Jersey HK2 bindings
        using the HK2 public API to customize life cycle management and dependency injection of application components.
    </p><p>
        Jersey user guide can by no means supply an exhaustive documentation of HK2 API in its entire scope.
        This chapter only points out the most common scenarios related
        to dependency injection in Jersey and suggests possible options to implement these scenarios.
        It is highly recommended to check out the <a class="link" href="https://github.com/eclipse-ee4j/glassfish-hk2" target="_top">Glassfish-HK2</a> website and read HK2 documentation in order to get
        better understanding of suggested approaches. HK2 documentation should also help in resolving use cases
        that are not discussed in this writing.
    </p><p>
        There are typically three main use cases, where your application may consider dealing with
        HK2 APIs exposed in Jersey:

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Implementing a custom injection provider that allows an application to define
                additional types to be injectable into Jersey-managed JAX-RS components.</li><li class="listitem">Defining a custom injection annotation (other than <a class="link" href="https://jakarta.ee/specifications//dependency-injection/2.0/apidocs/jakarta/inject/inject" target="_top">@Inject</a>
                or <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a>) to mark application injection points.</li><li class="listitem">Specifying a custom component life cycle management for your application
                components.</li></ul></div><p>
    </p><p>
        Relying on Servlet HTTP session concept is not very RESTful. It turns the originally state-less HTTP
        communication schema into a state-full manner. However, it could serve
        as a good example that will help me demonstrate implementation of the use cases described above.
        The following examples should work on top of Jersey Servlet integration module. The approach that will be
        demonstrated could be further generalized.
        Below we will show how to make actual Servlet <a class="link" href="https://jakarta.ee/specifications//servlet/5.0/apidocs/jakarta/servlet/http/httpsession" target="_top">HttpSession</a> injectable into JAX-RS components
        and how to make this injection work with a custom inject annotation type. Finally, we will demonstrate
        how you can write <code class="literal">HttpSession</code>-scoped JAX-RS resources.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e17051"></a>24.1.&nbsp;Implementing Custom Injection Provider</h2></div></div></div><p>
            Jersey implementation allows you to directly inject <a class="link" href="https://jakarta.ee/specifications//servlet/5.0/apidocs/jakarta/servlet/http/httpservletrequest" target="_top">HttpServletRequest</a> instance into
            your JAX-RS components.
            It is quite straight forward to get the appropriate <code class="literal">HttpSession</code> instance out of the
            injected request instance.
            Let say, you want to get <code class="literal">HttpSession</code> instance directly injected into your JAX-RS
            types like in the code snippet below.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("di-resource")
public class MyDiResource {

    @Inject HttpSession httpSession;

    ...

}</pre><p>

            To make the above injection work, you will need to define an additional HK2 binding in your
            application <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a>.
            Let's start with a custom HK2 <a class="link" href="https://javaee.github.io/hk2/apidocs//org/glassfish/hk2/api/Factory.html" target="_top">Factory</a> implementation that knows how to extract
            <code class="literal">HttpSession</code> out of given <code class="literal">HttpServletRequest</code>.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import org.glassfish.hk2.api.Factory;
    ...

    public class HttpSessionFactory implements Factory&lt;HttpSession&gt; {

    private final HttpServletRequest request;

    @Inject
    public HttpSessionFactory(HttpServletRequest request) {
        this.request = request;
    }

    @Override
    public HttpSession provide() {
       return request.getSession();
    }

    @Override
    public void dispose(HttpSession t) {
    }
}</pre><p>

            Please note that the factory implementation itself relies on having the actual
            <code class="literal">HttpServletRequest</code> instance injected.
            In your implementation, you can of course depend on other types (and inject them conveniently)
            as long as these other types are bound to the actual HK2 service locator by Jersey or by your
            application. The key notion to remember here is that your HK2 <code class="literal">Factory</code> implementation
            is responsible for implementing the <code class="literal">provide()</code> method that is used by HK2
            runtime to retrieve the injected instance. Those of you who worked with Guice binding API in the
            past will most likely find this concept very familiar.
        </p><p>
            Once implemented, the factory can be used in a custom HK2 <code class="literal">Binder</code> to define the
            new injection binding for <code class="literal">HttpSession</code>. Finally, the implemented binder
            can be registered in your <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a>:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import org.glassfish.hk2.utilities.binding.AbstractBinder;
...

public class MyApplication extends ResourceConfig {

    public MyApplication() {

        ...

        register(new AbstractBinder() {
            @Override
            protected void configure() {
                bindFactory(HttpSessionFactory.class).to(HttpSession.class)
                .proxy(true).proxyForSameScope(false).in(RequestScoped.class);
            }
        });
    }
}</pre><p>

            Note that we did not define any explicit injection scope for the new injection binding.
            By default, HK2 factories are bound in a HK2 <a class="link" href="https://javaee.github.io/hk2/apidocs//org/glassfish/hk2/api/PerLookup.html" target="_top">PerLookup</a> scope, which is in most
            cases a good choice and it is suitable also in our example.
        </p><p>
            To summarize the approach described above, here is a list of steps to follow
            when implementing custom injection provider in your Jersey application :

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Implement your own HK2 <code class="literal">Factory</code> to provide the
                    injectable instances.</li><li class="listitem">Use the HK2 <code class="literal">Factory</code> to define an injection
                    binding for the injected instance via custom HK2 <code class="literal">Binder</code>.</li><li class="listitem">Register the custom HK2 <code class="literal">Binder</code> in your application
                    <code class="literal">ResourceConfig</code>.</li></ul></div><p>
        </p><p>
            While the <code class="literal">Factory</code>-based approach is quite straight-forward and should help you to
            quickly prototype or even implement final solutions, you should bear in mind, that your
            implementation does not need to be based on factories. You can for instance bind your own
            types directly, while still taking advantage of HK2 provided dependency injection.
            Also, in your implementation you may want to pay more attention to defining or managing
            injection binding scopes for the sake of performance or correctness of your custom injection
            extension.

            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    While the individual injection binding implementations vary and depend on your use case,
                    to enable your custom injection extension in Jersey, you must register your custom HK2 <a class="link" href="https://javaee.github.io/hk2/apidocs//org/glassfish/hk2/utilities/Binder.html" target="_top">Binder</a>
                    implementation in your application <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a>!
                </p></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e17152"></a>24.2.&nbsp;Defining Custom Injection Annotation</h2></div></div></div><p>
            Java annotations are a convenient way for attaching metadata to various elements of Java code.
            Sometimes you may even decide to combine the metadata with additional functionality, such as
            ability to automatically inject the instances based on the annotation-provided metadata.
            The described scenario is one of the use cases where having means of defining a custom injection
            annotation in your Jersey application may prove to be useful. Obviously, this use case applies also
            to re-used existing, 3rd-party annotation types.
        </p><p>
            In the following example, we will describe how a custom injection annotation can be supported.
            Let's start with defining a new custom <code class="literal">SessionInject</code> injection annotation
            that we will specifically use to inject instances of <a class="link" href="https://jakarta.ee/specifications//servlet/5.0/apidocs/jakarta/servlet/http/httpsession" target="_top">HttpSession</a>
            (similarly to the previous example):

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface SessionInject { }</pre><p>

            The above <code class="literal">@SessionInject</code> annotation should be then used as follows:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("di-resource")
public class MyDiResource {

    @SessionInject HttpSession httpSession;

    ...

}</pre><p>

            Again, the semantics remains the same as in the example described in the previous section.
            You want to have the actual HTTP Servlet session instance injected into your
            <code class="literal">MyDiResource</code> instance. This time however, you expect that the
            <code class="literal">httpSession</code> field to be injected must be annotated with
            a custom <code class="literal">@SessionInject</code> annotation. Obviously, in this simplistic case
            the use of a custom injection annotation is an overkill, however, the simplicity of the
            use case will help us to avoid use case specific distractions and allow us better focus on
            the important aspects of the job of defining a custom injection annotation.
        </p><p>
            If you remember from the previous section, to make the injection in the code snippet above work,
            you first need to implement the injection provider (HK2 <a class="link" href="https://javaee.github.io/hk2/apidocs//org/glassfish/hk2/api/Factory.html" target="_top">Factory</a>) as well as define the
            injection binding for the <code class="literal">HttpSession</code> type. That part we have already
            done in the previous section.
            We will now focus on what needs to be done to inform the HK2 runtime about our <code class="literal">@SessionInject</code>
            annotation type that we want to support as a new injection point marker annotation. To do that,
            we need to implement our own HK2 <a class="link" href="https://javaee.github.io/hk2/apidocs//org/glassfish/hk2/api/InjectionResolver.html" target="_top">InjectionResolver</a> for the annotation as demonstrated
            in the following listing:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import jakarta.inject.Inject;
import jakarta.inject.Named;

import javax.servlet.http.HttpSession;

import org.glassfish.hk2.api.InjectionResolver;
import org.glassfish.hk2.api.ServiceHandle;

...

public class SessionInjectResolver implements InjectionResolver&lt;SessionInject&gt; {

    @Inject
    @Named(InjectionResolver.SYSTEM_RESOLVER_NAME)
    InjectionResolver&lt;Inject&gt; systemInjectionResolver;

    @Override
    public Object resolve(Injectee injectee, ServiceHandle&lt;?&gt; handle) {
        if (HttpSession.class == injectee.getRequiredType()) {
            return systemInjectionResolver.resolve(injectee, handle);
        }

        return null;
    }

    @Override
    public boolean isConstructorParameterIndicator() {
        return false;
    }

    @Override
    public boolean isMethodParameterIndicator() {
        return false;
    }
}</pre><p>

            The <code class="literal">SessionInjectResolver</code> above just delegates to the default
            HK2 system injection resolver to do the actual work.
        </p><p>
            You again need to register your injection resolver with your Jersey application,
            and you can do it the same was as in the previous case. Following listing includes
            HK2 binder that registers both, the injection provider from the previous step
            as well as the new HK2 inject resolver with Jersey application <code class="literal">ResourceConfig</code>.
            Note that in this case we're explicitly binding the <code class="literal">SessionInjectResolver</code>
            to a <a class="link" href="https://jakarta.ee/specifications//dependency-injection/2.0/apidocs/jakarta/inject/singleton" target="_top">@Singleton</a> scope to avoid the unnecessary proliferation of
            <code class="literal">SessionInjectResolver</code> instances in the application:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import org.glassfish.hk2.api.TypeLiteral;
import org.glassfish.hk2.utilities.binding.AbstractBinder;

import jakarta.inject.Singleton;

...

public class MyApplication extends ResourceConfig {

    public MyApplication() {

        ...

        register(new AbstractBinder() {
            @Override
            protected void configure() {
                bindFactory(HttpSessionFactory.class).to(HttpSession.class);

                bind(SessionInjectResolver.class)
                    .to(new TypeLiteral&lt;InjectionResolver&lt;SessionInject&gt;&gt;(){})
                    .in(Singleton.class);
            }
        });
    }
}</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e17220"></a>24.3.&nbsp;Custom Life Cycle Management</h2></div></div></div><p>
            The last use case discussed in this chapter will cover managing custom-scoped components
            within a Jersey application.
            If not configured otherwise, then all JAX-RS resources are by default managed on a per-request basis. A new instance
            of given resource class will be created for each incoming request that should be handled by that resource class.
            Let say you want to have your resource class managed in a per-session manner. It means a new instance of your
            resource class should be created only when a new Servlet <a class="link" href="https://jakarta.ee/specifications//servlet/5.0/apidocs/jakarta/servlet/http/httpsession" target="_top">HttpSession</a> is established.
            (As with previous examples in the chapter, this example assumes the deployment of your application
            to a Servlet container.)
        </p><p>
            Following is an example of such a resource class that builds on the support for
            <code class="literal">HttpSession</code> injection from the earlier examples described in this chapter.
            The <code class="literal">PerSessionResource</code> class allows you to count the number of requests made within
            a single client session and provides you a handy sub-resource method to obtain the number via
            a HTTP <code class="literal">GET</code> method call:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("session")
public class PerSessionResource {

    @SessionInject HttpSession httpSession;

    AtomicInteger counter = new AtomicInteger();

    @GET
    @Path("id")
    public String getSession() {
        counter.incrementAndGet();
        return httpSession.getId();
    }

    @GET
    @Path("count")
    public int getSessionRequestCount() {
        return counter.incrementAndGet();
    }
}</pre><p>

            Should the above resource be per-request scoped (default option), you would never be able to obtain
            any other number but 1 from it's getReqs sub-resource method, because then for each request
            a new instance of our <code class="literal">PerSessionResource</code> class would get created with a fresh
            instance <code class="literal">counter</code> field set to 0.
            The value of this field would get incremented to 1 in the the <code class="literal">getSessionRequestCount</code>
            method before this value is returned.
            In order to achieve what we want, we have to find a way how to bind the instances of
            our <code class="literal">PerSessionResource</code> class to <code class="literal">HttpSession</code> instances and
            then reuse those bound instances whenever new request bound to the same HTTP client session arrives.
            Let's see how to achieve this.
        </p><p>
            To get better control over your Jersey component instantiation and life cycle,
            you need to implement a custom Jersey <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/spi/ComponentProvider.html" target="_top">ComponentProvider</a> SPI,
            that would manage your custom components.
            Although it might seem quite complex to implement such a thing,
            the component provider concept in Jersey is in fact very simple. It allows you to define
            your own HK2 injection bindings for the types that you are interested in,
            while informing the Jersey runtime at the same time that it should back out and leave
            the component management to your provider in such a case.
            By default, if there is no custom component provider found for any given component type, Jersey
            runtime assumes the role of the default component provider and automatically defines the default
            HK2 binding for the component type.
        </p><p>
            Following example shows a simple <code class="literal">ComponentProvider</code> implementation,
            for our use case. Some comments on the code follow.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import jakarta.inject.Inject;
import jakarta.inject.Provider;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
...
import org.glassfish.hk2.api.DynamicConfiguration;
import org.glassfish.hk2.api.DynamicConfigurationService;
import org.glassfish.hk2.api.Factory;
import org.glassfish.hk2.api.PerLookup;
import org.glassfish.hk2.api.ServiceLocator;
import org.glassfish.hk2.utilities.binding.BindingBuilderFactory;
import org.glassfish.jersey.server.spi.ComponentProvider;

@jakarta.ws.rs.ext.Provider
public class PerSessionComponentProvider implements ComponentProvider {

    private ServiceLocator locator;

    static class PerSessionFactory implements Factory&lt;PerSessionResource&gt;{
        static ConcurrentHashMap&lt;String, PerSessionResource&gt; perSessionMap
                = new ConcurrentHashMap&lt;String, PerSessionResource&gt;();


        private final Provider&lt;HttpServletRequest&gt; requestProvider;
        private final ServiceLocator locator;

        @Inject
        public PerSessionFactory(
                Provider&lt;HttpServletRequest&gt; request,
                ServiceLocator locator) {

            this.requestProvider = request;
            this.locator = locator;
        }

        @Override
        @PerLookup
        public PerSessionResource provide() {
            final HttpSession session = requestProvider.get().getSession();

            if (session.isNew()) {
                PerSessionResource newInstance = createNewPerSessionResource();
                perSessionMap.put(session.getId(), newInstance);

                return newInstance;
            } else {
                return perSessionMap.get(session.getId());
            }
        }

        @Override
        public void dispose(PerSessionResource r) {
        }

        private PerSessionResource createNewPerSessionResource() {
            final PerSessionResource perSessionResource = new PerSessionResource();
            locator.inject(perSessionResource);
            return perSessionResource;
        }
    }

    @Override
    public void initialize(ServiceLocator locator) {
        this.locator = locator;
    }

    @Override
    public boolean bind(Class&lt;?&gt; component, Set&lt;Class&lt;?&gt;&gt; providerContracts) {
        if (component == PerSessionResource.class) {

            final DynamicConfigurationService dynamicConfigService =
                locator.getService(DynamicConfigurationService.class);
            final DynamicConfiguration dynamicConfiguration =
                dynamicConfigService.createDynamicConfiguration();

            BindingBuilderFactory
                .addBinding(BindingBuilderFactory.newFactoryBinder(PerSessionFactory.class)
                .to(PerSessionResource.class), dynamicConfiguration);

            dynamicConfiguration.commit();

            return true;
        }
        return false;
    }

    @Override
    public void done() {
    }
}</pre><p>
        </p><p>
            The first and very important aspect of writing your own <code class="literal">ComponentProvider</code>
            in Jersey is to store the actual HK2 <a class="link" href="https://javaee.github.io/hk2/apidocs//org/glassfish/hk2/api/ServiceLocator.html" target="_top">ServiceLocator</a> instance that will be passed to you as
            the only argument of the provider <code class="literal">initialize</code> method.
            Your component provider instance will not get injected at all so this is more or less your only chance
            to get access to the HK2 runtime of your application. Please bear in mind, that at the time when
            your component provider methods get invoked, the <code class="literal">ServiceLocator</code> is not fully configured yet.
            This limitation applies to all component provider methods, as the main goal of any component provider
            is to take part in configuring the application's <code class="literal">ServiceLocator</code>.
        </p><p>
            Now let's examine the <code class="literal">bind</code> method, which is where your provider tells the HK2
            how to bind your component.
            Jersey will invoke this method multiple times, once for each type that is registered with the
            actual application.
            Every time the <code class="literal">bind</code> method is invoked, your component provider needs to decide
            if it is taking control over the component or not. In our case we know exactly which Java type
            we are interested in (<code class="literal">PerSessionResource</code> class),
            so the logic in our <code class="literal">bind</code> method is quite straightforward. If we see our
            <code class="literal">PerSessionResource</code> class it is our turn to provide our custom binding for the class,
            otherwise we just return false to make Jersey poll other providers and, if no provider kicks in,
            eventually provide the default HK2 binding for the component.
            Please, refer to the <a class="link" href="https://github.com/eclipse-ee4j/glassfish-hk2" target="_top">Glassfish-HK2</a> documentation for the details of the concrete HK2 APIs used in
            the <code class="literal">bind</code> method implementation above. The main idea behind the code is that
            we register a new HK2 <a class="link" href="https://javaee.github.io/hk2/apidocs//org/glassfish/hk2/api/Factory.html" target="_top">Factory</a> (<code class="literal">PerSessionFactory</code>), to provide
            the <code class="literal">PerSessionResource</code> instances to HK2.
        </p><p>
            The implementation of the <code class="literal">PerSessionFactory</code> is also included above.
            Please note that as opposed to a component provider implementation that should never itself rely
            on an injection support, the factory bound by our component provider would get injected just fine,
            since it is only instantiated later, once the Jersey runtime for the application is fully
            initialized including the fully configured HK2 runtime.
            Whenever a new session is seen, the factory instantiates and injects
            a new PerSessionResource instance. The instance is then stored in the perSessionMap for later use
            (for future calls).
        </p><p>
            In a real life scenario, you would want to pay more attention to possible synchronization issues.
            Also, we do not consider a mechanism that would clean-up any obsolete resources for closed, expired or
            otherwise invalidated HTTP client sessions.
            We have omitted those considerations here for the sake of brevity of our example.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="cdi.support"></a>Chapter&nbsp;25.&nbsp;Jersey CDI Container Agnostic Support</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#cdi.support.intro">25.1. Introduction</a></span></dt><dt><span class="section"><a href="#cdi.support.existing.containers">25.2. Containers Known to Work With Jersey CDI Support</a></span></dt><dt><span class="section"><a href="#cdi.support.request.scope.binding">25.3. Request Scope Binding</a></span></dt><dt><span class="section"><a href="#cdi.support.weld.se">25.4. Jersey Weld SE Support</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cdi.support.intro"></a>25.1.&nbsp;Introduction</h2></div></div></div><p>
          At the time of this writing, Java SE support is being discussed as one of important additions to CDI 3.0 specification.
          Existing CDI implementations brought this feature already, only container bootstrapping has not yet been standardized.
          In Jersey version 2.15 we introduced Weld SE support, so that people could take advantage of CDI features 
          also when running in Java SE environment. As part of this work, the old Jersey CDI module has been refactored
          so that it supports CDI integration in any CDI-enabled HTTP container.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                This chapter is mainly focused on server-side Jersey Weld SE support.
                We will mention other containers that are known to be working with Jersey CDI integration modules.
                We will also describe features demonstrated in Jersey HelloWorld Weld example
                and provide some hints on how to enable Java SE support for other (non Weld) CDI implementations.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cdi.support.existing.containers"></a>25.2.&nbsp;Containers Known to Work With Jersey CDI Support</h2></div></div></div><p>
          To stick with JAX-RS specification, Jersey has to support JAX-RS/CDI integration in Java/Jakarta EE environment.
          The two containers supporting JAX-RS/CDI integration out of the box are Oracle GlassFish and Oracle WebLogic application server.
        </p><p>
          Apache Tomcat is another Servlet container that is known to work fine with Jersey CDI support.
          However, things do not work there out of the box. You need to enable CDI support in Tomcat e.g. using Weld.
          Jersey <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/cdi-webapp" target="_top">CDI example</a> shows how a WAR application could be packaged
          (see <code class="literal">tomcat-packaging</code> profile in the pom file) in order to enable JAX-RS/CDI integration
          in Tomcat with Jersey using Weld.
        </p><p>
          If not bundled already with underlying Servlet container, the following Jersey module needs to be packaged with the application
          or otherwise included in the container class-path:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-cdi1x&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;
            </pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cdi.support.request.scope.binding"></a>25.3.&nbsp;Request Scope Binding</h2></div></div></div><p>
        There is a common pattern for all above mentioned containers. Jersey CDI integration builds upon existing CDI/Servlet integration there.
        In other words, in all above cases, Jersey application must be deployed as a Servlet, where the underlying Servlet container
        has CDI integrated already and CDI container bootstrapped properly.
      </p><p>
        The key feature in CDI/Servlet integration is proper request scope binding. If this feature was missing,
        you would not be able to use any request scoped CDI beans in your Jersey application. To make Jersey work with CDI
        in containers that do not have request scope binding resolved, some extra work is required.
      </p><p>
        To allow smooth integration with Jersey request scope a new SPI, <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/spi/ExternalRequestScope.html" target="_top">ExternalRequestScope</a>, was introduced in Jersey version 2.15.
        An SPI implementation should be registered via the standard <code class="literal">META-INF/services</code> mechanism
        and needs to make sure CDI implentation request scope has been properly managed and request scoped data kept in the right context. 
        For performance reasons, at most a single external request scope provider is allowed by Jersey runtime.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cdi.support.weld.se"></a>25.4.&nbsp;Jersey Weld SE Support</h2></div></div></div><p>
            The extra work to align HTTP request with CDI request scope was already done by Jersey team for Weld 4.x implementation.
            In order to utilize Jersey/Weld request scope binding, you need to use the following module:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext.cdi&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-weld2-se&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;
            </pre><p>
            Then you could use your CDI backed JAX-RS components in a Jersey application running in Grizzly HTTP container
            bootstrapped as follows:
            </p><div class="example"><a name="d0e17379"></a><p class="title"><b>Example&nbsp;25.1.&nbsp;Bootstrapping Jersey application with Weld support on Grizzly</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">            Weld weld = new Weld();
            weld.initialize();

            final HttpServer server = GrizzlyHttpServerFactory.createHttpServer(URI.create("http://localhost:8080/weld/"), jerseyResourceConfig);

            // ...

            server.shutdownNow();
            weld.shutdown();</pre></div></div><p><br class="example-break">
        </p><p>
          The above pattern could be applied also for other Jersey supported HTTP containers as long as you stick with CDI Weld 4.x implementation.
          You simply add the above mentioned <code class="literal">jersey-weld2-se</code> module into you class-path and bootstrap the Weld container manually
          before starting the HTTP container.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="test-framework"></a>Chapter&nbsp;26.&nbsp;Jersey Test Framework</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d0e17414">26.1. Basics</a></span></dt><dt><span class="section"><a href="#d0e17451">26.2. Supported Containers</a></span></dt><dt><span class="section"><a href="#testng">26.3. Running TestNG Tests</a></span></dt><dt><span class="section"><a href="#d0e17644">26.4. Advanced features</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e17647">26.4.1. <code class="literal">JerseyTest</code> Features</a></span></dt><dt><span class="section"><a href="#d0e17671">26.4.2. External container</a></span></dt><dt><span class="section"><a href="#d0e17682">26.4.3. Test Client configuration</a></span></dt><dt><span class="section"><a href="#d0e17696">26.4.4. Accessing the logged test records programmatically</a></span></dt></dl></dd><dt><span class="section"><a href="#parallel">26.5. Parallel Testing with Jersey Test Framework</a></span></dt></dl></div><p>
        Jersey Test Framework originated as an internal tool used for verifying the correct implementation of
        server-side components. Testing RESTful applications became a more pressing issue with "modern" approaches like
        test-driven development and users started to look for a tool that could help with designing and running
        the tests as fast as possible but with many options related to test execution environment.
    </p><p>
        Current implementation of Jersey Test Framework supports the following set of features:

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>pre-configured client to access deployed application</p></li><li class="listitem"><p>support for multiple containers - grizzly, in-memory, jdk, simple, jetty</p></li><li class="listitem"><p>able to run against any external container</p></li><li class="listitem"><p>automated configurable traffic logging</p></li></ul></div><p>

        Jersey Test Framework is primarily based on JUnit but you can run tests using TestNG as well. It works almost out-of-the
        box and it is easy to integrate it within your Maven-based project. While it is usable on all environments where you can
        run JUnit, we support primarily the Maven-based setups.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e17414"></a>26.1.&nbsp;Basics</h2></div></div></div><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class SimpleTest extends JerseyTest {

    @Path("hello")
    public static class HelloResource {
        @GET
        public String getHello() {
            return "Hello World!";
        }
    }

    @Override
    protected Application configure() {
        return new ResourceConfig(HelloResource.class);
    }

    @Test
    public void test() {
        final String hello = target("hello").request().get(String.class);
        assertEquals("Hello World!", hello);
    }
}</pre><p>
            If you want to develop a test using Jersey Test Framework, you need to subclass <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html" target="_top">JerseyTest</a> and
            configure the set of resources and/or providers that will be deployed as part of the test application. This short
            code snippet shows basic resource class <code class="literal">HelloResource</code> used in tests defined as part of the
            <code class="literal">SimpleTest</code> class. The overridden <code class="literal">configure</code> method returns
            a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> of the test application,that contains only the <code class="literal">HelloResource</code>
            resource class. <code class="literal">ResourceConfig</code> is a sub-class of JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a>. It is a Jersey
            convenience class for configuring JAX-RS applications. <code class="literal">ResourceConfig</code> also implements JAX-RS
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> interface to make the application configuration more flexible.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e17451"></a>26.2.&nbsp;Supported Containers</h2></div></div></div><p>
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html" target="_top">JerseyTest</a> supports deploying applications on various containers, all (except the external container
            wrapper) need to have some "glue" code to be supported. Currently Jersey Test Framework provides support for
            Grizzly, In-Memory, JDK (<code class="literal">com.sun.net.httpserver.HttpServer</code>), Simple HTTP container
            (<code class="literal">org.simpleframework.http</code>) and Jetty HTTP container (<code class="literal">org.eclipse.jetty</code>)
            - since Jersey 3.x HTTP Jetty container requires JDK 11+.
        </p><p>
            A test container is selected based on various inputs.
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html#getTestContainerFactory()" target="_top">JerseyTest#getTestContainerFactory()</a>
            is always executed, so if you override it and provide your own version of
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/spi/TestContainerFactory.html" target="_top">TestContainerFactory</a>, nothing else will be considered.
            Setting a system variable
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/TestProperties.html#CONTAINER_FACTORY" target="_top">TestProperties#CONTAINER_FACTORY</a>
            has similar effect. This way you may defer the decision on which containers you want to run your tests
            from the compile time to the test execution time.
            Default implementation of <code class="literal">TestContainerFactory</code> looks for container factories on classpath.
            If more than one instance is found and there is a Grizzly test container factory among them, it will be used; if not,
            a warning will be logged and the first found factory will be instantiated.
        </p><p>
            Following is a brief description of all container factories supported in Jersey Test Framework.
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Jersey provides 2 different test container factories based on Grizzly.
                        The <code class="literal">GrizzlyTestContainerFactory</code> creates a container that can run as a light-weight,
                        plain HTTP container. Almost all Jersey tests are using Grizzly HTTP test container factory.
                        Second factory is <code class="literal">GrizzlyWebTestContainerFactory</code> that is Servlet-based and supports
                        Servlet deployment context for tested applications. This factory can be useful when testing more complex
                        Servlet-based application deployments.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-grizzly2&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    </p></li><li class="listitem"><p>
                        In-Memory container is not a real container. It starts Jersey application and directly calls internal
                        APIs to handle request created by client provided by test framework. There is no network communication
                        involved. This containers does not support servlet and other container dependent features, but it is
                        a perfect choice for simple unit tests.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-inmemory&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    </p></li><li class="listitem"><p>
                        <code class="literal">HttpServer</code> from JDK is another supported test container.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-jdk-http&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    </p></li><li class="listitem"><p>
                        Simple container (<code class="literal">org.simpleframework.http</code>) is another light-weight HTTP container
                        that integrates with Jersey and is supported by Jersey Test Framework.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-simple&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    </p></li><li class="listitem"><p>
                        Jetty container (<code class="literal">org.eclipse.jetty</code>) is another high-performance, light-weight HTTP server
                        that integrates with Jersey and is supported by Jersey Test Framework. Shall be used along with JDK 11+.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-jetty&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    </p></li></ul></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testng"></a>26.3.&nbsp;Running TestNG Tests</h2></div></div></div><p>
            It is possible to run not only JUnit tests but also tests based on TestNG. In order to do this you need to make sure
            the following 2 steps are fulfilled:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        Extend <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTestNg.html" target="_top">JerseyTestNg</a>, or one of its inner classes <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTestNg.ContainerPerClassTest.html" target="_top">JerseyTestNg.ContainerPerClassTest</a>
                        / <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTestNg.ContainerPerMethodTest.html" target="_top">JerseyTestNg.ContainerPerMethodTest</a>, instead of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html" target="_top">JerseyTest</a>.
                    </p></li><li class="listitem"><p>
                        Add TestNG to your class-patch, i.e.:

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-core&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.testng&lt;/groupId&gt;
    &lt;artifactId&gt;testng&lt;/artifactId&gt;
    &lt;version&gt;...&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    </p></li></ul></div><p>
        </p><p>
            To discuss the former requirement in more depth we need to take a look at the differences between JUnit and TestNG.
            JUnit creates a new instance of a test class for every test present in that class which, from the point of view of
            Jersey Test Framework, means that new test container and client is created for each test of a test class. However,
            TestNG creates only one instance of a test class and the initialization of the test container depends more on
            setup/teardown methods (driven by <code class="literal">@BeforeXXX</code> and <code class="literal">@AfterXXX</code> annotations) than in
            JUnit. This means that, basically, you can start one instance of test container for all tests present in a test class
            or separate test container for each and every test. For this reason a separate subclasses of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTestNg.html" target="_top">JerseyTestNg</a>
            have been created:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTestNg.ContainerPerClassTest.html" target="_top">JerseyTestNg.ContainerPerClassTest</a> creates one container to run all the tests in. Setup method
                        is annotated with <code class="literal">@BeforeClass</code>, teardown method with <code class="literal">@AfterClass</code>.
                    </p><p>
                        For example take a look at <code class="literal">ContainerPerClassTest</code> test. It contains two test
                        methods (<code class="literal">first</code> and <code class="literal">second</code>), one singleton resource that returns an
                        increasing sequence of number. Since we spawn only one instance of a test container for the whole class the
                        value expected in the first test is <code class="literal">1</code> and in the second it's <code class="literal">2</code>.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class ContainerPerClassTest extends JerseyTestNg.ContainerPerClassTest {

    @Path("/")
    @Singleton
    @Produces("text/plain")
    public static class Resource {

        private int i = 1;

        @GET
        public int get() {
            return i++;
        }
    }

    @Override
    protected Application configure() {
        return new ResourceConfig(Resource.class);
    }

    @Test(priority = 1)
    public void first() throws Exception {
        test(1);
    }

    @Test(priority = 2)
    public void second() throws Exception {
        test(2);
    }

    private void test(final Integer expected) {
        final Response response = target().request().get();

        assertEquals(response.getStatus(), 200);
        assertEquals(response.readEntity(Integer.class), expected);
    }
}</pre><p>
                    </p></li><li class="listitem"><p>
                        <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTestNg.ContainerPerMethodTest.html" target="_top">JerseyTestNg.ContainerPerMethodTest</a> creates separate container for each test. Setup method
                        is annotated with <code class="literal">@BeforeMethod</code>, teardown method with <code class="literal">@AfterMethod</code>.
                    </p><p>
                        We can create a similar test to the previous one. Take a look at <code class="literal">ContainerPerMethodTest</code>
                        test. It looks the same except the expected values and extending class: it contains two test
                        methods (<code class="literal">first</code> and <code class="literal">second</code>), one singleton resource that returns an
                        increasing sequence of number. In this case we create a separate test container for each test so
                        value expected in the first test is <code class="literal">1</code> and in the second it's also <code class="literal">1</code>.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class ContainerPerMethodTest extends JerseyTestNg.ContainerPerMethodTest {

    @Path("/")
    @Singleton
    @Produces("text/plain")
    public static class Resource {

        private int i = 1;

        @GET
        public int get() {
            return i++;
        }
    }

    @Override
    protected Application configure() {
        return new ResourceConfig(Resource.class);
    }

    @Test
    public void first() throws Exception {
        test(1);
    }

    @Test
    public void second() throws Exception {
        test(1);
    }

    private void test(final Integer expected) {
        final Response response = target().request().get();

        assertEquals(response.getStatus(), 200);
        assertEquals(response.readEntity(Integer.class), expected);
    }
}</pre><p>
                    </p></li></ul></div><p>
        </p><p>
            If you need more complex setup of your test you can achieve this by directly extending the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTestNg.html" target="_top">JerseyTestNg</a>
            class create setup/teardown methods suited to your needs and provide a strategy for storing and handling a test
            container / client instance (see <code class="literal">JerseyTestNg.configureStrategy(TestNgStrategy)</code> method).
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e17644"></a>26.4.&nbsp;Advanced features</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e17647"></a>26.4.1.&nbsp;<code class="literal">JerseyTest</code> Features</h3></div></div></div><p><code class="literal">JerseyTest</code> provide
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html#enable(java.lang.String)" target="_top">enable(...)</a>,
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html#forceEnable(java.lang.String)" target="_top">forceEnable(...)</a>
                and <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html#disable(java.lang.String)" target="_top">disable(...)</a>
                methods, that give you control over configuring values of the properties defined and described in the
                <code class="literal">TestProperties</code> class. A typical code that overrides the default property values is listed
                below:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class SimpleTest extends JerseyTest {
    // ...

    @Override
    protected Application configure() {
        enable(TestProperties.LOG_TRAFFIC);
        enable(TestProperties.DUMP_ENTITY);

        // ...

    }
}</pre><p>

                The code in the example above enables test traffic logging (inbound and outbound headers) as well as
                dumping the HTTP message entity as part of the traffic logging.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e17671"></a>26.4.2.&nbsp;External container</h3></div></div></div><p>
                Complicated test scenarios may require fully started containers with complex setup configuration, that is not
                easily doable with current Jersey container support. To address these use cases, Jersey Test Framework providers
                general fallback mechanism - an External Test Container Factory. Support of this external container "wrapper" is
                provided as the following module:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-external&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                As indicated, the "container" exposed by this module is just a wrapper or stub, that redirects all request to
                a configured host and port. Writing tests for this container is similar to any other but you have to provide
                the information about host and port during the test execution:

                </p><pre class="screen">mvn test -Djersey.test.host=myhost.org -Djersey.config.test.container.port=8080</pre><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e17682"></a>26.4.3.&nbsp;Test Client configuration</h3></div></div></div><p>
                Tests might require some advanced client configuration. This is possible by overriding
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html#configureClient(org.glassfish.jersey.client.ClientConfig)" target="_top">configureClient(ClientConfig clientConfig)</a>
                method. Typical use case for this is registering more providers, such as <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>s or
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>s, or enabling additional features.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e17696"></a>26.4.4.&nbsp;Accessing the logged test records programmatically</h3></div></div></div><p>
                Sometimes you might need to check a logged message as part of your test assertions. For this purpose Jersey Test
                Framework provides convenient access to the logged records via
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html#getLastLoggedRecord()" target="_top">JerseyTest#getLastLoggedRecord()</a>
                and
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/JerseyTest.html#getLoggedRecords()" target="_top">JerseyTest#getLoggedRecords()</a>
                methods. Note that this feature is not enabled by default, see
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/TestProperties.html#RECORD_LOG_LEVEL" target="_top">TestProperties#RECORD_LOG_LEVEL</a>
                for more information.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="parallel"></a>26.5.&nbsp;Parallel Testing with Jersey Test Framework</h2></div></div></div><p>
            For a purpose of running multiple test containers in parallel you need to set the
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/test/TestProperties.CONTAINER_PORT.html" target="_top">TestProperties.CONTAINER_PORT</a>
            to <code class="literal">0</code> value. This will tell Jersey Test Framework (and the underlying test container) to use the
            first available port.
        </p><p>
            You can set the value as a system property (via command line option) or directly in the test (to not affect ports of
            other tests):

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Override
    protected Application configure() {
        // Find first available port.
        forceSet(TestProperties.CONTAINER_PORT, "0");

        return new ResourceConfig(Resource.class);
    }</pre><p>
        </p><p>
            The easiest way to setup your JUnit or TestNG tests to run in parallel is to configure Maven Surefire plugin. You can
            do this via configuration options <code class="literal">parallel</code> and <code class="literal">threadCount</code>, i.e.:

                            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">...
&lt;configuration&gt;
    &lt;parallel&gt;methods&lt;/parallel&gt;
    &lt;threadCount&gt;5&lt;/threadCount&gt;
    ...
&lt;/configuration&gt;
...</pre><p>

            For more information about this topic consult the following Maven Surefire articles:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="http://maven.apache.org/surefire/maven-surefire-plugin/examples/fork-options-and-parallel-execution.html" target="_top">Fork Options and Parallel Test Execution</a></p></li><li class="listitem"><p><a class="link" href="http://maven.apache.org/surefire/maven-surefire-plugin/examples/testng.html#Running_tests_in_parallel" target="_top">Using TestNG - Running tests in parallel</a></p></li><li class="listitem"><p><a class="link" href="http://maven.apache.org/surefire/maven-surefire-plugin/examples/junit.html#Running_tests_in_parallel" target="_top">Using JUnit - Running tests in parallel</a></p></li></ul></div><p>
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="how-to-build"></a>Chapter&nbsp;27.&nbsp;Building and Testing Jersey</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#checkout">27.1. Checking Out the Source</a></span></dt><dt><span class="section"><a href="#building">27.2. Building the Source</a></span></dt><dt><span class="section"><a href="#testing">27.3. Testing</a></span></dt><dt><span class="section"><a href="#netbeans-build">27.4. Using NetBeans</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="checkout"></a>27.1.&nbsp;Checking Out the Source</h2></div></div></div><p>
            Jersey source code is available on GitHub. You can browse the sources at
            <a class="link" href="https://github.com/eclipse-ee4j/jersey" target="_top">https://github.com/eclipse-ee4j/jersey</a>.
        </p><p>
            In case you are not familiar with Git, we recommend reading some of the many "Getting Started with Git" articles
            you can find on the web. For example this
            <a class="link" href="http://refcardz.dzone.com/refcardz/getting-started-git" target="_top">DZone RefCard</a>.
        </p><p>
            To clone the Jersey repository you can execute the following command on the command-line
            (provided you have a command-line Git client installed on your machine):
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">git clone git://github.com/eclipse-ee4j/jersey.git</pre><p>
            This creates read-only copy of Jersey workspace. If you want to contribute, please use "pull request":
            <a class="link" href="https://help.github.com/articles/creating-a-pull-request" target="_top">https://help.github.com/articles/creating-a-pull-request</a>.
        </p><p>
            Milestones and releases of Jersey are tagged. You can list the tags by executing the standard Git command in the repository directory:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">git tag -l</pre><p> or by visiting
            <a class="link" href="https://github.com/eclipse-ee4j/jersey/tags" target="_top">https://github.com/eclipse-ee4j/jersey/tags</a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="building"></a>27.2.&nbsp;Building the Source</h2></div></div></div><p>
            Jersey source code requires Java SE 8 or higher. Support of Jetty HTTP container/client requires JDK 11+.
            The build is based on Maven. Maven 3.6.3 or higher is highly recommended. Also it is recommended you use
            the following Maven options when building the workspace (can be set in <code class="literal">MAVEN_OPTS</code>
            environment variable):
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">-Xmx1048m -XX:PermSize=64M -XX:MaxPermSize=128M</pre><p>
        </p><p>
            It is recommended to build all of Jersey after you cloned the source code repository.
            To do that execute the following commands in the directory where jersey source repository
            was cloned (typically the directory named "jersey"):
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn -Dmaven.test.skip=true -DskipTests clean install</pre><p>
            This command will build Jersey, but skip the test execution.
            If you don't want to skip the tests, execute the following instead:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn clean install</pre><p>
            Building the whole Jersey project including tests could take significant amount of time.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testing"></a>27.3.&nbsp;Testing</h2></div></div></div><p>
            Jersey contains many tests. Unit tests are in the individual Jersey modules,
            integration and end-to-end tests are in <code class="literal">jersey/tests/e2e</code> directory.
            You can run tests related to a particular area using the following command:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn -Dtest=&lt;pattern&gt; test -pl :[modulename]</pre><p>
            where
            <code class="literal">pattern</code>
            may be a comma separated set of names matching tests classes or individual methods (like
            <code class="literal">LinkTest#testDelimiters</code>)
            and [modulename] is name of a module from which tests are called. If module does not contain those tests
            build failure (as no tests run) occurs.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netbeans-build"></a>27.4.&nbsp;Using NetBeans</h2></div></div></div><p>
            <a class="link" href="http://netbeans.org" target="_top">NetBeans IDE</a>
            has excellent maven support. The Jersey maven
            modules can be loaded, built and tested in NetBeans without any additional
            NetBeans-specific project files.
        </p></div></div><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="migration"></a>Chapter&nbsp;28.&nbsp;Migration Guide</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#mig-3.0.0">28.1. Migrating from Jersey 2.32 to 3.0.2.</a></span></dt><dd><dl><dt><span class="section"><a href="#mig-3.0.0-breaking-changes">28.1.1. Breaking Changes</a></span></dt><dt><span class="section"><a href="#mig-3.0.0-removed-deprecated">28.1.2. Removed deprecated APIs</a></span></dt><dt><span class="section"><a href="#mig-3.0.0-application-servers">28.1.3. Application servers for Jersey</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mig-3.0.0"></a>28.1.&nbsp;Migrating from Jersey 2.32 to 3.0.2.</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mig-3.0.0-breaking-changes"></a>28.1.1.&nbsp;Breaking Changes</h3></div></div></div><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The most fundamental change in Jersey 3.0.2 and later is namespace change.
                            Since Jakarta EE 9 the <code class="literal">jakarta.</code> namespace is introduced as a replacement
                            for javax namespace from Java EE.
                        </p><p>
                            Due to required jakartification several modules where omitted (because of not satisfied dependencies).
                            Or require higher JDK (11+).
                        </p><p>
                            Spring for now is not supported.
                        </p><p>
                            Examples and tests are reduced in quantity (so you probably will not find all those examples which were available
                            in the 2.32 version).
                        </p></li></ul></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mig-3.0.0-removed-deprecated"></a>28.1.2.&nbsp;Removed deprecated APIs</h3></div></div></div><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Jackson 1 support was removed.
                        </p></li></ul></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mig-3.0.0-application-servers"></a>28.1.3.&nbsp;Application servers for Jersey</h3></div></div></div><p>
                At the end of the year 2020 only few application servers where supporting Jakarta EE 9.
                Those are <code class="literal">GlassFish 6.0.0 (RCx)</code>, <code class="literal">Tomcat 10 (Mx)</code> and
                <code class="literal">Jetty 11.x (JDK 11+ required)</code>
            </p></div></div></div><div lang="en" class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="appendix-properties"></a>Appendix&nbsp;A.&nbsp;Configuration Properties</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#appendix-properties-common">A.1. Common (client/server) configuration properties</a></span></dt><dt><span class="section"><a href="#appendix-properties-server">A.2. Server configuration properties</a></span></dt><dt><span class="section"><a href="#appendix-properties-servlet">A.3. Servlet configuration properties</a></span></dt><dt><span class="section"><a href="#appendix-properties-client">A.4. Client configuration properties</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="appendix-properties-common"></a>A.1.&nbsp;Common (client/server) configuration properties</h2></div></div></div><p>
            List of common configuration properties that can be found in <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html" target="_top">CommonProperties</a> class. All of these properties
            can be overridden by their server/client counterparts.
        </p><div class="table"><a name="d0e17897"></a><p class="title"><b>Table&nbsp;A.1.&nbsp;List of common configuration properties</b></p><div class="table-contents"><table summary="List of common configuration properties" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th>Constant</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#ALLOW_SYSTEM_PROPERTIES_PROVIDER" target="_top">CommonProperties.ALLOW_SYSTEM_PROPERTIES_PROVIDER</a></td><td><code class="literal">jersey.config.allowSystemPropertiesProvider</code></td><td>
                            <p>
                                Property which allows (if true) default System properties configuration provider.
                                Default value is <code class="literal">true</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a> /
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE_CLIENT" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE_CLIENT</a> /
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE_SERVER" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE_SERVER</a></td><td><code class="literal">jersey.config.disableAutoDiscovery</code>/
                            <code class="literal">jersey.config.client.disableAutoDiscovery</code>/
                            <code class="literal">jersey.config.server.disableAutoDiscovery</code></td><td>
                            <p>
                                Disables feature auto discovery globally on client/server. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">CommonProperties.JSON_PROCESSING_FEATURE_DISABLE</a> /
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#JSON_PROCESSING_FEATURE_DISABLE_CLIENT" target="_top">CommonProperties.JSON_PROCESSING_FEATURE_DISABLE_CLIENT</a> /
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#JSON_PROCESSING_FEATURE_DISABLE_SERVER" target="_top">CommonProperties.JSON_PROCESSING_FEATURE_DISABLE_SERVER</a></td><td><code class="literal">jersey.config.disableJsonProcessing</code> /
                            <code class="literal">jersey.config.client.disableJsonProcessing</code> /
                            <code class="literal">jersey.config.server.disableJsonProcessing</code></td><td>
                            <p>
                                Disables configuration of Json Processing (JSR-353) feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">CommonProperties.METAINF_SERVICES_LOOKUP_DISABLE</a> /
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#METAINF_SERVICES_LOOKUP_DISABLE_CLIENT" target="_top">CommonProperties.METAINF_SERVICES_LOOKUP_DISABLE_CLIENT</a> /
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#METAINF_SERVICES_LOOKUP_DISABLE_SERVER" target="_top">CommonProperties.METAINF_SERVICES_LOOKUP_DISABLE_SERVER</a></td><td><code class="literal">jersey.config.disableMetainfServicesLookup</code> /
                            <code class="literal">jersey.config.client.disableMetainfServicesLookup</code> /
                            <code class="literal">jersey.config.server.disableMetainfServicesLookup</code></td><td>
                            <p>
                                Disables META-INF/services lookup globally on client/server. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">CommonProperties.MOXY_JSON_FEATURE_DISABLE</a> /
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#MOXY_JSON_FEATURE_DISABLE_CLIENT" target="_top">CommonProperties.MOXY_JSON_FEATURE_DISABLE_CLIENT</a> /
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#MOXY_JSON_FEATURE_DISABLE_SERVER" target="_top">CommonProperties.MOXY_JSON_FEATURE_DISABLE_SERVER</a></td><td><code class="literal">jersey.config.disableMoxyJson</code> /
                            <code class="literal">jersey.config.client.disableMoxyJson</code> /
                            <code class="literal">jersey.config.server.disableMoxyJson</code></td><td>
                            <p>
                                Disables configuration of MOXy Json feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#OUTBOUND_CONTENT_LENGTH_BUFFER" target="_top">CommonProperties.OUTBOUND_CONTENT_LENGTH_BUFFER</a> /
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#OUTBOUND_CONTENT_LENGTH_BUFFER_CLIENT" target="_top">CommonProperties.OUTBOUND_CONTENT_LENGTH_BUFFER_CLIENT</a> /
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#OUTBOUND_CONTENT_LENGTH_BUFFER_SERVER" target="_top">CommonProperties.OUTBOUND_CONTENT_LENGTH_BUFFER_SERVER</a></td><td><code class="literal">jersey.config.contentLength.buffer</code> /
                            <code class="literal">jersey.config.client.contentLength.buffer</code> /
                            <code class="literal">jersey.config.server.contentLength.buffer</code></td><td>
                            <p>
                                An integer value that defines the buffer size used to buffer the outbound message entity in order to
                                determine its size and set the value of HTTP <code class="literal">Content-Length</code> header. Default
                                value is <code class="literal">8192</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#PROVIDER_DEFAULT_DISABLE" target="_top">CommonProperties.PROVIDER_DEFAULT_DISABLE</a>
                        </td><td>
                            <code class="literal">jersey.config.disableDefaultProvider</code>
                        </td><td>
                             Disable some of the default providers from being loaded. The following providers extend application footprint
                             by XML dependencies, which is too heavy for native image, or by AWT which may possibly be not available by JDK 11 desktop:

                                 <table border="0" summary="Simple list" class="simplelist"><tr><td>java.awt.image.RenderedImage</td></tr><tr><td>javax.xml.transform.Source</td></tr><tr><td>javax.xml.transform.dom.DOMSource</td></tr><tr><td>javax.xml.transform.sax.SAXSource</td></tr><tr><td>javax.xml.transform.stream.StreamSource</td></tr></table>

                             The following are the options to disable the provides: {@code DOMSOURCE, RENDEREDIMAGE, SAXSOURCE, SOURCE, STREAMSOURCE},
                             or to disable all: {@code ALL}. Multiple options can be disabled by adding multiple comma separated values.
                             Default value is <code class="literal">NULL</code>
                             @since 2.30
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_LOGGER_NAME" target="_top">LoggingFeature.LOGGING_FEATURE_LOGGER_NAME</a>
                        </td><td>
                            <code class="literal">jersey.config.logging.logger.name</code>
                        </td><td>
                            Logger name of the logging filter.
                            See <a class="link" href="#">logging</a> chapter for more information.
                            The default value is <code class="literal">org.glassfish.jersey.logging.LoggingFeature</code>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_LOGGER_LEVEL" target="_top">LoggingFeature.LOGGING_FEATURE_LOGGER_LEVEL</a>
                        </td><td>
                            <code class="literal">jersey.config.logging.logger.level</code>
                        </td><td>
                            Level of logging filter's logger at which the messages will be logged.
                            See <a class="link" href="#">logging</a> chapter for more information.
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_VERBOSITY" target="_top">LoggingFeature.LOGGING_FEATURE_VERBOSITY</a>
                        </td><td>
                            <code class="literal">jersey.config.logging.verbosity</code>
                        </td><td>
                            Verbosity of logging filter describes how verbose the logging filter will be.
                            There are 3 possible values <code class="literal">LoggingFeature.Verbosity.HEADERS_ONLY</code>,
                            <code class="literal">LoggingFeature.Verbosity.PAYLOAD_TEXT</code> or
                            <code class="literal">LoggingFeature.Verbosity.PAYLOAD_ANY</code>.
                            See <a class="link" href="#">logging</a> chapter for more information.
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_MAX_ENTITY_SIZE" target="_top">LoggingFeature.LOGGING_FEATURE_MAX_ENTITY_SIZE</a>
                        </td><td>
                            <code class="literal">jersey.config.logging.entity.maxSize</code>
                        </td><td>
                            The maximum number of bytes of the entity which will be logged.
                            See <a class="link" href="#">logging</a> chapter for more information.
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_SEPARATOR" target="_top">LoggingFeature.LOGGING_FEATURE_SEPARATOR</a>
                        </td><td>
                            <code class="literal">jersey.config.logging.entity.separator</code>
                        </td><td>
                            Custom logging delimiter for new lines separation.
                            See <a class="link" href="#">logging</a> chapter for more information.
                        </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="appendix-properties-server"></a>A.2.&nbsp;Server configuration properties</h2></div></div></div><p>
            List of server configuration properties that can be found in <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html" target="_top">ServerProperties</a> class.
        </p><div class="table"><a name="d0e18185"></a><p class="title"><b>Table&nbsp;A.2.&nbsp;List of server configuration properties</b></p><div class="table-contents"><table summary="List of server configuration properties" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th>Constant</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#APPLICATION_NAME" target="_top">ServerProperties.APPLICATION_NAME</a></td><td><code class="literal">jersey.config.server.application.name</code></td><td>
                            <p>
                                Defines the application name. The name is an arbitrary user defined name which is used to
                                distinguish between Jersey applications in the case that more applications are deployed on
                                the same runtime (container). The name can be used for example for purposes of monitoring
                                by JMX when name identifies to which application deployed MBeans belong to. The name should
                                be unique in the runtime. The property does not have a default value.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_FEATURE_DISABLE" target="_top">ServerProperties.BV_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.beanValidation.disable.server</code></td><td>
                            <p>
                                Disables Bean Validation support. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK" target="_top">ServerProperties
                            .BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK</a></td><td><code class="literal">jersey.config.beanValidation
                            .disable.validateOnExecutableCheck.server</code></td><td>
                            <p>
                                Disables <code class="literal">@ValidateOnExecution</code> check. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_SEND_ERROR_IN_RESPONSE" target="_top">ServerProperties.BV_SEND_ERROR_IN_RESPONSE</a></td><td><code class="literal">jersey.config.beanValidation
                            .enableOutputValidationErrorEntity.server</code></td><td>
                            <p>
                                Enables sending validation error information to the client. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">ServerProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></td><td><code class="literal">jersey.config.server.disableAutoDiscovery</code></td><td>
                            <p>
                                Disables feature auto discovery on server. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#HTTP_METHOD_OVERRIDE" target="_top">ServerProperties.HTTP_METHOD_OVERRIDE</a></td><td><code class="literal">jersey.config.server.httpMethodOverride</code></td><td>
                            <p>
                                Defines configuration of HTTP method overriding.
                                This property is used by <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/filter/HttpMethodOverrideFilter.html" target="_top">HttpMethodOverrideFilter</a> to determine
                                where it should look for method override information (e.g. request header or query parameters).
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">ServerProperties.JSON_PROCESSING_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.server.disableJsonProcessing</code></td><td>
                            <p>
                                Disables configuration of Json Processing (JSR-353) feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#LANGUAGE_MAPPINGS" target="_top">ServerProperties.LANGUAGE_MAPPINGS</a></td><td><code class="literal">jersey.config.server.languageMappings</code></td><td>
                            <p>
                                Defines mapping of URI extensions to languages. The property is used by <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/filter/UriConnegFilter.html" target="_top">UriConnegFilter</a>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MEDIA_TYPE_MAPPINGS" target="_top">ServerProperties.MEDIA_TYPE_MAPPINGS</a></td><td><code class="literal">jersey.config.server.mediaTypeMappings</code></td><td>
                            <p>
                                Defines mapping of URI extensions to media types. The property is used by <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/filter/UriConnegFilter.html" target="_top">UriConnegFilter</a>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">ServerProperties.METAINF_SERVICES_LOOKUP_DISABLE</a></td><td><code class="literal">jersey.config.server.disableMetainfServicesLookup</code></td><td>
                            <p>
                                Disables META-INF/services lookup on server. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">ServerProperties.MOXY_JSON_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.server.disableMoxyJson</code></td><td>
                            <p>
                                Disables configuration of MOXy Json feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_ENABLED" target="_top">ServerProperties.MONITORING_ENABLED</a> (Jersey 2.12 or later)</td><td><code class="literal">jersey.config.server
                            .monitoring.statistics.enabled</code></td><td>
                            <p>
                                If <code class="literal">true</code>, then application monitoring will be enabled. This will enable the possibility
                                of injecting <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/ApplicationInfo.html" target="_top">ApplicationInfo</a> into resource and providers.
                                Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_ENABLED" target="_top">ServerProperties.MONITORING_STATISTICS_ENABLED</a></td><td><code class="literal">jersey.config.server
                            .monitoring.enabled</code></td><td>
                            <p>
                                If <code class="literal">true</code>, the calculation of monitoring statistics will be enabled. This will enable the
                                possibility of injecting <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a> into resource and
                                providers and also the registered listeners implementing
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatisticsListener.html" target="_top">MonitoringStatisticsListener</a> will be called when statistics are
                                available for processing.
                                Monitoring statistics extends basic monitoring feature. Therefore when enabled,
                                the monitoring gets automatically enabled too (the same result as setting the property
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_ENABLED" target="_top">ServerProperties.MONITORING_ENABLED</a> to <code class="literal">true</code>).
                                Note that enabling statistics may have a negative performance impact
                                and therefore should be enabled only when needed. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_MBEANS_ENABLED" target="_top">ServerProperties.MONITORING_STATISTICS_MBEANS_ENABLED</a></td><td><code class="literal">jersey.config.server
                            .monitoring.statistics.mbeans.enabled</code></td><td>
                            <p>
                                If <code class="literal">true</code> then Jersey will expose MBeans for the collected monitoring statistics. Exposed
                                JMX MBeans are based on <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a> data and therefore when
                                enabled, the calculation of monitoring statistics gets automatically enabled too (the same result
                                as setting the property <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_ENABLED" target="_top">ServerProperties.MONITORING_STATISTICS_ENABLED</a> to
                                <code class="literal">true</code>). Note that enabling MBeans for monitoring statistics may have a negative performance
                                impact and therefore should be enabled only when needed. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_REFRESH_INTERVAL" target="_top">ServerProperties.MONITORING_STATISTICS_REFRESH_INTERVAL</a> (Jersey 2.10 or later)</td><td><code class="literal">jersey.config.server
                            .monitoring.statistics.refresh.interval</code></td><td>
                            <p>
                                Interval (in <code class="literal">ms</code>}) indicating how often will be monitoring statistics refreshed
                                (<code class="literal">onStatistics</code> method called). Default value is <code class="literal">500</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#OUTBOUND_CONTENT_LENGTH_BUFFER" target="_top">ServerProperties.OUTBOUND_CONTENT_LENGTH_BUFFER</a>
                            (Jersey 2.2 or later)</td><td><code class="literal">jersey.config.contentLength.server.buffer</code></td><td>
                            <p>
                                An integer value that defines the buffer size used to buffer the outbound message entity in order to
                                determine its size and set the value of HTTP <code class="literal">Content-Length</code> header. Default
                                value is <code class="literal">8192</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#PROVIDER_CLASSNAMES" target="_top">ServerProperties.PROVIDER_CLASSNAMES</a></td><td><code class="literal">jersey.config.server.provider.classnames</code></td><td>
                            <p>
                                Defines one or more class names that implement application-specific resources
                                and providers. If the property is set, the specified classes will be instantiated
                                and registered as either application JAX-RS root resources or providers.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#PROVIDER_CLASSPATH" target="_top">ServerProperties.PROVIDER_CLASSPATH</a></td><td><code class="literal">jersey.config.server.provider.classpath</code></td><td>
                            <p>
                                Defines class-path that contains application-specific resources and
                                providers. If the property is set, the specified packages will be scanned for
                                JAX-RS root resources and providers.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#PROVIDER_PACKAGES" target="_top">ServerProperties.PROVIDER_PACKAGES</a></td><td><code class="literal">jersey.config.server.provider.packages</code></td><td>
                            <p>
                                Defines one or more packages that contain application-specific resources and
                                providers. If the property is set, the specified packages will be scanned for
                                JAX-RS root resources and providers.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#PROVIDER_SCANNING_RECURSIVE" target="_top">ServerProperties.PROVIDER_SCANNING_RECURSIVE</a></td><td><code class="literal">jersey.config.server
                            .provider.scanning.recursive</code></td><td>
                            <p>
                                Sets the recursion strategy for package scanning. Default value is <code class="literal">true</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#REDUCE_CONTEXT_PATH_SLASHES_ENABLED" target="_top">ServerProperties.REDUCE_CONTEXT_PATH_SLASHES_ENABLED</a></td><td><code class="literal">jersey.config.server.reduceContextPathSlashes.enabled</code></td><td>
                            <p>
                                Ignores multiple slashes between a port and a context path and will resolve it
                                as URI with only one slash. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#RESOURCE_VALIDATION_DISABLE" target="_top">ServerProperties.RESOURCE_VALIDATION_DISABLE</a></td><td><code class="literal">jersey.config.server
                            .resource.validation.disable</code></td><td>
                            <p>
                                Disables <code class="literal">Resource</code> validation. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#RESOURCE_VALIDATION_IGNORE_ERRORS" target="_top">ServerProperties.RESOURCE_VALIDATION_IGNORE_ERRORS</a></td><td><code class="literal">jersey.config.server
                            .resource.validation.ignoreErrors</code></td><td>
                            <p>
                                Determines whether validation of application resource models should fail even in case of a fatal
                                validation errors. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#WADL_FEATURE_DISABLE" target="_top">ServerProperties.WADL_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.server.wadl.disableWadl</code></td><td>
                            <p>
                                Disables WADL generation. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#WADL_GENERATOR_CONFIG" target="_top">ServerProperties.WADL_GENERATOR_CONFIG</a></td><td><code class="literal">jersey.config.server.wadl.generatorConfig</code></td><td>
                            <p>
                                Defines the wadl generator configuration that provides a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/wadl/WadlGenerator.html" target="_top">WadlGenerator</a>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#RESPONSE_SET_STATUS_OVER_SEND_ERROR" target="_top">ServerProperties.RESPONSE_SET_STATUS_OVER_SEND_ERROR</a></td><td><code class="literal">jersey.config.server.response.setStatusOverSendError</code></td><td>
                            <p>
                                Whenever response status is <code class="literal">4xx</code> or <code class="literal">5xx</code> it is
                                possible to choose between <code class="literal">sendError</code> or <code class="literal">setStatus</code>
                                on container specific <code class="literal">Response</code> implementation. E.g. on servlet
                                container Jersey can call <code class="literal">HttpServletResponse.setStatus(...)</code> or
                                <code class="literal">HttpServletResponse.sendError(...)</code>.

                                Calling <code class="literal">sendError(...)</code> method usually resets entity, response headers
                                and provide error page for specified status code (e.g. servlet
                                <code class="literal">error-page</code> configuration).
                                However if you want to post-process response (e.g. by servlet filter) the only
                                way to do it is calling <code class="literal">setStatus(...)</code> on container Response object.

                                If property value is <code class="literal">true</code> the method <code class="literal">Response.setStatus(...)</code> is
                                used over default <code class="literal">Response.sendError(...)</code>.

                                Type of the property value is <code class="literal">boolean</code>.
                                The default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#TRACING" target="_top">ServerProperties.TRACING</a></td><td><code class="literal">jersey.config.server.tracing.type</code></td><td>
                            <p>
                                Enables/disables tracing support. Possible values are <code class="literal">OFF</code> (default),
                                <code class="literal">ON_DEMAND</code> and <code class="literal">ALL</code>.
                                See <a class="xref" href="#tracing.configuration" title="23.2.1.&nbsp;Configuration options">Section&nbsp;23.2.1, &#8220;Configuration options&#8221;</a> for more detail.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#TRACING_THRESHOLD" target="_top">ServerProperties.TRACING_THRESHOLD</a></td><td><code class="literal">jersey.config.server.tracing.threshold</code></td><td>
                            <p>
                                Sets the amount of detail provided by tracing. Possible values are <code class="literal">SUMMARY</code>,
                                <code class="literal">TRACE</code> and <code class="literal">VERBOSE</code>.
                                See <a class="xref" href="#tracing.configuration" title="23.2.1.&nbsp;Configuration options">Section&nbsp;23.2.1, &#8220;Configuration options&#8221;</a> to learn more about the levels.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#PROCESSING_RESPONSE_ERRORS_ENABLED" target="_top">ServerProperties.PROCESSING_RESPONSE_ERRORS_ENABLED</a></td><td><code class="literal">jersey.config.server.exception.processResponseErrors</code></td><td>
                            <p>
                                If property value is <code class="literal">true</code> then the errors raised during response processing are
                                tried to be handled using available response error mappers.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#SUBRESOURCE_LOCATOR_CACHE_SIZE" target="_top">ServerProperties.SUBRESOURCE_LOCATOR_CACHE_SIZE</a></td><td><code class="literal">jersey.config.server.subresource.cache.size</code></td><td>
                            <p>
                                An integer value that defines the size of cache for sub-resource locator models. The cache is used
                                to provide better performance for application that uses JAX-RS sub-resource locators.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#SUBRESOURCE_LOCATOR_CACHE_AGE" target="_top">ServerProperties.SUBRESOURCE_LOCATOR_CACHE_AGE</a></td><td><code class="literal">jersey.config.server.subresource.cache.age</code></td><td>
                            <p>
                                An integer value that defines the maximum age (in seconds) for cached for sub-resource locator
                                models. The age of an cache entry is defined as the time since the last access (read) to the entry
                                in the cache. Entry aging is not enabled by default.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#SUBRESOURCE_LOCATOR_CACHE_JERSEY_RESOURCE_ENABLED" target="_top">ServerProperties.SUBRESOURCE_LOCATOR_CACHE_JERSEY_RESOURCE_ENABLED</a></td><td><code class="literal">jersey.config.server.subresource.cache.jersey.resource.enabled</code></td><td>
                            <p>
                                If <code class="literal">true</code> then Jersey will cache Jersey resources in addition to caching
                                sub-resource locator classes and instances (which are cached by default). To make sure the caching
                                is effective in this case you need to return same Jersey Resource instances for same input
                                parameters from resource method. This means that generating new Jersey Resource instances for same
                                input parameters would not have any performance effect and it would only fill-up the cache.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#LOCATION_HEADER_RELATIVE_URI_RESOLUTION_RFC7231" target="_top">ServerProperties.LOCATION_HEADER_RELATIVE_URI_RESOLUTION_RFC7231</a></td><td><code class="literal">jersey.config.server.headers.location.relative.resolution.rfc7231</code></td><td>
                            <p>
                                If <code class="literal">true</code> then Jersey will resolve relative URIs in the
                                <code class="literal">Location</code> http header against the request URI according to <code class="literal">RFC7231</code>
                                (new HTTP Specification)
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#LOCATION_HEADER_RELATIVE_URI_RESOLUTION_DISABLED" target="_top">ServerProperties.LOCATION_HEADER_RELATIVE_URI_RESOLUTION_DISABLED</a></td><td><code class="literal">jersey.config.server.headers.location.relative.resolution.disabled</code></td><td>
                            <p>
                                If <code class="literal">true</code>, Jersey will not resolve relative URIs in the <code class="literal">Location</code>
                                http header.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_LOGGER_NAME_SERVER" target="_top">LoggingFeature.LOGGING_FEATURE_LOGGER_NAME_SERVER</a>
                        </td><td>
                            <code class="literal">jersey.config.server.logging.logger.name</code>
                        </td><td>
                            Logger name of the logging filter.
                            See <a class="link" href="#">logging</a> chapter for more information.
                            The default value is <code class="literal">org.glassfish.jersey.logging.LoggingFeature</code>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_LOGGER_LEVEL_SERVER" target="_top">LoggingFeature.LOGGING_FEATURE_LOGGER_LEVEL_SERVER</a>
                        </td><td>
                            <code class="literal">jersey.config.server.logging.logger.level</code>
                        </td><td>
                            Level of logging filter's logger at which the messages will be logged.
                            See <a class="link" href="#">logging</a> chapter for more information.
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_VERBOSITY_SERVER" target="_top">LoggingFeature.LOGGING_FEATURE_VERBOSITY_SERVER</a>
                        </td><td>
                            <code class="literal">jersey.config.server.logging.verbosity</code>
                        </td><td>
                            Verbosity of logging filter describes how verbose the logging filter will be.
                            There are 3 possible values <code class="literal">LoggingFeature.Verbosity.HEADERS_ONLY</code>,
                            <code class="literal">LoggingFeature.Verbosity.PAYLOAD_TEXT</code> or
                            <code class="literal">LoggingFeature.Verbosity.PAYLOAD_ANY</code>.
                            See <a class="link" href="#">logging</a> chapter for more information.
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_MAX_ENTITY_SIZE_SERVER" target="_top">LoggingFeature.LOGGING_FEATURE_MAX_ENTITY_SIZE_SERVER</a>
                        </td><td>
                            <code class="literal">jersey.config.server.logging.entity.maxSize</code>
                        </td><td>
                            The maximum number of bytes of the entity which will be logged.
                            See <a class="link" href="#">logging</a> chapter for more information.
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_MAX_ENTITY_SIZE_SERVER" target="_top">LoggingFeature.LOGGING_FEATURE_SEPARATOR_SERVER</a>
                        </td><td>
                            <code class="literal">jersey.config.server.logging.entity.separator</code>
                        </td><td>
                            Custom delimiter for new lines separation.
                            See <a class="link" href="#">logging</a> chapter for more information.
                        </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="appendix-properties-servlet"></a>A.3.&nbsp;Servlet configuration properties</h2></div></div></div><p>
            List of servlet configuration properties that can be found in <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/servlet/ServletProperties.html" target="_top">ServletProperties</a> class.
        </p><div class="table"><a name="d0e18903"></a><p class="title"><b>Table&nbsp;A.3.&nbsp;List of servlet configuration properties</b></p><div class="table-contents"><table summary="List of servlet configuration properties" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th>Constant</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/servlet/ServletProperties.html#FILTER_CONTEXT_PATH" target="_top">ServletProperties.FILTER_CONTEXT_PATH</a></td><td><code class="literal">jersey.config.servlet.filter.contextPath</code></td><td>
                            <p>
                                If set, indicates the URL pattern of the Jersey servlet filter context path.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/servlet/ServletProperties.html#FILTER_FORWARD_ON_404" target="_top">ServletProperties.FILTER_FORWARD_ON_404</a></td><td><code class="literal">jersey.config.servlet.filter.forwardOn404</code></td><td>
                            <p>
                                If set to <code class="literal">true</code> and a 404 response with no entity body is returned from either
                                the runtime or the application then the runtime forwards the request to the next filter in the
                                filter chain. This enables another filter or the underlying servlet engine to process the request.
                                Before the request is forwarded the response status is set to 200.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/servlet/ServletProperties.html#FILTER_STATIC_CONTENT_REGEX" target="_top">ServletProperties.FILTER_STATIC_CONTENT_REGEX</a></td><td><code class="literal">jersey.config.servlet.filter.staticContentRegex</code></td><td>
                            <p>
                                If set the regular expression is used to match an incoming servlet path URI to some web page
                                content such as static resources or JSPs to be handled by the underlying servlet engine.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/servlet/ServletProperties.html#JAXRS_APPLICATION_CLASS" target="_top">ServletProperties.JAXRS_APPLICATION_CLASS</a></td><td><code class="literal">jakarta.ws.rs.Application</code></td><td>
                            <p>
                                Application configuration initialization property whose value is a fully qualified class name of a
                                class that implements JAX-RS Application.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/servlet/ServletProperties.html#PROVIDER_WEB_APP" target="_top">ServletProperties.PROVIDER_WEB_APP</a></td><td><code class="literal">jersey.config.servlet.provider.webapp</code></td><td>
                            <p>
                                Indicates that Jersey should scan the whole web app for application-specific resources and
                                providers.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/servlet/ServletProperties.html#QUERY_PARAMS_AS_FORM_PARAMS_DISABLED" target="_top">ServletProperties.QUERY_PARAMS_AS_FORM_PARAMS_DISABLED</a></td><td><code class="literal">jersey.config.servlet.form.queryParams.disabled</code></td><td>
                            <p>
                                If <code class="literal">true</code> then query parameters will not be treated as form parameters
                                (e.g. injectable using @FormParam) in case a Form request is processed by server.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/servlet/ServletProperties.html#SERVICE_LOCATOR" target="_top">ServletProperties.SERVICE_LOCATOR</a></td><td><code class="literal">jersey.config.servlet.context.serviceLocator</code></td><td>
                            <p>
                                Identifies the object that will be used as a parent ServiceLocator in the Jersey WebComponent.
                            </p>
                        </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="appendix-properties-client"></a>A.4.&nbsp;Client configuration properties</h2></div></div></div><p>
            List of client configuration properties that can be found in <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html" target="_top">ClientProperties</a> class.
        </p><div class="table"><a name="d0e19014"></a><p class="title"><b>Table&nbsp;A.4.&nbsp;List of client configuration properties</b></p><div class="table-contents"><table summary="List of client configuration properties" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th>Constant</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#ASYNC_THREADPOOL_SIZE" target="_top">ClientProperties.ASYNC_THREADPOOL_SIZE</a></td><td><code class="literal">jersey.config.client.async.threadPoolSize</code></td><td>
                            <p>
                                Asynchronous thread pool size. Default value is not set.
                                <span class="emphasis"><em>Supported with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/grizzly/connector/GrizzlyConnectorProvider.html" target="_top">GrizzlyConnectorProvider</a> only.</em></span>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#BACKGROUND_SCHEDULER_THREADPOOL_SIZE" target="_top">ClientProperties.BACKGROUND_SCHEDULER_THREADPOOL_SIZE</a></td><td><code class="literal">jersey.config.client.backgroundScheduler.threadPoolSize</code></td><td>
                            <p>
                                Scheduler thread pool size. Default value is not set.
                                <span class="emphasis"><em>Support is undefined</em></span>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#CHUNKED_ENCODING_SIZE" target="_top">ClientProperties.CHUNKED_ENCODING_SIZE</a></td><td><code class="literal">jersey.config.client.chunkedEncodingSize</code></td><td>
                            <p>
                                Chunked encoding size. Default value is  <code class="literal">4096</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#CONNECT_TIMEOUT" target="_top">ClientProperties.CONNECT_TIMEOUT</a></td><td><code class="literal">jersey.config.client.connectTimeout</code></td><td>
                            <p>
                                Read timeout interval, in milliseconds. Default value is <code class="literal">0</code> (infinity).
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">ClientProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></td><td><code class="literal">jersey.config.client.disableAutoDiscovery</code></td><td>
                            <p>
                                Disables feature auto discovery on client. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#FOLLOW_REDIRECTS" target="_top">ClientProperties.FOLLOW_REDIRECTS</a></td><td><code class="literal">jersey.config.client.followRedirects</code></td><td>
                            <p>
                                Declares that the client will automatically redirect to the URI declared in 3xx responses. Default value is <code class="literal">true</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">ClientProperties.JSON_PROCESSING_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.client.disableJsonProcessing</code></td><td>
                            <p>
                                Disables configuration of Json Processing (JSR-353) feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">ClientProperties.METAINF_SERVICES_LOOKUP_DISABLE</a></td><td><code class="literal">jersey.config.disableMetainfServicesLookup.client</code></td><td>
                            <p>
                                Disables META-INF/services lookup on client. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">ClientProperties.MOXY_JSON_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.client.disableMoxyJson</code></td><td>
                            <p>
                                Disables configuration of MOXy Json feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#OUTBOUND_CONTENT_LENGTH_BUFFER" target="_top">ClientProperties.OUTBOUND_CONTENT_LENGTH_BUFFER</a>
                            (Jersey 2.2 or later)</td><td><code class="literal">jersey.config.client.contentLength.buffer</code></td><td>
                            <p>
                                An integer value that defines the buffer size used to buffer the outbound message entity in order to
                                determine its size and set the value of HTTP <code class="literal">Content-Length</code> header. Default
                                value is <code class="literal">8192</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#PROXY_URI" target="_top">ClientProperties.PROXY_URI</a></td><td><code class="literal">jersey.config.client.proxy.uri</code></td><td>
                            <p>
                                URI of a HTTP proxy the client connector should use. Default value is not set.
                                <span class="emphasis"><em>Currently supported with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/apache/connector/ApacheConnectorProvider.html" target="_top">ApacheConnectorProvider</a> and
                                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jetty/connector/JettyConnectorProvider.html" target="_top">JettyConnectorProvider</a> only.</em></span>
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#PROXY_USERNAME" target="_top">ClientProperties.PROXY_USERNAME</a> (Jersey 2.5 or later)</td><td><code class="literal">jersey.config.client.proxy.username</code></td><td>
                            <p>
                                User name which will be used for HTTP proxy authentication. Default value is not set.
                                <span class="emphasis"><em>Currently supported with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/apache/connector/ApacheConnectorProvider.html" target="_top">ApacheConnectorProvider</a> and
                                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jetty/connector/JettyConnectorProvider.html" target="_top">JettyConnectorProvider</a> only.</em></span>
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#PROXY_PASSWORD" target="_top">ClientProperties.PROXY_PASSWORD</a> (Jersey 2.5 or later)</td><td><code class="literal">jersey.config.client.proxy.password</code></td><td>
                            <p>
                                Password which will be used for HTTP proxy authentication. Default value is not set.
                                <span class="emphasis"><em>Currently supported with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/apache/connector/ApacheConnectorProvider.html" target="_top">ApacheConnectorProvider</a> and
                                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jetty/connector/JettyConnectorProvider.html" target="_top">JettyConnectorProvider</a> only.</em></span>
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#READ_TIMEOUT" target="_top">ClientProperties.READ_TIMEOUT</a> (Jersey 2.5 or later)</td><td><code class="literal">jersey.config.client.readTimeout</code></td><td>
                            <p>
                                Read timeout interval, in milliseconds. Default value is <code class="literal">0</code> (infinity).
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#REQUEST_ENTITY_PROCESSING" target="_top">ClientProperties.REQUEST_ENTITY_PROCESSING</a> (Jersey 2.5 or later)</td><td><code class="literal">jersey.config.client.request.entity.processing</code></td><td>
                            <p>
                                Defines whether the request entity should be serialized using internal buffer to
                                evaluate content length or chunk encoding should be used. Possible values are
                                <code class="literal">BUFFERED</code> or <code class="literal">CHUNKED</code>. Default value is
                                <code class="literal">BUFFERED</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#SUPPRESS_HTTP_COMPLIANCE_VALIDATION" target="_top">ClientProperties.SUPPRESS_HTTP_COMPLIANCE_VALIDATION</a>
                            (Jersey 2.2 or later)</td><td><code class="literal">jersey.config.client.suppressHttpComplianceValidation</code></td><td>
                            <p>
                                If <code class="literal">true</code>, the strict validation of HTTP specification compliance for client-side
                                requests will be suppressed. When compliance checks are suppressed, any violations will
                                be merely logged as warnings, rather than causing exceptions being raised in Jersey
                                runtime. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#USE_ENCODING" target="_top">ClientProperties.USE_ENCODING</a></td><td><code class="literal">jersey.config.client.useEncoding</code></td><td>
                            <p>
                                Indicates the value of <code class="literal">Content-Encoding</code> property the
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/filter/EncodingFilter.html" target="_top">EncodingFilter</a> should be adding. Default value is not set.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#DIGESTAUTH_URI_CACHE_SIZELIMIT" target="_top">ClientProperties.DIGESTAUTH_URI_CACHE_SIZELIMIT</a></td><td><code class="literal">jersey.config.client.digestAuthUriCacheSizeLimit</code></td><td>
                            <p>
                                The property defines a URI of a HTTP proxy the client connector should use.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#EXPECT_100_CONTINUE" target="_top">ClientProperties.EXPECT_100_CONTINUE</a></td><td><code class="literal">jersey.config.client.request.expect.100.continue.processing</code></td><td>
                            <p>
                                Allows for HTTP Expect:100-Continue being handled by the HttpUrlConnector (default Jersey
                                connector). <code class="literal">Since 2.32</code>
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#EXPECT_100_CONTINUE_THRESHOLD_SIZE" target="_top">ClientProperties.EXPECT_100_CONTINUE_THRESHOLD_SIZE</a></td><td><code class="literal">jersey.config.client.request.expect.100.continue.threshold.size</code></td><td>
                            <p>
                                Property for threshold size for content length after which Expect:100-Continue header would be applied
                                before the main request.
                                Default threshold size (64kb) after which which Expect:100-Continue header would be applied before
                                the main request.
                                <code class="literal">Since 2.32</code>
                            </p>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_LOGGER_NAME_CLIENT" target="_top">LoggingFeature.LOGGING_FEATURE_LOGGER_NAME_CLIENT</a>
                        </td><td>
                            <code class="literal">jersey.config.client.logging.logger.name</code>
                        </td><td>
                            Logger name of the logging filter.
                            See <a class="link" href="#">logging</a> chapter for more information.
                            The default value is <code class="literal">org.glassfish.jersey.logging.LoggingFeature</code>
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_LOGGER_LEVEL_CLIENT" target="_top">LoggingFeature.LOGGING_FEATURE_LOGGER_LEVEL_CLIENT</a>
                        </td><td>
                            <code class="literal">jersey.config.client.logging.logger.level</code>
                        </td><td>
                            Level of logging filter's logger at which the messages will be logged.
                            See <a class="link" href="#logging_chapter" title="Chapter&nbsp;22.&nbsp;Logging">logging</a> chapter for more information.
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_VERBOSITY_CLIENT" target="_top">LoggingFeature.LOGGING_FEATURE_VERBOSITY_CLIENT</a>
                        </td><td>
                            <code class="literal">jersey.config.client.logging.verbosity</code>
                        </td><td>
                            Verbosity of logging filter describes how verbose the logging filter will be.
                            There are 3 possible values <code class="literal">LoggingFeature.Verbosity.HEADERS_ONLY</code>,
                            <code class="literal">LoggingFeature.Verbosity.PAYLOAD_TEXT</code> or
                            <code class="literal">LoggingFeature.Verbosity.PAYLOAD_ANY</code>.
                            See <a class="link" href="#logging_chapter" title="Chapter&nbsp;22.&nbsp;Logging">logging</a> chapter for more information.
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_MAX_ENTITY_SIZE_CLIENT" target="_top">LoggingFeature.LOGGING_FEATURE_MAX_ENTITY_SIZE_CLIENT</a>
                        </td><td>
                            <code class="literal">jersey.config.client.logging.entity.maxSize</code>
                        </td><td>
                            The maximum number of bytes of the entity which will be logged.
                            See <a class="link" href="#logging_chapter" title="Chapter&nbsp;22.&nbsp;Logging">logging</a> chapter for more information.
                        </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/logging/LoggingFeature.html#LOGGING_FEATURE_MAX_ENTITY_SIZE_CLIENT" target="_top">LoggingFeature.LOGGING_FEATURE_SEPARATOR_CLIENT</a>
                        </td><td>
                            <code class="literal">jersey.config.client.logging.entity.separator</code>
                        </td><td>
                            New line delimiter property (client side).
                            See <a class="link" href="#logging_chapter" title="Chapter&nbsp;22.&nbsp;Logging">logging</a> chapter for more information.
                        </td></tr></tbody></table></div></div><br class="table-break"></div></div></div><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.css" rel="stylesheet" type="text/css"><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shThemeDefault.css" rel="stylesheet" type="text/css"><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.js" type="text/javascript"></script><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shAutoloader.js" type="text/javascript"></script><script type="text/javascript">
            function path() {
              var args = arguments,
                  result = []
                  ;

              for(var i = 0; i < args.length; i++)
                  result.push(args[i].replace('@', 'https://eclipse-ee4j.github.io/jersey.github.io/sh/'));

              return result
            };

            SyntaxHighlighter.autoloader.apply(null, path(
              'applescript            @shBrushAppleScript.js',
              'actionscript3 as3      @shBrushAS3.js',
              'bash shell             @shBrushBash.js',
              'coldfusion cf          @shBrushColdFusion.js',
              'cpp c                  @shBrushCpp.js',
              'c# c-sharp csharp      @shBrushCSharp.js',
              'css                    @shBrushCss.js',
              'delphi pascal          @shBrushDelphi.js',
              'diff patch pas         @shBrushDiff.js',
              'erl erlang             @shBrushErlang.js',
              'groovy                 @shBrushGroovy.js',
              'java                   @shBrushJava.js',
              'jfx javafx             @shBrushJavaFX.js',
              'js jscript javascript  @shBrushJScript.js',
              'perl pl                @shBrushPerl.js',
              'php                    @shBrushPhp.js',
              'text plain             @shBrushPlain.js',
              'py python              @shBrushPython.js',
              'ruby rails ror rb      @shBrushRuby.js',
              'sass scss              @shBrushSass.js',
              'scala                  @shBrushScala.js',
              'sql                    @shBrushSql.js',
              'vb vbnet               @shBrushVb.js',
              'xml xhtml xslt html    @shBrushXml.js'
            ));

            SyntaxHighlighter.all();
        </script></div></body></html>