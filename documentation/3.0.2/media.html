<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;9.&nbsp;Support for Common Media Type Representations</title><link rel="stylesheet" type="text/css" href="/jersey.github.io/documentation.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Jersey 3.0.2 User Guide"><link rel="up" href="index.html" title="Jersey 3.0.2 User Guide"><link rel="prev" href="message-body-workers.html" title="Chapter&nbsp;8.&nbsp;JAX-RS Entity Providers"><link rel="next" href="filters-and-interceptors.html" title="Chapter&nbsp;10.&nbsp;Filters and Interceptors"><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-3160303-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script></head><body class="contents"><div class="contents" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;9.&nbsp;Support for Common Media Type Representations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="message-body-workers.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="filters-and-interceptors.html">Next</a></td></tr></table><hr></div><div style="float:right"><a href="https://eclipse-ee4j.github.io/jersey"><img src="https://eclipse-ee4j.github.io/jersey.github.io/images/jersey_logo.png"></a></div><small>Links:
            <a href="index.html">
                Table of Contents
            </a> | <a href="user-guide.html">
                Single HTML
            </a></small><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="media"></a>Chapter&nbsp;9.&nbsp;Support for Common Media Type Representations</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="media.html#json">9.1. JSON</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#d0e7581">9.1.1. Approaches to JSON Support</a></span></dt><dt><span class="section"><a href="media.html#json.moxy">9.1.2. MOXy</a></span></dt><dt><span class="section"><a href="media.html#json.json-p">9.1.3. Java API for JSON Processing (JSON-P)</a></span></dt><dt><span class="section"><a href="media.html#json.jackson">9.1.4. Jackson (2.x)</a></span></dt><dt><span class="section"><a href="media.html#json.jettison">9.1.5. Jettison</a></span></dt><dt><span class="section"><a href="media.html#d0e8349">9.1.6. <code class="literal">@JSONP</code> - JSON with Padding Support</a></span></dt><dt><span class="section"><a href="media.html#json.json-b">9.1.7. Java API for JSON Binding (JSON-B)</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#xml">9.2. XML</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#d0e8594">9.2.1. Low level XML support</a></span></dt><dt><span class="section"><a href="media.html#d0e8642">9.2.2. Getting started with JAXB</a></span></dt><dt><span class="section"><a href="media.html#d0e8730">9.2.3. POJOs</a></span></dt><dt><span class="section"><a href="media.html#d0e8768">9.2.4. Using custom JAXBContext</a></span></dt><dt><span class="section"><a href="media.html#d0e8800">9.2.5. MOXy</a></span></dt></dl></dd><dt><span class="section"><a href="media.html#multipart">9.3. Multipart</a></span></dt><dd><dl><dt><span class="section"><a href="media.html#d0e8855">9.3.1. Overview</a></span></dt><dt><span class="section"><a href="media.html#d0e8956">9.3.2. Client</a></span></dt><dt><span class="section"><a href="media.html#d0e9087">9.3.3. Server</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="json"></a>9.1.&nbsp;JSON</h2></div></div></div><p>
            Jersey JSON support comes as a set of extension modules where each of these modules contains an implementation of
            a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Feature.html" target="_top">Feature</a> that needs to be registered into your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> instance (client/server).
            There are multiple frameworks that provide support for JSON processing and/or JSON-to-Java binding.
            The modules listed below provide support for JSON representations by integrating the individual JSON frameworks into
            Jersey. At present, Jersey integrates with the following modules to provide JSON support:

            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                        <a class="link" href="media.html#json.moxy" title="9.1.2.&nbsp;MOXy">MOXy</a> - JSON binding support via MOXy is a default and preferred way of supporting JSON binding
                        in your Jersey applications since Jersey 2.0. When JSON MOXy module is on the class-path, Jersey will
                        automatically discover the module and seamlessly enable JSON binding support via MOXy in your
                        applications. (See <a class="xref" href="deployment.html#deployment.autodiscoverable" title="4.3.&nbsp;Auto-Discoverable Features">Section&nbsp;4.3, &#8220;Auto-Discoverable Features&#8221;</a>.)
                    </p></li><li class="listitem"><p><a class="link" href="media.html#json.json-p" title="9.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a></p></li><li class="listitem"><p><a class="link" href="media.html#json.jackson" title="9.1.4.&nbsp;Jackson (2.x)">Jackson</a></p></li><li class="listitem"><p><a class="link" href="media.html#json.jettison" title="9.1.5.&nbsp;Jettison">Jettison</a></p></li><li class="listitem"><p><a class="link" href="media.html#json.json-b" title="9.1.7.&nbsp;Java API for JSON Binding (JSON-B)">Java API for JSON Binding (JSON-B)</a></p></li></ul></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7581"></a>9.1.1.&nbsp;Approaches to JSON Support</h3></div></div></div><p>
                Each of the aforementioned extension modules uses one or more of the three basic approaches available when
                working with JSON representations:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>POJO based JSON binding support</p></li><li class="listitem"><p>JAXB based JSON binding support</p></li><li class="listitem"><p>Low-level JSON parsing &amp; processing support</p></li></ul></div><p>

                The first method is pretty generic and allows you to map any Java Object to JSON and vice versa.
                The other two approaches limit you in Java types your resource methods could produce and/or consume.
                JAXB based approach is useful if you plan to utilize certain JAXB features and support both XML and JSON
                representations. The last, low-level, approach gives you the best fine-grained control over the out-coming
                JSON data format.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="json-pojo"></a>9.1.1.1.&nbsp;POJO support</h4></div></div></div><p>POJO support represents the easiest way to convert your Java Objects to JSON and back.</p><p>Media modules that support this approach are <a class="link" href="media.html#json.moxy" title="9.1.2.&nbsp;MOXy">MOXy</a>, <a class="link" href="media.html#json.jackson" title="9.1.4.&nbsp;Jackson (2.x)">Jackson</a>, and <a class="link" href="media.html#json.json-b" title="9.1.7.&nbsp;Java API for JSON Binding (JSON-B)">Java API for JSON Binding (JSON-B)</a></p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="json-jaxb"></a>9.1.1.2.&nbsp;JAXB based JSON support</h4></div></div></div><p>
                    Taking this approach will save you a lot of time, if you want to easily produce/consume both JSON and XML
                    data format. With JAXB beans you will be able to use the same Java model to generate JSON as well as XML
                    representations.
                    Another advantage is simplicity of working with such a model and availability of the API in Java SE Platform.
                    JAXB leverages annotated POJOs and these could be handled as simple Java beans.
                </p><p>
                    A disadvantage of JAXB based approach could be if you need to work with a very specific JSON format. Then it
                    might be difficult to find a proper way to get such a format produced and consumed. This is a reason why a
                    lot of configuration options are provided, so that you can control how JAXB beans get serialized and
                    de-serialized. The extra configuration options however requires you to learn more details about the framework
                    you are using.
                </p><p>
                    Following is a very simple example of how a JAXB bean could look like.

                    </p><div class="example"><a name="d0e7621"></a><p class="title"><b>Example&nbsp;9.1.&nbsp;Simple JAXB bean implementation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class MyJaxbBean {
    public String name;
    public int age;

    public MyJaxbBean() {} // JAXB needs this

    public MyJaxbBean(String name, int age) {
        this.name = name;
        this.age = age;
    }
}</pre></div></div><p><br class="example-break">

                    Using the above JAXB bean for producing JSON data format from you resource method, is then as simple as:

                    </p><div class="example"><a name="d0e7627"></a><p class="title"><b>Example&nbsp;9.2.&nbsp;JAXB bean used to generate JSON representation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces("application/json")
public MyJaxbBean getMyBean() {
    return new MyJaxbBean("Agamemnon", 32);
}</pre></div></div><p><br class="example-break">

                    Notice, that JSON specific mime type is specified in <code class="literal">@Produces</code> annotation, and the method returns
                    an instance of <code class="literal">MyJaxbBean</code>, which JAXB is able to process. Resulting JSON in this case
                    would look like:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: text;&#xA;    gutter: false;">{"name":"Agamemnon", "age":"32"}</pre><p>
                </p><p>
                    A proper use of JAXB annotations itself enables you to control output JSON format to certain extent.
                    Specifically, renaming and omitting items is easy to do directly just by using JAXB annotations.
                    For example, the following example depicts changes in the above mentioned MyJaxbBean that will result in
                    <code class="literal">{"king":"Agamemnon"}</code> JSON output.

                    </p><div class="example"><a name="d0e7647"></a><p class="title"><b>Example&nbsp;9.3.&nbsp;Tweaking JSON format using JAXB</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class MyJaxbBean {

    @XmlElement(name="king")
    public String name;

    @XmlTransient
    public int age;

    // several lines removed
}</pre></div></div><p><br class="example-break">
                </p><p>Media modules that support this approach are <a class="link" href="media.html#json.moxy" title="9.1.2.&nbsp;MOXy">MOXy</a>, <a class="link" href="media.html#json.jackson" title="9.1.4.&nbsp;Jackson (2.x)">Jackson</a>, <a class="link" href="media.html#json.jettison" title="9.1.5.&nbsp;Jettison">Jettison</a></p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="json-lowlevel"></a>9.1.1.3.&nbsp;Low-level based JSON support</h4></div></div></div><p>
                    JSON Processing API is a new standard API for parsing and processing JSON structures in similar way to what
                    SAX and StAX parsers provide for XML. The API is part of Jakarta EE 9 and later. Another such JSON
                    parsing/processing API is provided by Jettison framework (which is also supported in jakartified environment).
                    Both APIs provide a low-level access to producing
                    and consuming JSON data structures. By adopting this low-level approach you would be working with
                    <code class="literal">JsonObject</code> (or <code class="literal">JSONObject</code> respectively) and/or
                    <code class="literal">JsonArray</code> (or <code class="literal">JSONArray</code> respectively) classes when processing your
                    JSON data representations.
                </p><p>
                    The biggest advantage of these low-level APIs is that you will gain full control over the JSON format
                    produced and consumed. You will also be able to produce and consume very large JSON structures using
                    streaming JSON parser/generator APIs.
                    On the other hand, dealing with your data model objects will probably be a lot more complex, compared
                    to the POJO or JAXB based binding approach. Differences are depicted at the following code snippets.
                </p><p>
                    Let's start with JAXB-based approach.

                    </p><div class="example"><a name="d0e7684"></a><p class="title"><b>Example&nbsp;9.4.&nbsp;JAXB bean creation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">MyJaxbBean myBean = new MyJaxbBean("Agamemnon", 32);</pre></div></div><p><br class="example-break">

                    Above you construct a simple JAXB bean, which could be written in JSON as
                    <code class="literal">{"name":"Agamemnon", "age":32}</code>
                </p><p>
                    Now to build an equivalent <code class="literal">JsonObject</code>/<code class="literal">JSONObject</code> (in terms of
                    resulting JSON expression), you would need several more lines of code. The following example illustrates
                    how to construct the same JSON data using the standard Jakarta EE 9 JSON-Processing API.
                    </p><div class="example"><a name="d0e7701"></a><p class="title"><b>Example&nbsp;9.5.&nbsp;Constructing a <code class="literal">JsonObject</code> (JSON-Processing)</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">JsonObject myObject = Json.createObjectBuilder()
        .add("name", "Agamemnon")
        .add("age", 32)
        .build();</pre></div></div><p><br class="example-break">

                    And at last, here's how the same work can be done with Jettison API.
                    </p><div class="example"><a name="d0e7710"></a><p class="title"><b>Example&nbsp;9.6.&nbsp;Constructing a <code class="literal">JSONObject</code> (Jettison)</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">JSONObject myObject = new JSONObject();
try {
    myObject.put("name", "Agamemnon");
    myObject.put("age", 32);
} catch (JSONException ex) {
    LOGGER.log(Level.SEVERE, "Error ...", ex);
}</pre></div></div><p><br class="example-break">
                </p><p>
                    Media modules that support the low-level JSON parsing and generating approach are <a class="link" href="media.html#json.json-p" title="9.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a>
                    and <a class="link" href="media.html#json.jettison" title="9.1.5.&nbsp;Jettison">Jettison</a>. Unless you have a strong reason for using the non-standard <a class="link" href="media.html#json.jettison" title="9.1.5.&nbsp;Jettison">Jettison</a> API,
                    we recommend you to use the new standard <a class="link" href="media.html#json.json-p" title="9.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a> API instead.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json.moxy"></a>9.1.2.&nbsp;MOXy</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7736"></a>9.1.2.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use MOXy as your JSON provider you need to add <code class="literal">jersey-media-moxy</code> module to your <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-moxy&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-moxy/dependencies.html" target="_top">jersey-media-moxy</a>) on the classpath.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="moxy-registration"></a>9.1.2.2.&nbsp;Configure and register</h4></div></div></div><p>
                    As stated in the <a class="xref" href="deployment.html#deployment.autodiscoverable" title="4.3.&nbsp;Auto-Discoverable Features">Section&nbsp;4.3, &#8220;Auto-Discoverable Features&#8221;</a> as well as earlier in this chapter, MOXy media
                    module is one of the modules where you don't need to explicitly register its <code class="literal">Feature</code>s
                    (<code class="literal">MoxyJsonFeature</code>) in your client/server <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> as this feature is
                    automatically discovered and registered when you add <code class="literal">jersey-media-moxy</code> module to your class-path.
                </p><p>
                    The auto-discoverable <code class="literal">jersey-media-moxy</code> module defines a few properties that can be used to control the
                    automatic registration of <code class="literal">MoxyJsonFeature</code> (besides the generic
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a> an the its client/server variants):

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">CommonProperties.MOXY_JSON_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">ServerProperties.MOXY_JSON_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">ClientProperties.MOXY_JSON_FEATURE_DISABLE</a></p></li></ul></div><p>
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        A manual registration of any other Jersey JSON provider feature (except for <a class="link" href="media.html#json.json-p" title="9.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a>)
                        disables the automated enabling and configuration of <code class="literal">MoxyJsonFeature</code>.
                    </p></div><p>
                    To configure <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>s / <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>s provided by MOXy you can simply
                    create an instance of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html" target="_top">MoxyJsonConfig</a> and set values of needed properties. For most common
                    properties you can use a particular method to set the value of the property or you can use more generic
                    methods to set the property:

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html#property(java.lang.String, java.lang.Object)" target="_top">MoxyJsonConfig#property(java.lang.String, java.lang.Object)</a> - sets a property value for both Marshaller and Unmarshaller.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html#marshallerProperty(java.lang.String, java.lang.Object)" target="_top">MoxyJsonConfig#marshallerProperty(java.lang.String, java.lang.Object)</a> - sets a property value for Marshaller.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html#unmarshallerProperty(java.lang.String, java.lang.Object)" target="_top">MoxyJsonConfig#unmarshallerProperty(java.lang.String, java.lang.Object)</a> - sets a property value for Unmarshaller.
                            </p></li></ul></div><p>

                    </p><div class="example"><a name="d0e7837"></a><p class="title"><b>Example&nbsp;9.7.&nbsp;<a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html" target="_top">MoxyJsonConfig</a> - Setting properties.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Map&lt;String, String&gt; namespacePrefixMapper = new HashMap&lt;String, String&gt;();
namespacePrefixMapper.put("http://www.w3.org/2001/XMLSchema-instance", "xsi");

final MoxyJsonConfig configuration = new MoxyJsonConfig()
        .setNamespacePrefixMapper(namespacePrefixMapper)
        .setNamespaceSeparator(':');
                        </pre></div></div><p><br class="example-break">

                    In order to make <code class="literal">MoxyJsonConfig</code> visible for MOXy you need to create and register
                    <code class="literal">ContextResolver&lt;T&gt;</code> in your client/server code.

                    </p><div class="example"><a name="d0e7851"></a><p class="title"><b>Example&nbsp;9.8.&nbsp;Creating <code class="literal">ContextResolver&lt;MoxyJsonConfig&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Map&lt;String, String&gt; namespacePrefixMapper = new HashMap&lt;String, String&gt;();
namespacePrefixMapper.put("http://www.w3.org/2001/XMLSchema-instance", "xsi");

final MoxyJsonConfig moxyJsonConfig = MoxyJsonConfig()
            .setNamespacePrefixMapper(namespacePrefixMapper)
            .setNamespaceSeparator(':');

final ContextResolver&lt;MoxyJsonConfig&gt; jsonConfigResolver = moxyJsonConfig.resolver();
</pre></div></div><p><br class="example-break">
                </p><p>
                    Another way to pass configuration properties to the underlying <code class="literal">MOXyJsonProvider</code> is to set
                    them directly into your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> instance (see an example below). These are overwritten by
                    properties set into the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html" target="_top">MoxyJsonConfig</a>.

                    </p><div class="example"><a name="d0e7870"></a><p class="title"><b>Example&nbsp;9.9.&nbsp;Setting properties for MOXy providers into <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
                            .property(MarshallerProperties.JSON_NAMESPACE_SEPARATOR, ".")
                            // further configuration</pre></div></div><p><br class="example-break">
                </p><p>
                    There are some properties for which Jersey sets the default value when
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> / <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> from MOXy is used and they are:

                    </p><div class="table"><a name="d0e7886"></a><p class="title"><b>Table&nbsp;9.1.&nbsp;Default property values for MOXy <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> / <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a></b></p><div class="table-contents"><table summary="Default property values for MOXy MessageBodyReader<T&gt; / MessageBodyWriter<T&gt;" border="1"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><td align="left"><code class="literal">jakarta.xml.bind.Marshaller#JAXB_FORMATTED_OUTPUT</code></td><td align="left"><code class="literal">false</code></td></tr><tr><td align="left">
                                        <code class="literal">org.eclipse.persistence.jaxb.JAXBContextProperties#JSON_INCLUDE_ROOT</code>
                                    </td><td align="left"><code class="literal">false</code></td></tr><tr><td align="left">
                                        <code class="literal">org.eclipse.persistence.jaxb.MarshallerProperties#JSON_MARSHAL_EMPTY_COLLECTIONS</code>
                                    </td><td align="left"><code class="literal">true</code></td></tr><tr><td align="left">
                                        <code class="literal">org.eclipse.persistence.jaxb.JAXBContextProperties#JSON_NAMESPACE_SEPARATOR</code>
                                    </td><td align="left"><code class="literal">org.eclipse.persistence.oxm.XMLConstants#DOT</code></td></tr></tbody></table></div></div><p><br class="table-break">
                </p><div class="example"><a name="ex-moxy-client"></a><p class="title"><b>Example&nbsp;9.10.&nbsp;Building client with MOXy JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
        // The line below that registers MOXy feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is
        // not disabled.
        .register(MoxyJsonFeature.class)
        .register(jsonConfigResolver)
        .build();</pre></div></div><br class="example-break"><div class="example"><a name="ex-moxy-server"></a><p class="title"><b>Example&nbsp;9.11.&nbsp;Creating JAX-RS application with MOXy JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        .packages("org.glassfish.jersey.examples.jsonmoxy")
        // The line below that registers MOXy feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is
        // not disabled.
        .register(MoxyJsonFeature.class)
        .register(jsonConfigResolver);</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7941"></a>9.1.2.3.&nbsp;Examples</h4></div></div></div><p>
                    Jersey provides a <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-moxy" target="_top">JSON MOXy example</a>
                    on how to use MOXy to consume/produce JSON.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json.json-p"></a>9.1.3.&nbsp;Java API for JSON Processing (JSON-P)</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7952"></a>9.1.3.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use JSON-P as your JSON provider you need to add <code class="literal">jersey-media-json-processing</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-processing&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-processing/dependencies.html" target="_top">jersey-media-json-processing</a>)
                    on the class-path.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jsonp-registration"></a>9.1.3.2.&nbsp;Configure and register</h4></div></div></div><p>
                    As stated in <a class="xref" href="deployment.html#deployment.autodiscoverable" title="4.3.&nbsp;Auto-Discoverable Features">Section&nbsp;4.3, &#8220;Auto-Discoverable Features&#8221;</a> JSON-Processing media module is one of the
                    modules where you don't need to explicitly register its
                    <code class="literal">Feature</code>s (<code class="literal">JsonProcessingFeature</code>) in your client/server
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> as this feature is automatically discovered and registered when you add
                    <code class="literal">jersey-media-json-processing</code> module to your classpath.
                </p><p>
                    As for the other modules, <code class="literal">jersey-media-json-processing</code> has also few properties that can affect the
                    registration of <code class="literal">JsonProcessingFeature</code>
                    (besides <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a> and the like):

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/CommonProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">CommonProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ServerProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">ServerProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ClientProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">ClientProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p></li></ul></div><p>
                </p><p>
                    To configure <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>s / <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>s provided by JSON-P you can simply
                    add values for supported properties into the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configuration.html" target="_top">Configuration</a> instance (client/server). Currently
                    supported are these properties:

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <code class="literal">JsonGenerator.PRETTY_PRINTING</code>
                                ("<code class="literal">jakarta.json.stream.JsonGenerator.prettyPrinting</code>")
                            </p></li></ul></div><p>
                </p><div class="example"><a name="d0e8035"></a><p class="title"><b>Example&nbsp;9.12.&nbsp;Building client with JSON-Processing JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientBuilder.newClient(new ClientConfig()
        // The line below that registers JSON-Processing feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is not disabled.
        .register(JsonProcessingFeature.class)
        .property(JsonGenerator.PRETTY_PRINTING, true)
);</pre></div></div><br class="example-break"><div class="example"><a name="d0e8040"></a><p class="title"><b>Example&nbsp;9.13.&nbsp;Creating JAX-RS application with JSON-Processing JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        // The line below that registers JSON-Processing feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is not disabled.
        .register(JsonProcessingFeature.class)
        .packages("org.glassfish.jersey.examples.jsonp")
        .property(JsonGenerator.PRETTY_PRINTING, true);</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8045"></a>9.1.3.3.&nbsp;Examples</h4></div></div></div><p>Jersey provides a
                    <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-processing-webapp" target="_top">JSON Processing example</a>
                    on how to use JSON-Processing to consume/produce JSON.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json.jackson"></a>9.1.4.&nbsp;Jackson (2.x)</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8056"></a>9.1.4.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use Jackson 2.x as your JSON provider you need to add <code class="literal">jersey-media-json-jackson</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-jackson/dependencies.html" target="_top">jersey-media-json-jackson</a>)
                    on the classpath.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jackson-registration"></a>9.1.4.2.&nbsp;Configure and register</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Note that namespace for Jackson 2.x is (<code class="literal">com.fasterxml.jackson</code>).
                    </p></div><p>
                    Jackson JSON processor could be controlled via providing a custom Jackson 2 <a class="link" href="http://fasterxml.github.io/jackson-databind/javadoc/2.3.0/com/fasterxml/jackson/databind/ObjectMapper.html" target="_top">ObjectMapper</a> instance.
                    This could be handy if you need to redefine the default Jackson behaviour and to fine-tune how your JSON data
                    structures look like. Detailed description of all Jackson features is out of scope of this guide. The example
                    below gives you a hint on how to wire your <code class="literal">ObjectMapper</code>
                    instance into your Jersey application.
                </p><p>
                    In order to use Jackson as your JSON (JAXB/POJO) provider you need to register <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jackson/JacksonFeature.html" target="_top">JacksonFeature</a>
                    and a <code class="literal">ContextResolver&lt;T&gt;</code> for <code class="literal">ObjectMapper</code>,
                    if needed, in your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> (client/server).

                    </p><div class="example"><a name="d0e8104"></a><p class="title"><b>Example&nbsp;9.14.&nbsp;<code class="literal">ContextResolver&lt;ObjectMapper&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class MyObjectMapperProvider implements ContextResolver&lt;ObjectMapper&gt; {

    final ObjectMapper defaultObjectMapper;

    public MyObjectMapperProvider() {
        defaultObjectMapper = createDefaultMapper();
    }

    @Override
    public ObjectMapper getContext(Class&lt;?&gt; type) {
            return defaultObjectMapper;
        }
    }

    private static ObjectMapper createDefaultMapper() {
        final ObjectMapper result = new ObjectMapper();
        result.configure(Feature.INDENT_OUTPUT, true);

        return result;
    }

    // ...
}</pre><p>To view the complete example source code, see
    <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-jackson/src/main/java/org/glassfish/jersey/examples/jackson/MyObjectMapperProvider.java" target="_top">
    MyObjectMapperProvider</a> class from the
    <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-jackson" target="_top">JSON-Jackson</a> example.</p></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8119"></a><p class="title"><b>Example&nbsp;9.15.&nbsp;Building client with Jackson JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
        .register(MyObjectMapperProvider.class)  // No need to register this provider if no special configuration is required.
        .register(JacksonFeature.class)
        .build();</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8125"></a><p class="title"><b>Example&nbsp;9.16.&nbsp;Creating JAX-RS application with Jackson JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        .packages("org.glassfish.jersey.examples.jackson")
        .register(MyObjectMapperProvider.class)  // No need to register this provider if no special configuration is required.
        .register(JacksonFeature.class);</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8131"></a>9.1.4.3.&nbsp;Examples</h4></div></div></div><p>
                    Jersey provides <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-jackson" target="_top">JSON Jackson (2.x) example</a>
                    showing how to use Jackson to consume/produce JSON.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json.jettison"></a>9.1.5.&nbsp;Jettison</h3></div></div></div><p>
                JAXB approach for (de)serializing JSON in Jettison module provides, in addition to using pure JAXB,
                configuration options that could be set on an <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jettison/JettisonConfig.html" target="_top">JettisonConfig</a> instance. The instance could be then
                further used to create a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jettison/JettisonJaxbContext.html" target="_top">JettisonJaxbContext</a>, which serves as a main configuration point in this
                area.
                To pass your specialized <code class="literal">JettisonJaxbContext</code> to Jersey, you will finally need to implement
                a JAXBContext <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ContextResolver.html" target="_top">ContextResolver&lt;T&gt;</a> (see below).
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8156"></a>9.1.5.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use Jettison as your JSON provider you need to add <code class="literal">jersey-media-json-jettison</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-jettison&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-jettison/dependencies.html" target="_top">jersey-media-json-jettison</a>) on
                    the classpath.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8173"></a>9.1.5.2.&nbsp;JSON Notations</h4></div></div></div><p>
                    <code class="literal">JettisonConfig</code> allows you to use two JSON notations. Each of these notations serializes
                    JSON in a different way. Following is a list of supported notations:

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>JETTISON_MAPPED (default notation)</p></li><li class="listitem"><p>BADGERFISH</p></li></ul></div><p>

                    You might want to use one of these notations, when working with more complex XML documents. Namely when you
                    deal with multiple XML namespaces in your JAXB beans.
                </p><p>
                    Individual notations and their further configuration options are described below. Rather then explaining
                    rules for mapping XML constructs into JSON, the notations will be described using a simple example. Following
                    are JAXB beans, which will be used.

                    </p><div class="example"><a name="d0e8191"></a><p class="title"><b>Example&nbsp;9.17.&nbsp;JAXB beans for JSON supported notations description, simple address bean</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class Address {
    public String street;
    public String town;

    public Address(){}

    public Address(String street, String town) {
        this.street = street;
        this.town = town;
    }
}</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8197"></a><p class="title"><b>Example&nbsp;9.18.&nbsp;JAXB beans for JSON supported notations description, contact bean</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class Contact {

    public int id;
    public String name;
    public List&lt;Address&gt; addresses;

    public Contact() {};

    public Contact(int id, String name, List&lt;Address&gt; addresses) {
        this.name = name;
        this.id = id;
        this.addresses =
            (addresses != null) ? new LinkedList&lt;Address&gt;(addresses) : null;
    }
}</pre></div></div><p><br class="example-break">
                </p><p>
                    Following text will be mainly working with a contact bean initialized with:

                    </p><div class="example"><a name="d0e8205"></a><p class="title"><b>Example&nbsp;9.19.&nbsp;JAXB beans for JSON supported notations description, initialization</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Address[] addresses = {new Address("Long Street 1", "Short Village")};
Contact contact = new Contact(2, "Bob", Arrays.asList(addresses));</pre></div></div><p><br class="example-break">

                    I.e. contact bean with <code class="literal">id=2</code>, <code class="literal">name="Bob"</code> containing
                    a single address (<code class="literal">street="Long Street 1"</code>, <code class="literal">town="Short Village"</code>).
                </p><p>
                    All below described configuration options are documented also in api-docs at <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jettison/JettisonConfig.html" target="_top">JettisonConfig</a>.
                </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8228"></a>9.1.5.2.1.&nbsp;Jettison mapped notation</h5></div></div></div><p>
                        If you need to deal with various XML namespaces, you will find Jettison <code class="literal">mapped</code>
                        notation pretty useful. Lets define a particular namespace for <code class="code">id</code> item:

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
@XmlElement(namespace="http://example.com")
public int id;
...</pre><p>

                        Then you simply configure a mapping from XML namespace into JSON prefix as follows:

                        </p><div class="example"><a name="json.jaxb.jettison.mapped.ns.def"></a><p class="title"><b>Example&nbsp;9.20.&nbsp;
                                XML namespace to JSON mapping configuration for Jettison based <code class="literal">mapped</code> notation
                            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Map&lt;String,String&gt; ns2json = new HashMap&lt;String, String&gt;();
ns2json.put("http://example.com", "example");
context = new JettisonJaxbContext(
    JettisonConfig.mappedJettison().xml2JsonNs(ns2json).build(),
    types);</pre></div></div><p><br class="example-break">

                        Resulting JSON will look like in the example below.

                        </p><div class="example"><a name="d0e8251"></a><p class="title"><b>Example&nbsp;9.21.&nbsp;JSON expression with XML namespaces mapped into JSON</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "contact":{
      "example.id":2,
      "name":"Bob",
      "addresses":{
         "street":"Long Street 1",
         "town":"Short Village"
      }
   }
}</pre></div></div><p><br class="example-break">

                        Please note, that <code class="code">id</code> item became <code class="code">example.id</code> based on the XML namespace mapping.
                        If you have more XML namespaces in your XML, you will need to configure appropriate mapping for all of
                        them.
                    </p><p>
                        Another configurable option introduced in Jersey version 2.2 is related to serialization of JSON arrays with Jettison's
                        mapped notation. When serializing elements representing single item lists/arrays, you might want to utilise
                        the following Jersey configuration method to explicitly name which elements to treat as arrays no matter what the actual content is.

                        </p><div class="example"><a name="json.jaxb.jettison.mapped.array.def"></a><p class="title"><b>Example&nbsp;9.22.&nbsp;
                                JSON Array configuration for Jettison based <code class="literal">mapped</code> notation
                            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">context = new JettisonJaxbContext(
    JettisonConfig.mappedJettison().serializeAsArray("name").build(),
    types);</pre></div></div><p><br class="example-break">

                        Resulting JSON will look like in the example below, unimportant lines removed for sanity.

                        </p><div class="example"><a name="d0e8274"></a><p class="title"><b>Example&nbsp;9.23.&nbsp;JSON expression with JSON arrays explicitly configured via Jersey</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "contact":{
      ...
      "name":["Bob"],
      ...
   }
}</pre></div></div><p><br class="example-break">

                    </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d0e8280"></a>9.1.5.2.2.&nbsp;Badgerfish notation</h5></div></div></div><p>
                        From JSON and JavaScript perspective, this notation is definitely the worst readable one.
                        You will probably not want to use it, unless you need to make sure your JAXB beans could be flawlessly
                        written and read back to and from JSON, without bothering with any formatting configuration, namespaces,
                        etc.
                    </p><p>
                        <code class="literal">JettisonConfig</code> instance using <code class="literal">badgerfish</code> notation could be built
                        with

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">JettisonConfig.badgerFish().build()</pre><p>

                        and the JSON output JSON will be as follows.

                        </p><div class="example"><a name="d0e8296"></a><p class="title"><b>Example&nbsp;9.24.&nbsp;JSON expression produced using <code class="literal">badgerfish</code> notation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "contact":{
      "id":{
         "$":"2"
      },
      "name":{
         "$":"Bob"
      },
      "addresses":{
         "street":{
            "$":"Long Street 1"
         },
         "town":{
            "$":"Short Village"
         }
      }
   }
}</pre></div></div><p><br class="example-break">
                    </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="jettison-registration"></a>9.1.5.3.&nbsp;Configure and register</h4></div></div></div><p>
                    In order to use Jettison as your JSON (JAXB/POJO) provider you need to register <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/jettison/JettisonFeature.html" target="_top">JettisonFeature</a>
                    and a <code class="literal">ContextResolver&lt;T&gt;</code> for <code class="literal">JAXBContext</code> (if needed) in your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a>
                    (client/server).

                    </p><div class="example"><a name="d0e8322"></a><p class="title"><b>Example&nbsp;9.25.&nbsp;<code class="literal">ContextResolver&lt;ObjectMapper&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class JaxbContextResolver implements ContextResolver&lt;JAXBContext&gt; {

    private final JAXBContext context;
    private final Set&lt;Class&lt;?&gt;&gt; types;
    private final Class&lt;?&gt;[] cTypes = {Flights.class, FlightType.class, AircraftType.class};

    public JaxbContextResolver() throws Exception {
        this.types = new HashSet&lt;Class&lt;?&gt;&gt;(Arrays.asList(cTypes));
        this.context = new JettisonJaxbContext(JettisonConfig.DEFAULT, cTypes);
    }

    @Override
    public JAXBContext getContext(Class&lt;?&gt; objectType) {
        return (types.contains(objectType)) ? context : null;
    }
}</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8329"></a><p class="title"><b>Example&nbsp;9.26.&nbsp;Building client with Jettison JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
        .register(JaxbContextResolver.class)  // No need to register this provider if no special configuration is required.
        .register(JettisonFeature.class)
        .build();</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8335"></a><p class="title"><b>Example&nbsp;9.27.&nbsp;Creating JAX-RS application with Jettison JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        .packages("org.glassfish.jersey.examples.jettison")
        .register(JaxbContextResolver.class)  // No need to register this provider if no special configuration is required.
        .register(JettisonFeature.class);</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8341"></a>9.1.5.4.&nbsp;Examples</h4></div></div></div><p>
                    Jersey provides an <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-jettison" target="_top">JSON Jettison example</a>
                    on how to use Jettison to consume/produce JSON.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8349"></a>9.1.6.&nbsp;<code class="literal">@JSONP</code> - JSON with Padding Support</h3></div></div></div><p>
                Jersey provides out-of-the-box support for <a class="link" href="http://en.wikipedia.org/wiki/JSONP" target="_top">JSONP</a>
                - JSON with padding. The following conditions has to be met to take advantage of this capability:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            Resource method, which should return wrapped JSON, needs to be annotated with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/JSONP.html" target="_top">@JSONP</a>
                            annotation.
                        </p></li><li class="listitem"><p>
                            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for <code class="literal">application/json</code> media type, which also accepts
                            the return type of the resource method, needs to be registered (see <a class="link" href="media.html#json" title="9.1.&nbsp;JSON">JSON</a>
                            section of this chapter).
                        </p></li><li class="listitem"><p>
                            User's request has to contain <code class="literal">Accept</code> header with one of the JavaScript media types
                            defined (see below).
                        </p></li></ul></div><p>

                Acceptable media types compatible with <code class="literal">@JSONP</code> are: <code class="literal">application/javascript</code>,
                <code class="literal">application/x-javascript</code>, <code class="literal">application/ecmascript</code>,
                <code class="literal">text/javascript</code>, <code class="literal">text/x-javascript</code>, <code class="literal">text/ecmascript</code>,
                <code class="literal">text/jscript</code>.

                </p><div class="example"><a name="d0e8409"></a><p class="title"><b>Example&nbsp;9.28.&nbsp;Simplest case of using <code class="literal">@JSONP</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@JSONP
@Produces({"application/json", "application/javascript"})
public JaxbBean getSimpleJSONP() {
    return new JaxbBean("jsonp");
}</pre></div></div><p><br class="example-break">

                Assume that we have registered a JSON providers and that the <code class="literal">JaxbBean</code> looks like:

                </p><div class="example"><a name="d0e8420"></a><p class="title"><b>Example&nbsp;9.29.&nbsp;JaxbBean for @JSONP example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class JaxbBean {

    private String value;

    public JaxbBean() {}

    public JaxbBean(final String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    public void setValue(final String value) {
        this.value = value;
    }
}</pre></div></div><p><br class="example-break">

                When you send a <code class="literal">GET</code> request with <code class="literal">Accept</code> header set to
                <code class="literal">application/javascript</code> you'll get a result entity that look like:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">callback({
    "value" : "jsonp",
})</pre><p>
            </p><p>
                There are, of course, ways to configure wrapping method of the returned entity which defaults to
                <code class="literal">callback</code> as you can see in the previous example.
                <code class="literal">@JSONP</code> has two parameters that can be configured: <code class="literal">callback</code> and
                <code class="literal">queryParam</code>.
                <code class="literal">callback</code> stands for the name of the JavaScript callback function defined by the application.
                The second parameter, <code class="literal">queryParam</code>, defines the name of the query parameter holding the name of
                the callback function to be used (if present in the request). Value of <code class="literal">queryParam</code> defaults to
                <code class="literal">__callback</code> so even if you do not set the name of the query parameter yourself, client can
                always affect the result name of the wrapping JavaScript callback method.

                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        <code class="literal">queryParam</code> value (if set) always takes precedence over <code class="literal">callback</code>
                        value.
                    </p></div><p>
            </p><p>
                Lets modify our example a little bit:

                </p><div class="example"><a name="d0e8476"></a><p class="title"><b>Example&nbsp;9.30.&nbsp;Example of <code class="literal">@JSONP</code> with configured parameters.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces({"application/json", "application/javascript"})
@JSONP(callback = "eval", queryParam = "jsonpCallback")
public JaxbBean getSimpleJSONP() {
    return new JaxbBean("jsonp");
}</pre></div></div><p><br class="example-break">

                And make two requests:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">curl -X GET http://localhost:8080/jsonp</pre><p>

                will return

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">eval({
    "value" : "jsonp",
})</pre><p>

                and the

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">curl -X GET http://localhost:8080/jsonp?jsonpCallback=alert</pre><p>

                will return

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">alert({
    "value" : "jsonp",
})</pre><p>
            </p><p><b>Example.&nbsp;</b>
                    You can take a look at a provided
                    <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-with-padding" target="_top">JSON with Padding example</a>.
                </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json.json-b"></a>9.1.7.&nbsp;Java API for JSON Binding (JSON-B)</h3></div></div></div><p>
                Jersey uses <a class="link" href="https://eclipse-ee4j.github.io/yasson/" target="_top">Yasson</a> for JSON Binding (JSR-367) implementation.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8513"></a>9.1.7.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use JSON-B as your JSON provider you need to add <code class="literal">jersey-media-json-binding</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies
                    (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-json-binding/dependencies.html" target="_top">jersey-media-json-binding</a>) on the classpath.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="json.jsonb-registration"></a>9.1.7.2.&nbsp;Configure and register</h4></div></div></div><p>
                    As stated in <a class="xref" href="deployment.html#deployment.autodiscoverable" title="4.3.&nbsp;Auto-Discoverable Features">Section&nbsp;4.3, &#8220;Auto-Discoverable Features&#8221;</a> JSON-Binding media module is one of the
                    modules where you don't need to explicitly register its
                    <code class="literal">Feature</code>s (<code class="literal">JsonBindingFeature</code>) in your client/server
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a> as this feature is automatically discovered and registered when you add
                    <code class="literal">jersey-media-json-binding</code> module to your classpath.
                </p><p>
                    To use custom preconfigured JSON-B, it is simply possible to register
                    a <code class="literal">ContextResolver&lt;T&gt;</code> for <code class="literal">Jsonb</code> in your <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a>
                    (client/server) and configure <a class="link" href="https://javaee.github.io/javaee-spec/javadocs/javax/json/bind/JsonbConfig" target="_top">JsonbConfig</a>.
                </p><div class="example"><a name="d0e8563"></a><p class="title"><b>Example&nbsp;9.31.&nbsp;<code class="literal">ContextResolver&lt;Jsonb&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class JsonbContextResolver implements ContextResolver&lt;Jsonb&gt; {

        @Override
        public Jsonb getContext(Class&gt;?&lt; type) {
            JsonbConfig config = new JsonbConfig();
            // configure JsonbConfig
            ...
            return JsonbBuilder.create(config);
        }
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e8569"></a><p class="title"><b>Example&nbsp;9.32.&nbsp;<code class="literal">Register the feature and ContextResolver&lt;Jsonb&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientBuilder.newClient(new ClientConfig()
    // The line below that registers JSON-Binding feature can be
    // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is not disabled.
    .register(JsonBindingFeature.class)
    .register(JsonbContextResolver.class)
);</pre></div></div><br class="example-break"><p><b>Example.&nbsp;</b>
                        You can take a look at a provided
                        <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/json-binding-webapp" target="_top">JSON-B example.</a>.
                    </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml"></a>9.2.&nbsp;XML</h2></div></div></div><p>
            As you probably already know, Jersey uses <code class="literal">MessageBodyWriter&lt;T&gt;</code>s and <code class="literal">MessageBodyReader&lt;T&gt;</code>s to
            parse incoming requests and create outgoing responses. Every user can create its own representation but... this is not
            recommended way how to do things. XML is proven standard for interchanging information, especially in web services.
            Jerseys supports low level data types used for direct manipulation and JAXB XML entities.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8594"></a>9.2.1.&nbsp;Low level XML support</h3></div></div></div><p>
                Jersey currently support several low level data types: <a class="link" href="http://docs.oracle.com/javase/7/docs/api/javax/xml/transform/stream/StreamSource.html" target="_top">StreamSource</a>, <a class="link" href="http://docs.oracle.com/javase/7/docs/api/javax/xml/transform/sax/SAXSource.html" target="_top">SAXSource</a>, <a class="link" href="http://docs.oracle.com/javase/7/docs/api/javax/xml/transform/dom/DOMSource.html" target="_top">DOMSource</a>
                and <a class="link" href="http://docs.oracle.com/javase/7/docs/api/org/w3c/dom/Document.html" target="_top">Document</a>. You can use these types as the return type or as a method (resource) parameter.
                Lets say we want to test this feature and we have
                <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/helloworld" target="_top">helloworld example</a> as a starting point.
                All we need to do is add methods (resources) which consumes and produces XML and types mentioned above will be
                used.
            </p><div class="example"><a name="d0e8614"></a><p class="title"><b>Example&nbsp;9.33.&nbsp;Low level XML test - methods added to <code class="literal">HelloWorldResource.java</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Path("StreamSource")
public StreamSource getStreamSource(StreamSource streamSource) {
    return streamSource;
}

@POST
@Path("SAXSource")
public SAXSource getSAXSource(SAXSource saxSource) {
    return saxSource;
}

@POST
@Path("DOMSource")
public DOMSource getDOMSource(DOMSource domSource) {
    return domSource;
}

@POST
@Path("Document")
public Document getDocument(Document document) {
    return document;
}</pre></div></div><br class="example-break"><p>
                Both <code class="literal">MessageBodyWriter&lt;T&gt;</code> and <code class="literal">MessageBodyReader&lt;T&gt;</code> are used in this case, all we need is
                a <code class="literal">POST</code> request with some XML document as a request entity. To keep this as simple as possible only root
                element with no content will be sent: <code class="literal">"&lt;test /&gt;"</code>. You can create JAX-RS client to do that
                or use some other tool, for example <code class="literal">curl</code>:
                </p><div class="informalexample"><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">curl -v http://localhost:8080/base/helloworld/StreamSource -d "&lt;test/&gt;"</pre></div><p>
                You should get exactly the same XML from our service as is present in the request; in this case, XML headers are
                added to response but content stays. Feel free to iterate through all resources.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8642"></a>9.2.2.&nbsp;Getting started with JAXB</h3></div></div></div><p>
                Good start for people which already have some experience with JAXB annotations
                is <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/jaxb" target="_top">JAXB example</a>. You can see various use-cases there.
                This text is mainly meant for those who don't have prior experience with JAXB. Don't expect that all possible
                annotations and their combinations will be covered in this chapter,
                <a class="link" href="http://jaxb.java.net" target="_top">JAXB (JSR 222 implementation)</a>
                is pretty complex and comprehensive. But if you just want to know how you can interchange XML messages with your
                REST service, you are looking at the right chapter.
            </p><p>
                Lets start with simple example. Lets say we have class <code class="literal">Planet</code> and service which produces
                "Planets".
            </p><div class="example"><a name="d0e8658"></a><p class="title"><b>Example&nbsp;9.34.&nbsp;Planet class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class Planet {
    public int id;
    public String name;
    public double radius;
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e8663"></a><p class="title"><b>Example&nbsp;9.35.&nbsp;Resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("planet")
public class Resource {

    @GET
    @Produces(MediaType.APPLICATION_XML)
    public Planet getPlanet() {
        final Planet planet = new Planet();

        planet.id = 1;
        planet.name = "Earth";
        planet.radius = 1.0;

        return planet;
    }
}</pre></div></div><br class="example-break"><p>
                You can see there is some extra annotation declared on <code class="literal">Planet</code> class, particularly
                <a class="link" href="https://eclipse-ee4j.github.io/jaxb-ri/docs/api/jakarta.xml.bind/annotation/XmlRootElement.html" target="_top">@XmlRootElement</a>. This is an JAXB annotation which maps java classes
                to XML elements. We don't need to specify anything else, because <code class="literal">Planet</code> is very simple class
                and all fields are public. In this case, XML element name will be derived from the class name or
                you can set the name property: <code class="literal">@XmlRootElement(name="yourName")</code>.
            </p><p>
                Our resource class will respond to <code class="literal">GET /planet</code> with

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;planet&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;name&gt;Earth&lt;/name&gt;
    &lt;radius&gt;1.0&lt;/radius&gt;
&lt;/planet&gt;</pre><p>

                which might be exactly what we want... or not. Or we might not really care, because we
                can use JAX-RS client for making requests to this resource and this is easy as:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">
                    Planet planet = webTarget.path("planet").request(MediaType.APPLICATION_XML_TYPE).get(Planet.class);
                </pre><p>
                There is pre-created <code class="literal">WebTarget</code> object which points to our applications context root and
                we simply add path (in our case its <code class="literal">planet</code>), accept header (not mandatory, but service could
                provide different content based on this header; for example <code class="literal">text/html</code> can be served for web
                browsers) and at the end we specify that we are expecting <code class="literal">Planet</code> class via <code class="literal">GET</code>
                request.
            </p><p>
                There may be need for not just producing XML, we might want to consume it as well.

                </p><div class="example"><a name="d0e8710"></a><p class="title"><b>Example&nbsp;9.36.&nbsp;Method for consuming Planet</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes(MediaType.APPLICATION_XML)
public void setPlanet(Planet planet) {
    System.out.println("setPlanet " + planet);
}</pre></div></div><p><br class="example-break">

                After valid request is made, service will print out string representation of <code class="literal">Planet</code>, which can
                look like <code class="literal">Planet{id=2, name='Mars', radius=1.51}</code>. With JAX-RS client you can do:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">
                    webTarget.path("planet").request().post(Entity.xml(planet));
                </pre><p>
            </p><p>
                If there is a need for some other (non default) XML representation, other JAXB annotations would
                need to be used. This process is usually simplified by generating java source from XML Schema which is
                done by <code class="literal">xjc</code> which is XML to java compiler and it is part of JAXB.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8730"></a>9.2.3.&nbsp;POJOs</h3></div></div></div><p>
                Sometimes you can't / don't want to add JAXB annotations to source code and you still want to have resources
                consuming and producing XML representation of your classes. In this case, <a class="link" href="https://eclipse-ee4j.github.io/jaxb-ri/docs/api/jakarta.xml.bind/JAXBElement.html" target="_top">JAXBElement</a> class should help
                you. Let's redo planet resource but this time we won't have an <a class="link" href="https://eclipse-ee4j.github.io/jaxb-ri/docs/api/jakarta.xml.bind/annotation/XmlRootElement.html" target="_top">@XmlRootElement</a> annotation on
                <code class="literal">Planet</code> class.
            </p><div class="example"><a name="d0e8744"></a><p class="title"><b>Example&nbsp;9.37.&nbsp;Resource class - JAXBElement</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("planet")
public class Resource {

    @GET
    @Produces(MediaType.APPLICATION_XML)
    public JAXBElement&lt;Planet&gt; getPlanet() {
        Planet planet = new Planet();

        planet.id = 1;
        planet.name = "Earth";
        planet.radius = 1.0;

        return new JAXBElement&lt;Planet&gt;(new QName("planet"), Planet.class, planet);
    }

    @POST
    @Consumes(MediaType.APPLICATION_XML)
    public void setPlanet(JAXBElement&lt;Planet&gt; planet) {
        System.out.println("setPlanet " + planet.getValue());
    }
}</pre></div></div><br class="example-break"><p>
                As you can see, everything is little more complicated with <code class="literal">JAXBElement</code>. This is because now you need
                to explicitly set element name for <code class="literal">Planet</code> class XML representation. Client side is even more
                complicated than server side because you can't do <code class="literal">JAXBElement&lt;Planet&gt;</code> so JAX-RS client
                API provides way how to workaround it by declaring subclass of <code class="literal">GenericType&lt;T&gt;</code>.
            </p><div class="example"><a name="d0e8763"></a><p class="title"><b>Example&nbsp;9.38.&nbsp;Client side - JAXBElement</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// GET
GenericType&lt;JAXBElement&lt;Planet&gt;&gt; planetType = new GenericType&lt;JAXBElement&lt;Planet&gt;&gt;() {};

Planet planet = (Planet) webTarget.path("planet").request(MediaType.APPLICATION_XML_TYPE).get(planetType).getValue();
System.out.println("### " + planet);

// POST
planet = new Planet();

// ...

webTarget.path("planet").post(new JAXBElement&lt;Planet&gt;(new QName("planet"), Planet.class, planet));</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8768"></a>9.2.4.&nbsp;Using custom JAXBContext</h3></div></div></div><p>In some scenarios you can take advantage of using custom <a class="link" href="https://eclipse-ee4j.github.io/jaxb-ri/docs/api/jakarta.xml.bind/JAXBContext.html" target="_top">JAXBContext</a>. Creating
                <code class="literal">JAXBContext</code> is an expensive operation and if you already have one created, same instance
                can be used by Jersey. Other possible use-case for this is when you need to set some specific things
                to <code class="literal">JAXBContext</code>, for example to set a different class loader.
            </p><div class="example"><a name="d0e8782"></a><p class="title"><b>Example&nbsp;9.39.&nbsp;PlanetJAXBContextProvider</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class PlanetJAXBContextProvider implements ContextResolver&lt;JAXBContext&gt; {
    private JAXBContext context = null;

    public JAXBContext getContext(Class&lt;?&gt; type) {
        if (type != Planet.class) {
            return null; // we don't support nothing else than Planet
        }

        if (context == null) {
            try {
                context = JAXBContext.newInstance(Planet.class);
            } catch (JAXBException e) {
                // log warning/error; null will be returned which indicates that this
                // provider won't/can't be used.
            }
        }

        return context;
    }
}</pre></div></div><br class="example-break"><p>
                Sample above shows simple <code class="literal">JAXBContext</code> creation, all you need to do is put
                this <code class="literal">@Provider</code> annotated class somewhere where Jersey can find it. Users sometimes
                have problems with using provider classes on client side, so just to reminder - you have to
                register them in the client config (client does not do anything like package scanning done by server).
            </p><div class="example"><a name="d0e8795"></a><p class="title"><b>Example&nbsp;9.40.&nbsp;Using Provider with JAX-RS client</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
ClientConfig config = new ClientConfig();
config.register(PlanetJAXBContextProvider.class);

Client client = ClientBuilder.newClient(config);
                </pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8800"></a>9.2.5.&nbsp;MOXy</h3></div></div></div><p>
                If you want to use <a class="link" href="http://www.eclipse.org/eclipselink/moxy.php" target="_top">MOXy</a> as your JAXB
                implementation instead of JAXB RI you have two options. You can either use the standard JAXB mechanisms to define
                the <code class="literal">JAXBContextFactory</code> from which a <code class="literal">JAXBContext</code> instance would be obtained (for more
                on this topic, read JavaDoc on <a class="link" href="https://eclipse-ee4j.github.io/jaxb-ri/docs/api/jakarta.xml.bind/JAXBContext.html" target="_top">JAXBContext</a>) or you can add <code class="literal">jersey-media-moxy</code> module to
                your project and register/configure
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/moxy/xml/MoxyXmlFeature.html" target="_top">MoxyXmlFeature</a> class/instance in
                the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Configurable.html" target="_top">Configurable</a>.
            </p><div class="example"><a name="d0e8826"></a><p class="title"><b>Example&nbsp;9.41.&nbsp;Add <code class="literal">jersey-media-moxy</code> dependency.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-moxy&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><br class="example-break"><div class="example"><a name="d0e8834"></a><p class="title"><b>Example&nbsp;9.42.&nbsp;Register the <code class="literal">MoxyXmlFeature</code> class.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final ResourceConfig config = new ResourceConfig()
    .packages("org.glassfish.jersey.examples.xmlmoxy")
    .register(MoxyXmlFeature.class);</pre></div></div><br class="example-break"><div class="example"><a name="d0e8842"></a><p class="title"><b>Example&nbsp;9.43.&nbsp;Configure and register an <code class="literal">MoxyXmlFeature</code> instance.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Configure Properties.
final Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
// ...

// Obtain a ClassLoader you want to use.
final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

final ResourceConfig config = new ResourceConfig()
    .packages("org.glassfish.jersey.examples.xmlmoxy")
    .register(new MoxyXmlFeature(
        properties,
        classLoader,
        true, // Flag to determine whether eclipselink-oxm.xml file should be used for lookup.
        CustomClassA.class, CustomClassB.class  // Classes to be bound.
    ));</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="multipart"></a>9.3.&nbsp;Multipart</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8855"></a>9.3.1.&nbsp;Overview</h3></div></div></div><p>
                The classes in this module provide an integration of <code class="literal">multipart/*</code> request and response bodies
                in a JAX-RS runtime environment. The set of registered providers is leveraged, in that the content type for a body
                part of such a message reuses the same <code class="literal">MessageBodyReader&lt;T&gt;</code>/<code class="literal">MessageBodyWriter&lt;T&gt;</code>
                implementations as would be used for that content type as a standalone entity.
            </p><p>
                The following list of general MIME MultiPart features is currently supported:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            The <code class="literal">MIME-Version: 1.0</code> HTTP header is included on generated responses.
                            It is accepted, but not required, on processed requests.
                        </p></li><li class="listitem"><p>
                            A <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> implementation for consuming MIME MultiPart entities.
                        </p></li><li class="listitem"><p>
                            A <code class="literal">MessageBodyWriter&lt;T&gt;</code> implementation for producing MIME MultiPart entities.
                            The appropriate <code class="literal">@Provider</code> is used to serialize each body part, based on its media type.
                        </p></li><li class="listitem"><p>
                            Optional creation of an appropriate <code class="literal">boundary</code> parameter on a generated
                            <code class="literal">Content-Type</code> header, if not already present.
                        </p></li></ul></div><p>
            </p><p>
                For more information refer to <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/package-summary.html" target="_top">Multi Part</a>.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8908"></a>9.3.1.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use multipart features you need to add <code class="literal">jersey-media-multipart</code> module to your <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-multipart&lt;/artifactId&gt;
    &lt;version&gt;3.0.2&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/project-info/3.0.2/jersey/project/jersey-media-multipart/dependencies.html" target="_top">jersey-media-multipart</a>) on the
                    class-path.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8925"></a>9.3.1.2.&nbsp;Registration</h4></div></div></div><p>
                    Before you can use capabilities of the <code class="literal">jersey-media-multipart</code> module in your client/server code, you
                    need to register <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/MultiPartFeature.html" target="_top">MultiPartFeature</a>.

                    </p><div class="example"><a name="d0e8936"></a><p class="title"><b>Example&nbsp;9.44.&nbsp;Building client with MultiPart feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
    .register(MultiPartFeature.class)
    .build();</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e8942"></a><p class="title"><b>Example&nbsp;9.45.&nbsp;Creating JAX-RS application with MultiPart feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
    .packages("org.glassfish.jersey.examples.multipart")
    .register(MultiPartFeature.class)</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8948"></a>9.3.1.3.&nbsp;Examples</h4></div></div></div><p>Jersey provides a
                    <a class="link" href="https://github.com/eclipse-ee4j/jersey/tree/3.0.2/examples/multipart-webapp" target="_top">Multipart Web Application Example</a>
                    on how to use multipart features.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8956"></a>9.3.2.&nbsp;Client</h3></div></div></div><p>
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/MultiPart.html" target="_top">MultiPart</a> class (or it's subclasses) can be used as an entry point to use
                <code class="literal">jersey-media-multipart</code> module on the client side. This class represents a
                <a class="link" href="http://en.wikipedia.org/wiki/MIME#Multipart_messages" target="_top">MIME multipart message</a> and is able
                to hold an arbitrary number of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/BodyPart.html" target="_top">BodyPart</a>s. Default media type is
                <a class="link" href="http://en.wikipedia.org/wiki/MIME#Mixed" target="_top">multipart/mixed</a>
                for <code class="literal">MultiPart</code> entity and <code class="literal">text/plain</code> for
                <code class="literal">BodyPart</code>.

                </p><div class="example"><a name="d0e8985"></a><p class="title"><b>Example&nbsp;9.46.&nbsp;<code class="literal">MultiPart</code> entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final MultiPart multiPartEntity = new MultiPart()
        .bodyPart(new BodyPart().entity("hello"))
        .bodyPart(new BodyPart(new JaxbBean("xml"), MediaType.APPLICATION_XML_TYPE))
        .bodyPart(new BodyPart(new JaxbBean("json"), MediaType.APPLICATION_JSON_TYPE));

final WebTarget target = // Create WebTarget.
final Response response = target
        .request()
        .post(Entity.entity(multiPartEntity, multiPartEntity.getMediaType()));</pre></div></div><p><br class="example-break">

                If you send a <code class="literal">multiPartEntity</code> to the server the entity with <code class="literal">Content-Type</code>
                header in HTTP message would look like (don't forget to register a JSON provider):

                </p><div class="example"><a name="d0e8999"></a><p class="title"><b>Example&nbsp;9.47.&nbsp;<code class="literal">MultiPart</code> entity in HTTP message.</b></p><div class="example-contents"><pre class="screen"><span class="emphasis"><em>Content-Type: multipart/mixed; boundary=Boundary_1_829077776_1369128119878</em></span>

--Boundary_1_829077776_1369128119878
Content-Type: text/plain

hello
--Boundary_1_829077776_1369128119878
Content-Type: application/xml

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;jaxbBean&gt;&lt;value&gt;xml&lt;/value&gt;&lt;/jaxbBean&gt;
--Boundary_1_829077776_1369128119878
Content-Type: application/json

{"value":"json"}
--Boundary_1_829077776_1369128119878--</pre></div></div><p><br class="example-break">
            </p><p>
                When working with forms (e.g. media type <code class="literal">multipart/form-data</code>) and various fields in them,
                there is a more convenient class to be used - <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/FormDataMultiPart.html" target="_top">FormDataMultiPart</a>. It automatically sets
                the media type for the <code class="literal">FormDataMultiPart</code> entity to
                <code class="literal">multipart/form-data</code> and <code class="literal">Content-Disposition</code> header to
                <code class="literal">FormDataBodyPart</code> body parts.

                </p><div class="example"><a name="d0e9029"></a><p class="title"><b>Example&nbsp;9.48.&nbsp;<code class="literal">FormDataMultiPart</code> entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final FormDataMultiPart multipart = new FormDataMultiPart()
    .field("hello", "hello")
    .field("xml", new JaxbBean("xml"))
    .field("json", new JaxbBean("json"), MediaType.APPLICATION_JSON_TYPE);

final WebTarget target = // Create WebTarget.
final Response response = target.request().post(Entity.entity(multipart, multipart.getMediaType()));</pre></div></div><p><br class="example-break">

                To illustrate the difference when using <code class="literal">FormDataMultiPart</code> instead of
                <code class="literal">FormDataBodyPart</code> you can take a look at the
                <code class="literal">FormDataMultiPart</code> entity from HTML message:

                </p><div class="example"><a name="d0e9046"></a><p class="title"><b>Example&nbsp;9.49.&nbsp;<code class="literal">FormDataMultiPart</code> entity in HTTP message.</b></p><div class="example-contents"><pre class="screen"><span class="emphasis"><em>Content-Type: multipart/form-data; boundary=Boundary_1_511262261_1369143433608</em></span>

--Boundary_1_511262261_1369143433608
Content-Type: text/plain
Content-Disposition: form-data; name="hello"

hello
--Boundary_1_511262261_1369143433608
Content-Type: application/xml
Content-Disposition: form-data; name="xml"

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;jaxbBean&gt;&lt;value&gt;xml&lt;/value&gt;&lt;/jaxbBean&gt;
--Boundary_1_511262261_1369143433608
Content-Type: application/json
Content-Disposition: form-data; name="json"

{"value":"json"}
--Boundary_1_511262261_1369143433608--</pre></div></div><p><br class="example-break">
            </p><p>
                A common use-case for many users is sending files from client to server. For this purpose you can use classes from
                <code class="literal">org.glassfish.jersey.jersey.media.multipart</code> package, such as
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/file/FileDataBodyPart.html" target="_top">FileDataBodyPart</a> or <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/file/StreamDataBodyPart.html" target="_top">StreamDataBodyPart</a>.

                </p><div class="example"><a name="d0e9067"></a><p class="title"><b>Example&nbsp;9.50.&nbsp;Multipart - sending files.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// MediaType of the body part will be derived from the file.
final FileDataBodyPart filePart = new FileDataBodyPart("my_pom", new File("pom.xml"));

final FormDataMultiPart multipart = new FormDataMultiPart()
    .field("foo", "bar")
    .bodyPart(filePart);

final WebTarget target = // Create WebTarget.
final Response response = target.request()
    .post(Entity.entity(multipart, multipart.getMediaType()));</pre></div></div><p><br class="example-break">
            </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
                    Do not use <code class="literal">ApacheConnectorProvider</code> nor <code class="literal">GrizzlyConnectorProvider</code>
                    neither <code class="literal">JettyConnectorProvider</code> connector implementations with Jersey Multipart
                    features. See <a class="xref" href="client.html#connectors.warning" title="Warning">Header modification issue</a> warning for more details.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9087"></a>9.3.3.&nbsp;Server</h3></div></div></div><p>
                Returning a multipart response from server to client is not much different from the parts described in the client
                section above. To obtain a multipart entity, sent by a client, in the application you can use two approaches:

                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Injecting the whole <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/MultiPart.html" target="_top">MultiPart</a> entity.</p></li><li class="listitem"><p>
                            Injecting particular parts of a <code class="literal">form-data</code> multipart request via
                            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/FormDataParam.html" target="_top">@FormDataParam</a> annotation.
                        </p></li></ul></div><p>
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9109"></a>9.3.3.1.&nbsp;Injecting and returning the <code class="literal">MultiPart</code> entity</h4></div></div></div><p>
                    Working with <code class="literal">MultiPart</code> types is no different from injecting/returning other
                    entity types.
                    Jersey provides <code class="literal">MessageBodyReader&lt;T&gt;</code> for reading the request entity and injecting this entity
                    into a method parameter of a resource method and <code class="literal">MessageBodyWriter&lt;T&gt;</code> for writing output entities.
                    You can expect that either <code class="literal">MultiPart</code> or
                    <code class="literal">FormDataMultiPart</code> (<code class="literal">multipart/form-data</code> media type) object
                    to be injected into a resource method.
                </p><div class="example"><a name="d0e9135"></a><p class="title"><b>Example&nbsp;9.51.&nbsp;Resource method using <code class="literal">MultiPart</code> as input parameter / return value.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Produces("multipart/mixed")
public MultiPart post(final FormDataMultiPart multiPart) {
    return multiPart;
}</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9143"></a>9.3.3.2.&nbsp;Injecting with <code class="literal">@FormDataParam</code></h4></div></div></div><p>
                    If you just need to bind the named body part(s) of a <code class="literal">multipart/form-data</code> request
                    entity body to a resource method parameter you can use <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/FormDataParam.html" target="_top">@FormDataParam</a> annotation.
                </p><p>
                    This annotation in conjunction with the media type <code class="literal">multipart/form-data</code> should be used for
                    submitting and consuming forms that contain files, non-ASCII data, and binary data.
                </p><p>
                    The type of the annotated parameter can be one of the following (for more detailed description see
                    javadoc to <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/FormDataParam.html" target="_top">@FormDataParam</a>):

                    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                <code class="literal">FormDataBodyPart</code> - The value of the parameter will be the first
                                named body part or <code class="literal">null</code> if such a named body part is not present.
                            </p></li><li class="listitem"><p>
                                A <code class="literal">List</code> or <code class="literal">Collection</code> of
                                <code class="literal">FormDataBodyPart</code>.
                                The value of the parameter will be one or more named body parts with the same name or
                                <code class="literal">null</code> if such a named body part is not present.
                            </p></li><li class="listitem"><p>
                                <code class="literal">FormDataContentDisposition</code> - The value of the parameter will be the
                                content disposition of the first named body part part or <code class="literal">null</code> if such a named body part
                                is not present.
                            </p></li><li class="listitem"><p>
                                A <code class="literal">List</code> or <code class="literal">Collection</code> of
                                <code class="literal">FormDataContentDisposition</code>.
                                The value of the parameter will be one or more content dispositions of the named body parts with the
                                same name or <code class="literal">null</code> if such a named body part is not present.
                            </p></li><li class="listitem"><p>
                                A type for which a message body reader is available given the media type of the first named body
                                part. The value of the parameter will be the result of reading using the message body reader given
                                the type <code class="literal">T</code>, the media type of the named part, and the bytes of the named body
                                part as input.
                            </p><p>
                                If there is no named part present and there is a default value present as declared by
                                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/DefaultValue.html" target="_top">@DefaultValue</a> then the media type will be set to <code class="literal">text/plain</code>.
                                The value of the parameter will be the result of reading using the message body reader given the
                                type <code class="literal">T</code>, the media type <code class="literal">text/plain</code>, and the UTF-8 encoded
                                bytes of the default value as input.
                            </p><p>
                                If there is no message body reader available and the type <code class="literal">T</code> conforms
                                to a type specified by <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/FormParam.html" target="_top">@FormParam</a> then processing is performed as specified by
                                <code class="literal">@FormParam</code>, where the values of the form parameter are <code class="literal">String</code>
                                instances produced by reading the bytes of the named body parts utilizing a message body reader
                                for the <code class="literal">String</code> type and the media type <code class="literal">text/plain</code>.
                            </p><p>
                                If there is no named part present then processing is performed as specified by
                                <code class="literal">@FormParam</code>.
                            </p></li></ul></div><p>
                </p><div class="example"><a name="d0e9261"></a><p class="title"><b>Example&nbsp;9.52.&nbsp;Use of <code class="literal">@FormDataParam</code> annotation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes(MediaType.MULTIPART_FORM_DATA)
public String postForm(
    @DefaultValue("true") @FormDataParam("enabled") boolean enabled,
    @FormDataParam("data") FileData bean,
    @FormDataParam("file") InputStream file,
    @FormDataParam("file") FormDataContentDisposition fileDisposition) {

    // ...
}</pre></div></div><br class="example-break"><p>
                    In the example above the server consumes a <code class="literal">multipart/form-data</code> request entity body that
                    contains one optional named body part <code class="literal">enabled</code> and two required named body parts
                    <code class="literal">data</code> and <code class="literal">file</code>.
                </p><p>
                    The optional part <code class="literal">enabled</code> is processed
                    as a <code class="literal">boolean</code> value, if the part is absent then the value will be <code class="literal">true</code>.
                </p><p>
                    The part <code class="literal">data</code> is processed as a JAXB bean and contains some meta-data about the following
                    part.
                </p><p>
                    The part <code class="literal">file</code> is a file that is uploaded, this is processed as an
                    <code class="literal">InputStream</code>. Additional information about the file from the
                    <code class="literal">Content-Disposition</code> header can be accessed by the parameter
                    <code class="literal">fileDisposition</code>.
                </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p><code class="literal">@FormDataParam</code> annotation can be also used on fields.</p></div></div></div></div></div><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.css" rel="stylesheet" type="text/css"><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shThemeDefault.css" rel="stylesheet" type="text/css"><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.js" type="text/javascript"></script><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shAutoloader.js" type="text/javascript"></script><script type="text/javascript">
            function path() {
              var args = arguments,
                  result = []
                  ;

              for(var i = 0; i < args.length; i++)
                  result.push(args[i].replace('@', 'https://eclipse-ee4j.github.io/jersey.github.io/sh/'));

              return result
            };

            SyntaxHighlighter.autoloader.apply(null, path(
              'applescript            @shBrushAppleScript.js',
              'actionscript3 as3      @shBrushAS3.js',
              'bash shell             @shBrushBash.js',
              'coldfusion cf          @shBrushColdFusion.js',
              'cpp c                  @shBrushCpp.js',
              'c# c-sharp csharp      @shBrushCSharp.js',
              'css                    @shBrushCss.js',
              'delphi pascal          @shBrushDelphi.js',
              'diff patch pas         @shBrushDiff.js',
              'erl erlang             @shBrushErlang.js',
              'groovy                 @shBrushGroovy.js',
              'java                   @shBrushJava.js',
              'jfx javafx             @shBrushJavaFX.js',
              'js jscript javascript  @shBrushJScript.js',
              'perl pl                @shBrushPerl.js',
              'php                    @shBrushPhp.js',
              'text plain             @shBrushPlain.js',
              'py python              @shBrushPython.js',
              'ruby rails ror rb      @shBrushRuby.js',
              'sass scss              @shBrushSass.js',
              'scala                  @shBrushScala.js',
              'sql                    @shBrushSql.js',
              'vb vbnet               @shBrushVb.js',
              'xml xhtml xslt html    @shBrushXml.js'
            ));

            SyntaxHighlighter.all();
        </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="message-body-workers.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="filters-and-interceptors.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;8.&nbsp;JAX-RS Entity Providers&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;10.&nbsp;Filters and Interceptors</td></tr></table></div></div></body></html>