<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;11.&nbsp;Asynchronous Services and Clients</title><link rel="stylesheet" type="text/css" href="/jersey.github.io/documentation.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Jersey 3.0.2 User Guide"><link rel="up" href="index.html" title="Jersey 3.0.2 User Guide"><link rel="prev" href="filters-and-interceptors.html" title="Chapter&nbsp;10.&nbsp;Filters and Interceptors"><link rel="next" href="uris-and-links.html" title="Chapter&nbsp;12.&nbsp;URIs and Links"><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-3160303-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script></head><body class="contents"><div class="contents" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;11.&nbsp;Asynchronous Services and Clients</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="filters-and-interceptors.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="uris-and-links.html">Next</a></td></tr></table><hr></div><div style="float:right"><a href="https://eclipse-ee4j.github.io/jersey"><img src="https://eclipse-ee4j.github.io/jersey.github.io/images/jersey_logo.png"></a></div><small>Links:
            <a href="index.html">
                Table of Contents
            </a> | <a href="user-guide.html">
                Single HTML
            </a></small><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="async"></a>Chapter&nbsp;11.&nbsp;Asynchronous Services and Clients</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="async.html#d0e9886">11.1. Asynchronous Server API</a></span></dt><dd><dl><dt><span class="section"><a href="async.html#d0e10007">11.1.1. Asynchronous Server-side Callbacks</a></span></dt><dt><span class="section"><a href="async.html#chunked-output">11.1.2. Chunked Output</a></span></dt></dl></dd><dt><span class="section"><a href="async.html#d0e10137">11.2. Client API</a></span></dt><dd><dl><dt><span class="section"><a href="async.html#d0e10200">11.2.1. Asynchronous Client Callbacks</a></span></dt><dt><span class="section"><a href="async.html#d0e10276">11.2.2. Chunked input</a></span></dt></dl></dd></dl></div><p>
        This chapter describes the usage of asynchronous API on the client and server side. The term <span class="emphasis"><em>async</em></span>
        will be sometimes used interchangeably with the term <span class="emphasis"><em>asynchronous</em></span> in this chapter.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9886"></a>11.1.&nbsp;Asynchronous Server API</h2></div></div></div><p>
            Request processing on the server works by default in a synchronous processing mode, which means that a client
            connection of a request is processed in a single I/O container thread. Once the thread processing the request
            returns to the I/O container, the container can safely assume that the request processing is finished and that
            the client connection can be safely released including all the resources associated with the connection. This model
            is typically sufficient for processing of requests for which the processing resource method execution takes
            a relatively short time. However, in cases where a resource method execution is known to take a long time to compute
            the result, server-side asynchronous processing model should be used. In this model, the association between a
            request processing thread and client connection is broken. I/O container that handles incoming request may no longer
            assume that a client connection can be safely closed when a request processing thread returns. Instead a facility for
            explicitly suspending, resuming and closing client connections needs to be exposed.
            Note that the use of server-side asynchronous processing model will not improve the request processing time perceived
            by the client. It will however increase the throughput of the server, by releasing the
            initial request processing thread back to the I/O container while the request may still be waiting in a queue for
            processing or the processing may still be running on another dedicated thread. The released I/O container thread
            can be used to accept and process new incoming request connections.
        </p><p>
            The following example shows a simple asynchronous resource method defined using the new JAX-RS async API:
            </p><div class="example"><a name="d0e9893"></a><p class="title"><b>Example&nbsp;11.1.&nbsp;Simple async resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/resource")
public class AsyncResource {
    @GET
    public void asyncGet(@Suspended final AsyncResponse asyncResponse) {

        new Thread(new Runnable() {
            @Override
            public void run() {
                String result = veryExpensiveOperation();
                asyncResponse.resume(result);
            }

            private String veryExpensiveOperation() {
                // ... very expensive operation
            }
        }).start();
    }
}</pre></div></div><p><br class="example-break">
            In the example above, a resource <code class="literal">AsyncResource</code>
            with one <code class="literal">GET</code> method <code class="literal">asyncGet</code> is defined. The <code class="literal">asyncGet</code> method
            injects a JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/AsyncResponse.html" target="_top">AsyncResponse</a> instance using a JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/Suspended.html" target="_top">@Suspended</a> annotation.
            Please note that <code class="literal">AsyncResponse</code> must be injected by the <code class="literal">@Suspended</code>
            annotation and not by <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a> as <code class="literal">@Suspended</code> does not only inject response but also
            says that the method is executed in the asynchronous mode. By the <code class="literal">AsyncResponse</code> parameter into
            a resource method we tell the Jersey runtime that the method is supposed to be invoked using the asynchronous
            processing mode, that is the client connection should not be automatically closed by the underlying I/O container
            when the method returns. Instead, the injected <code class="literal">AsyncResponse</code> instance (that represents the
            suspended client request connection) will be used to explicitly send the response back to the client using some other
            thread. In other words, Jersey runtime knows that when the <code class="literal">asyncGet</code> method completes, the response
            to the client may not be ready yet and the processing must be suspended and wait to be explicitly resumed with a
            response once it becomes available. Note that the method <code class="literal">asyncGet</code> returns <code class="literal">void</code>
            in our example. This is perfectly valid in case of an asynchronous JAX-RS resource method, even for a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a>
            method, as the response is never returned directly from the resource method as its return value. Instead, the response
            is later returned using <code class="literal">AsyncResponse</code> instance as it is demonstrated in the example. The
            <code class="literal">asyncGet</code> resource method starts a new thread and exits from the method. In that state the
            request processing is suspended and the container thread (the one which entered the resource method) is returned back
            to the container's thread pool and it can process other requests. New thread started in the resource method may
            execute an expensive operation which might take a long time to finish. Once a result is ready it is resumed using
            the <code class="literal">resume()</code> method on the <code class="literal">AsyncResponse</code> instance.
            The resumed response is then processed in the new thread by Jersey in a same way as any other synchronous response,
            including execution of filters and interceptors, use of exception mappers as necessary and sending the response
            back to the client.
        </p><p>
            It is important to note that the asynchronous response (<code class="literal">asyncResponse</code> in the example)
            does not need to be resumed from the thread started from the resource method. The asynchronous
            response can be resumed even from different request processing thread as it is shown in the
            the example of the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/AsyncResponse.html" target="_top">AsyncResponse</a> javadoc. In the javadoc example the
            async response suspended from the <code class="literal">GET</code> method is resumed later on from
            the <code class="literal">POST</code> method. The suspended async response is passed between requests using
            a static field and is resumed from the other resource method running on a different request processing thread.
        </p><p>
            Imagine now a situation when there is a long delay between two requests and you would not like to let
            the client wait for the response "forever" or at least for an unacceptable long time. In asynchronous processing
            model, occurrences of such situations should be carefully considered with client connections not being automatically
            closed when the processing method returns and the response needs to be resumed explicitly based on an event that
            may actually even never happen. To tackle these situations asynchronous <span class="emphasis"><em>timeouts</em></span> can be used.
        </p><p>
            The following example shows the usage of timeouts:
            </p><div class="example"><a name="d0e9980"></a><p class="title"><b>Example&nbsp;11.2.&nbsp;Simple async method with timeout</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public void asyncGetWithTimeout(@Suspended final AsyncResponse asyncResponse) {
    asyncResponse.setTimeoutHandler(new TimeoutHandler() {

        @Override
        public void handleTimeout(AsyncResponse asyncResponse) {
            asyncResponse.resume(Response.status(Response.Status.SERVICE_UNAVAILABLE)
                    .entity("Operation time out.").build());
        }
    });
    asyncResponse.setTimeout(20, TimeUnit.SECONDS);

    new Thread(new Runnable() {

        @Override
        public void run() {
            String result = veryExpensiveOperation();
            asyncResponse.resume(result);
        }

        private String veryExpensiveOperation() {
            // ... very expensive operation that typically finishes within 20 seconds
        }
    }).start();
}</pre></div></div><p><br class="example-break">
            By default, there is no timeout defined on the suspended <code class="literal">AsyncResponse</code> instance.
            A custom timeout and timeout event handler may be defined using <code class="literal">setTimeoutHandler(TimeoutHandler)</code>
            and <code class="literal">setTimeout(long, TimeUnit)</code> methods. The <code class="literal">setTimeoutHandler(TimeoutHandler)</code>
            method defines the handler that will be invoked when timeout is reached. The handler resumes the response with the
            response code 503 (from Response.Status.<code class="literal">SERVICE_UNAVAILABLE</code>).
            A timeout interval can be also defined without specifying a custom timeout handler (using just the
            <code class="literal">setTimeout(long, TimeUnit)</code> method).
            In such case the default behaviour of Jersey runtime is to throw a <code class="literal">ServiceUnavailableException</code>
            that gets mapped into 503, "Service Unavailable" HTTP error response, as defined by the JAX-RS specification.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10007"></a>11.1.1.&nbsp;Asynchronous Server-side Callbacks</h3></div></div></div><p>
                As operations in asynchronous cases might take long time and they are not always finished within
                a single resource method invocation, JAX-RS offers facility to register callbacks to be invoked
                based on suspended async response state changes. In Jersey you can register two JAX-RS callbacks:
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
                        <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/CompletionCallback.html" target="_top">CompletionCallback</a> that is executed when request finishes or fails, and
                    </li><li class="listitem">
                        <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ConnectionCallback.html" target="_top">ConnectionCallback</a> executed when a connection to a client is closed or lost.
                    </li></ul></div><p>
                </p><div class="example"><a name="d0e10026"></a><p class="title"><b>Example&nbsp;11.3.&nbsp;CompletionCallback example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/resource")
public class AsyncResource {
    private static int numberOfSuccessResponses = 0;
    private static int numberOfFailures = 0;
    private static Throwable lastException = null;

    @GET
    public void asyncGetWithTimeout(@Suspended final AsyncResponse asyncResponse) {
        asyncResponse.register(new CompletionCallback() {
            @Override
            public void onComplete(Throwable throwable) {
                if (throwable == null) {
                    // no throwable - the processing ended successfully
                    // (response already written to the client)
                    numberOfSuccessResponses++;
                } else {
                    numberOfFailures++;
                    lastException = throwable;
                }
            }
        });

        new Thread(new Runnable() {
            @Override
            public void run() {
                String result = veryExpensiveOperation();
                asyncResponse.resume(result);
            }

            private String veryExpensiveOperation() {
                // ... very expensive operation
            }
        }).start();
    }
}</pre></div></div><p><br class="example-break">
                A completion callback is registered using <code class="literal">register(...)</code> method
                on the <code class="literal">AsyncResponse</code> instance. A registered completion callback is bound only
                to the response(s) to which it has been registered. In the example the <code class="literal">CompletionCallback</code>
                is used to calculate successfully processed responses, failures and to store last exception. This is only a
                simple case demonstrating the usage of the callback. You can use completion callback to release the resources,
                change state of internal resources or representations or handle failures. The method has an argument
                <code class="literal">Throwable</code> which is set only in case of an error. Otherwise the parameter
                will be <code class="literal">null</code>, which means that the response was successfully written. The callback is executed
                only after the response is written to the client (not immediately after the response is resumed).
            </p><p>
                The <code class="literal">AsyncResponse</code> <code class="literal">register(...)</code> method is overloaded and offers options
                to register a single callback as an <code class="literal">Object</code> (in the example), as a <code class="literal">Class</code> or
                multiple callbacks using varags.
            </p><p>
                As some async requests may take long time to process the client may decide to terminate its connection to the
                server before the response has been resumed or before it has been fully written to the client. To deal with these
                use cases a <code class="literal">ConnectionCallback</code> can be used. This callback will be executed only if the
                connection was prematurely terminated or lost while the response is being written to the back client. Note that
                this callback will not be invoked when a response is written successfully and the client connection is closed
                as expected. See javadoc of <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ConnectionCallback.html" target="_top">ConnectionCallback</a> for more information.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="chunked-output"></a>11.1.2.&nbsp;Chunked Output</h3></div></div></div><p>Jersey offers a facility for sending response to the client in multiple more-or-less independent chunks using a
                <span class="emphasis"><em>chunked output</em></span>. Each response chunk usually takes some (longer) time to prepare before
                sending it to the client. The most important fact about response chunks is that you want
                to send them to the client immediately as they become available without waiting for the remaining chunks to become
                available too. The first bytes of each chunked response consists of the HTTP headers that are sent to the client.
                As noted above, the entity of the response is then sent in chunks as they become available.
                Client knows that the response is going to be chunked, so it reads each chunk of the response separately,
                processes it, and waits for more chunks to arrive on the same connection. After some time, the server generates
                another response chunk and send it again to the client. Server keeps on sending response chunks until
                it closes the connection after sending the last chunk when the response processing is finished.
            </p><p>
                In Jersey you can use <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ChunkedOutput.html" target="_top">ChunkedOutput</a> to send response to a client in chunks. Chunks are strictly
                defined pieces of a response body can be marshalled as a separate entities using Jersey/JAX-RS
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> providers. A chunk can be String, Long or JAXB bean serialized to XML or JSON or
                any other defined custom type for which a <code class="literal">MessageBodyWriter&lt;T&gt;</code> is available.
            </p><p>
                The resource method
                that returns <code class="literal">ChunkedOutput</code> informs the Jersey runtime that the response will be chunked
                and that the processing works asynchronously as such. You do not need to inject
                <code class="literal">AsyncResponse</code> to start the asynchronous processing mode in this case.
                Returning a <code class="literal">ChunkedOutput</code> instance from the method is enough to indicate the asynchronous
                processing. Response headers will be sent to a client when the resource method returns and the client will wait
                for the stream of chunked data which you will be able to write from different thread using the same
                <code class="literal">ChunkedOutput</code> instance returned from the resource method earlier. The following example
                demonstrates this use case:
                </p><div class="example"><a name="d0e10102"></a><p class="title"><b>Example&nbsp;11.4.&nbsp;ChunkedOutput example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/resource")
public class AsyncResource {
    @GET
    public ChunkedOutput&lt;String&gt; getChunkedResponse() {
        final ChunkedOutput&lt;String&gt; output = new ChunkedOutput&lt;String&gt;(String.class);

        new Thread() {
            public void run() {
                try {
                    String chunk;

                    while ((chunk = getNextString()) != null) {
                        output.write(chunk);
                    }
                } catch (IOException e) {
                    // IOException thrown when writing the
                    // chunks of response: should be handled
                } finally {
                    output.close();
                        // simplified: IOException thrown from
                        // this close() should be handled here...
                }
            }
        }.start();

        // the output will be probably returned even before
        // a first chunk is written by the new thread
        return output;
    }

    private String getNextString() {
        // ... long running operation that returns
        //     next string or null if no other string is accessible
    }
}</pre></div></div><p><br class="example-break">
                The example above defines a <code class="literal">GET</code> method that returns a <code class="literal">ChunkedOutput</code> instance.
                The generic type of <code class="literal">ChunkedOutput</code> defines the chunk types (in this case chunks are Strings).
                Before the instance is returned a new thread is started that writes individual chunks into
                the chunked output instance named <code class="literal">output</code>. Once the original
                thread returns from the resource method, Jersey runtime writes headers to the container response but does not
                close the client connection yet and waits for the response data to be written to the chunked
                <code class="literal">output</code>.
                New thread in a loop calls the method <code class="literal">getNextString()</code> which returns a
                next String or <code class="literal">null</code> if no other String exists (the method could for example load latest data
                from the database). Returned Strings are written to the chunked <code class="literal">output</code>. Such a written
                chunks are internally written to the container response and client can read them. At the end the
                chunked output is closed which determines the end of the chunked response. Please note that you must close
                the output explicitly in order to close the client connection as Jersey does not implicitly know when
                you are finished with writing the chunks.
            </p><p>
                A chunked output can be processed also from threads created from another request as it is explained in the
                sections above. This means that one resource method may e.g. only return a <code class="literal">ChunkedOutput</code>
                instance and other resource method(s) invoked from another request thread(s) can write data into the chunked
                output and/or close the chunked response.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10137"></a>11.2.&nbsp;Client API</h2></div></div></div><p>The client API supports asynchronous processing too. Simple usage of asynchronous client API is shown in the
        following example:
            </p><div class="example"><a name="d0e10142"></a><p class="title"><b>Example&nbsp;11.5.&nbsp;Simple client async invocation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final AsyncInvoker asyncInvoker = target().path("http://example.com/resource/")
        .request().async();
final Future&lt;Response&gt; responseFuture = asyncInvoker.get();
System.out.println("Request is being processed asynchronously.");
final Response response = responseFuture.get();
    // get() waits for the response to be ready
System.out.println("Response received.");</pre></div></div><p><br class="example-break">
            The difference against synchronous invocation is that the http method call <code class="literal">get()</code>
            is not called on <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/SyncInvoker.html" target="_top">SyncInvoker</a> but on <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/AsyncInvoker.html" target="_top">AsyncInvoker</a>. The
            <code class="literal">AsyncInvoker</code> is returned from the call of method
            <code class="literal">Invocation.Builder.async()</code> as shown above. <code class="literal">AsyncInvoker</code>
            offers methods similar to <code class="literal">SyncInvoker</code> only these methods do not return a response
            synchronously. Instead a <code class="literal">Future&lt;...&gt;</code> representing response data is returned.
            These method calls also return immediately without waiting for the actual request to complete.
            In order to get the response of the invoked <code class="literal">get()</code> method, the
            <code class="literal">responseFuture.get()</code> is invoked which waits for the response to be finished
            (this call is blocking as defined by the Java SE <code class="literal">Future</code> contract).
        </p><p>
            Asynchronous Client API in JAX-RS is fully integrated in the fluent JAX-RS Client API flow, so that
            the async client-side invocations can be written fluently just like in the following example:
            </p><div class="example"><a name="d0e10183"></a><p class="title"><b>Example&nbsp;11.6.&nbsp;Simple client fluent async invocation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Future&lt;Response&gt; responseFuture = target().path("http://example.com/resource/")
        .request().async().get();</pre></div></div><p><br class="example-break">
        </p><p>
            To work with asynchronous results on the client-side, all standard <code class="literal">Future</code> API facilities
            can be used. For example, you can use the <code class="literal">isDone()</code> method
            to determine whether a response has finished to avoid the use of a blocking call to <code class="literal">Future.get()</code>.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10200"></a>11.2.1.&nbsp;Asynchronous Client Callbacks</h3></div></div></div><p>Similarly to the server side, in the client API you can register asynchronous callbacks too. You can use
                these callbacks to be notified when a response arrives instead of waiting for the
                response on <code class="literal">Future.get()</code> or checking the status by <code class="literal">Future.isDone()</code> in
                a loop.
                A client-side asynchronous invocation callback can be registered as shown in the following example:
                </p><div class="example"><a name="d0e10211"></a><p class="title"><b>Example&nbsp;11.7.&nbsp;Client async callback</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Future&lt;Response&gt; responseFuture = target().path("http://example.com/resource/")
        .request().async().get(new InvocationCallback&lt;Response&gt;() {
            @Override
            public void completed(Response response) {
                System.out.println("Response status code "
                        + response.getStatus() + " received.");
            }

            @Override
            public void failed(Throwable throwable) {
                System.out.println("Invocation failed.");
                throwable.printStackTrace();
            }
        });</pre></div></div><p><br class="example-break">

                The registered callback is expected to implement the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/InvocationCallback.html" target="_top">InvocationCallback</a> interface that defines
                two methods.
                First method <code class="literal">completed(Response)</code> gets invoked when an invocation successfully
                finishes. The result response is passed as a parameter to the callback method. The second method
                <code class="literal">failed(Throwable)</code> is invoked in case the invocation fails and the exception describing
                the failure is passed to the method as a parameter. In this case since the callback generic type is
                <code class="literal">Response</code>, the <code class="literal">failed(Throwable)</code> method would  only invoked in case
                the invocation fails because of an internal client-side processing error. It would not be invoked
                in case a server responds with an HTTP error code, for example if the requested resource
                is not found on the server and HTTP <code class="literal">404</code> response code is returned. In such case
                <code class="literal">completed(Response)</code> callback method would be invoked and the response passed to the method
                would contain the returned error response with HTTP <code class="literal">404</code> error code. This is a special
                behavior in case the generic callback return type is <code class="literal">Response</code>. In the next example an
                exception is thrown (or <code class="literal">failed(Throwable)</code> method on the invocation callback is invoked)
                even in case a non-<code class="literal">2xx</code> HTTP error code is returned.
            </p><p>
                As with the synchronous client API, you can retrieve the response entity as a Java type directly without
                requesting a <code class="literal">Response</code> first. In case of an <code class="literal">InvocationCallback</code>, you need
                to set its generic type to the expected response entity type instead of using the <code class="literal">Response</code>
                type as demonstrated in the example below:
                </p><div class="example"><a name="d0e10261"></a><p class="title"><b>Example&nbsp;11.8.&nbsp;Client async callback for specific entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Future&lt;String&gt; entityFuture = target().path("http://example.com/resource/")
        .request().async().get(new InvocationCallback&lt;String&gt;() {
            @Override
            public void completed(String response) {
                System.out.println("Response entity '" + response + "' received.");
            }

            @Override
            public void failed(Throwable throwable) {
                System.out.println("Invocation failed.");
                throwable.printStackTrace();
            }
        });
System.out.println(entityFuture.get());</pre></div></div><p><br class="example-break">
                Here, the generic type of the invocation callback information is used to unmarshall the HTTP response content
                into a desired Java type.
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    Please note that in this case the method <code class="literal">failed(Throwable throwable)</code> would be invoked even
                    for cases when a server responds with a non HTTP-<code class="literal">2xx</code> HTTP error code. This is because in this
                    case the user does not have any other means of finding out that the server returned an error response.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10276"></a>11.2.2.&nbsp;Chunked input</h3></div></div></div><p>
                In an <a class="link" href="async.html#chunked-output" title="11.1.2.&nbsp;Chunked Output">earlier section</a> the <code class="literal">ChunkedOutput</code> was
                described. It was shown how to use a chunked output on the server. In order to read chunks on the client the
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ChunkedInput.html" target="_top">ChunkedInput</a> can be used to complete the story.
            </p><p>
                You can, of course, process input on the client as a standard input stream but if you would like to
                leverage Jersey infrastructure to provide support of translating message chunk data into Java types
                using a <code class="literal">ChunkedInput</code> is much more straightforward. See the usage of the
                <code class="literal">ChunkedInput</code> in the following example:

                </p><div class="example"><a name="d0e10298"></a><p class="title"><b>Example&nbsp;11.9.&nbsp;ChunkedInput example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Response response = target().path("http://example.com/resource/")
        .request().get();
final ChunkedInput&lt;String&gt; chunkedInput =
        response.readEntity(new GenericType&lt;ChunkedInput&lt;String&gt;&gt;() {});
String chunk;
while ((chunk = chunkedInput.read()) != null) {
    System.out.println("Next chunk received: " + chunk);
}
</pre></div></div><p><br class="example-break">

                The response is retrieved in a standard way from the server. The entity is read as a
                <code class="literal">ChunkedInput</code> entity. In order to do that the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/GenericEntity.html" target="_top">GenericEntity&lt;T&gt;</a> is used to preserve
                a generic information at run time. If you would not use <code class="literal">GenericEntity&lt;T&gt;</code>, Java language generic type
                erasure would cause that the generic information would get lost at compile time and an exception would be thrown
                at run time complaining about the missing chunk type definition.
            </p><p>
                In the next lines in the example, individual chunks are being read from the response. Chunks can come with some
                delay, so they will be written to the console as they come from the server. After receiving last chunk the
                <code class="literal">null</code> will be returned from the <code class="literal">read()</code> method. This will mean that the server has sent
                the last chunk and closed the connection. Note that the <code class="literal">read()</code> is a blocking operation and the
                invoking thread is blocked until a new chunk comes.
            </p><p>
                Writing chunks with <code class="literal">ChunkedOutput</code> is simple, you only call method <code class="literal">write()</code>
                which writes exactly one chunk to the output. With the input reading it is slightly more complicated. The
                <code class="literal">ChunkedInput</code> does not know how to distinguish chunks in the byte stream unless being told by
                the developer. In order to define custom chunks boundaries,
                the <code class="literal">ChunkedInput</code> offers possibility to register a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/client/ChunkParser.html" target="_top">ChunkParser</a> which
                reads chunks from the input stream and separates them. Jersey provides several chunk parser implementations and
                you can implement your own parser to separate your chunks if you need. In our example above the default parser
                provided by Jersey is used that separates chunks based on presence of a <code class="literal">\r\n</code> delimiting
                character sequence.
            </p><p>
                Each incoming input stream is firstly parsed by the <code class="literal">ChunkParser</code>, then each chunk is processed
                by the proper <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>.
                You can define the media type of chunks to aid the selection of a proper <code class="literal">MessageBodyReader&lt;T&gt;</code> in
                order to read chunks correctly into the requested entity types (in our case into Strings).
            </p></div></div></div><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.css" rel="stylesheet" type="text/css"><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shThemeDefault.css" rel="stylesheet" type="text/css"><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.js" type="text/javascript"></script><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shAutoloader.js" type="text/javascript"></script><script type="text/javascript">
            function path() {
              var args = arguments,
                  result = []
                  ;

              for(var i = 0; i < args.length; i++)
                  result.push(args[i].replace('@', 'https://eclipse-ee4j.github.io/jersey.github.io/sh/'));

              return result
            };

            SyntaxHighlighter.autoloader.apply(null, path(
              'applescript            @shBrushAppleScript.js',
              'actionscript3 as3      @shBrushAS3.js',
              'bash shell             @shBrushBash.js',
              'coldfusion cf          @shBrushColdFusion.js',
              'cpp c                  @shBrushCpp.js',
              'c# c-sharp csharp      @shBrushCSharp.js',
              'css                    @shBrushCss.js',
              'delphi pascal          @shBrushDelphi.js',
              'diff patch pas         @shBrushDiff.js',
              'erl erlang             @shBrushErlang.js',
              'groovy                 @shBrushGroovy.js',
              'java                   @shBrushJava.js',
              'jfx javafx             @shBrushJavaFX.js',
              'js jscript javascript  @shBrushJScript.js',
              'perl pl                @shBrushPerl.js',
              'php                    @shBrushPhp.js',
              'text plain             @shBrushPlain.js',
              'py python              @shBrushPython.js',
              'ruby rails ror rb      @shBrushRuby.js',
              'sass scss              @shBrushSass.js',
              'scala                  @shBrushScala.js',
              'sql                    @shBrushSql.js',
              'vb vbnet               @shBrushVb.js',
              'xml xhtml xslt html    @shBrushXml.js'
            ));

            SyntaxHighlighter.all();
        </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="filters-and-interceptors.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="uris-and-links.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;10.&nbsp;Filters and Interceptors&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;12.&nbsp;URIs and Links</td></tr></table></div></div></body></html>