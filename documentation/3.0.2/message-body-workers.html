<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;8.&nbsp;JAX-RS Entity Providers</title><link rel="stylesheet" type="text/css" href="/jersey.github.io/documentation.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Jersey 3.0.2 User Guide"><link rel="up" href="index.html" title="Jersey 3.0.2 User Guide"><link rel="prev" href="representations.html" title="Chapter&nbsp;7.&nbsp;Representations and Responses"><link rel="next" href="media.html" title="Chapter&nbsp;9.&nbsp;Support for Common Media Type Representations"><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-3160303-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script></head><body class="contents"><div class="contents" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;8.&nbsp;JAX-RS Entity Providers</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="representations.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="media.html">Next</a></td></tr></table><hr></div><div style="float:right"><a href="https://eclipse-ee4j.github.io/jersey"><img src="https://eclipse-ee4j.github.io/jersey.github.io/images/jersey_logo.png"></a></div><small>Links:
            <a href="index.html">
                Table of Contents
            </a> | <a href="user-guide.html">
                Single HTML
            </a></small><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="message-body-workers"></a>Chapter&nbsp;8.&nbsp;JAX-RS Entity Providers</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="message-body-workers.html#d0e6406">8.1. Introduction</a></span></dt><dt><span class="section"><a href="message-body-workers.html#d0e6440">8.2. How to Write Custom Entity Providers</a></span></dt><dd><dl><dt><span class="section"><a href="message-body-workers.html#d0e6477">8.2.1. MessageBodyWriter</a></span></dt><dt><span class="section"><a href="message-body-workers.html#d0e6765">8.2.2. MessageBodyReader</a></span></dt></dl></dd><dt><span class="section"><a href="message-body-workers.html#providers-selection">8.3. Entity Provider Selection</a></span></dt><dt><span class="section"><a href="message-body-workers.html#d0e7326">8.4. Jersey <code class="literal">MessageBodyWorkers</code> API</a></span></dt><dt><span class="section"><a href="message-body-workers.html#d0e7410">8.5. Default Jersey Entity Providers</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6406"></a>8.1.&nbsp;Introduction</h2></div></div></div><p>
            Entity payload, if present in an received HTTP message, is passed to Jersey from an I/O container as an input stream.
            The stream may, for example, contain data represented as a plain text, XML or JSON document. However, in many JAX-RS
            components that process these inbound data, such as resource methods or client responses, the JAX-RS API user can
            access the inbound entity as an arbitrary Java object that is created from the content of the input stream based on
            the representation type information. For example, an entity created from an input stream that contains data
            represented as a XML document, can be converted to a custom JAXB bean.
            Similar concept is supported for the outbound entities. An entity returned from the resource method in the form
            of an arbitrary Java object can be serialized by Jersey into a container output stream as a specified representation.
            Of course, while JAX-RS implementations do provide default support for most common combinations of Java type and it's
            respective on-the-wire representation formats, JAX-RS implementations do not support the conversion described above
            for any arbitrary Java type and any arbitrary representation format by default. Instead, a generic extension concept
            is exposed in JAX-RS API to allow application-level customizations of this JAX-RS runtime to support for entity
            conversions. The JAX-RS extension API components that provide the user-level extensibility are typically referred to
            by several terms with the same meaning, such as <span class="emphasis"><em>entity providers</em></span>,
            <span class="emphasis"><em>message body providers</em></span>, <span class="emphasis"><em>message body workers</em></span> or
            <span class="emphasis"><em>message body readers and writers</em></span>. You may find all these terms used interchangeably throughout
            the user guide and they all refer to the same concept.
        </p><p>
            In JAX-RS extension API (or SPI - service provider interface, if you like) the concept is captured in 2 interfaces.
            One for handling inbound entity representation-to-Java de-serialization - <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> and the other
            one for handling the outbound entity Java-to-representation serialization - <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>.
            A <code class="literal">MessageBodyReader&lt;T&gt;</code>, as the name suggests, is an extension that supports reading the message body
            representation from an input stream and converting the data into an instance of a specific Java type.
            A <code class="literal">MessageBodyWriter&lt;T&gt;</code> is then responsible for converting a message payload from an instance of a
            specific Java type into a specific representation format that is sent over the wire to the other party as part of an
            HTTP message exchange.
            Both of these providers can be used to provide message payload serialization and de-serialization support on the
            server as well as the client side. A message body reader or writer is always used whenever a HTTP request or
            response contains an entity and the entity is either requested by the application code (e.g. injected as a parameter
            of JAX-RS resource method or a response entity read on the client from a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a>) or has to be
            serialized and sent to the other party (e.g. an instance returned from a JAX-RS resource method or a request
            entity sent by a JAX-RS client).
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6440"></a>8.2.&nbsp;How to Write Custom Entity Providers</h2></div></div></div><p>
            A best way how to learn about entity providers is to walk through an example of writing one. Therefore we will
            describe here the process of implementing a custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> and
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> using a practical example. Let's first setup the stage by defining a JAX-RS
            resource class for the server side story of our application.

            </p><div class="example"><a name="d0e6451"></a><p class="title"><b>Example&nbsp;8.1.&nbsp;Example resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public class MyResource {
    @GET
    @Produces("application/xml")
    public MyBean getMyBean() {
        return new MyBean("Hello World!", 42);
    }

    @POST
    @Consumes("application/xml")
    public String postMyBean(MyBean myBean) {
        return myBean.anyString;
    }
}</pre></div></div><p><br class="example-break">

            The resource class defines <code class="literal">GET</code> and <code class="literal">POST</code> resource methods. Both methods work with an entity
            that is an instance of <code class="literal">MyBean</code>.
        </p><p>
            The <code class="literal">MyBean</code> class is defined in the next example:

            </p><div class="example"><a name="d0e6471"></a><p class="title"><b>Example&nbsp;8.2.&nbsp;MyBean entity class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class MyBean {
    @XmlElement
    public String anyString;
    @XmlElement
    public int anyNumber;

    public MyBean(String anyString, int anyNumber) {
        this.anyString = anyString;
        this.anyNumber = anyNumber;
    }

    // empty constructor needed for deserialization by JAXB
    public MyBean() {
    }

    @Override
    public String toString() {
        return "MyBean{" +
            "anyString='" + anyString + '\'' +
            ", anyNumber=" + anyNumber +
            '}';
    }
}</pre></div></div><p><br class="example-break">
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6477"></a>8.2.1.&nbsp;MessageBodyWriter</h3></div></div></div><p>
                The <code class="literal">MyBean</code> is a JAXB-annotated POJO. In <code class="literal">GET</code> resource method we return
                the instance of MyBean and we would like Jersey runtime to serialize it into XML and write
                it as an entity body to the response output stream. We design a custom <code class="literal">MessageBodyWriter&lt;T&gt;</code>
                that can serialize this POJO into XML. See the following code sample:

                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Please note, that this is only a demonstration of how to write a custom entity provider.
                        Jersey already contains default support for entity providers that can serialize JAXB beans
                        into XML.
                    </p></div><p>

                </p><div class="example"><a name="d0e6495"></a><p class="title"><b>Example&nbsp;8.3.&nbsp;MessageBodyWriter example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Produces("application/xml")
public class MyBeanMessageBodyWriter implements MessageBodyWriter&lt;MyBean&gt; {

    @Override
    public boolean isWriteable(Class&lt;?&gt; type, Type genericType,
                               Annotation[] annotations, MediaType mediaType) {
        return type == MyBean.class;
    }

    @Override
    public long getSize(MyBean myBean, Class&lt;?&gt; type, Type genericType,
                        Annotation[] annotations, MediaType mediaType) {
        // deprecated by JAX-RS 2.0 and ignored by Jersey runtime
        return -1;
    }

    @Override
    public void writeTo(MyBean myBean,
                        Class&lt;?&gt; type,
                        Type genericType,
                        Annotation[] annotations,
                        MediaType mediaType,
                        MultivaluedMap&lt;String, Object&gt; httpHeaders,
                        OutputStream entityStream)
                        throws IOException, WebApplicationException {

        try {
            JAXBContext jaxbContext = JAXBContext.newInstance(MyBean.class);

            // serialize the entity myBean to the entity output stream
            jaxbContext.createMarshaller().marshal(myBean, entityStream);
        } catch (JAXBException jaxbException) {
            throw new ProcessingException(
                "Error serializing a MyBean to the output stream", jaxbException);
        }
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                The <code class="literal">MyBeanMessageBodyWriter</code> implements the <code class="literal">MessageBodyWriter&lt;T&gt;</code>
                interface that contains three methods. In the next sections we'll explore these methods more closely.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6509"></a>8.2.1.1.&nbsp;
                    <code class="literal">MessageBodyWriter.isWriteable</code>
                </h4></div></div></div><p>
                    A method <code class="literal">isWriteable</code>
                    should return true if the <code class="literal">MessageBodyWriter&lt;T&gt;</code> is able to write the given type. Method
                    does not decide only based on the Java type of the entity but also on annotations attached to the entity
                    and the requested representation media type.
                </p><p>
                    Parameters <code class="literal">type</code> and <code class="literal">genericType</code> both define the entity,
                    where <code class="literal">type</code> is a raw Java type
                    (for example, a <code class="literal">java.util.List</code> class) and <code class="literal">genericType</code> is a
                    <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/ParameterizedType.html" target="_top">ParameterizedType</a> including generic information (for example <code class="literal">List&lt;String&gt;</code>).
                </p><p>
                    Parameter <code class="literal">annotations</code> contains annotations that are either attached to the resource
                    method and/or annotations that are attached to the entity by building response like in the following piece
                    of code:

                    </p><div class="example"><a name="d0e6551"></a><p class="title"><b>Example&nbsp;8.4.&nbsp;Example of assignment of annotations to a response entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public static class AnnotatedResource {

    @GET
    public Response get() {
        Annotation annotation = AnnotatedResource.class
                            .getAnnotation(Path.class);
        return Response.ok()
                .entity("Entity", new Annotation[] {annotation}).build();
    }
}</pre></div></div><p><br class="example-break">

                    In the example above, the <code class="literal">MessageBodyWriter&lt;T&gt;</code> would get
                    <code class="literal">annotations</code> parameter containing a JAX-RS <code class="literal">@GET</code> annotation
                    as it annotates the resource method and also a <code class="literal">@Path</code> annotation as it
                    is passed in the response (but not because it annotates the resource; only resource
                    method annotations are included). In the case of <code class="literal">MyResource</code>
                    and method <code class="literal">getMyBean</code> the annotations would contain the
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a> and the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Produces.html" target="_top">@Produces</a> annotation.
                </p><p>
                    The last parameter of the <code class="literal">isWriteable</code> method is the <code class="literal">mediaType</code>
                    which is the media type attached to the response entity by annotating the resource method with a
                    <code class="literal">@Produces</code> annotation or the request media type specified in the JAX-RS Client API.
                    In our example, the media type passed to providers for the resource <code class="literal">MyResource</code> and method
                    <code class="literal">getMyBean</code> would be <code class="literal">"application/xml"</code>.
                </p><p>
                    In our implementation of the <code class="literal">isWriteable</code> method, we
                    just check that the type is <code class="literal">MyBean</code>. Please note, that
                    this method might be executed multiple times by Jersey runtime as Jersey needs to check
                    whether this provider can be used for a particular combination of entity Java type, media type, and attached
                    annotations, which may be potentially a performance hog. You can limit the number of execution by
                    properly defining the <code class="literal">@Produces</code> annotation on the <code class="literal">MessageBodyWriter&lt;T&gt;</code>.
                    In our case thanks to <code class="literal">@Produces</code> annotation, the provider will be considered
                    as writeable (and the method <code class="literal">isWriteable</code> might be executed) only if the
                    media type of the outbound message is <code class="literal">"application/xml"</code>. Additionally, the provider
                    will only be considered as possible candidate and its <code class="literal">isWriteable</code> method will
                    be executed, if the generic type of the provider is either a sub class or super class of
                    <code class="literal">type</code> parameter.
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6630"></a>8.2.1.2.&nbsp;
                <code class="literal">MessageBodyWriter.writeTo</code>
            </h4></div></div></div><p>
                Once a message body writer is selected as the most appropriate (see the <a class="xref" href="message-body-workers.html#providers-selection" title="8.3.&nbsp;Entity Provider Selection">Section&nbsp;8.3, &#8220;Entity Provider Selection&#8221;</a>
                for more details on entity provider selection), its <code class="literal">writeTo</code> method is invoked. This method
                receives parameters with the same meaning as in <code class="literal">isWriteable</code> as well as a few additional ones.
            </p><p>
                In addition to the parameters already introduced, the <code class="literal">writeTo</code> method defies also
                <code class="literal">httpHeaders</code> parameter, that contains HTTP headers associated with the
                outbound message.

                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        When a <code class="literal">MessageBodyWriter&lt;T&gt;</code> is invoked, the headers still can be modified in this point
                        and any modification will be reflected in the outbound HTTP message being sent. The modification of
                        headers must however happen before a first byte is written to the supplied output stream.
                    </p></div><p>
            </p><p>
                Another new parameter, <code class="literal">myBean</code>, contains the entity instance to be serialized (the type of
                entity corresponds to generic type of <code class="literal">MessageBodyWriter&lt;T&gt;</code>). Related parameter
                <code class="literal">entityStream</code> contains the entity output stream to which the method should serialize the entity.
                In our case we use JAXB to marshall the entity into the <code class="literal">entityStream</code>. Note, that the
                <code class="literal">entityStream</code> is not closed at the end of method; the stream will be closed by Jersey.
                </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                        Do not close the entity output stream in the <code class="literal">writeTo</code> method of your
                        <code class="literal">MessageBodyWriter&lt;T&gt;</code> implementation.
                    </p></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6688"></a>8.2.1.3.&nbsp;
                <code class="literal">MessageBodyWriter.getSize</code>
            </h4></div></div></div><p>
                The method is deprecated since JAX-RS 2.0 and Jersey 2 ignores the return value. In JAX-RS 1.0 the
                method could return the size of the entity that would be then used for "Content-Length" response
                header. In Jersey 2.0 the "Content-Length" parameter is computed automatically using an internal
                outbound entity buffering. For details about configuration options of outbound entity buffering see the javadoc
                of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/MessageProperties.html" target="_top">MessageProperties</a>, property <code class="literal">OUTBOUND_CONTENT_LENGTH_BUFFER</code>
                which configures the size of the buffer.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        You can disable the Jersey outbound entity buffering by setting the buffer size to 0.
                    </p></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6706"></a>8.2.1.4.&nbsp;Testing a <code class="literal">MessageBodyWriter&lt;T&gt;</code></h4></div></div></div><p>
                Before testing the <code class="literal">MyBeanMessageBodyWriter</code>, the writer must
                be registered as a custom JAX-RS extension provider. It should either be added to your application
                <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a>, or returned from your custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a> sub-class, or
                annotated with <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/Provider.html" target="_top">@Provider</a> annotation to leverage JAX-RS provider auto-discovery feature.
            </p><p>
                After registering the <code class="literal">MyBeanMessageBodyWriter</code> and <code class="literal">MyResource</code> class
                in our application, the request can be initiated (in this example from Client API).

                </p><div class="example"><a name="client-get-call"></a><p class="title"><b>Example&nbsp;8.5.&nbsp;Client code testing MyBeanMessageBodyWriter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget webTarget = // initialize web target to the context root
            // of example application
Response response = webTarget.path("resource")
                        .request(MediaType.APPLICATION_XML).get();
System.out.println(response.getStatus());
String myBeanXml = response.readEntity(String.class);
System.out.println(myBeanXml);</pre></div></div><p><br class="example-break">

                The client code initiates the <code class="literal">GET</code> which will be matched to the resource method
                <code class="literal">MyResource.getMyBean()</code>. The response entity is de-serialized as a <code class="literal">String</code>.
            </p><p>
                The result of console output is:

                </p><div class="example"><a name="d0e6750"></a><p class="title"><b>Example&nbsp;8.6.&nbsp;Result of MyBeanMessageBodyWriter test</b></p><div class="example-contents"><pre class="screen">200
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;myBean&gt;
&lt;anyString&gt;Hello World!&lt;/anyString&gt;&lt;anyNumber&gt;42&lt;/anyNumber&gt;&lt;/myBean&gt;</pre></div></div><p><br class="example-break">

                The returned status is 200 and the entity is stored in the response in a <code class="literal">XML</code> format.
                Next, we will look at how the Jersey de-serializes this XML document into a <code class="literal">MyBean</code> consumed by
                our <code class="literal">POST</code> resource method.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6765"></a>8.2.2.&nbsp;MessageBodyReader</h3></div></div></div><p>
                In order to de-serialize the entity of <code class="literal">MyBean</code> on the server or the client, we need to implement
                a custom <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Please note, that this is only a demonstration of how to write a custom entity provider.
                        Jersey already contains default support for entity providers that can serialize JAXB beans
                        into XML.
                    </p></div><p>
            </p><p>
                Our <code class="literal">MessageBodyReader&lt;T&gt;</code> implementation is listed in <a class="xref" href="message-body-workers.html#mbw.ex.mbr" title="Example&nbsp;8.7.&nbsp;MessageBodyReader example">Example&nbsp;8.7, &#8220;MessageBodyReader example&#8221;</a>.

                </p><div class="example"><a name="mbw.ex.mbr"></a><p class="title"><b>Example&nbsp;8.7.&nbsp;MessageBodyReader example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public static class MyBeanMessageBodyReader
        implements MessageBodyReader&lt;MyBean&gt; {

@Override
public boolean isReadable(Class&lt;?&gt; type, Type genericType,
    Annotation[] annotations, MediaType mediaType) {
    return type == MyBean.class;
}

@Override
public MyBean readFrom(Class&lt;MyBean&gt; type,
    Type genericType,
    Annotation[] annotations, MediaType mediaType,
    MultivaluedMap&lt;String, String&gt; httpHeaders,
    InputStream entityStream)
        throws IOException, WebApplicationException {

    try {
        JAXBContext jaxbContext = JAXBContext.newInstance(MyBean.class);
        MyBean myBean = (MyBean) jaxbContext.createUnmarshaller()
            .unmarshal(entityStream);
        return myBean;
    } catch (JAXBException jaxbException) {
        throw new ProcessingException("Error deserializing a MyBean.",
            jaxbException);
    }
}
}</pre></div></div><p><br class="example-break">

                It is obvious that the <code class="literal">MessageBodyReader&lt;T&gt;</code> interface is similar to <code class="literal">MessageBodyWriter&lt;T&gt;</code>.
                In the next couple of sections we will explore it's API methods.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6799"></a>8.2.2.1.&nbsp;<code class="literal">MessageBodyReader.isReadable</code></h4></div></div></div><p>
                    It defines the method <code class="literal">isReadable()</code> which has a very similar meaning as method
                    <code class="literal">isWriteable()</code> in <code class="literal">MessageBodyWriter&lt;T&gt;</code>. The method returns <code class="literal">true</code>
                    if it is able to de-serialize the given type. The <code class="literal">annotations</code> parameter contains annotations
                    that are attached to the entity parameter in the resource method. In our <code class="literal">POST</code> resource
                    method <code class="literal">postMyBean</code> the entity parameter <code class="literal">myBean</code> is not
                    annotated, therefore no annotation will be passed to the isReadable. The <code class="literal">mediaType</code>
                    parameter contains the entity media type. The media type, in our case, must be consumable by the <code class="literal">POST</code>
                    resource method, which is specified by placing a JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Consumes.html" target="_top">@Consumes</a> annotation to the method.
                    The resource method <code class="literal">postMyBean()</code> is annotated with
                    <code class="literal">@Consumes("application/xml")</code>,
                    therefore for purpose of de-serialization of entity for the <code class="literal">postMyBean()</code> method,
                    only requests with entities represented as <code class="literal">"application/xml"</code>
                    media type will match the method. However, this method might be executed for entity types that are sub classes
                    or super classes of the declared generic type on the <code class="literal">MessageBodyReader&lt;T&gt;</code> will be also considered.
                    It is a responsibility of the <code class="literal">isReadable</code> method to decide whether it is able
                    to de-serialize the entity and type comparison is one of the basic decision steps.
                    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                            In order to reduce number of <code class="literal">isReadable</code> executions, always define correctly the consumable
                            media type(s) with the <code class="literal">@Consumes</code> annotation on your custom <code class="literal">MessageBodyReader&lt;T&gt;</code>.
                        </p></div><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6869"></a>8.2.2.2.&nbsp;<code class="literal">MessageBodyReader.readFrom</code></h4></div></div></div><p>
                    The <code class="literal">readForm()</code> method gets the parameters with the same meaning as in
                    <code class="literal">isReadable()</code>. The additional <code class="literal">entityStream</code> parameter provides a handle
                    to the entity input stream from which the entity bytes should be read and de-serialized into a Java entity which
                    is then returned from the method. Our <code class="literal">MyBeanMessageBodyReader</code> de-serializes the incoming
                    XML data into an instance of <code class="literal">MyBean</code> using JAXB.

                    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                            Do not close the entity input stream in your <code class="literal">MessageBodyReader&lt;T&gt;</code> implementation. The stream
                            will be automatically closed by Jersey runtime.
                        </p></div><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6897"></a>8.2.2.3.&nbsp;Testing a <code class="literal">MessageBodyWriter&lt;T&gt;</code></h4></div></div></div><p>
                    Now let's send a test request using the JAX-RS Client API.

                    </p><div class="example"><a name="d0e6904"></a><p class="title"><b>Example&nbsp;8.8.&nbsp;Testing MyBeanMessageBodyReader</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final MyBean myBean = new MyBean("posted MyBean", 11);
Response response = webTarget.path("resource").request("application/xml")
        .post(Entity.entity(myBean, "application/xml"));

System.out.println(response.getStatus());
final String responseEntity = response.readEntity(String.class);
System.out.println(responseEntity);
</pre></div></div><p><br class="example-break">
                </p><p>
                    The console output is:

                    </p><div class="example"><a name="d0e6912"></a><p class="title"><b>Example&nbsp;8.9.&nbsp;Result of testing MyBeanMessageBodyReader</b></p><div class="example-contents"><pre class="screen">200
posted MyBean</pre></div></div><p><br class="example-break">
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6918"></a>8.2.2.4.&nbsp;Using Entity Providers with JAX-RS Client API</h4></div></div></div><p>
                    Both, <code class="literal">MessageBodyReader&lt;T&gt;</code> and <code class="literal">MessageBodyWriter&lt;T&gt;</code> can be registered in a
                    configuration of JAX-RS Client API components typically without any need to change their code. The example
                    <a class="xref" href="message-body-workers.html#mbw.ex.client.mbr.reg" title="Example&nbsp;8.10.&nbsp;MessageBodyReader registered on a JAX-RS client">Example&nbsp;8.10, &#8220;MessageBodyReader registered on a JAX-RS client&#8221;</a> is a variation on the <a class="xref" href="message-body-workers.html#client-get-call" title="Example&nbsp;8.5.&nbsp;Client code testing MyBeanMessageBodyWriter">Example&nbsp;8.5, &#8220;Client code testing MyBeanMessageBodyWriter&#8221;</a>
                    listed in one of the previous sections.

                    </p><div class="example"><a name="mbw.ex.client.mbr.reg"></a><p class="title"><b>Example&nbsp;8.10.&nbsp;MessageBodyReader registered on a JAX-RS client</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
    .register(MyBeanMessageBodyReader.class).build();

Response response = client.target("http://example/comm/resource")
    .request(MediaType.APPLICATION_XML).get();
System.out.println(response.getStatus());
MyBean myBean = response.readEntity(MyBean.class);
System.out.println(myBean);</pre></div></div><p><br class="example-break">
                </p><p>
                    The code above registers <code class="literal">MyBeanMessageBodyReader</code> to the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a> configuration
                    using a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientBuilder.html" target="_top">ClientBuilder</a> which means that the provider will be used for any <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a>
                    produced by the <code class="literal">client</code> instance.
                    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                            You could also register the JAX-RS entity (and any other) providers to individual
                            <code class="literal">WebTarget</code> instances produced by the client.
                        </p></div><p>

                    Then, using the fluent chain of method invocations, a resource target pointing to our
                    <code class="literal">MyResource</code> is defined, a HTTP <code class="literal">GET</code> request is invoked.
                    The response entity is then read as an instance of a <code class="literal">MyBean</code> type by invoking the
                    <code class="literal">response.readEntity</code> method, that internally locates the registered
                    <code class="literal">MyBeanMessageBodyReader</code> and uses it for entity de-serialization.
                </p><p>
                    The console output for the example is:
                    </p><div class="example"><a name="d0e6980"></a><p class="title"><b>Example&nbsp;8.11.&nbsp;Result of client code execution</b></p><div class="example-contents"><pre class="screen">200
MyBean{anyString='Hello World!', anyNumber=42}</pre></div></div><p><br class="example-break">
                </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="providers-selection"></a>8.3.&nbsp;Entity Provider Selection</h2></div></div></div><p>
            Usually there are many entity providers registered on the server or client side (be default there must be
            at least providers mandated by the JAX-RS specification, such as providers for primitive types, byte array,
            JAXB beans, etc.).
            JAX-RS defines an algorithm for selecting the most suitable provider for entity processing. This algorithm
            works with information such as entity Java type and on-the-wire media type representation of entity, and searches
            for the most suitable entity provider from the list of available providers based on the supported media type
            declared on each provider (defined by <code class="literal">@Produces</code> or <code class="literal">@Consumes</code> on the provider class)
            as well as based on the generic type declaration of the available providers. When a list of suitable candidate
            entity providers is selected and sorted based on the rules defined in JAX-RS specification, a JAX-RS runtime
            then it invokes <code class="literal">isReadable</code> or <code class="literal">isWriteable</code> method respectively on each
            provider in the list until a first provider is found that returns <code class="literal">true</code>. This provider is then used to
            process the entity.
        </p><p>
            The following steps describe the algorithm for selecting a <code class="literal">MessageBodyWriter&lt;T&gt;</code> (extracted
            from JAX-RS with little modifications). The steps refer to the previously discussed example application.
            The <code class="literal">MessageBodyWriter&lt;T&gt;</code> is searched for purpose of deserialization of <code class="literal">MyBean</code>
            entity returned from the method <code class="literal">getMyBean</code>. So, <span class="emphasis"><em>type is <code class="literal">MyBean</code>
            and media type <code class="literal">"application/xml"</code></em></span>. Let's assume the runtime contains also
            registered providers, namely:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                    <code class="literal">A</code>: <code class="literal">@Produces("application/*")</code> with generic type
                    <code class="literal">&lt;Object&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">B</code>: <code class="literal">@Produces("*/*")</code> with generic type <code class="literal">&lt;MyBean&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">C</code>: <code class="literal">@Produces("text/plain")</code> with generic type
                    <code class="literal">&lt;MyBean&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">D</code>: <code class="literal">@Produces("application/xml")</code> with generic type
                    <code class="literal">&lt;Object&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">MyBeanMessageBodyWriter</code>: <code class="literal">@Produces("application/xml")</code> with generic
                    type <code class="literal">&lt;MyBean&gt;</code>
                </td></tr></table><p>
        </p><p>
            The algorithm executed by a JAX-RS runtime to select a proper <code class="literal">MessageBodyWriter&lt;T&gt;</code> implementation
            is illustrated in <a class="xref" href="message-body-workers.html#mbw.writer.selection.algorithm" title="Procedure&nbsp;8.1.&nbsp;MessageBodyWriter<T&gt; Selection Algorithm">Procedure&nbsp;8.1, &#8220;<code class="literal">MessageBodyWriter&lt;T&gt;</code> Selection Algorithm&#8221;</a>.
        </p><div class="procedure"><a name="mbw.writer.selection.algorithm"></a><p class="title"><b>Procedure&nbsp;8.1.&nbsp;<code class="literal">MessageBodyWriter&lt;T&gt;</code> Selection Algorithm</b></p><ol class="procedure" type="1"><li class="step"><p>
                    Obtain the object that will be mapped to the message entity body. For a return type of Response
                    or subclasses, the object is the value of the entity property, for other return types it is the returned
                    object.
                </p><p>
                    So in our case, for the resource method <code class="literal">getMyBean</code> the type will
                    be <code class="literal">MyBean</code>.
                </p></li><li class="step"><p>
                    Determine the media type of the response.
                </p><p>
                    In our case, for resource method <code class="literal">getMyBean</code>
                    annotated with <code class="literal">@Produces("application/xml")</code>, the media type will be
                    <code class="literal">"application/xml"</code>.
                </p></li><li class="step"><p>
                    Select the set of MessageBodyWriter providers that support the object and media
                    type of the message entity body.
                </p><p>
                    In our case, for entity media type <code class="literal">"application/xml"</code>
                    and type <code class="literal">MyBean</code>, the appropriate <code class="literal">MessageBodyWriter&lt;T&gt;</code> will
                    be the <code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">D</code>
                    and <code class="literal">MyBeanMessageBodyWriter</code>. The provider <code class="literal">C</code> does
                    not define the appropriate
                    media type. <code class="literal">A</code> and <code class="literal">B</code> are fine as
                    their type is more generic and compatible with <code class="literal">"application/xml"</code>.
                </p></li><li class="step"><a name="mbw.writer.selection.algorithm.sortStep"></a><p>
                    Sort the selected MessageBodyWriter providers with a primary key of generic type where providers
                    whose generic type is the nearest superclass of the object class are sorted first and a secondary key of
                    media type. Additionally, JAX-RS specification mandates that custom, user registered providers have to
                    be sorted ahead of default providers provided by JAX-RS implementation. This is used as a tertiary
                    comparison key. User providers are places prior to Jersey internal providers in to the final ordered list.
                </p><p>
                    The sorted providers will be: <code class="literal">MyBeanMessageBodyWriter</code>,
                    <code class="literal">B</code>. <code class="literal">D</code>, <code class="literal">A</code>.
                </p></li><li class="step"><p>
                    Iterate through the sorted <code class="literal">MessageBodyWriter&lt;T&gt;</code> providers and, utilizing the
                    <code class="literal">isWriteable</code> method of each until you find a <code class="literal">MessageBodyWriter&lt;T&gt;</code> that
                    returns <code class="literal">true</code>.
                </p><p>
                    The first provider in the list - our <code class="literal">MyBeanMessageBodyWriter</code> returns <code class="literal">true</code> as
                    it compares types and the types matches. If it would return <code class="literal">false</code>, the next provider
                    <code class="literal">B</code> would by check by invoking its <code class="literal">isWriteable</code> method.
                </p></li><li class="step"><p>
                    If step 5 locates a suitable <code class="literal">MessageBodyWriter&lt;T&gt;</code> then use its writeTo method to map the
                    object to the entity body.
                </p><p>
                    <code class="literal">MyBeanMessageBodyWriter.writeTo</code> will be executed and it will serialize the
                    entity.
                </p><ul class="stepalternatives">
                    <li class="step"><p>
                            Otherwise, the server runtime MUST generate an
                            <code class="literal">InternalServerErrorException</code>, a subclass of
                            <code class="literal">WebApplicationException</code> with its status set to 500, and no entity and the client
                            runtime MUST generate a <code class="literal">ProcessingException</code>.
                        </p><p>
                            We have successfully found a provider, thus no exception is generated.
                        </p></li>
                </ul></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                JAX-RS 3.x/2.x is incompatible with JAX-RS 1.x in one step of the entity provider selection algorithm.
                JAX-RS 1.x defines sorting keys priorities in the <a class="xref" href="message-body-workers.html#mbw.writer.selection.algorithm.sortStep" title="Step 4">Step 4</a>
                in exactly opposite order. So, in JAX-RS 1.x the keys are defined in the order: primary media type,
                secondary type declaration distance where custom providers have always precedence to internal providers.
                If you want to force Jersey to use the algorithm compatible with JAX-RS 1.x, setup the property
                (to <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> or return from <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Application.html" target="_top">Application</a> from its
                <code class="literal">getProperties</code> method):

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">jersey.config.workers.legacyOrdering=true</pre><p>

                Documentation of this property can be found in the javadoc of <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/MessageProperties.html" target="_top">MessageProperties</a>.
            </p></div><p>
            The algorithm for selection of <code class="literal">MessageBodyReader&lt;T&gt;</code> is similar, including the incompatibility
            between JAX-RS 3.x/2.x and JAX-RS 1.x and the property to workaround it. The algorithm is defined as follows:
        </p><div class="procedure"><a name="mbw.reader.selection.algorithm"></a><p class="title"><b>Procedure&nbsp;8.2.&nbsp;<code class="literal">MessageBodyReader&lt;T&gt;</code> Selection Algorithm</b></p><ol class="procedure" type="1"><li class="step"><p>
                    Obtain the media type of the request. If the request does not contain a <code class="literal">Content-Type</code>
                    header then use <code class="literal">application/octet-stream</code> media type.
                </p></li><li class="step"><p>
                    Identify the Java type of the parameter whose value will be mapped from the entity body. The
                    Java type on the server is the type of the entity parameter of the resource method. On the client
                    it is the <code class="literal">Class</code> passed to <code class="literal">readFrom</code> method.
                </p></li><li class="step"><p>
                    Select the set of available <code class="literal">MessageBodyReader&lt;T&gt;</code> providers that support the media type
                    of the request.
                </p></li><li class="step"><a name="mbw.reader.selection.algorithm.selectStep"></a><p>
                    Iterate through the selected <code class="literal">MessageBodyReader&lt;T&gt;</code> classes and, utilizing their
                    <code class="literal">isReadable</code> method, choose the first <code class="literal">MessageBodyReader&lt;T&gt;</code> provider that
                    supports the desired combination of Java type/media type/annotations parameters.
                </p></li><li class="step"><p>
                    If <a class="xref" href="message-body-workers.html#mbw.reader.selection.algorithm.selectStep" title="Step 4">Step 4</a> locates a suitable
                    <code class="literal">MessageBodyReader&lt;T&gt;</code>, then use its <code class="literal">readFrom</code> method to map the entity
                    body to the desired Java type.
                </p><ul class="stepalternatives">
                    <li class="step"><p>
                            Otherwise, the server runtime MUST generate a <code class="literal">NotSupportedException</code>
                            (HTTP 415 status code) and no entity and the client runtime MUST generate an instance
                            of <code class="literal">ProcessingException</code>.
                        </p></li>
                </ul></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7326"></a>8.4.&nbsp;Jersey <code class="literal">MessageBodyWorkers</code> API</h2></div></div></div><p>
            In case you need to directly work with JAX-RS entity providers, for example to serialize an entity in your resource
            method, filter or in a composite entity provider, you would need to perform quite a lot of steps.
            You would need to choose the appropriate <code class="literal">MessageBodyWriter&lt;T&gt;</code> based on the type, media type and
            other parameters. Then you would need to instantiate it, check it by <code class="literal">isWriteable</code> method and
            basically perform all the steps that are normally performed by Jersey
            (see <a class="xref" href="message-body-workers.html#mbw.reader.selection.algorithm" title="Procedure&nbsp;8.2.&nbsp;MessageBodyReader<T&gt; Selection Algorithm">Procedure&nbsp;8.2, &#8220;<code class="literal">MessageBodyReader&lt;T&gt;</code> Selection Algorithm&#8221;</a>).
        </p><p>
            To remove this burden from developers, Jersey exposes a proprietary public API that simplifies the manipulation
            of entity providers. The API is defined by <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/message/MessageBodyWorkers.html" target="_top">MessageBodyWorkers</a> interface and Jersey provides an
            implementation that can be injected using the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Context.html" target="_top">@Context</a> injection annotation. The interface declares
            methods for selection of most appropriate <code class="literal">MessageBodyReader&lt;T&gt;</code> and <code class="literal">MessageBodyWriter&lt;T&gt;</code>
            based on the rules defined in JAX-RS spec, methods for writing and reading entity that ensure proper and timely
            invocation of interceptors and other useful methods.
        </p><p>
            See the following example of usage of <code class="literal">MessageBodyWorkers</code>.

            </p><div class="example"><a name="d0e7361"></a><p class="title"><b>Example&nbsp;8.12.&nbsp;Usage of MessageBodyWorkers interface</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("workers")
public static class WorkersResource {

    @Context
    private MessageBodyWorkers workers;

    @GET
    @Produces("application/xml")
    public String getMyBeanAsString() {

        final MyBean myBean = new MyBean("Hello World!", 42);

        // buffer into which myBean will be serialized
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        // get most appropriate MBW
        final MessageBodyWriter&lt;MyBean&gt; messageBodyWriter =
                workers.getMessageBodyWriter(MyBean.class, MyBean.class,
                        new Annotation[]{}, MediaType.APPLICATION_XML_TYPE);

        try {
            // use the MBW to serialize myBean into baos
            messageBodyWriter.writeTo(myBean,
                MyBean.class, MyBean.class, new Annotation[] {},
                MediaType.APPLICATION_XML_TYPE, new MultivaluedHashMap&lt;String, Object&gt;(),
                baos);
        } catch (IOException e) {
            throw new RuntimeException(
                "Error while serializing MyBean.", e);
        }

        final String stringXmlOutput = baos.toString();
        // stringXmlOutput now contains XML representation:
        // "&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
        // &lt;myBean&gt;&lt;anyString&gt;Hello World!&lt;/anyString&gt;
        // &lt;anyNumber&gt;42&lt;/anyNumber&gt;&lt;/myBean&gt;"

        return stringXmlOutput;
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            In the example a resource injects <code class="literal">MessageBodyWorkers</code> and uses it for selection
            of the most appropriate <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Then the writer is utilized to serialize the entity
            into the buffer as XML document. The <code class="literal">String</code> content of the buffer is then returned.
            This will cause that Jersey will not use <code class="literal">MyBeanMessageBodyWriter</code>
            to serialize the entity as it is already in the <code class="literal">String</code> type
            (<code class="literal">MyBeanMessageBodyWriter</code> does not support <code class="literal">String</code>). Instead, a simple
            <code class="literal">String</code>-based  <code class="literal">MessageBodyWriter&lt;T&gt;</code> will be chosen and it will only serialize the
            <code class="literal">String</code> with XML to the output entity stream by writing out the bytes of the
            <code class="literal">String</code>.
        </p><p>
            Of course, the code in the example does not bring any benefit as the entity could
            have been serialized by <code class="literal">MyBeanMessageBodyWriter</code> by Jersey as in previous examples;
            the purpose of the example was to show how to use <code class="literal">MessageBodyWorkers</code> in a resource method.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7410"></a>8.5.&nbsp;Default Jersey Entity Providers</h2></div></div></div><p>
            Jersey internally contains entity providers for these types with combination of media types (in brackets):
        </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <code class="literal">byte[]</code> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/String.html" target="_top">String</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/InputStream.html" target="_top">InputStream</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/Reader.html" target="_top">Reader</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_top">File</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="https://jakarta.ee/specifications//activation/2.0/apidocs/jakarta.activation/jakarta/activation/datasource" target="_top">DataSource</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Source.html" target="_top">Source</a> (<code class="literal">text/xml</code>, <code class="literal">application/xml</code> and media types of the form
                <code class="literal">application/*+xml</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/jakarta.xml.bind/JAXBElement.html" target="_top">JAXBElement</a> (<code class="literal">text/xml</code>, <code class="literal">application/xml</code> and media types of the form
                <code class="literal">application/*+xml</code>)
            </td></tr><tr><td>
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/MultivaluedMap.html" target="_top">MultivaluedMap&lt;K,V&gt;</a> (<code class="literal">application/x-www-form-urlencoded</code>)
            </td></tr><tr><td>
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Form.html" target="_top">Form</a> (<code class="literal">application/x-www-form-urlencoded</code>)
            </td></tr><tr><td>
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/StreamingOutput.html" target="_top">StreamingOutput</a> ((<code class="literal">*/*</code>)) - this class can be used as an lightweight
                <code class="literal">MessageBodyWriter&lt;T&gt;</code> that can be returned from a resource method
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Boolean.html" target="_top">Boolean</a>, <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Character.html" target="_top">Character</a> and <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Number.html" target="_top">Number</a> (<code class="literal">text/plain</code>) - corresponding
                primitive types supported via boxing/unboxing conversion
            </td></tr></table><p>
            For other media type supported in jersey please see the <a class="xref" href="media.html" title="Chapter&nbsp;9.&nbsp;Support for Common Media Type Representations">Chapter&nbsp;9, <i>Support for Common Media Type Representations</i></a> which describes
            additional Jersey entity provider extensions for serialization to JSON, XML, serialization of collections,
            <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/multipart/package-summary.html" target="_top">Multi Part</a> and others.
        </p></div></div><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.css" rel="stylesheet" type="text/css"><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shThemeDefault.css" rel="stylesheet" type="text/css"><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.js" type="text/javascript"></script><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shAutoloader.js" type="text/javascript"></script><script type="text/javascript">
            function path() {
              var args = arguments,
                  result = []
                  ;

              for(var i = 0; i < args.length; i++)
                  result.push(args[i].replace('@', 'https://eclipse-ee4j.github.io/jersey.github.io/sh/'));

              return result
            };

            SyntaxHighlighter.autoloader.apply(null, path(
              'applescript            @shBrushAppleScript.js',
              'actionscript3 as3      @shBrushAS3.js',
              'bash shell             @shBrushBash.js',
              'coldfusion cf          @shBrushColdFusion.js',
              'cpp c                  @shBrushCpp.js',
              'c# c-sharp csharp      @shBrushCSharp.js',
              'css                    @shBrushCss.js',
              'delphi pascal          @shBrushDelphi.js',
              'diff patch pas         @shBrushDiff.js',
              'erl erlang             @shBrushErlang.js',
              'groovy                 @shBrushGroovy.js',
              'java                   @shBrushJava.js',
              'jfx javafx             @shBrushJavaFX.js',
              'js jscript javascript  @shBrushJScript.js',
              'perl pl                @shBrushPerl.js',
              'php                    @shBrushPhp.js',
              'text plain             @shBrushPlain.js',
              'py python              @shBrushPython.js',
              'ruby rails ror rb      @shBrushRuby.js',
              'sass scss              @shBrushSass.js',
              'scala                  @shBrushScala.js',
              'sql                    @shBrushSql.js',
              'vb vbnet               @shBrushVb.js',
              'xml xhtml xslt html    @shBrushXml.js'
            ));

            SyntaxHighlighter.all();
        </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="representations.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="media.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;7.&nbsp;Representations and Responses&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;9.&nbsp;Support for Common Media Type Representations</td></tr></table></div></div></body></html>