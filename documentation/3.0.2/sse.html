<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;16.&nbsp;Server-Sent Events (SSE) Support</title><link rel="stylesheet" type="text/css" href="/jersey.github.io/documentation.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Jersey 3.0.2 User Guide"><link rel="up" href="index.html" title="Jersey 3.0.2 User Guide"><link rel="prev" href="jersey-configuration.html" title="Chapter&nbsp;15.&nbsp;Jersey configuration"><link rel="next" href="security.html" title="Chapter&nbsp;17.&nbsp;Security"><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-3160303-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script></head><body class="contents"><div class="contents" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;16.&nbsp;Server-Sent Events (SSE) Support</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="jersey-configuration.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="security.html">Next</a></td></tr></table><hr></div><div style="float:right"><a href="https://eclipse-ee4j.github.io/jersey"><img src="https://eclipse-ee4j.github.io/jersey.github.io/images/jersey_logo.png"></a></div><small>Links:
            <a href="index.html">
                Table of Contents
            </a> | <a href="user-guide.html">
                Single HTML
            </a></small><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="sse"></a>Chapter&nbsp;16.&nbsp;Server-Sent Events (SSE) Support</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="sse.html#d0e11194">16.1. What are Server-Sent Events</a></span></dt><dt><span class="section"><a href="sse.html#d0e11237">16.2. When to use Server-Sent Events</a></span></dt><dt><span class="section"><a href="sse.html#jaxrs-sse-api-overview">16.3. Server-Sent Events API</a></span></dt><dt><span class="section"><a href="sse.html#d0e11299">16.4. Implementing SSE support in a JAX-RS resource (with JAX-RS SSE API)</a></span></dt><dd><dl><dt><span class="section"><a href="sse.html#d0e11302">16.4.1. Simple SSE resource method</a></span></dt><dt><span class="section"><a href="sse.html#d0e11478">16.4.2. Broadcasting with Jersey SSE</a></span></dt></dl></dd><dt><span class="section"><a href="sse.html#sse-client-jaxrs">16.5. Consuming SSE events within Jersey clients</a></span></dt><dd><dl><dt><span class="section"><a href="sse.html#sse-event-source-reconnect">16.5.1. 
                <code class="literal">SseEventSource</code>
                reconnect support
            </a></span></dt></dl></dd><dt><span class="section"><a href="sse.html#overview-jersey-specific">16.6. Jersey-specific Server-Sent Events API</a></span></dt><dd><dl><dt><span class="section"><a href="sse.html#d0e11914">16.6.1. Implementing SSE support in a JAX-RS resource</a></span></dt><dt><span class="section"><a href="sse.html#d0e12103">16.6.2. Consuming SSE events with Jersey clients</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11194"></a>16.1.&nbsp;What are Server-Sent Events</h2></div></div></div><p>
            In a standard HTTP request-response scenario a client opens a connection, sends a HTTP request to the server (for
            example a HTTP <code class="literal">GET</code> request), then receives a HTTP response back and the server closes the connection once
            the response is fully sent/received. The initiative <span class="emphasis"><em>always</em></span> comes from a client when the client
            requests all the data. In contrast, <span class="emphasis"><em>Server-Sent Events (SSE)</em></span> is a mechanism that allows server
            to asynchronously push the data from the server to the client once the client-server connection is established by the
            client. Once the connection is established by the client, it is the server who provides the data and decides
            to send it to the client whenever new "chunk" of data is available. When a new data event occurs on the server,
            the data event is sent by the server to the client. Thus the name Server-Sent Events. Note that at high level there
            are more technologies working on this principle, a short overview of the technologies supporting server-to-client
            communication is in this list:

            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Polling</span></dt><dd><p>
                            With polling a client repeatedly sends new requests to a server. If the server has no new data,
                            then it send appropriate indication and closes the connection. The client then waits a bit and sends
                            another request after some time (after one second, for example).
                        </p></dd><dt><span class="term">Long-polling</span></dt><dd><p>
                            With long-polling a client sends a request to a server. If the server has no new data,
                            it just holds the connection open and waits until data is available. Once the server has data
                            (message) for the client, it uses the connection and sends it back to the client. Then the connection
                            is closed.
                        </p></dd><dt><span class="term">Server-Sent events</span></dt><dd><p>
                            SSE is similar to the long-polling mechanism, except it does not send only one message per connection.
                            The client sends a request and server holds a connection until a new message is ready, then it sends
                            the message back to the client while still keeping the connection open so that it can be used
                            for another message once it becomes available. Once a new message is ready, it is sent back to the
                            client on the same initial connection. Client processes the messages sent back from the server
                            individually without closing the connection after processing each message.
                            So, SSE typically reuses one connection for more messages (called events). SSE also defines a
                            dedicated media type that describes a simple format of individual events sent from the server to the
                            client. SSE also offers standard javascript client API implemented most modern browsers. For more
                            information about SSE, see the
                            <a class="link" href="https://www.w3.org/TR/eventsource/" target="_top">SSE API specification</a>.
                        </p></dd><dt><span class="term">WebSocket</span></dt><dd><p>
                            WebSocket technology is different from previous technologies as it provides a real full duplex
                            connection. The initiator is again a client which sends a request to a server with a special HTTP
                            header that informs the server that the HTTP connection may be "upgraded" to a full duplex TCP/IP
                            WebSocket connection. If server supports WebSocket, it may choose to do so. Once a WebSocket
                            connection is established, it can be used for bi-directional communication between the client and the
                            server. Both client and server can then send data to the other party at will whenever it is needed.
                            The communication on the new WebSocket connection is no longer based on HTTP protocol and can be
                            used for example for for online gaming or any other applications that require fast exchange of small
                            chunks of data in flowing in both directions.
                        </p></dd></dl></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11237"></a>16.2.&nbsp;When to use Server-Sent Events</h2></div></div></div><p>
            As explained above, SSE is a technology that allows clients to subscribe to event notifications that originate on
            a server. Server generates new events and sends these events back to the clients subscribed to receive the
            notifications. In other words, SSE offers a solution for a one-way publish-subscribe model.
        </p><p>
            A good example of the use case where SSE can be used is a simple message exchange RESTful service. Clients
            <code class="literal">POST</code> new messages to the service and subscribe to receive messages from other clients.
            Let's call the resource <code class="literal">messages</code>. While <code class="literal">POST</code>ing a new message to this resource involves
            a typical HTTP request-response communication between a client and the <code class="literal">messages</code> resource,
            subscribing to receive all new message notifications would be hard and impractical to model with a sequence of
            standard request-response message exchanges. Using Server-sent events provides a much more practical approach here.
            You can use SSE to let clients subscribe to the <code class="literal">messages</code> resource via standard <code class="literal">GET</code>
            request (use a SSE client API, for example javascript API or Jersey Client SSE API) and let the server broadcast
            new messages to all connected clients in the form of individual events (in our case using Jersey Server SSE API).
            Note that with Jersey a SSE support is implemented as an usual JAX-RS resource method. There's no need to do anything
            special to provide a SSE support in your Jersey/JAX-RS applications, your SSE-enabled resources are a standard part of
            your RESTful Web application that defines the REST API of your application. The following chapters describes SSE
            support in Jersey in more details.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jaxrs-sse-api-overview"></a>16.3.&nbsp;Server-Sent Events API</h2></div></div></div><p>
            In previous JAX-RS versions, no standard API for server-sent events was defined. The SSE support bundled with
            Jersey was Jersey-specific. With JAX-RS 2.1 (with respect to namespace change after jakartification),
            situation changed and SSE API is well defined in the <code class="literal">jakarta.ws.rs.sse</code> package.
        </p><p>Following chapters will describe the new SSE API. For backwards compatibility reasons, the original
            Jersey-specific API remains valid and will be described in
            <a class="xref" href="sse.html#overview-jersey-specific" title="16.6.&nbsp;Jersey-specific Server-Sent Events API">Section&nbsp;16.6, &#8220;Jersey-specific Server-Sent Events API&#8221;</a>
        </p><p>
            Jersey contains support for SSE for both - server and client. SSE in Jersey is implemented as an extension
            supporting a new media type using existing "chunked" messages support. However, in contrast to the original API,
            the instances of SSE related classes are not to be obtained manually by invoking constructors, nor to be directly
            returned from the resource methods.
            Actually, the implementing classes in the <code class="literal">jersey.media.sse.internal</code> package should never be needed
            to be imported. The only API to be used is directly in the JAX-RS package (<code class="literal">jakarta.ws.rs.sse</code>).
            Only builders in the API along with dependency injection should be used and provides access to the entire
            functionality.
        </p><p>
            In order to take advantage of the SSE support, the <code class="literal">jersey-media-sse</code> module has to be on classpath.
            In maven, this can be achieved by adding the dependency to the <span class="emphasis"><em>SSE media type module</em></span>:
            </p><div class="example"><a name="sse-dependency-jaxrs"></a><p class="title"><b>Example&nbsp;16.1.&nbsp;Adding the SSE dependency</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-sse&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></div></div><p><br class="example-break">
            The <code class="literal">Feature</code> defined in the module is (forced) auto-discoverable, which means having the module on
            classpath is sufficient, no need to further register it in the code.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11299"></a>16.4.&nbsp;Implementing SSE support in a JAX-RS resource (with JAX-RS SSE API)</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11302"></a>16.4.1.&nbsp;Simple SSE resource method</h3></div></div></div><div class="example"><a name="example-simple-sse-jaxrs"></a><p class="title"><b>Example&nbsp;16.2.&nbsp;Simple SSE resource method</b></p><div class="example-contents">
                As mentioned above, the SSE related are not instantiated directly. In this case, Jersey takes care of the
                dependencies and injects the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSink.html" target="_top">SseEventSink</a> (represents the output) and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/Sse.html" target="_top">Sse</a> (provides
                factory methods for other SSE related types, in this case it is used to retrieve the event builder).
                <pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import jakarta.ws.rs.sse.Sse;
import jakarta.ws.rs.sse.SseEventSink;
import jakarta.ws.rs.sse.OutboundSseEvent;
...

@Path("events")
public static class SseResource {

    @GET
    @Produces(MediaType.SERVER_SENT_EVENTS)
    public void getServerSentEvents(@Context SseEventSink eventSink, @Context Sse sse) {
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 10; i++) {
                // ... code that waits 1 second
                final OutboundSseEvent event = sse.newEventBuilder()
                    .name("message-to-client")
                    .data(String.class, "Hello world " + i + "!")
                    .build();
                eventSink.send(event);
            }
        }).start();
    }
}
                </pre></div></div><br class="example-break"><p>
                The code above defines the resource deployed on URI "/events". This resource has a single
                <code class="literal">@GET</code>
                resource method which <span class="emphasis"><em>returns void</em></span>. This is an imported difference
                against the original API. It is Jersey's responsibility to bind the injected <code class="literal">SseEventSink</code> to
                the output chain.
            </p><p>
                After the <code class="literal">SseEventInput</code> is "returned" from the method, the Jersey runtime recognizes that this
                is a <code class="literal">ChunkedOutput</code> extension and does not close the client connection immediately. Instead, it
                writes the HTTP headers to the response stream and waits for more chunks (SSE events) to be sent. At this point
                the client can read headers and starts listening for individual events.
            </p><p>
                In the <a class="xref" href="sse.html#example-simple-sse-jaxrs" title="Example&nbsp;16.2.&nbsp;Simple SSE resource method">Example&nbsp;16.2, &#8220;Simple SSE resource method&#8221;</a>, the resource method creates a new thread that sends a
                sequence of 10 events. There is a 1 second delay between two subsequent events as indicated in a comment. Each
                event is represented by <code class="literal">jakarta.ws.rs.sse.OutboundSseEvent</code> type and is built with a help of a
                provided <code class="literal">Builder</code>. The <code class="literal">Builder</code> is obtain via the injected instance
                (actually, it is a singleton) of <code class="literal">jakarta.ws.rs.sse.Sse</code> (the
                <code class="literal">newEventBuilder()</code>
                method). The <code class="literal">OutboundSseEvent</code> implementation reflects the standardized format of
                SSE messages and contains properties that represent <code class="literal">name</code> (for named events),
                <code class="literal">comment</code>, <code class="literal">data</code> or <code class="literal">id</code>. The code also sets the
                event data media type using the <code class="literal">mediaType(MediaType)</code> method on the
                <code class="literal">eventBuilder</code>. The media type, together with the data type set by the
                <code class="literal">data(Class, Object)</code>
                method (in our case <code class="literal">String.class</code>), is used
                for serialization of the event data. Note that the event data media type will not be written to any headers as
                the response <code class="literal">Content-type</code> header is already defined by the <code class="literal">@Produces</code> and set to
                <code class="literal">"text/event-stream"</code>
                using constant from the <code class="literal">MediaType</code>.
                The event media type is used for serialization of event <code class="literal">data</code>. Event data media type and Java
                type are used to select the proper <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for event data serialization and are passed
                to the selected writer that serializes the event <code class="literal">data</code> content. In our case the string
                <code class="literal">"Hello world " + i + "!"</code>
                is serialized as <code class="literal">"text/plain"</code>. In event
                <code class="literal">data</code>
                you can send any Java entity and associate it with any media type that you would be able
                to serialize with an available <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Typically, you may want to send e.g. JSON data,
                so you would fill the <code class="literal">data</code> with a JAXB annotated bean instance and define media type to JSON.
                </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If the event media type is not set explicitly, the <code class="literal">"text/plain"</code> media type is used
                        by default.
                    </p></div><p>
            </p><p>
                Once an outbound event is ready, it can be written to the <code class="literal">EventSink</code>. At that point the event
                is serialized by internal <code class="literal">OutboundEventWriter</code> which uses an appropriate
                <code class="literal">MessageBodyWriter&lt;T&gt;</code> to serialize the <code class="literal">"Hello world " + i + "!"</code> string. You can
                send as many messages as you like. At the end of the thread execution the response is closed which also closes
                the connection to the client. After that, no more messages can be sent to the client on this connection. If the
                client would like to receive more messages, it would have to send a new request to the server to initiate a
                new SSE streaming connection.
            </p><p>
                A client connecting to our SSE-enabled resource will receive the following data from the entity stream:

                </p><pre class="screen">event: message-to-client
data: Hello world 0!

event: message-to-client
data: Hello world 1!

event: message-to-client
data: Hello world 2!

event: message-to-client
data: Hello world 3!

event: message-to-client
data: Hello world 4!

event: message-to-client
data: Hello world 5!

event: message-to-client
data: Hello world 6!

event: message-to-client
data: Hello world 7!

event: message-to-client
data: Hello world 8!

event: message-to-client
data: Hello world 9!
                </pre><p>

                Each message is received with a delay of one second.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    If you have worked with streams in JAX-RS, you may wonder what is the difference between
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ChunkedOutput.html" target="_top">ChunkedOutput</a> and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/StreamingOutput.html" target="_top">StreamingOutput</a>.
                </p><p>
                    <code class="literal">ChunkedOutput</code> is Jersey-specific API. It lets you send "chunks" of data without closing
                    the client connection using series of convenient calls to <code class="literal">ChunkedOutput.write</code> methods
                    that take POJO + chunk media type as an input and then use the configured JAX-RS
                    <code class="literal">MessageBodyWriter&lt;T&gt;</code> providers to figure out the proper way of serializing each chunk POJO
                    to bytes. Additionally, <code class="literal">ChunkedOutput</code> writes can be invoked multiple times on the same
                    outbound response connection, i.e. individual chunks are written in each write, not the full response entity.
                </p><p>
                    <code class="literal">StreamingOutput</code> is, on the other hand, a low level JAX-RS API that works with bytes
                    directly. You have to implement <code class="literal">StreamingOutput</code> interface yourself. Also, its
                    <code class="literal">write(OutputStream)</code>
                    method will be invoked by JAX-RS runtime only once per response
                    and the call to this method is blocking, i.e. the method is expected to write the entire entity body
                    before returning.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11478"></a>16.4.2.&nbsp;Broadcasting with Jersey SSE</h3></div></div></div><p>
                JAX-RS SSE API defines <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseBroadcaster.html" target="_top">SseBroadcaster</a> which allows to broadcast individual events to multiple
                clients. A simple broadcasting implementation is shown in the following example:

                </p><div class="example"><a name="d0e11486"></a><p class="title"><b>Example&nbsp;16.3.&nbsp;Broadcasting SSE messages (with JAX-RS 3.0 API)</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import jakarta.ws.rs.sse.Sse;
import jakarta.ws.rs.sse.SseEventSink;
import jakarta.ws.rs.sse.SseBroadcaster;
...

@Singleton
@Path("broadcast")
public static class BroadcasterResource {
    private Sse sse;
    private SseBroadcaster broadcaster;

    public BroadcasterResource(@Context final Sse sse) {
        this.sse = sse;
        this.broadcaster = sse.newBroadcaster();
    }

    @POST
    @Produces(MediaType.TEXT_PLAIN)
    @Consumes(MediaType.TEXT_PLAIN)
    public String broadcastMessage(String message) {
        final OutboundSseEvent event = sse.newEventBuilder()
            .name("message")
            .mediaType(MediaType.TEXT_PLAIN_TYPE)
            .data(String.class, message)
            .build();

        broadcaster.broadcast(event);

        return "Message '" + message + "' has been broadcast.";
    }

    @GET
    @Produces(MediaType.SERVER_SENT_EVENTS)
    public void listenToBroadcast(@Context SseEventSink eventSink) {
        this.broadcaster.register(eventSink);
    }
}
                    </pre></div></div><p><br class="example-break">
                Let's explore the example together. The <code class="literal">BroadcasterResource</code> resource class is annotated with
                <a class="link" href="https://jakarta.ee/specifications//dependency-injection/2.0/apidocs/jakarta/inject/singleton" target="_top">@Singleton</a> annotation which tells Jersey runtime that only a single instance of the resource
                class should be used to serve all the incoming requests to <code class="literal">/broadcast</code> path. This is needed as
                we want to keep an application-wide single reference to the private <code class="literal">broadcaster</code> field so
                we can use the same instance for all requests. Clients that want to listen to SSE events first send a
                <code class="literal">GET</code> request to the <code class="literal">BroadcasterResource</code>, that is handled by the
                <code class="literal">listenToBroadcast()</code>
                resource method.
                The method is injected with a new <code class="literal">SseEventSink</code> representing the connection to the
                requesting client and registers this <code class="literal">eventSink</code> instance with the singleton
                <code class="literal">broadcaster</code>
                by calling its <code class="literal">subscribe()</code> method.
                The method then, as already explained returns <code class="literal">void</code> and Jersey runtime is responsible for
                binding the injected <code class="literal">EventSink</code> instance so as it would have been returned from the resource
                method (note that really returning the <code class="literal">EventSink</code> from the resource method will cause
                failure) and to bind the <code class="literal">eventSink</code> instance with the requesting client and send the
                response HTTP headers to the client. The client connection remains open and the client is now waiting ready to
                receive new SSE events. All the events are written to the <code class="literal">eventSink</code> by
                <code class="literal">broadcaster</code>
                later on. This way developers can conveniently handle sending new events to
                all the clients that subscribe to them.
            </p><p>
                When a client wants to broadcast new message to all the clients listening on their SSE connections,
                it sends a <code class="literal">POST</code> request to <code class="literal">BroadcasterResource</code> resource with the message content.
                The method <code class="literal">broadcastMessage(String)</code> is invoked on
                <code class="literal">BroadcasterResource</code>
                resource with the message content as an input parameter. A new SSE outbound event is built in the standard way
                and passed to the broadcaster. The broadcaster internally invokes <code class="literal">write(OutboundEvent)</code> on all
                registered <code class="literal">EventSink</code>s. After that the method just returns a standard text response
                to the <code class="literal">POST</code>ing client to inform the client that the message was successfully broadcast. As you can see,
                the <code class="literal">broadcastMessage(String)</code> resource method is just a simple JAX-RS resource method.
            </p><p>
                In order to implement such a scenario, you may have noticed, that the
                <code class="literal">SseBroadcaster</code>
                is not mandatory to complete the use case. Individual <code class="literal">EventSink</code>s can be just stored in
                a collection and iterated over in the <code class="literal">broadcastMessage</code> method. However, the
                <code class="literal">SseBroadcaster</code>
                internally identifies and handles also client disconnects. When a client
                closes the connection, the broadcaster detects this and removes the stale connection from the internal collection
                of the registered <code class="literal">EventSink</code>s as well as it frees all the server-side resources associated with
                the stale connection.
                Additionally, the <code class="literal">SseBroadcaster</code> is implemented to be thread-safe, so that clients can connect
                and disconnect at any time and <code class="literal">SseBroadcaster</code> will always broadcast messages to the most recent
                collection of registered and active set of clients.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sse-client-jaxrs"></a>16.5.&nbsp;Consuming SSE events within Jersey clients</h2></div></div></div><p>
            On the client side, push programming model is used (event consumer / client) gets asynchronously notified about
            incoming events by subscribing custom listener to <code class="literal">jakarta.ws.rs.sse.SseEventSource</code>. This happens by
            invoking one of its <code class="literal">subscribe()</code> methods.
        </p><p>
            The usage of <code class="literal">SseEventSource</code> is shown in the following example.
            </p><div class="example"><a name="sse-event-source-example"></a><p class="title"><b>Example&nbsp;16.4.&nbsp;Consuming SSE events with SseEventSource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import jakarta.ws.rs.sse.SseEventSource;
...
Client client = ClientBuilder.newBuilder().build();
WebTarget target = client.target("http://example.com/events");
SseEventSource sseEventSource = SseEventSource.target(target).build();
sseEventSource.register(event -&gt; System.out.println(event.getName() + "; "
    + event.readData(String.class)));
sseEventSource.open();

// do other stuff, block here and continue when done

sseEventSource.close();
                </pre></div></div><p><br class="example-break">
            In this example, the client code connects to the server where the <code class="literal">SseResource</code> from the
            <a class="xref" href="sse.html#example-simple-sse-jaxrs" title="Example&nbsp;16.2.&nbsp;Simple SSE resource method">Example&nbsp;16.2, &#8220;Simple SSE resource method&#8221;</a>
            is deployed. The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a> instance
            is created (and initialized with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a> automatically). Then the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> is built.
            In this case a request to the web target is not made directly in the code, instead, the web target instance
            is used to initialize a new <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.Builder.html" target="_top">SseEventSource.Builder</a> instance that is used to build a new
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.html" target="_top">SseEventSource</a>. The choice of <code class="literal">build()</code> method is important, as it tells
            the <code class="literal">SseEventSource.Builder</code> to create a new <code class="literal">SseEventSource</code> that is not
            automatically connected to the <code class="literal">target</code>. The connection is established only later by manually
            invoking the <code class="literal">sseEventSource.open()</code> method. A custom
            <code class="literal">java.util.function.Consumer&lt;InboundSseEvent&gt;</code>
            implementation is used to listen to and
            process incoming SSE events. The method readData(Class) says that the
            event data should be de-serialized from a received <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/InboundSseEvent.html" target="_top">InboundSseEvent</a> instance into a
            <code class="literal">String</code>
            Java type. This method call internally executes <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> which
            de-serializes the event data. This is similar to reading an entity from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a> by
            <code class="literal">readEntity(Class)</code>. The method <code class="literal">readData</code> can throw a
            <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ProcessingException.html" target="_top">ProcessingException</a>.
        </p><p>
            After a connection to the server is opened by calling the <code class="literal">open()</code> method on the event source,
            the <code class="literal">eventSource</code> starts listening to events. When an event comes, the listener will be executed
            by the event source. Once the client is done with processing and does not want to receive events the connection by
            calling the <code class="literal">close()</code> method on the event source.
        </p><p>
            The listener from the example above will print the following output:
            </p><pre class="screen">message-to-client; Hello world 0!
message-to-client; Hello world 1!
message-to-client; Hello world 2!
message-to-client; Hello world 3!
message-to-client; Hello world 4!
message-to-client; Hello world 5!
message-to-client; Hello world 6!
message-to-client; Hello world 7!
message-to-client; Hello world 8!
message-to-client; Hello world 9!
            </pre><p>
        </p><p>
            There are other events than the incoming data that also may occur. The <code class="literal">SseEventSource</code> for
            instance always signals, that it has finished processing events, or there might also be an error while processing the
            messages. <code class="literal">SseEventSource</code>. There are total of four overloaded
            <code class="literal">subscribe()</code>
            methods defined in the API.
        </p><p>
            </p><div class="example"><a name="sse-event-source-subscribe-methods"></a><p class="title"><b>Example&nbsp;16.5.&nbsp;SseEventSource subscribe() methods</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// 1. basic one - the one we used in the example
void subscribe(Consumer&lt;InboundSseEvent&gt; onEvent);

// 2. with an error callback
void subscribe(Consumer&lt;InboundSseEvent&gt; onEvent, Consumer&lt;Throwable&gt; onError);

// 3. with an error callback and completion callback
void subscribe(Consumer&lt;InboundSseEvent&gt; onEvent, Consumer&lt;Throwable&gt; onError, Runnable onComplete)

// 4. complete one - with error callback, completion callback an onSubscribe callback
void subscribe(Consumer&lt;SseSubscription&gt; onSubscribe, Consumer&lt;InboundSseEvent&gt; onEvent, Consumer&lt;Throwable&gt;
onError,
Runnable
onComplete);
                </pre></div></div><p><br class="example-break">

                Few notes to the <code class="literal">subscribe()</code> methods:
                </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            All the overloaded methods have the <code class="literal">onEvent</code> handler. As shown in the example,
                            this parameter is used to consume the SSE events with data.
                        </p></li><li class="listitem"><p>
                            Except the basic one-arg method, all the others contain an <code class="literal">onError</code> handler. In
                            case of error, the <code class="literal">SseEventSource</code> invokes the <code class="literal">onError</code> method
                            of all its subscribers, that registered the handler. This makes it possible to react to the error
                            conditions in a custom manner.
                        </p></li><li class="listitem"><p>
                            Another possible argument is the <code class="literal">onComplete</code> handler. If registered (used an
                            appropriate <code class="literal">subscribe()</code> method, that has the
                            <code class="literal">onComplete</code>
                            argument), it is invoked (for all the subscribers) every time when the
                            <code class="literal">SseEventSource</code>
                            terminates normally. Either <code class="literal">onComplete</code> or
                            <code class="literal">onError</code>
                            should be called every time.
                        </p></li><li class="listitem"><p>
                            The complete <code class="literal">subscribe()</code> method adds the <code class="literal">onSubscribe()</code> callback.
                            This gives the subscriber a tool to manage the load and do a back-pressure by incrementally
                            requesting only certain amount of items. When <code class="literal">SseEventSource</code> registers a new
                            subscriber, it calls its <code class="literal">onSubscribe</code> handler and hands over the
                            <code class="literal">jakarta.ws.rs.sse.SseSubscription</code>
                            instance. This class only has two methods -
                            <code class="literal">request(long)</code>
                            for asking for a certain amount of events (often used as
                            <code class="literal">request(Long.MAX_VALUE)</code>
                            when no back-pressure is needed) and
                            <code class="literal">cancel()</code>
                            to stop receiving further events.
                        </p></li><li class="listitem"><p>
                            When using the full-arg version of <code class="literal">subscribe()</code>, it is the caller's
                            responsibility to manage the amount of data it can handle. The
                            <code class="literal">sseSubscription.request()</code>
                            method <span class="emphasis"><em>MUST</em></span> be called, otherwise
                            the subscriber will not receive ANY data. Furthermore, in the current
                            <code class="literal">SseEventSource</code>
                            implementation, such a subscriber will block a thread and will
                            occasionally lead to overflow of an internal buffer in <code class="literal">SseEventSource</code>. As
                            mentioned, calling <code class="literal">subscription.request(Long.MAX_VALUE)</code>, e.g. in the registered
                            <code class="literal">onSubscribe</code>
                            handler is sufficient (and is also a default behaviour for all the
                            other overloaded methods).
                        </p></li></ul></div><p>



        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sse-event-source-reconnect"></a>16.5.1.&nbsp;
                <code class="literal">SseEventSource</code>
                reconnect support
            </h3></div></div></div><p>
                The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.html" target="_top">SseEventSource</a> implementation supports automated recuperation
                from a connection loss, including negotiation of delivery of any missed events based on the last received
                SSE event <code class="literal">id</code> field value, provided this field is set by the server and the negotiation
                facility is supported by the server. In case of a connection loss, the last received SSE event
                <code class="literal">id</code>
                field value is sent in the <code class="literal">Last-Event-ID</code> HTTP request
                header as part of a new connection request sent to the SSE endpoint. Upon a receipt of such reconnect request,
                the SSE endpoint that supports this negotiation facility is expected to replay all missed events.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Note, that SSE lost event negotiation facility is a best-effort mechanism which does not provide
                    any guarantee that all events would be delivered without a loss. You should therefore not
                    rely on receiving every single event and design your client application code accordingly.
                </p></div><p>
                By default, when a connection to the SSE endpoint is lost, the event source will use a default delay
                before attempting to reconnect to the SSE endpoint. The SSE endpoint can however control the client-side
                retry delay by including a special <code class="literal">retry</code> field value in any event sent to the client.
                Jersey <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.html" target="_top">SseEventSource</a> implementation automatically tracks any received SSE event
                <code class="literal">retry</code>
                field values set by the endpoint and adjusts the reconnect delay accordingly,
                using the last received <code class="literal">retry</code> field value as the new reconnect delay.
            </p><p>
                In addition to handling the standard connection losses, Jersey <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.html" target="_top">SseEventSource</a> automatically
                deals with any <code class="literal">HTTP 503 Service Unavailable</code> responses received from the SSE endpoint,
                that include a <code class="literal">Retry-After</code> HTTP header with a valid value. The
                <code class="literal">HTTP 503 + Retry-After</code>
                technique is often used by HTTP endpoints as a means of
                connection and traffic throttling. In case a <code class="literal">HTTP 503 + Retry-After</code> response is received
                in return to a connection request from SSE endpoint, Jersey <code class="literal">SseEventSource</code> will automatically
                schedule a reconnect attempt and use the received <code class="literal">Retry-After</code> HTTP header value as a
                one-time override of the reconnect delay.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-jersey-specific"></a>16.6.&nbsp;Jersey-specific Server-Sent Events API</h2></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                Prior to JAX-RS 2.1, server-sent events was not standardized and was optional and implementation-specific.
                Jersey provided its own, specific version of SSE implementation, that remains valid and functional to achieve
                backwards compatibility. This implementation is a Jersey-specific extension of JAX-RS (2.0) standard. It works
                with common JAX-RS resources the same way as the JAX-RS 2.1 based implementation does.
            </p><p>
                After the jakartification Jersey complies with JAX-RS 3.0 and SSE implementation may not be backward compatible due to
                namespace change. When the 3.x version is being used, it's required to comply with JAX-RS 3.0 SSE spec.
            </p></div><p>
            This chapter briefly describes the Jersey-specific support for SSE, focusing on the differences against the new SSE
            implementation described in
            <a class="xref" href="">???</a>
        </p><p>
            The API contains SSE support for both - server and client. To use the Jersey-specific SSE API, you need to
            add the dependency to the
        </p><p>
            In order to add support for this SSE implementation, you also need to include the dependency to the
            <span class="emphasis"><em>SSE media type module</em></span>
            the same way as for the JAX-RS SSE implementation.
            </p><div class="example"><a name="sse.dependency"></a><p class="title"><b>Example&nbsp;16.6.&nbsp;Add <code class="literal">jersey-media-sse</code> dependency.
                </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-sse&lt;/artifactId&gt;
&lt;/dependency&gt;</pre></div></div><p><br class="example-break">
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Prior to Jersey 2.8, you had to manually register <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a> in your application.
                    (The <code class="literal">SseFeature</code> is a feature that can be registered for both, the client and the server.)
                    Since Jersey 2.8, the feature gets automatically discovered and registered when Jersey SSE module is
                    put on the application's classpath. The automatic discovery and registration of SSE feature can be suppressed
                    by setting <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html#DISABLE_SSE" target="_top">DISABLE_SSE</a> property to <code class="literal">true</code>.
                    The behavior can also be selectively suppressed in either client or server runtime by setting
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html#DISABLE_SSE_CLIENT" target="_top">DISABLE_SSE_CLIENT</a> or <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html#DISABLE_SSE_SERVER" target="_top">DISABLE_SSE_SERVER</a> property
                    respectively.
                </p></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11914"></a>16.6.1.&nbsp;Implementing SSE support in a JAX-RS resource</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11917"></a>16.6.1.1.&nbsp;Simple SSE resource method</h4></div></div></div><p>
                    </p><div class="example"><a name="example-simple-sse"></a><p class="title"><b>Example&nbsp;16.7.&nbsp;Simple SSE resource method</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import org.glassfish.jersey.media.sse.EventOutput;
import org.glassfish.jersey.media.sse.OutboundEvent;
import org.glassfish.jersey.media.sse.SseFeature;
...

@Path("events")
public static class SseResource {

    @GET
    @Produces(SseFeature.SERVER_SENT_EVENTS)
    public EventOutput getServerSentEvents() {
        final EventOutput eventOutput = new EventOutput();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    for (int i = 0; i &lt; 10; i++) {
                        // ... code that waits 1 second
                        final OutboundEvent.Builder eventBuilder = new OutboundEvent.Builder();
                        eventBuilder.name("message-to-client");
                        eventBuilder.data(String.class, "Hello world " + i + "!");
                        final OutboundEvent event = eventBuilder.build();
                        eventOutput.write(event);
                    }
                } catch (IOException e) {
                    throw new RuntimeException("Error when writing the event.", e);
                } finally {
                    try {
                        eventOutput.close();
                    } catch (IOException ioClose) {
                        throw new RuntimeException("Error when closing the event output.", ioClose);
                    }
                }
            }
        }).start();
        return eventOutput;
    }
}
                        </pre></div></div><p><br class="example-break">

                    The code above defines the resource deployed on URI <code class="literal">"/events"</code>. This resource has a single
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/GET.html" target="_top">@GET</a> resource method which returns as an entity <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a> - an extension of generic
                    Jersey
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/server/ChunkedOutput.html" target="_top">ChunkedOutput</a> API for output chunked message processing.
                </p><p>
                    In the <a class="xref" href="sse.html#example-simple-sse" title="Example&nbsp;16.7.&nbsp;Simple SSE resource method">Example&nbsp;16.7, &#8220;Simple SSE resource method&#8221;</a>, the resource method creates a new thread that sends a sequence of
                    10 events. There is a 1 second delay between two subsequent events as indicated in a comment. Each event is
                    represented by <code class="literal">OutboundEvent</code> type and is built with a help of an outbound event
                    <code class="literal">Builder</code>. The <code class="literal">OutboundEvent</code> reflects the standardized format of SSE
                    messages
                    and contains properties that represent <code class="literal">name</code> (for named
                    events), <code class="literal">comment</code>, <code class="literal">data</code> or <code class="literal">id</code>. The code also sets the
                    event data media type using the <code class="literal">mediaType(MediaType)</code> method on the
                    <code class="literal">eventBuilder</code>. The media type, together with the data type set by the
                    <code class="literal">data(Class, Object&gt;</code>
                    method (in our case <code class="literal">String.class</code>), is used
                    for serialization of the event data. Note that the event data media type will not be written to any headers as
                    the response <code class="literal">Content-type</code> header is already defined by the <code class="literal">@Produces</code> and set to
                    <code class="literal">"text/event-stream"</code>
                    using constant from the <code class="literal">SseFeature</code>.
                    The event media type is used for serialization of event <code class="literal">data</code>. Event data media type and
                    Java
                    type are used to select the proper <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for event data serialization and are passed
                    to the selected writer that serializes the event <code class="literal">data</code> content. In our case the string
                    <code class="literal">"Hello world " + i + "!"</code>
                    is serialized as <code class="literal">"text/plain"</code>. In event
                    <code class="literal">data</code>
                    you can send any Java entity and associate it with any media type that you would be able
                    to serialize with an available <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Typically, you may want to send e.g. JSON
                    data,
                    so you would fill the <code class="literal">data</code> with a JAXB annotated bean instance and define media type to
                    JSON.
                    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                            If the event media type is not set explicitly, the <code class="literal">"text/plain"</code> media type is used
                            by default.
                        </p></div><p>
                </p><p>
                    Once an outbound event is ready, it can be written to the <code class="literal">eventOutput</code>. At that point the
                    event
                    is serialized by internal <code class="literal">OutboundEventWriter</code> which uses an appropriate
                    <code class="literal">MessageBodyWriter&lt;T&gt;</code> to serialize the <code class="literal">"Hello world " + i + "!"</code> string. You can
                    send as many messages as you like. At the end of the thread execution the response is closed which also closes
                    the connection to the client. After that, no more messages can be sent to the client on this connection. If
                    the
                    client would like to receive more messages, it would have to send a new request to the server to initiate a
                    new SSE streaming connection.
                </p><p>
                    A client connecting to our SSE-enabled resource will receive the exact same output as in the corresponding
                    example
                    in the JAX-RS implementation example.

                    </p><pre class="screen">event: message-to-client
data: Hello world 0!

event: message-to-client
data: Hello world 1!

...
                    </pre><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12039"></a>16.6.1.2.&nbsp;Broadcasting</h4></div></div></div><p>
                    Jersey SSE server API defines <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseBroadcaster.html" target="_top">SseBroadcaster</a> which allows to broadcast individual events to
                    multiple
                    clients. A simple broadcasting implementation is shown in the following example:

                    </p><div class="example"><a name="d0e12047"></a><p class="title"><b>Example&nbsp;16.8.&nbsp;Broadcasting SSE messages</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import org.glassfish.jersey.media.sse.SseBroadcaster;
...

@Singleton
@Path("broadcast")
public static class BroadcasterResource {

    private SseBroadcaster broadcaster = new SseBroadcaster();

    @POST
    @Produces(MediaType.TEXT_PLAIN)
    @Consumes(MediaType.TEXT_PLAIN)
    public String broadcastMessage(String message) {
        OutboundEvent.Builder eventBuilder = new OutboundEvent.Builder();
        OutboundEvent event = eventBuilder.name("message")
            .mediaType(MediaType.TEXT_PLAIN_TYPE)
            .data(String.class, message)
            .build();

        broadcaster.broadcast(event);
        return "Message '" + message + "' has been broadcast.";
    }

    @GET
    @Produces(SseFeature.SERVER_SENT_EVENTS)
    public EventOutput listenToBroadcast() {
        final EventOutput eventOutput = new EventOutput();
        this.broadcaster.add(eventOutput);
        return eventOutput;
    }
}
                        </pre></div></div><p><br class="example-break">
                    The example is similar to its relevant JAX-RS counterpart. The <code class="literal">listenToBroadcast()</code> resource
                    method creates a new <code class="literal">EventOutput</code> representing the connection to the requesting client
                    and registers this <code class="literal">eventOutput</code> instance with the singleton <code class="literal">broadcaster</code>,
                    using its <code class="literal">add(EventOutput)</code> method. The method then returns the
                    <code class="literal">eventOutput</code>
                    which causes Jersey to bind the <code class="literal">eventOutput</code> instance with the requesting client and send
                    the
                    response HTTP headers to the client. The client connection remains open and the client is now waiting ready to
                    receive new SSE events. All the events are written to the <code class="literal">eventOutput</code> by
                    <code class="literal">broadcaster</code>
                    later on.
                </p><p>
                    When a client wants to broadcast new message to all the clients listening on their SSE connections,
                    it sends a <code class="literal">POST</code> request to <code class="literal">BroadcasterResource</code> resource with the message
                    content.
                    The method <code class="literal">broadcastMessage(String)</code> is invoked on
                    <code class="literal">BroadcasterResource</code>
                    resource with the message content as an input parameter. A new SSE outbound event is built in the standard way
                    and passed to the broadcaster. The broadcaster internally invokes <code class="literal">write(OutboundEvent)</code> on
                    all
                    registered <code class="literal">EventOutput</code>s. After that the method just return a standard text response
                    to the <code class="literal">POST</code>ing client to inform the client that the message was successfully broadcast.
                </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12103"></a>16.6.2.&nbsp;Consuming SSE events with Jersey clients</h3></div></div></div><p>
                On the client side, Jersey exposes APIs that support receiving and processing SSE events using two programming
                models:

                </p><table border="0" summary="Simple list" class="simplelist"><tr><td>Pull model - pulling events from a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventInput.html" target="_top">EventInput</a>, or
                    </td></tr><tr><td>Push model - listening for asynchronous notifications of <code class="literal">EventSource</code>
                    </td></tr></table><p>
                The push model is similar to what is implemented in the JAX-RS SSE API. The pull model does not have a direct
                counterpart in the JAX-RS API and has to be implemented by the developer, if required.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12120"></a>16.6.2.1.&nbsp;Reading SSE events with <code class="literal">EventInput</code>
                </h4></div></div></div><p>
                    The events can be read on the client side from a <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventInput.html" target="_top">EventInput</a>. See the following code:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
        .register(SseFeature.class).build();
WebTarget target = client.target("http://localhost:9998/events");

EventInput eventInput = target.request().get(EventInput.class);
while (!eventInput.isClosed()) {
    final InboundEvent inboundEvent = eventInput.read();
    if (inboundEvent == null) {
        // connection has been closed
        break;
    }
    System.out.println(inboundEvent.getName() + "; " + inboundEvent.readData(String.class));
}
                    </pre><p>

                    In this example, a client connects to the server where the <code class="literal">SseResource</code> from the
                    <a class="xref" href="sse.html#example-simple-sse" title="Example&nbsp;16.7.&nbsp;Simple SSE resource method">Example&nbsp;16.7, &#8220;Simple SSE resource method&#8221;</a>
                    is deployed. At first, a new JAX-RS/Jersey
                    <code class="literal">client</code>
                    instance is created with a <code class="literal">SseFeature</code> registered. Then a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> instance is
                    retrieved from the <code class="literal">client</code> and is used to invoke a HTTP request. The returned response
                    entity
                    is directly read as a <code class="literal">EventInput</code> Java type, which is an extension of Jersey
                    <code class="literal">ChunkedInput</code> that provides generic support for consuming chunked message payloads. The
                    code in the example then process starts a loop to process the inbound SSE events read from the
                    <code class="literal">eventInput</code>
                    response stream. Each chunk read from the input is a <code class="literal">InboundEvent</code>.
                    The method <code class="literal">InboundEvent.readData(Class)</code> provides a way for the client to indicate what Java
                    type
                    should be used for the event data de-serialization. In our example, individual events are de-serialized as
                    <code class="literal">String</code>
                    Java type instances. This method internally finds and executes a proper
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> which is the used to do the actual de-serialization. This is similar to reading
                    an
                    entity from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a> by <code class="literal">readEntity(Class)</code>. The method
                    <code class="literal">readData</code>
                    can also throw a <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ProcessingException.html" target="_top">ProcessingException</a>.
                </p><p>
                    The <code class="literal">null</code> check on <code class="literal">inboundEvent</code> is necessary to make sure that the chunk was properly
                    read and connection has not been closed by the server. Once the connection is closed, the loop terminates and
                    the program completes execution. The client code produces the following console output:

                    </p><pre class="screen">message-to-client; Hello world 0!
message-to-client; Hello world 1!
message-to-client; Hello world 2!
message-to-client; Hello world 3!
message-to-client; Hello world 4!
message-to-client; Hello world 5!
message-to-client; Hello world 6!
message-to-client; Hello world 7!
message-to-client; Hello world 8!
message-to-client; Hello world 9!
                    </pre><p>
                </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12195"></a>16.6.2.2.&nbsp;Asynchronous SSE processing with <code class="literal">EventSource</code>
                </h4></div></div></div><p>
                    The main Jersey-specific SSE client API component used to read SSE events asynchronously is
                    <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventSource.html" target="_top">EventSource</a>. The usage of the <code class="literal">EventSource</code> is shown on the following example.
                    </p><div class="example"><a name="sse.ex.client.eventListener"></a><p class="title"><b>Example&nbsp;16.9.&nbsp;Registering <code class="literal">EventListener</code> with <code class="literal">EventSource</code>
                        </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
        .register(SseFeature.class).build();
WebTarget target = client.target("http://example.com/events");
EventSource eventSource = EventSource.target(target).build();
EventListener listener = new EventListener() {
    @Override
    public void onEvent(InboundEvent inboundEvent) {
        System.out.println(inboundEvent.getName() + "; " + inboundEvent.readData(String.class));
    }
};
eventSource.register(listener, "message-to-client");
eventSource.open();
...
eventSource.close();
                        </pre></div></div><p><br class="example-break">

                    In this example, the client code again connects to the server where the <code class="literal">SseResource</code> from
                    the
                    <a class="xref" href="sse.html#example-simple-sse" title="Example&nbsp;16.7.&nbsp;Simple SSE resource method">Example&nbsp;16.7, &#8220;Simple SSE resource method&#8221;</a>
                    is deployed. The <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/Client.html" target="_top">Client</a> instance
                    is again created and initialized with <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a>. Then the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> is built.
                    In this case a request to the web target is not made directly in the code, instead, the web target instance
                    is used to initialize a new <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventSource.Builder.html" target="_top">EventSource.Builder</a> instance that is used to build a new
                    <code class="literal">EventSource</code>. The choice of <code class="literal">build()</code> method is important, as it tells
                    the <code class="literal">EventSource.Builder</code> to create a new <code class="literal">EventSource</code> that is not
                    automatically
                    connected to the <code class="literal">target</code>. The connection is established only later by manually invoking
                    the <code class="literal">eventSource.open()</code> method. A custom <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventListener.html" target="_top">EventListener</a>
                    implementation is used to listen to and process incoming SSE events. The method readData(Class) says that the
                    event data should be de-serialized from a received <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/InboundEvent.html" target="_top">InboundEvent</a> instance into a
                    <code class="literal">String</code>
                    Java type. This method call internally executes <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> which
                    de-serializes the event data. This is similar to reading an entity from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/core/Response.html" target="_top">Response</a> by
                    <code class="literal">readEntity(Class)</code>. The method <code class="literal">readData</code> can throw a
                    <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ProcessingException.html" target="_top">ProcessingException</a>.
                </p><p>
                    The custom event source listener is registered in the event source via
                    <code class="literal">EventSource</code><code class="literal">.register(EventListener, String)</code>
                    method. The next method
                    arguments define the names of the events to receive and can be omitted. If names are defined, the listener
                    will be associated with the named events and will only be invoked for events with a name from the set of defined
                    event names. It will not be invoked for events with any other names or for events without a name.

                    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                            It is a common mistake to think that unnamed events will be processed by listeners that are registered
                            to process events from a particular name set. That is NOT the case! Unnamed events are only processed
                            by listeners that are not name-bound. The same limitation applied to HTML5 Javascript SSE Client API
                            supported by modern browsers.
                        </p></div><p>

                    After a connection to the server is opened by calling the <code class="literal">open()</code> method on the event
                    source,
                    the <code class="literal">eventSource</code> starts listening to events. When an event named
                    <code class="literal">"message-to-client"</code>
                    comes, the listener will be executed by the event source. If any other
                    event comes (with a name different from <code class="literal">"message-to-client"</code>), the registered listener is
                    not
                    invoked. Once the client is done with processing and does not want to receive events anymore, it closes the
                    connection by calling the <code class="literal">close()</code> method on the event source.
                </p><p>
                    The listener from the example above will print the following output:
                    </p><pre class="screen">message-to-client; Hello world 0!
message-to-client; Hello world 1!
message-to-client; Hello world 2!
message-to-client; Hello world 3!
message-to-client; Hello world 4!
message-to-client; Hello world 5!
message-to-client; Hello world 6!
message-to-client; Hello world 7!
message-to-client; Hello world 8!
message-to-client; Hello world 9!
                    </pre><p>
                </p><p>
                    When browsing through the Jersey SSE API documentation, you may have noticed that the <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventSource.html" target="_top">EventSource</a>
                    implements <a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/apidocs/3.0.2/jersey/org/glassfish/jersey/media/sse/EventListener.html" target="_top">EventListener</a> and provides an empty implementation for the
                    <code class="literal">onEvent(InboundEvent inboundEvent)</code>
                    listener method. This adds more flexibility to the
                    Jersey client-side SSE API. Instead of defining and registering a separate event listener, in simple scenarios
                    you can also choose to derive directly from the <code class="literal">EventSource</code> and override the empty listener
                    method to handle the incoming events. This programming model is shown in the following example:

                    </p><div class="example"><a name="d0e12325"></a><p class="title"><b>Example&nbsp;16.10.&nbsp;Overriding <code class="literal">EventSource.onEvent(InboundEvent)</code> method
                        </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
        .register(SseFeature.class).build();
WebTarget target = client.target("http://example.com/events");
EventSource eventSource = new EventSource(target) {
    @Override
    public void onEvent(InboundEvent inboundEvent) {
        if ("message-to-client".equals(inboundEvent.getName())) {
            System.out.println(inboundEvent.getName() + "; " + inboundEvent.readData(String.class));
        }
    }
};
...
eventSource.close();
                        </pre></div></div><p><br class="example-break">

                    The code above is very similar to the code in <a class="xref" href="sse.html#sse.ex.client.eventListener" title="Example&nbsp;16.9.&nbsp;Registering EventListener with EventSource">Example&nbsp;16.9, &#8220;Registering <code class="literal">EventListener</code> with <code class="literal">EventSource</code>
                        &#8221;</a>. In this example
                    however, the <code class="literal">EventSource</code> is constructed directly using a single-parameter constructor.
                    This way, the connection to the SSE endpoint is by default automatically opened at the event source
                    creation. The implementation of the <code class="literal">EventListener</code> has been moved into the overridden
                    <code class="literal">EventSource.onEvent(...)</code>
                    method. However, this time, the listener method will be executed for
                    all events - unnamed as well as with any <code class="literal">name</code>. Therefore the code checks the name whether
                    it is
                    an event with the name "message-to-client" that we want to handle. Note that you can still register
                    additional <code class="literal">EventListener</code>s later on. The overridden method on the event source allows you to
                    handle messages even when no additional listeners are registered yet.
                </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="d0e12351"></a>16.6.2.2.1.&nbsp;<code class="literal">EventSource</code> reconnect support
                    </h5></div></div></div><p>
                        Reconnect support in Jersey-specific <code class="literal">EventSource</code> works the same way as in the
                        implementation of the JAX-RS <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/sse/SseEventSource.html" target="_top">SseEventSource</a>.
                    </p></div></div></div></div></div><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.css" rel="stylesheet" type="text/css"><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shThemeDefault.css" rel="stylesheet" type="text/css"><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.js" type="text/javascript"></script><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shAutoloader.js" type="text/javascript"></script><script type="text/javascript">
            function path() {
              var args = arguments,
                  result = []
                  ;

              for(var i = 0; i < args.length; i++)
                  result.push(args[i].replace('@', 'https://eclipse-ee4j.github.io/jersey.github.io/sh/'));

              return result
            };

            SyntaxHighlighter.autoloader.apply(null, path(
              'applescript            @shBrushAppleScript.js',
              'actionscript3 as3      @shBrushAS3.js',
              'bash shell             @shBrushBash.js',
              'coldfusion cf          @shBrushColdFusion.js',
              'cpp c                  @shBrushCpp.js',
              'c# c-sharp csharp      @shBrushCSharp.js',
              'css                    @shBrushCss.js',
              'delphi pascal          @shBrushDelphi.js',
              'diff patch pas         @shBrushDiff.js',
              'erl erlang             @shBrushErlang.js',
              'groovy                 @shBrushGroovy.js',
              'java                   @shBrushJava.js',
              'jfx javafx             @shBrushJavaFX.js',
              'js jscript javascript  @shBrushJScript.js',
              'perl pl                @shBrushPerl.js',
              'php                    @shBrushPhp.js',
              'text plain             @shBrushPlain.js',
              'py python              @shBrushPython.js',
              'ruby rails ror rb      @shBrushRuby.js',
              'sass scss              @shBrushSass.js',
              'scala                  @shBrushScala.js',
              'sql                    @shBrushSql.js',
              'vb vbnet               @shBrushVb.js',
              'xml xhtml xslt html    @shBrushXml.js'
            ));

            SyntaxHighlighter.all();
        </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="jersey-configuration.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="security.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;15.&nbsp;Jersey configuration&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;17.&nbsp;Security</td></tr></table></div></div></body></html>