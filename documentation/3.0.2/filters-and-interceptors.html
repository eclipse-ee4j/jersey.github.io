<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;10.&nbsp;Filters and Interceptors</title><link rel="stylesheet" type="text/css" href="/jersey.github.io/documentation.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Jersey 3.0.2 User Guide"><link rel="up" href="index.html" title="Jersey 3.0.2 User Guide"><link rel="prev" href="media.html" title="Chapter&nbsp;9.&nbsp;Support for Common Media Type Representations"><link rel="next" href="async.html" title="Chapter&nbsp;11.&nbsp;Asynchronous Services and Clients"><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-3160303-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script></head><body class="contents"><div class="contents" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;10.&nbsp;Filters and Interceptors</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="media.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="async.html">Next</a></td></tr></table><hr></div><div style="float:right"><a href="https://eclipse-ee4j.github.io/jersey"><img src="https://eclipse-ee4j.github.io/jersey.github.io/images/jersey_logo.png"></a></div><small>Links:
            <a href="index.html">
                Table of Contents
            </a> | <a href="user-guide.html">
                Single HTML
            </a></small><div lang="en" class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="filters-and-interceptors"></a>Chapter&nbsp;10.&nbsp;Filters and Interceptors</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="filters-and-interceptors.html#d0e9322">10.1. Introduction</a></span></dt><dt><span class="section"><a href="filters-and-interceptors.html#d0e9327">10.2. Filters</a></span></dt><dd><dl><dt><span class="section"><a href="filters-and-interceptors.html#d0e9356">10.2.1. Server filters</a></span></dt><dt><span class="section"><a href="filters-and-interceptors.html#d0e9461">10.2.2. Client filters</a></span></dt></dl></dd><dt><span class="section"><a href="filters-and-interceptors.html#d0e9496">10.3. Interceptors</a></span></dt><dt><span class="section"><a href="filters-and-interceptors.html#d0e9605">10.4. Filter and interceptor execution order</a></span></dt><dt><span class="section"><a href="filters-and-interceptors.html#d0e9666">10.5. Name binding</a></span></dt><dt><span class="section"><a href="filters-and-interceptors.html#d0e9739">10.6. Dynamic binding</a></span></dt><dt><span class="section"><a href="filters-and-interceptors.html#d0e9807">10.7. Priorities</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9322"></a>10.1.&nbsp;Introduction</h2></div></div></div><p>This chapter describes filters, interceptors and their configuration. Filters and interceptors
            can be used on both sides, on the client and the server side. Filters can modify inbound and outbound requests
            and responses including modification of headers, entity and other request/response parameters. Interceptors
            are used primarily for modification of entity input and output streams. You can use interceptors for example
            to zip and unzip output and input entity streams.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9327"></a>10.2.&nbsp;Filters</h2></div></div></div><p>
            Filters can be used when you want to modify any request or response parameters like headers. For example
            you would like to add a response header "X-Powered-By" to each generated response. Instead of adding this header
            in each resource method you would use a response filter to add this header.
        </p><p>
            There are filters on the server side and the client side.
        </p><p>
            Server filters:
            </p><table border="0" summary="Simple list" class="simplelist"><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerRequestFilter.html" target="_top">ContainerRequestFilter</a>
                </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerResponseFilter.html" target="_top">ContainerResponseFilter</a>
                </td></tr></table><p>
            Client filters:
            </p><table border="0" summary="Simple list" class="simplelist"><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientRequestFilter.html" target="_top">ClientRequestFilter</a>
                </td></tr><tr><td><a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientResponseFilter.html" target="_top">ClientResponseFilter</a>
                </td></tr></table><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9356"></a>10.2.1.&nbsp;Server filters</h3></div></div></div>
            The following example shows a simple container response filter adding a header to each response.

            <p>
                </p><div class="example"><a name="d0e9362"></a><p class="title"><b>Example&nbsp;10.1.&nbsp;Container response filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import java.io.IOException;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerResponseContext;
import jakarta.ws.rs.container.ContainerResponseFilter;
import jakarta.ws.rs.core.Response;

public class PoweredByResponseFilter implements ContainerResponseFilter {

    @Override
    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext)
        throws IOException {

            responseContext.getHeaders().add("X-Powered-By", "Jersey :-)");
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                In the example above the <code class="literal">PoweredByResponseFilter</code>
                always adds a header "X-Powered-By" to the
                response. The filter must inherit from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerResponseFilter.html" target="_top">ContainerResponseFilter</a> and must be registered
                as a provider. The filter will be executed for every response which is in most cases after the resource method
                is executed. Response filters are executed even if the resource method is not run, for example when
                the resource method is not found and 404 "Not found" response code is returned by the Jersey runtime. In this case
                the filter will be executed and will process the 404 response.
            </p><p>
                The <code class="literal">filter()</code> method has two arguments, the container request and container response. The
                <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerRequestContext.html" target="_top">ContainerRequestContext</a> is accessible only for read only purposes as the filter is executed already
                in response phase. The modifications can be done in the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerResponseContext.html" target="_top">ContainerResponseContext</a>.
            </p><p>
                The following example shows the usage of a request filter.
            </p><div class="example"><a name="d0e9389"></a><p class="title"><b>Example&nbsp;10.2.&nbsp;Container request filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import java.io.IOException;
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;

public class AuthorizationRequestFilter implements ContainerRequestFilter {

    @Override
    public void filter(ContainerRequestContext requestContext)
                    throws IOException {

        final SecurityContext securityContext =
                    requestContext.getSecurityContext();
        if (securityContext == null ||
                    !securityContext.isUserInRole("privileged")) {

                requestContext.abortWith(Response
                    .status(Response.Status.UNAUTHORIZED)
                    .entity("User cannot access the resource.")
                    .build());
        }
    }
}</pre></div></div><br class="example-break"><p>
                The request filter is similar to the response filter but does not have access to the ContainerResponseContext
                as no response is accessible yet. Response filter inherits from <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/ContainerResponseFilter.html" target="_top">ContainerResponseFilter</a>.
                Request filter is executed before the resource method is run and before the
                response is created. The filter has possibility to manipulate the request parameters including request
                headers or entity.
            </p><p>
                The <code class="literal">AuthorizationRequestFilter</code> in the example checks whether the
                authenticated user is in the privileged role. If it is not then the request is <span class="emphasis"><em>aborted</em></span>
                by calling <code class="literal">ContainerRequestContext.abortWith(Response response)</code> method. The method
                is intended to be called from the request filter in situation when the request should not be processed further in the standard processing chain.
                When the <code class="literal">filter</code> method is finished the response passed as a parameter to the
                <code class="literal">abortWith</code> method is used to respond to the request. Response filters, if any are registered,
                will be executed and will have possibility to process the aborted response.
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d0e9416"></a>10.2.1.1.&nbsp;Pre-matching and post-matching filters</h4></div></div></div></div><p>
                All the request filters shown above was implemented as post-matching filters. It means that the filters
                would be applied only after a suitable resource method has been selected to process the actual request
                i.e. after request matching happens. Request matching is the process of finding a resource method that
                should be executed based on the request path and other request parameters. Since post-matching request
                filters are invoked when a particular resource method has already been selected, such filters can not
                influence the resource method matching process.
            </p><p>
                To overcome the above described limitation, there is a possibility to mark
                a server request filter as a <span class="emphasis"><em>pre-matching</em></span> filter,
                i.e. to annotate the filter class with the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/PreMatching.html" target="_top">@PreMatching</a> annotation.
                Pre-matching filters are request filters that are executed before
                the request matching is started. Thanks to this, pre-matching request filters have
                the possibility to influence which method will be matched. Such a pre-matching request filter example is shown
                here:
            </p><p>
                </p><div class="example"><a name="d0e9431"></a><p class="title"><b>Example&nbsp;10.3.&nbsp;Pre-matching request filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import jakarta.ws.rs.container.ContainerRequestContext;
import jakarta.ws.rs.container.ContainerRequestFilter;
import jakarta.ws.rs.container.PreMatching;
...

@PreMatching
public class PreMatchingFilter implements ContainerRequestFilter {

    @Override
    public void filter(ContainerRequestContext requestContext)
                        throws IOException {
        // change all PUT methods to POST
        if (requestContext.getMethod().equals("PUT")) {
            requestContext.setMethod("POST");
        }
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                The <code class="literal">PreMatchingFilter</code> is a simple pre-matching filter which changes all PUT HTTP
                methods to POST. This might be useful when you want to always handle these PUT and POST HTTP methods
                with the same Java code. After the <code class="literal">PreMatchingFilter</code> has been invoked, the rest
                of the request processing will behave as if the POST HTTP method was originally used.
                You cannot do this in post-matching filters
                (standard filters without <code class="literal">@PreMatching</code> annotation)
                as the resource method is already matched (selected). An attempt to tweak the original HTTP method in
                a post-matching filter would cause an <code class="literal">IllegalArgumentException</code>.
            </p><p>
                As written above, pre-matching filters can fully influence the request matching process, which means
                you can even modify request URI in a pre-matching filter by invoking
                the <code class="literal">setRequestUri(URI)</code> method of <code class="literal">ContainerRequestFilter</code>
                so that a different resource would be matched.
            </p><p>
                Like in post-matching filters you can abort a response in pre-matching filters too.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9461"></a>10.2.2.&nbsp;Client filters</h3></div></div></div><p>
                Client filters are similar to container filters. The response can also be aborted
                in the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientRequestFilter.html" target="_top">ClientRequestFilter</a> which would cause that no request will actually be sent to the server at all.
                A new response is passed to the <code class="literal">abort</code> method. This response will be used and delivered
                as a result of the request invocation. Such a response goes through the client response filters.
                This is similar to what happens on the server side. The process is shown in the following example:
            </p><p>
                </p><div class="example"><a name="d0e9474"></a><p class="title"><b>Example&nbsp;10.4.&nbsp;Client request filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class CheckRequestFilter implements ClientRequestFilter {

    @Override
    public void filter(ClientRequestContext requestContext)
                        throws IOException {
        if (requestContext.getHeaders(
                        ).get("Client-Name") == null) {
            requestContext.abortWith(
                        Response.status(Response.Status.BAD_REQUEST)
                .entity("Client-Name header must be defined.")
                        .build());
         }
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                The <code class="literal">CheckRequestFilter</code> validates the outgoing request. It is checked for presence of
                a <code class="literal">Client-Name</code> header. If the header is not present the request will be aborted
                with a made up response with an appropriate code and message in the entity body. This will cause that
                the original request will not be effectively sent to the server but the actual invocation
                will still end up with a response as if it would be generated by the
                server side. If there would be any client response filter it would be executed on this response.
            </p><p>
                To summarize the workflow, for any client request invoked from the client API
                the client request filters (<a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientRequestFilter.html" target="_top">ClientRequestFilter</a>)
                are executed that could manipulate the request.
                If not aborted, the outgoing request is then physically sent over to the server side
                and once a response is received back from the server the client response
                filters (<a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/client/ClientResponseFilter.html" target="_top">ClientResponseFilter</a>)
                are executed that might again manipulate the returned response.
                Finally the response is passed back to the code that invoked the request.
                If the request was aborted in any client request filter then the
                client/server communication is skipped and the aborted response
                is used in the response filters.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9496"></a>10.3.&nbsp;Interceptors</h2></div></div></div><p>
            Interceptors share a common API for the server and the client side. Whereas filters are primarily intended to manipulate
            request and response parameters like HTTP headers, URIs and/or HTTP methods, interceptors are intended to manipulate entities, via manipulating
            entity input/output streams. If you for example need to encode entity body of a client request then you could
            implement an interceptor to do the work for you.
         </p><p>
            There are two kinds of interceptors, <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ReaderInterceptor.html" target="_top">ReaderInterceptor</a> and <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/WriterInterceptor.html" target="_top">WriterInterceptor</a>.
            Reader interceptors are used to manipulate inbound entity streams. These are the streams coming from
            the "wire". So, using a reader interceptor you
            can manipulate request entity stream on the server side (where
            an entity is read from the client request) and response entity stream on the client side (where an entity
            is read from the server response). Writer interceptors are used for cases where entity is written to the
            "wire" which on the server means when writing out a response entity and on the client side when writing
            request entity for a request to be sent out to the server. Writer and reader interceptors are executed before message body
            readers or writers are executed and their primary intention is to wrap the entity streams that will be used in message body
            reader and writers.
        </p><p>
            The following example shows a writer interceptor that enables GZIP compression of the whole entity body.
        </p><p>
            </p><div class="example"><a name="d0e9513"></a><p class="title"><b>Example&nbsp;10.5.&nbsp;GZIP writer interceptor</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class GZIPWriterInterceptor implements WriterInterceptor {

    @Override
    public void aroundWriteTo(WriterInterceptorContext context)
                    throws IOException, WebApplicationException {
        final OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(new GZIPOutputStream(outputStream));
        context.proceed();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The interceptor gets an output stream from the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/WriterInterceptorContext.html" target="_top">WriterInterceptorContext</a> and sets
            a new one which is a GZIP wrapper of the original output stream. After all interceptors are executed the
            output stream lastly set to the <code class="literal">WriterInterceptorContext</code> will be used for serialization of the entity. In the
            example above the entity bytes will be written to the GZIPOutputStream which will compress the stream data
            and write them to the original output stream. The original stream is always the stream which writes the data to
            the "wire". When the interceptor is used on the server, the original output stream is the stream into which writes
            data to the underlying server container stream that sends the response to the client.
        </p><p>
            The interceptors wrap the streams and they itself work as wrappers. This means that each interceptor is a wrapper
            of another interceptor and it is responsibility of each interceptor implementation to call the wrapped interceptor.
            This is achieved by calling the <code class="literal">proceed()</code> method on the <code class="literal">WriterInterceptorContext</code>.
            This method will call the next registered interceptor in the chain, so effectively this will call all remaining
            registered interceptors. Calling <code class="literal">proceed()</code> from the last
            interceptor in the chain will call the appropriate message body reader. Therefore every interceptor must call the
            <code class="literal">proceed()</code> method otherwise the entity would not be written. The wrapping principle is reflected
            also in the method name, aroundWriteTo, which says that the method is wrapping the writing of the entity.
        </p><p>
            The method aroundWriteTo() gets <code class="literal">WriterInterceptorContext</code> as a parameter. This context contains getters
            and setters for header parameters, request properties, entity, entity stream and other properties. These are the
            properties which will be passed to the final <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Interceptors are allowed to modify
            all these properties. This could influence writing of an entity by <code class="literal">MessageBodyWriter&lt;T&gt;</code> and even
            selection of such a writer. By changing media type (<code class="literal">WriterInterceptorContext</code>.setMediaType())
            the interceptor can cause that different message body writer will be chosen. The interceptor can also
            completely replace the entity if it is needed. However, for modification of headers, request
            properties and such, the filters are usually more preferable choice. Interceptors are executed
            only when there is any entity and when the entity is to be written. So, when you always want to add a new
            header to a response no matter what, use filters as interceptors might not be executed when no entity is
            present. Interceptors should modify properties only for entity serialization
            and deserialization purposes.
        </p><p>
            Let's now look at an example of a <code class="literal">ReaderInterceptor</code>
        </p><p>
            </p><div class="example"><a name="d0e9562"></a><p class="title"><b>Example&nbsp;10.6.&nbsp;GZIP reader interceptor</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class GZIPReaderInterceptor implements ReaderInterceptor {

    @Override
    public Object aroundReadFrom(ReaderInterceptorContext context)
                    throws IOException, WebApplicationException {
        final InputStream originalInputStream = context.getInputStream();
        context.setInputStream(new GZIPInputStream(originalInputStream));
        return context.proceed();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The <code class="literal">GZIPReaderInterceptor</code> wraps the original input stream with the
            <code class="literal">GZIPInputStream</code>. All further reads from the entity stream will cause that data will be decompressed
            by this stream. The interceptor method <code class="literal">aroundReadFrom()</code> must return an entity. The entity
            is returned from the <code class="literal">proceed</code> method of the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/ext/ReaderInterceptorContext.html" target="_top">ReaderInterceptorContext</a>. The
            <code class="literal">proceed</code> method internally calls the wrapped interceptor which must also return an entity.
            The <code class="literal">proceed</code> method invoked from the last interceptor in the chain calls message body reader which deserializes
            the entity end returns it. Every interceptor can change this entity if there is a need but in the most cases
            interceptors will just return the entity as returned from the <code class="literal">proceed</code> method.
        </p><p>
            As already mentioned above, interceptors should be primarily used to manipulate entity body.
            Similar to methods exposed by <code class="literal">WriterInterceptorContext</code> the <code class="literal">ReaderInterceptorContext</code>
            introduces a set of methods for modification of request/response properties like HTTP headers,
            URIs and/or HTTP methods (excluding getters and setters for entity as entity has not been read yet).
            Again the same rules as for <code class="literal">WriterInterceptor</code> applies for changing these properties (change only
            properties in order to influence reading of an entity).
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9605"></a>10.4.&nbsp;Filter and interceptor execution order</h2></div></div></div><p>
            Let's look closer at the context of execution of filters and interceptors. The following steps describes scenario
            where a JAX-RS client makes a POST request to the server. The server receives an entity and sends a response back
            with the same entity. GZIP reader and writer interceptors are registered on the
            client and the server. Also filters are registered on client and server which change the headers of request
            and response.
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Client request invoked: The POST request with attached entity is built on the client and invoked.</li><li class="listitem">ClientRequestFilters: client request filters are executed on the client and they
                    manipulate the request headers.</li><li class="listitem">Client <code class="literal">WriterInterceptor</code>: As the request contains an entity, writer interceptor registered
                    on the client is executed before
                    a MessageBodyWriter is executed. It wraps the entity output stream with the GZipOutputStream.</li><li class="listitem">Client MessageBodyWriter: message body writer is executed on the client which serializes the entity
                    into the new GZipOutput stream. This stream zips the data and sends it to the "wire".</li><li class="listitem">Server: server receives a request. Data of the entity is compressed which means that pure read from
                    the entity input stream would return compressed data.</li><li class="listitem">Server pre-matching ContainerRequestFilters: ContainerRequestFilters are executed that can manipulate
                    resource method matching process.</li><li class="listitem">Server: matching: resource method matching is done.</li><li class="listitem">Server: post-matching ContainerRequestFilters: ContainerRequestFilters post matching filters are executed.
                    This include execution of all global filters (without name binding) and filters name-bound to the matched
                    method.</li><li class="listitem">Server <code class="literal">ReaderInterceptor</code>: reader interceptors are executed on the server. The GZIPReaderInterceptor
                    wraps the input stream (the stream from the "wire") into the GZipInputStream and set it to context.</li><li class="listitem">Server MessageBodyReader: server message body reader is executed and it deserializes the entity
                    from new GZipInputStream (get from the context). This means the reader will read unzipped data and not
                    the compressed data from the "wire".</li><li class="listitem">Server resource method is executed: the deserialized entity object is passed to the matched resource
                    method as a parameter. The method returns this entity as a response entity.</li><li class="listitem">Server ContainerResponseFilters are executed: response filters are executed on the server and
                    they manipulate the response headers. This include all global bound filters (without name binding) and all filters name-bound to the resource method.</li><li class="listitem">Server <code class="literal">WriterInterceptor</code>: is executed on the server. It wraps the original
                    output stream with a new GZIPOuptutStream. The original stream is the stream that "goes to the wire" (output
                    stream for response from the underlying server container).
                </li><li class="listitem">Server MessageBodyWriter: message body writer is executed on the server which serializes the entity
                    into the GZIPOutputStream. This stream compresses the data and writes it to the original stream which sends
                    this compressed data back to the client.
                </li><li class="listitem">Client receives the response: the response contains compressed entity data.</li><li class="listitem">Client ClientResponseFilters: client response filters are executed and they manipulate the response headers.</li><li class="listitem">Client response is returned: the jakarta.ws.rs.core.Response is returned from the request invocation.</li><li class="listitem">Client code calls response.readEntity(): read entity is executed on the client to extract the entity from the response.</li><li class="listitem">Client <code class="literal">ReaderInterceptor</code>: the client reader interceptor is executed when readEntity(Class) is called. The interceptor
                        wraps the entity input stream with GZIPInputStream. This will decompress the data from the original input stream.
                </li><li class="listitem">Client MessageBodyReaders: client message body reader is invoked which reads decompressed data from
                    GZIPInputStream and deserializes the entity.</li><li class="listitem">Client: The entity is returned from the readEntity().</li></ol></div><p>
            It is worth to mention that in the scenario above the reader and writer interceptors are invoked only if the
            entity is present (it does not make sense to wrap entity stream when no entity will be written). The same behaviour
            is there for message body readers and writers. As mentioned above, interceptors are executed before
            the message body reader/writer as a part of their execution and they can wrap the input/output stream
            before the entity is read/written. There are exceptions when interceptors are not run before message body
            reader/writers but this is not the case of simple scenario above. This happens for example when the entity is
            read many times from client response using internal buffering. Then the data are intercepted only once and kept
            'decoded' in the buffer.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9666"></a>10.5.&nbsp;Name binding</h2></div></div></div><p>
            Filters and interceptors can be <span class="emphasis"><em>name-bound</em></span>. Name binding is a concept that allows to say to a JAX-RS
            runtime that a specific filter or interceptor will be executed only for a specific resource method. When a filter or
            an interceptor is limited only to a specific resource method we say that it is <span class="emphasis"><em>name-bound</em></span>.
            Filters and interceptors that do not have such a limitation are called <span class="emphasis"><em>global</em></span>.
        </p><p>
            Filter or interceptor can be assigned to a resource method using the <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/NameBinding.html" target="_top">@NameBinding</a> annotation. The annotation
            is used as meta annotation for other user implemented annotations that are applied to a providers and resource
            methods. See the following example:
        </p><p>
            </p><div class="example"><a name="d0e9687"></a><p class="title"><b>Example&nbsp;10.7.&nbsp;<code class="literal">@NameBinding</code> example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.zip.GZIPInputStream;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.NameBinding;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
...


// @Compress annotation is the name binding annotation
@NameBinding
@Retention(RetentionPolicy.RUNTIME)
public @interface Compress {}


@Path("helloworld")
public class HelloWorldResource {

    @GET
    @Produces("text/plain")
    public String getHello() {
        return "Hello World!";
    }

    @GET
    @Path("too-much-data")
    @Compress
    public String getVeryLongString() {
        String str = ... // very long string
        return str;
    }
}

// interceptor will be executed only when resource methods
// annotated with @Compress annotation will be executed
@Compress
public class GZIPWriterInterceptor implements WriterInterceptor {
    @Override
    public void aroundWriteTo(WriterInterceptorContext context)
                    throws IOException, WebApplicationException {
        final OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(new GZIPOutputStream(outputStream));
        context.proceed();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The example above defines a new <code class="literal">@Compress</code> annotation which is a name binding annotation as
            it is annotated with <code class="literal">@NameBinding</code>. The <code class="literal">@Compress</code> is applied on the
            resource method <code class="literal">getVeryLongString()</code> and on the interceptor
            <code class="literal">GZIPWriterInterceptor</code>. The interceptor will be executed only if any resource method
            with such an annotation will be executed. In our example case the interceptor will be executed only for
            the <code class="literal">getVeryLongString()</code> method. The interceptor will not be executed for method
            <code class="literal">getHello()</code>. In this example the reason is probably clear. We would like to compress
            only long data and we do not need to compress the short response of "Hello World!".
        </p><p>
            Name binding can be applied on a resource class. In the example <code class="literal">HelloWorldResource</code>
            would be annotated with <code class="literal">@Compress</code>. This would mean that all resource
            methods will use compression in this case.
        </p><p>
            There might be many name binding annotations defined in an application. When any provider (filter
            or interceptor) is annotated with more than one name binding annotation, then it will be executed for
            resource methods which contain ALL these annotations. So, for example if our interceptor would be
            annotated with another name binding annotation @GZIP then the resource method would need to have both annotations attached,
            @Compress and @GZIP, otherwise the interceptor would not be executed. Based on the previous paragraph we can
            even use the combination when the
            resource method <code class="literal">getVeryLongString()</code> would be annotated with @Compress and resource class
            <code class="literal">HelloWorldResource</code> would be annotated from with @GZIP. This would also trigger the interceptor as
            annotations of resource methods are aggregated from resource method and from resource class. But this is probably
            just an edge case which will not be used so often.
        </p><p>
            Note that <span class="emphasis"><em>global filters are always executed</em></span>, even for resource methods
            which have any name binding annotations.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9739"></a>10.6.&nbsp;Dynamic binding</h2></div></div></div><p>Dynamic binding is a way how to assign filters and interceptors to the resource methods in a dynamic
        manner. Name binding from the previous chapter uses a static approach and changes to binding require source
        code change and recompilation. With dynamic binding you can implement code which defines bindings during the application
        initialization time. The following example shows how to implement dynamic binding.</p><p>
            </p><div class="example"><a name="d0e9746"></a><p class="title"><b>Example&nbsp;10.8.&nbsp;Dynamic binding example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import jakarta.ws.rs.core.FeatureContext;
import jakarta.ws.rs.container.DynamicFeature;
...

@Path("helloworld")
public class HelloWorldResource {

    @GET
    @Produces("text/plain")
    public String getHello() {
        return "Hello World!";
    }

    @GET
    @Path("too-much-data")
    public String getVeryLongString() {
        String str = ... // very long string
        return str;
    }
}

// This dynamic binding provider registers GZIPWriterInterceptor
// only for HelloWorldResource and methods that contain
// "VeryLongString" in their name. It will be executed during
// application initialization phase.
public class CompressionDynamicBinding implements DynamicFeature {

    @Override
    public void configure(ResourceInfo resourceInfo, FeatureContext context) {
        if (HelloWorldResource.class.equals(resourceInfo.getResourceClass())
                &amp;&amp; resourceInfo.getResourceMethod()
                    .getName().contains("VeryLongString")) {
            context.register(GZIPWriterInterceptor.class);
        }
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The example contains one <code class="literal">HelloWorldResource</code> which is known from the previous name binding example.
            The difference is in the <code class="literal">getVeryLongString</code> method, which now does not define
            the <code class="literal">@Compress</code> name binding annotations. The binding is done
            using the provider which implements <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/container/DynamicFeature.html" target="_top">DynamicFeature</a> interface. The interface defines
            one <code class="literal">configure</code>
            method with two arguments, <code class="literal">ResourceInfo</code> and <code class="literal">FeatureContext</code>.
            <code class="literal">ResourceInfo</code> contains information about the resource and method to which the binding can be done.
            The <code class="literal">configure</code> method will be executed once for each resource method that is defined in the application.
            In the example above the provider will be executed twice, once for the <code class="literal">getHello()</code> method
            and once for <code class="literal">getVeryLongString()</code> (
            once the resourceInfo will contain information about getHello() method and once it will point to
            getVeryLongString()). If a dynamic binding provider wants to register any provider for the actual resource method
            it will do that using provided <code class="literal">FeatureContext</code> which extends
            JAX-RS <code class="literal">Configurable</code> API. All methods for registration of filter or interceptor classes or instances can be used.
            Such dynamically registered filters or interceptors will be bound only to the actual resource method. In the example above the
            <code class="literal">GZIPWriterInterceptor</code> will be bound only to the method <code class="literal">getVeryLongString()</code>
            which will cause that data will be compressed only for this method and not for the method
            <code class="literal">getHello()</code>. The code of <code class="literal">GZIPWriterInterceptor</code> is in the examples above.
        </p><p>
            Note that filters and interceptors registered using dynamic binding are only additional filters run for the
            resource method. If there are any name bound providers or global providers they will still be executed.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9807"></a>10.7.&nbsp;Priorities</h2></div></div></div><p>In case you register more filters and interceptors you might want to define an exact order in which
            they should be invoked. The order can be controlled by the <code class="literal">@Priority</code> annotation defined
            by the <code class="literal">jakarta.annotation.Priority</code> class. The annotation accepts an integer parameter of priority.
            Providers used in request processing (<code class="literal">ContainerRequestFilter</code>,
            <code class="literal">ClientRequestFilter</code>) as well as entity interceptors (<code class="literal">ReaderInterceptor</code>,
            <code class="literal">WriterInterceptor</code>) are sorted based on the priority in an ascending manner. So, a request filter with
            priority defined with <code class="literal">@Priority(1000)</code>
            will be executed before another request filter with priority  defined as <code class="literal">@Priority(2000)</code>. Providers
            used during response processing (<code class="literal">ContainerResponseFilter</code>,
            <code class="literal">ClientResponseFilter</code>) are executed
            in the reverse order (using descending manner), so a provider with the priority defined with
            <code class="literal">@Priority(2000)</code> will be executed before another provider with
             priority defined with <code class="literal">@Priority(1000)</code>.
        </p><p>
            It's a good practice to assign a priority to filters and interceptors. Use <a class="link" href="https://eclipse-ee4j.github.io/jaxrs-api/apidocs/3.0.0/jakarta/ws/rs/Priorities.html" target="_top">Priorities</a> class which
            defines standardized priorities in JAX-RS for different usages, rather than inventing your
            own priorities. For example, when you write an authentication filter you would assign a priority 1000 which
            is the value of <code class="literal">Priorities</code><code class="literal">.AUTHENTICATION</code>. The following example
            shows the filter from the beginning
            of this chapter with a priority assigned.
        </p><p>
            </p><div class="example"><a name="d0e9860"></a><p class="title"><b>Example&nbsp;10.9.&nbsp;Priorities example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import jakarta.annotation.Priority;
import jakarta.ws.rs.Priorities;
...

@Priority(Priorities.HEADER_DECORATOR)
public class ResponseFilter implements ContainerResponseFilter {

    @Override
    public void filter(ContainerRequestContext requestContext,
                    ContainerResponseContext responseContext)
                    throws IOException {

        responseContext.getHeaders().add("X-Powered-By", "Jersey :-)");
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            As this is a response filter and response filters are executed in the reverse order,
            any other filter with priority lower than 3000 (<code class="literal">Priorities.HEADER_DECORATOR</code> is 3000) will be executed after
            this filter. So, for example <code class="literal">AUTHENTICATION</code> filter (priority 1000) would be run after this filter.
        </p></div></div><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.css" rel="stylesheet" type="text/css"><link href="https://eclipse-ee4j.github.io/jersey.github.io/sh/shThemeDefault.css" rel="stylesheet" type="text/css"><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shCore.js" type="text/javascript"></script><script src="https://eclipse-ee4j.github.io/jersey.github.io/sh/shAutoloader.js" type="text/javascript"></script><script type="text/javascript">
            function path() {
              var args = arguments,
                  result = []
                  ;

              for(var i = 0; i < args.length; i++)
                  result.push(args[i].replace('@', 'https://eclipse-ee4j.github.io/jersey.github.io/sh/'));

              return result
            };

            SyntaxHighlighter.autoloader.apply(null, path(
              'applescript            @shBrushAppleScript.js',
              'actionscript3 as3      @shBrushAS3.js',
              'bash shell             @shBrushBash.js',
              'coldfusion cf          @shBrushColdFusion.js',
              'cpp c                  @shBrushCpp.js',
              'c# c-sharp csharp      @shBrushCSharp.js',
              'css                    @shBrushCss.js',
              'delphi pascal          @shBrushDelphi.js',
              'diff patch pas         @shBrushDiff.js',
              'erl erlang             @shBrushErlang.js',
              'groovy                 @shBrushGroovy.js',
              'java                   @shBrushJava.js',
              'jfx javafx             @shBrushJavaFX.js',
              'js jscript javascript  @shBrushJScript.js',
              'perl pl                @shBrushPerl.js',
              'php                    @shBrushPhp.js',
              'text plain             @shBrushPlain.js',
              'py python              @shBrushPython.js',
              'ruby rails ror rb      @shBrushRuby.js',
              'sass scss              @shBrushSass.js',
              'scala                  @shBrushScala.js',
              'sql                    @shBrushSql.js',
              'vb vbnet               @shBrushVb.js',
              'xml xhtml xslt html    @shBrushXml.js'
            ));

            SyntaxHighlighter.all();
        </script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="media.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="async.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;9.&nbsp;Support for Common Media Type Representations&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;11.&nbsp;Asynchronous Services and Clients</td></tr></table></div></div></body></html>