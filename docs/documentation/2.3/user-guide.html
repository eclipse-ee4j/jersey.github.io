<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Jersey 2.3 User Guide</title><link rel="stylesheet" type="text/css" href="/documentation.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-3160303-1']);
            _gaq.push(['_trackPageview']);

            (function() {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script></head><body class="contents"><div class="contents" bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div style="float:right"><a href="https://jersey.java.net"><img src="https://jersey.java.net/images/jersey_logo.png"></a></div><small>Links:
            <a href="index.html">
                Table of Contents
            </a> | <a href="user-guide.html">
                Single HTML
            </a></small><div lang="en" class="book" title="Jersey 2.3 User Guide"><div class="titlepage"><div><div><h1 class="title"><a name="d0e2"></a>Jersey 2.3 User Guide</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#getting-started">1. Getting Started</a></span></dt><dd><dl><dt><span class="section"><a href="#new-from-archetype">1.1. Creating a New Project from Maven Archetype</a></span></dt><dt><span class="section"><a href="#new-project-structure">1.2. Exploring the Newly Created Project</a></span></dt><dt><span class="section"><a href="#running-project">1.3. Running the Project</a></span></dt><dt><span class="section"><a href="#new-webapp">1.4. Creating a JavaEE Web Application</a></span></dt><dt><span class="section"><a href="#exploring-jersey-examples">1.5. Exploring Other Jersey Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#modules-and-dependencies">2. Modules and dependencies</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e377">2.1. Java SE Compatibility</a></span></dt><dt><span class="section"><a href="#d0e382">2.2. Introduction to Jersey dependencies</a></span></dt><dt><span class="section"><a href="#dependencies">2.3. Common Jersey Use Cases</a></span></dt><dd><dl><dt><span class="section"><a href="#servlet-app-glassfish">2.3.1. Servlet based application on Glassfish</a></span></dt><dt><span class="section"><a href="#servlet-app-general">2.3.2. Servlet based server-side application</a></span></dt><dt><span class="section"><a href="#client-jdk">2.3.3. Client application on JDK</a></span></dt><dt><span class="section"><a href="#server-jdk">2.3.4. Server-side application on supported containers</a></span></dt></dl></dd><dt><span class="section"><a href="#modules">2.4. List of modules</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jaxrs-resources">3. JAX-RS Application, Resources and Sub-Resources</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1201">3.1. Root Resource Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1240">3.1.1. @Path</a></span></dt><dt><span class="section"><a href="#d0e1290">3.1.2. @GET, @PUT, @POST, @DELETE, ... (HTTP Methods)</a></span></dt><dt><span class="section"><a href="#d0e1328">3.1.3. @Produces</a></span></dt><dt><span class="section"><a href="#d0e1407">3.1.4. @Consumes</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1432">3.2. Parameter Annotations (@*Param)</a></span></dt><dt><span class="section"><a href="#d0e1703">3.3. Sub-resources</a></span></dt><dt><span class="section"><a href="#d0e1850">3.4. Life-cycle of Root Resource Classes</a></span></dt><dt><span class="section"><a href="#d0e1921">3.5. Rules of Injection</a></span></dt><dt><span class="section"><a href="#d0e2029">3.6. Use of @Context</a></span></dt><dt><span class="section"><a href="#d0e2057">3.7. Programmatic resource model</a></span></dt></dl></dd><dt><span class="chapter"><a href="#deployment">4. Deploying a RESTful Web Service</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.autodiscoverable">4.1. Auto-Discoverable Features</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.autodiscovery.config">4.1.1. Configuring the Feature Auto-discovery mechanism</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.classpath-scanning">4.2. Turn off classpath scanning</a></span></dt></dl></dd><dt><span class="chapter"><a href="#client">5. Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2402">5.1. Uniform Interface Constraint</a></span></dt><dt><span class="section"><a href="#d0e2445">5.2. Ease of use and reusing JAX-RS artifacts</a></span></dt><dt><span class="section"><a href="#d0e2561">5.3. Overview of the Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2564">5.3.1. Getting started with the client API</a></span></dt><dt><span class="section"><a href="#d0e2583">5.3.2. 
                Creating and configuring a Client instance
            </a></span></dt><dt><span class="section"><a href="#d0e2767">5.3.3. Targeting a web resource</a></span></dt><dt><span class="section"><a href="#d0e2835">5.3.4. Identifying resource on WebTarget</a></span></dt><dt><span class="section"><a href="#d0e2911">5.3.5. Invoking a HTTP request</a></span></dt><dt><span class="section"><a href="#d0e3054">5.3.6. Example summary</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3083">5.4. Java instances and types for representations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3102">5.4.1. Adding support for new representations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3136">5.5. Client Transport Connectors</a></span></dt><dt><span class="section"><a href="#d0e3210">5.6. Using client request and response filters</a></span></dt><dt><span class="section"><a href="#d0e3248">5.7. Closing connections</a></span></dt><dt><span class="section"><a href="#d0e3272">5.8. Securing a Client</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3383">5.8.1. HTTP Basic Authentication Support</a></span></dt><dt><span class="section"><a href="#d0e3394">5.8.2. HTTP Digest Authentication Support</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#representations">6. Representations and Responses</a></span></dt><dd><dl><dt><span class="section"><a href="#reps-and-types">6.1. Representations and Java Types</a></span></dt><dt><span class="section"><a href="#d0e3548">6.2. Building Responses</a></span></dt><dt><span class="section"><a href="#d0e3585">6.3. WebApplicationException and Mapping Exceptions to Responses</a></span></dt><dt><span class="section"><a href="#d0e3666">6.4. Conditional GETs and Returning 304 (Not Modified) Responses</a></span></dt></dl></dd><dt><span class="chapter"><a href="#message-body-workers">7. JAX-RS Entity Providers</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3712">7.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e3746">7.2. How to Write Custom Entity Providers</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3783">7.2.1. MessageBodyWriter</a></span></dt><dt><span class="section"><a href="#d0e4071">7.2.2. MessageBodyReader</a></span></dt></dl></dd><dt><span class="section"><a href="#providers-selection">7.3. Entity Provider Selection</a></span></dt><dt><span class="section"><a href="#d0e4632">7.4. Jersey <code class="literal">MessageBodyWorkers</code> API</a></span></dt><dt><span class="section"><a href="#d0e4716">7.5. Default Jersey Entity Providers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#media">8. Support for Common Media Type Representations</a></span></dt><dd><dl><dt><span class="section"><a href="#json">8.1. JSON</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4883">8.1.1. Approaches to JSON Support</a></span></dt><dt><span class="section"><a href="#json.moxy">8.1.2. MOXy</a></span></dt><dt><span class="section"><a href="#json.json-p">8.1.3. Java API for JSON Processing (JSON-P)</a></span></dt><dt><span class="section"><a href="#json.jackson">8.1.4. Jackson</a></span></dt><dt><span class="section"><a href="#json.jettison">8.1.5. Jettison</a></span></dt><dt><span class="section"><a href="#d0e5633">8.1.6. <code class="literal">@JSONP</code> - JSON with Padding Support</a></span></dt></dl></dd><dt><span class="section"><a href="#xml">8.2. XML</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5800">8.2.1. Low level XML support</a></span></dt><dt><span class="section"><a href="#d0e5848">8.2.2. Getting started with JAXB</a></span></dt><dt><span class="section"><a href="#d0e5936">8.2.3. POJOs</a></span></dt><dt><span class="section"><a href="#d0e5974">8.2.4. Using custom JAXBContext</a></span></dt><dt><span class="section"><a href="#d0e6006">8.2.5. MOXy</a></span></dt></dl></dd><dt><span class="section"><a href="#multipart">8.3. Multipart</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6059">8.3.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e6160">8.3.2. Client</a></span></dt><dt><span class="section"><a href="#d0e6277">8.3.3. Server</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#filters-and-interceptors">9. Filters and Interceptors</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6512">9.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e6517">9.2. Filters</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6546">9.2.1. Server filters</a></span></dt><dt><span class="section"><a href="#d0e6651">9.2.2. Client fillers</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6686">9.3. Interceptors</a></span></dt><dt><span class="section"><a href="#d0e6795">9.4. Filter and interceptor execution order</a></span></dt><dt><span class="section"><a href="#d0e6856">9.5. Name binding</a></span></dt><dt><span class="section"><a href="#d0e6929">9.6. Dynamic binding</a></span></dt><dt><span class="section"><a href="#d0e6997">9.7. Priorities</a></span></dt></dl></dd><dt><span class="chapter"><a href="#async">10. Asynchronous Services and Clients</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7076">10.1. Asynchronous Server API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7197">10.1.1. Asynchronous Server-side Callbacks</a></span></dt><dt><span class="section"><a href="#chunked-output">10.1.2. Chunked Output</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7330">10.2. Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7393">10.2.1. Asynchronous Client Callbacks</a></span></dt><dt><span class="section"><a href="#d0e7469">10.2.2. Chunked input</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#uris-and-links">11. URIs and Links</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7552">11.1. Building URIs</a></span></dt><dt><span class="section"><a href="#d0e7626">11.2. Resolve and Relativize</a></span></dt><dt><span class="section"><a href="#d0e7669">11.3. Link</a></span></dt></dl></dd><dt><span class="chapter"><a href="#resource-builder">12. Programmatic API for Building Resources</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7714">12.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e7759">12.2. Programmatic Hello World example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7831">12.2.1. Deployment of programmatic resources</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7893">12.3. Additional examples</a></span></dt><dt><span class="section"><a href="#d0e7952">12.4. Model processors</a></span></dt></dl></dd><dt><span class="chapter"><a href="#sse">13. Server-Sent Events (SSE) Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7999">13.1. What are Server-Sent Events</a></span></dt><dt><span class="section"><a href="#d0e8042">13.2. When to use Server-Sent Events</a></span></dt><dt><span class="section"><a href="#overview">13.3. Jersey Server-Sent Events API</a></span></dt><dt><span class="section"><a href="#d0e8182">13.4. Implementing SSE support in a JAX-RS resource</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8185">13.4.1. Simple SSE resource method</a></span></dt><dt><span class="section"><a href="#d0e8342">13.4.2. Broadcasting with Jersey SSE</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8450">13.5. Consuming SSE events with Jersey clients</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8466">13.5.1. Reading SSE events with <code class="literal">EventInput</code></a></span></dt><dt><span class="section"><a href="#d0e8540">13.5.2. Asynchronous SSE processing with <code class="literal">EventSource</code></a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#security">14. Security</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8754">14.1. Securing server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8757">14.1.1. SecurityContext</a></span></dt><dt><span class="section"><a href="#d0e8865">14.1.2. Authorization - securing resources</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8969">14.2. Client Security</a></span></dt><dt><span class="section"><a href="#d0e8986">14.3. OAuth</a></span></dt></dl></dd><dt><span class="chapter"><a href="#wadl">15. WADL Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8995">15.1. WADL introduction</a></span></dt><dt><span class="section"><a href="#d0e9247">15.2. Configuration</a></span></dt><dt><span class="section"><a href="#d0e9302">15.3. Extended WADL support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#bean-validation">16. Bean Validation Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9346">16.1. Bean Validation Dependencies</a></span></dt><dt><span class="section"><a href="#d0e9372">16.2. Enabling Bean Validation in Jersey</a></span></dt><dt><span class="section"><a href="#d0e9406">16.3. Configuring Bean Validation Support</a></span></dt><dt><span class="section"><a href="#d0e9527">16.4. Validating JAX-RS resources and methods</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9556">16.4.1. Constraint Annotations</a></span></dt><dt><span class="section"><a href="#d0e9642">16.4.2. Annotation constraints and Validators</a></span></dt><dt><span class="section"><a href="#d0e9692">16.4.3. Entity Validation</a></span></dt><dt><span class="section"><a href="#d0e9773">16.4.4. Annotation Inheritance</a></span></dt></dl></dd><dt><span class="section"><a href="#bv.ValidateOnExecution">16.5. @ValidateOnExecution</a></span></dt><dt><span class="section"><a href="#bv.injecting">16.6. Injecting</a></span></dt><dt><span class="section"><a href="#d0e9897">16.7. Error Reporting</a></span></dt><dd><dl><dt><span class="section"><a href="#bv.ValidationError">16.7.1. ValidationError</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10055">16.8. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#entity-filtering">17. Entity Data Filtering</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10091">17.1. Enabling and configuring Entity Filtering in your application</a></span></dt><dt><span class="section"><a href="#d0e10192">17.2. Components used to describe Entity Filtering concepts</a></span></dt><dt><span class="section"><a href="#ef.annotations">17.3. Using custom annotations to filter entities</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10347">17.3.1. Server-side Entity Filtering</a></span></dt><dt><span class="section"><a href="#d0e10465">17.3.2. Client-side Entity Filtering</a></span></dt></dl></dd><dt><span class="section"><a href="#ef.security.annotations">17.4. Role-based Entity Filtering using (<code class="literal">javax.annotation.security</code>) annotations</a></span></dt><dt><span class="section"><a href="#ef.custom.annotations">17.5. Defining custom handling for entity-filtering annotations</a></span></dt><dt><span class="section"><a href="#ef.custom.providers">17.6. Supporting Entity Data Filtering in custom entity providers or frameworks</a></span></dt><dt><span class="section"><a href="#ef.modules">17.7. Modules with support for Entity Data Filtering</a></span></dt><dt><span class="section"><a href="#d0e10630">17.8. Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mvc">18. MVC Templates</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10651">18.1. Dependencies</a></span></dt><dt><span class="section"><a href="#d0e10730">18.2. Registration and Configuration</a></span></dt><dt><span class="section"><a href="#d0e10869">18.3. Explicit vs. Implicit View Templates</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10889">18.3.1. <code class="literal">Viewable</code> - Explicit View Templates</a></span></dt><dt><span class="section"><a href="#d0e10973">18.3.2. <code class="literal">@Template</code> - Implicit View Templates</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11088">18.4. JSP</a></span></dt><dt><span class="section"><a href="#mvc.spi">18.5. Custom Templating Engines</a></span></dt><dt><span class="section"><a href="#d0e11170">18.6. Other Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#monitoring">19. Monitoring and diagnostics</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11182">19.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e11233">19.2. Event Listeners</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11415">19.2.1. Guidelines for implementing Jersey event listeners</a></span></dt><dt><span class="section"><a href="#d0e11461">19.2.2. Monitoring Statistics</a></span></dt><dt><span class="section"><a href="#d0e11652">19.2.3. Monitoring Statistics as MBeans</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#spring">20. Spring DI</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11879">20.1. Dependencies</a></span></dt><dt><span class="section"><a href="#d0e11892">20.2. Registration and Configuration</a></span></dt><dt><span class="section"><a href="#d0e11897">20.3. Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#test-framework">21. Jersey Test Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11927">21.1. Basics</a></span></dt><dt><span class="section"><a href="#d0e11964">21.2. Supported Containers</a></span></dt><dt><span class="section"><a href="#d0e12026">21.3. Advanced features</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12029">21.3.1. <code class="literal">JerseyTest</code> Features</a></span></dt><dt><span class="section"><a href="#d0e12053">21.3.2. External container</a></span></dt><dt><span class="section"><a href="#d0e12064">21.3.3. Test Client configuration</a></span></dt><dt><span class="section"><a href="#d0e12078">21.3.4. Accessing the logged test records programmatically</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#how-to-build">22. Building and Testing Jersey</a></span></dt><dd><dl><dt><span class="section"><a href="#checkout">22.1. Checking Out the Source</a></span></dt><dt><span class="section"><a href="#building">22.2. Building the Source</a></span></dt><dt><span class="section"><a href="#testing">22.3. Testing</a></span></dt><dt><span class="section"><a href="#netbeans-build">22.4. Using NetBeans</a></span></dt></dl></dd><dt><span class="chapter"><a href="#migration">23. Migration Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#mig-2.3">23.1. Migrating from Jersey 2.0, 2.1 or 2.2 to 2.3</a></span></dt><dt><span class="section"><a href="#mig-1.x">23.2. Migrating from Jersey 1.x to 2.0</a></span></dt><dd><dl><dt><span class="section"><a href="#mig-server-api">23.2.1. Server API</a></span></dt><dt><span class="section"><a href="#mig-client-api">23.2.2. Migrating Jersey Client API</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#appendix-properties">A. Configuration Properties</a></span></dt><dd><dl><dt><span class="section"><a href="#appendix-properties-common">A.1. Common (client/server) configuration properties</a></span></dt><dt><span class="section"><a href="#appendix-properties-server">A.2. Server configuration properties</a></span></dt><dt><span class="section"><a href="#appendix-properties-client">A.3. Client configuration properties</a></span></dt></dl></dd></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>2.1. <a href="#dependencies-table-core">Jersey Core</a></dt><dt>2.2. <a href="#dependencies-table-containers">Jersey Containers</a></dt><dt>2.3. <a href="#dependencies-table-connectors">Jersey Connectors</a></dt><dt>2.4. <a href="#dependencies-table-media">Jersey Media</a></dt><dt>2.5. <a href="#dependencies-table-extensions">Jersey Extensions</a></dt><dt>2.6. <a href="#dependencies-table-test-framework">Jersey Test Framework</a></dt><dt>2.7. <a href="#dependencies-table-gf-bundles">Jersey Glassfish Bundles</a></dt><dt>2.8. <a href="#dependencies-table-examples">Jersey Examples</a></dt><dt>2.9. <a href="#dependencies-table-examples-webapp">Jersey Examples - WebApps</a></dt><dt>3.1. <a href="#d0e1867">Resource scopes</a></dt><dt>3.2. <a href="#d0e1975">Overview of injection types</a></dt><dt>8.1. <a href="#d0e5184">Default property values for MOXy MessageBodyReader&lt;T&gt; / MessageBodyWriter&lt;T&gt;</a></dt><dt>23.1. <a href="#d0e12395">Mapping of Jersey 1.x to JAX-RS 2.0 client classes</a></dt><dt>A.1. <a href="#d0e12540">List of common configuration properties</a></dt><dt>A.2. <a href="#d0e12639">List of server configuration properties</a></dt><dt>A.3. <a href="#d0e13009">List of client configuration properties</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>3.1. <a href="#d0e1234">Simple hello world root resource class</a></dt><dt>3.2. <a href="#d0e1273">Specifying URI path parameter</a></dt><dt>3.3. <a href="#d0e1316">PUT method</a></dt><dt>3.4. <a href="#d0e1341">Specifying output MIME type</a></dt><dt>3.5. <a href="#d0e1383">Using multiple output MIME types</a></dt><dt>3.6. <a href="#d0e1396">Server-side content negotiation</a></dt><dt>3.7. <a href="#d0e1417">Specifying input MIME type</a></dt><dt>3.8. <a href="#d0e1447">Query parameters</a></dt><dt>3.9. <a href="#d0e1460">Custom Java type for consuming request parameters</a></dt><dt>3.10. <a href="#d0e1579">Processing POSTed HTML form</a></dt><dt>3.11. <a href="#d0e1589">Obtaining general map of URI path and/or query parameters</a></dt><dt>3.12. <a href="#d0e1599">Obtaining general map of header parameters</a></dt><dt>3.13. <a href="#d0e1614">Obtaining general map of form parameters</a></dt><dt>3.14. <a href="#d0e1643">Example of the bean which will be used as @BeanParam
            </a></dt><dt>3.15. <a href="#d0e1651">Injection of MyBeanParam as a method parameter:</a></dt><dt>3.16. <a href="#d0e1698">Injection of more beans into one resource methods:</a></dt><dt>3.17. <a href="#d0e1723">Sub-resource methods</a></dt><dt>3.18. <a href="#d0e1756">Sub-resource locators</a></dt><dt>3.19. <a href="#d0e1784">Sub-resource locators with empty path</a></dt><dt>3.20. <a href="#d0e1799">Sub-resource locators returning sub-type</a></dt><dt>3.21. <a href="#d0e1812">Sub-resource locators created from classes</a></dt><dt>3.22. <a href="#d0e1836">Sub-resource locators returning resource model</a></dt><dt>3.23. <a href="#d0e1930">Injection</a></dt><dt>3.24. <a href="#d0e1940">Wrong injection into a singleton scope</a></dt><dt>3.25. <a href="#d0e1967">Injection of proxies into singleton</a></dt><dt>3.26. <a href="#d0e2018">Example of possible injections</a></dt><dt>4.1. <a href="#d0e2076">Deployment agnostic application model</a></dt><dt>4.2. <a href="#d0e2087">Reusing Jersey implementation in your custom application model</a></dt><dt>4.3. <a href="#d0e2106">Deployment of a JAX-RS application using
                <code class="literal">@ApplicationPath</code>
                with Servlet 3.0
            </a></dt><dt>4.4. <a href="#d0e2125">Configuration of maven-war-plugin in
                <code class="literal">pom.xml</code>
                with Servlet 3.0
            </a></dt><dt>4.5. <a href="#d0e2150">Deployment of a JAX-RS application using
                <code class="literal">web.xml</code>
                with Servlet 3.0
            </a></dt><dt>4.6. <a href="#d0e2175">Deployment of your application using Jersey specific servlet</a></dt><dt>4.7. <a href="#d0e2183">Using Jersey specific servlet without an application model instance</a></dt><dt>4.8. <a href="#d0e2369">Registering SPI implementations using ResourceConfig</a></dt><dt>5.1. <a href="#client.ex.formpost">POST request with form parameters</a></dt><dt>5.2. <a href="#d0e3059">Using JAX-RS Client API</a></dt><dt>5.3. <a href="#d0e3065">Using JAX-RS Client API fluently</a></dt><dt>5.4. <a href="#d0e3253">Closing connections</a></dt><dt>6.1. <a href="#d0e3509">Using
                    <code class="code">File</code>
                    with a specific media type to produce a response
                </a></dt><dt>6.2. <a href="#d0e3564">Returning 201 status code and adding
                    <code class="literal">Location</code>
                    header in response to POST request
                </a></dt><dt>6.3. <a href="#d0e3577">Adding an entity body to a custom response</a></dt><dt>6.4. <a href="#d0e3597">Throwing exceptions to control response</a></dt><dt>6.5. <a href="#d0e3610">Application specific exception implementation</a></dt><dt>6.6. <a href="#d0e3632">Mapping generic exceptions to responses</a></dt><dt>6.7. <a href="#d0e3680">Conditional GET support</a></dt><dt>7.1. <a href="#d0e3757">Example resource class</a></dt><dt>7.2. <a href="#d0e3777">MyBean entity class</a></dt><dt>7.3. <a href="#d0e3801">MessageBodyWriter example</a></dt><dt>7.4. <a href="#d0e3857">Example of assignment of annotations to a response entity</a></dt><dt>7.5. <a href="#client-get-call">Client code testing MyBeanMessageBodyWriter</a></dt><dt>7.6. <a href="#d0e4056">Result of MyBeanMessageBodyWriter test</a></dt><dt>7.7. <a href="#mbw.ex.mbr">MessageBodyReader example</a></dt><dt>7.8. <a href="#d0e4210">Testing MyBeanMessageBodyReader</a></dt><dt>7.9. <a href="#d0e4218">Result of testing MyBeanMessageBodyReader</a></dt><dt>7.10. <a href="#mbw.ex.client.mbr.reg">MessageBodyReader registered on a JAX-RS client</a></dt><dt>7.11. <a href="#d0e4286">Result of client code execution</a></dt><dt>7.12. <a href="#d0e4667">Usage of MessageBodyWorkers interface</a></dt><dt>8.1. <a href="#d0e4920">Simple JAXB bean implementation</a></dt><dt>8.2. <a href="#d0e4926">JAXB bean used to generate JSON representation</a></dt><dt>8.3. <a href="#d0e4946">Tweaking JSON format using JAXB</a></dt><dt>8.4. <a href="#d0e4983">JAXB bean creation</a></dt><dt>8.5. <a href="#d0e5000">Constructing a <code class="literal">JsonObject</code> (JSON-Processing)</a></dt><dt>8.6. <a href="#d0e5009">Constructing a <code class="literal">JSONObject</code> (Jettison)</a></dt><dt>8.7. <a href="#d0e5136">MoxyJsonConfig - Setting properties.</a></dt><dt>8.8. <a href="#d0e5150"><code class="literal">ContextResolver&lt;MoxyJsonConfig&gt;</code></a></dt><dt>8.9. <a href="#d0e5168">Setting properties for MOXy providers into Configurable</a></dt><dt>8.10. <a href="#d0e5229">Building client with MOXy JSON feature enabled.</a></dt><dt>8.11. <a href="#d0e5234">Creating JAX-RS application with MOXy JSON feature enabled.</a></dt><dt>8.12. <a href="#d0e5333">Building client with JSON-Processing JSON feature enabled.</a></dt><dt>8.13. <a href="#d0e5338">Creating JAX-RS application with JSON-Processing JSON feature enabled.</a></dt><dt>8.14. <a href="#d0e5396"><code class="literal">ContextResolver&lt;ObjectMapper&gt;</code></a></dt><dt>8.15. <a href="#d0e5403">Building client with Jackson JSON feature enabled.</a></dt><dt>8.16. <a href="#d0e5409">Creating JAX-RS application with Jackson JSON feature enabled.</a></dt><dt>8.17. <a href="#d0e5475">JAXB beans for JSON supported notations description, simple address bean</a></dt><dt>8.18. <a href="#d0e5481">JAXB beans for JSON supported notations description, contact bean</a></dt><dt>8.19. <a href="#d0e5489">JAXB beans for JSON supported notations description, initialization</a></dt><dt>8.20. <a href="#json.jaxb.jettison.mapped.ns.def">
                                XML namespace to JSON mapping configuration for Jettison based <code class="literal">mapped</code> notation
                            </a></dt><dt>8.21. <a href="#d0e5535">JSON expression with XML namespaces mapped into JSON</a></dt><dt>8.22. <a href="#json.jaxb.jettison.mapped.array.def">
                                JSON Array configuration for Jettison based <code class="literal">mapped</code> notation
                            </a></dt><dt>8.23. <a href="#d0e5558">JSON expression with JSON arrays explicitly configured via Jersey</a></dt><dt>8.24. <a href="#d0e5580">JSON expression produced using <code class="literal">badgerfish</code> notation</a></dt><dt>8.25. <a href="#d0e5606"><code class="literal">ContextResolver&lt;ObjectMapper&gt;</code></a></dt><dt>8.26. <a href="#d0e5613">Building client with Jettison JSON feature enabled.</a></dt><dt>8.27. <a href="#d0e5619">Creating JAX-RS application with Jettison JSON feature enabled.</a></dt><dt>8.28. <a href="#d0e5693">Simplest case of using <code class="literal">@JSONP</code></a></dt><dt>8.29. <a href="#d0e5704">JaxbBean for @JSONP example</a></dt><dt>8.30. <a href="#d0e5760">Example of <code class="literal">@JSONP</code> with configured parameters.</a></dt><dt>8.31. <a href="#d0e5820">Low level XML test - methods added to <code class="literal">HelloWorldResource.java</code></a></dt><dt>8.32. <a href="#d0e5864">Planet class</a></dt><dt>8.33. <a href="#d0e5869">Resource class</a></dt><dt>8.34. <a href="#d0e5916">Method for consuming Planet</a></dt><dt>8.35. <a href="#d0e5950">Resource class - JAXBElement</a></dt><dt>8.36. <a href="#d0e5969">Client side - JAXBElement</a></dt><dt>8.37. <a href="#d0e5988">PlanetJAXBContextProvider</a></dt><dt>8.38. <a href="#d0e6001">Using Provider with JAX-RS client</a></dt><dt>8.39. <a href="#d0e6032">Add <code class="literal">jersey-media-moxy</code> dependency.</a></dt><dt>8.40. <a href="#d0e6040">Register the <code class="literal">MoxyXmlFeature</code> class.</a></dt><dt>8.41. <a href="#d0e6048">Configure and register an <code class="literal">MoxyXmlFeature</code> instance.</a></dt><dt>8.42. <a href="#d0e6140">Building client with MultiPart feature enabled.</a></dt><dt>8.43. <a href="#d0e6146">Creating JAX-RS application with MultiPart feature enabled.</a></dt><dt>8.44. <a href="#d0e6189"><code class="literal">MultiPart</code> entity</a></dt><dt>8.45. <a href="#d0e6203"><code class="literal">MultiPart</code> entity in HTTP message.</a></dt><dt>8.46. <a href="#d0e6233"><code class="literal">FormDataMultiPart</code> entity</a></dt><dt>8.47. <a href="#d0e6250"><code class="literal">FormDataMultiPart</code> entity in HTTP message.</a></dt><dt>8.48. <a href="#d0e6271">Multipart - sending files.</a></dt><dt>8.49. <a href="#d0e6325">Resource method using <code class="literal">MultiPart</code> as input parameter / return value.</a></dt><dt>8.50. <a href="#d0e6451">Use of <code class="literal">@FormDataParam</code> annotation</a></dt><dt>9.1. <a href="#d0e6552">Container response filter</a></dt><dt>9.2. <a href="#d0e6579">Container request filter</a></dt><dt>9.3. <a href="#d0e6621">Pre-matching request filter</a></dt><dt>9.4. <a href="#d0e6664">Client request filter</a></dt><dt>9.5. <a href="#d0e6703">GZIP writer interceptor</a></dt><dt>9.6. <a href="#d0e6752">GZIP reader interceptor</a></dt><dt>9.7. <a href="#d0e6877"><code class="literal">@NameBinding</code> example</a></dt><dt>9.8. <a href="#d0e6936">Dynamic binding example</a></dt><dt>9.9. <a href="#d0e7050">Priorities example</a></dt><dt>10.1. <a href="#d0e7083">Simple async resource</a></dt><dt>10.2. <a href="#d0e7170">Simple async method with timeout</a></dt><dt>10.3. <a href="#d0e7216">CompletionCallback example</a></dt><dt>10.4. <a href="#d0e7295">ChunkedOutput example</a></dt><dt>10.5. <a href="#d0e7335">Simple client async invocation</a></dt><dt>10.6. <a href="#d0e7376">Simple client fluent async invocation</a></dt><dt>10.7. <a href="#d0e7404">Client async callback</a></dt><dt>10.8. <a href="#d0e7454">Client async callback for specific entity</a></dt><dt>10.9. <a href="#d0e7491">ChunkedInput example</a></dt><dt>11.1. <a href="#d0e7579">URI building</a></dt><dt>11.2. <a href="#d0e7620">Building URIs using query parameters</a></dt><dt>12.1. <a href="#d0e7766">A standard resource class</a></dt><dt>12.2. <a href="#d0e7774">A programmatic resource</a></dt><dt>12.3. <a href="#d0e7874">A programmatic resource</a></dt><dt>12.4. <a href="#d0e7898">A programmatic resource</a></dt><dt>12.5. <a href="#d0e7934">A programmatic resource</a></dt><dt>12.6. <a href="#d0e7968">A programmatic resource</a></dt><dt>13.1. <a href="#example-simple-sse">Simple SSE resource method</a></dt><dt>13.2. <a href="#d0e8350">Broadcasting SSE messages</a></dt><dt>13.3. <a href="#sse.ex.client.eventListener">Registering <code class="literal">EventListener</code> with <code class="literal">EventSource</code></a></dt><dt>13.4. <a href="#d0e8668">Overriding <code class="literal">EventSource.onEvent(InboundEvent)</code> method</a></dt><dt>14.1. <a href="#d0e8782">Accessing <code class="code">SecurityContext</code></a></dt><dt>14.2. <a href="#d0e8798">Injecting <code class="code">SecurityContext</code> into a singleton resource</a></dt><dt>14.3. <a href="#d0e8884">Securing resources using <code class="literal">web.xml</code></a></dt><dt>14.4. <a href="#d0e8918">Registering RolesAllowedDynamicFeature using ResourceConfig</a></dt><dt>14.5. <a href="#d0e8929">Injecting <code class="code">SecurityContext</code> into singletons</a></dt><dt>15.1. <a href="#d0e9011">A simple WADL example - JAX-RS resource definition</a></dt><dt>15.2. <a href="#d0e9023">A simple WADL example - WADL content</a></dt><dt>15.3. <a href="#d0e9141">OPTIONS method returning WADL</a></dt><dt>15.4. <a href="#d0e9164">More complex WADL example - JAX-RS resource definition</a></dt><dt>15.5. <a href="#d0e9176">More complex WADL example - WADL content</a></dt><dt>16.1. <a href="#bv.example.jersey.properties">Configuring Jersey specific properties for Bean Validation.</a></dt><dt>16.2. <a href="#bv.example.ValidationConfig">Using <code class="literal">ValidationConfig</code> to configure <code class="literal">Validator</code>.</a></dt><dt>16.3. <a href="#bv.example.constraints">Constraint annotations on input parameters</a></dt><dt>16.4. <a href="#bv.example.constraints.fields">Constraint annotations on fields</a></dt><dt>16.5. <a href="#bv.example.constraints.class">Constraint annotations on class</a></dt><dt>16.6. <a href="#bv.example.constraints.definition">Definition of a constraint annotation</a></dt><dt>16.7. <a href="#bv.example.validator.definition">Validator implementation.</a></dt><dt>16.8. <a href="#bv.example.constraints.entity">Entity validation</a></dt><dt>16.9. <a href="#bv.example.constraints.entity2">Entity validation 2</a></dt><dt>16.10. <a href="#bv.example.constraints.entity.response">Response entity validation</a></dt><dt>16.11. <a href="#bv.example.validateonexecution">Validate getter on execution</a></dt><dt>16.12. <a href="#bv.examples.injecting">Injecting UriInfo into a ConstraintValidator</a></dt><dt>16.13. <a href="#bv.examples.injecting.factory">Support for injecting Jersey's resources/providers via ConstraintValidatorFactory.</a></dt><dt>16.14. <a href="#d0e10015"><code class="literal">ValidationError</code> to <code class="literal">text/plain</code></a></dt><dt>16.15. <a href="#d0e10025"><code class="literal">ValidationError</code> to <code class="literal">text/html</code></a></dt><dt>16.16. <a href="#d0e10035"><code class="literal">ValidationError</code> to <code class="literal">application/xml</code></a></dt><dt>16.17. <a href="#d0e10045"><code class="literal">ValidationError</code> to <code class="literal">application/json</code></a></dt><dt>17.1. <a href="#ef.example.server.registration">Registering and configuring entity-filtering feature on server.</a></dt><dt>17.2. <a href="#ef.example.server.security.registration">Registering and configuring entity-filtering feature with security annotations on server.</a></dt><dt>17.3. <a href="#ef.example.client.registration">Registering and configuring entity-filtering feature on client.</a></dt><dt>17.4. <a href="#d0e10214">Project</a></dt><dt>17.5. <a href="#d0e10220">User</a></dt><dt>17.6. <a href="#d0e10226">Task</a></dt><dt>17.7. <a href="#d0e10237">ProjectsResource</a></dt><dt>17.8. <a href="#ef.annotations.sample.annotation">ProjectDetailedView</a></dt><dt>17.9. <a href="#d0e10293">Annotated Project</a></dt><dt>17.10. <a href="#d0e10299">Annotated User</a></dt><dt>17.11. <a href="#d0e10305">Annotated Task</a></dt><dt>17.12. <a href="#d0e10358">ProjectsResource - Response entity-filtering annotations</a></dt><dt>17.13. <a href="#d0e10364">ProjectsResource - Entity-filtering annotations on methods</a></dt><dt>17.14. <a href="#d0e10475">Client - Request entity-filtering annotations</a></dt><dt>17.15. <a href="#d0e10481">Client - Request entity-filtering annotations</a></dt><dt>17.16. <a href="#ef.custom.annotations.annotation">Entity-filtering annotation with custom meaning</a></dt><dt>17.17. <a href="#ef.modules.custom">Entity Data Filtering support in MOXy JSON binding provider</a></dt><dt>18.1. <a href="#d0e10769">Registering <code class="literal">MvcFeature</code></a></dt><dt>18.2. <a href="#d0e10777">Registering <code class="literal">JspMvcFeature</code></a></dt><dt>18.3. <a href="#mvc.ex.rc.properties">Setting <code class="literal">MvcProperties.TEMPLATE_BASE_PATH</code> value in <code class="literal">ResourceConfig</code></a></dt><dt>18.4. <a href="#mvc.ex.web.xml.properties">Setting <code class="literal">FreemarkerMvcProperties.TEMPLATE_BASE_PATH</code> value in <code class="literal">web.xml</code></a></dt><dt>18.5. <a href="#mvc.example.viewable.simple">Using <code class="literal">Viewable</code> in a resource class</a></dt><dt>18.6. <a href="#mvc.example.viewable.absolutePath">Using absolute path to template in <code class="literal">Viewable</code></a></dt><dt>18.7. <a href="#mvc.example.implicit.class">Using <code class="literal">@Template</code> on a resource class</a></dt><dt>18.8. <a href="#d0e11154">Custom TemplateProcessor</a></dt><dt>18.9. <a href="#d0e11162">Registering custom TemplateProcessor</a></dt><dt>19.1. <a href="#d0e11261">Application event listener</a></dt><dt>19.2. <a href="#d0e11267">Request event listener</a></dt><dt>19.3. <a href="#d0e11273">Event listener test resource</a></dt><dt>19.4. <a href="#d0e11478">Injecting MonitoringStatistics</a></dt><dt>23.1. <a href="#d0e12312">Jersey 1 reloader implementation</a></dt><dt>23.2. <a href="#d0e12318">Jersey 1 reloader registration</a></dt><dt>23.3. <a href="#d0e12358">Jersey 2 reloader implementation</a></dt><dt>23.4. <a href="#d0e12364">Jersey 2 reloader registration</a></dt></dl></div><div class="preface" title="Preface"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div></div><p>
            This is user guide for Jersey 2.3. We are trying to keep it up to date as we add new features.
            When reading the user guide, please consult also our
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/index.html" target="_top">Jersey API documentation</a> as an additional source
            of information about Jersey features and API.
        </p><p>
            If you would like to contribute to the guide or have questions on things not covered in our docs, please
            contact us at<a class="link" href="mailto:users@jersey.java.net" target="_top">users@jersey.java.net</a>. Similarly,
            in case you spot any errors in the Jersey documentation, please report them by filing a new issue in our
            <a class="link" href="http://java.net/jira/browse/JERSEY" target="_top">Jersey JIRA Issue Tracker</a>
            under
            <code class="literal">docs</code>
            component. Please make sure to specify the version of the Jersey User Guide where the error has been spotted
            by selecting the proper value for the
            <code class="literal">Affected Version</code>
            field.
        </p><div class="simplesect" title="Text formatting conventions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e28"></a>Text formatting conventions</h2></div></div></div><p>
                First mention of any Jersey and JAX-RS API component in a section links to the API documentation of the
                referenced component. Any sub-sequent mentions of the component in the same chapter are rendered using a
                <code class="literal">monospace</code>
                font.
            </p><p>
                <span class="emphasis"><em>Emphasised font</em></span>
                is used to a call attention to a newly introduce concept, when it first
                occurs in the text.
            </p><p>
                In some of the code listings, certain lines are too long to be displayed on one line for the available
                page width. In such case, the lines that exceed the available page width are broken up into multiple lines
                using a
                <code class="literal">'\'</code>
                at the end of each line to indicate that a break has been introduced to
                fit the line in the page. For example:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    gutter: false;">
This is an overly long line that \
might not fit the available page \
width and had to be broken into \
multiple lines.

This line fits the page width.
                </pre><p>

                Should read as:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    gutter: false;">
This is an overly long line that might not fit the available page width and had to be broken into multiple lines.

This line fits the page width.
                </pre><p>
            </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;1.&nbsp;Getting Started"><div class="titlepage"><div><div><h2 class="title"><a name="getting-started"></a>Chapter&nbsp;1.&nbsp;Getting Started</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#new-from-archetype">1.1. Creating a New Project from Maven Archetype</a></span></dt><dt><span class="section"><a href="#new-project-structure">1.2. Exploring the Newly Created Project</a></span></dt><dt><span class="section"><a href="#running-project">1.3. Running the Project</a></span></dt><dt><span class="section"><a href="#new-webapp">1.4. Creating a JavaEE Web Application</a></span></dt><dt><span class="section"><a href="#exploring-jersey-examples">1.5. Exploring Other Jersey Examples</a></span></dt></dl></div><p>
        This chapter provides a quick introduction on how to get started building RESTful services using Jersey.
        The example described here uses the lightweight Grizzly HTTP server. At the end of this chapter you will
        see how to implement equivalent functionality as a JavaEE web application you can deploy on any servlet
        container supporting Servlet 2.5 and higher.
    </p><div class="section" title="1.1.&nbsp;Creating a New Project from Maven Archetype"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-from-archetype"></a>1.1.&nbsp;Creating a New Project from Maven Archetype</h2></div></div></div><p>
            Jersey project is build using <a class="link" href="http://maven.apache.org/" target="_top">Apache Maven</a> software project build and management tool. All modules produced as
            part of Jersey project build are pushed to the <a class="link" href="http://search.maven.org/" target="_top">Central Maven Repository</a>. Therefore it is very convenient to work
            with Jersey for any Maven-based project as all the released (non-SNAPSHOT) Jersey dependencies are readily
            available without a need to configure a special maven repository to consume the Jersey modules.

            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    In case you want to depend on the latest SNAPSHOT versions of Jersey modules, the following repository
                    configuration needs to be added to your Maven project pom:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;repository&gt;
    &lt;id&gt;snapshot-repository.java.net&lt;/id&gt;
    &lt;name&gt;Java.net Snapshot Repository for Maven&lt;/name&gt;
    &lt;url&gt;https://maven.java.net/content/repositories/snapshots/&lt;/url&gt;
    &lt;layout&gt;default&lt;/layout&gt;
&lt;/repository&gt;</pre><p>
                </p></div><p>
        </p><p>
            Since starting from a Maven project is the most convenient way for working with Jersey, let's now have a look
            at this approach. We will now create a new Jersey project that runs on top of a <a class="link" href="http://grizzly.java.net/" target="_top">Grizzly</a> container. We will
            use a Jersey-provided maven archetype. To create the project, execute the following Maven command in the directory
            where the new project should reside:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn archetype:generate -DarchetypeArtifactId=jersey-quickstart-grizzly2 \
-DarchetypeGroupId=org.glassfish.jersey.archetypes -DinteractiveMode=false \
-DgroupId=com.example -DartifactId=simple-service -Dpackage=com.example \
-DarchetypeVersion=2.3</pre><p>

            Feel free to adjust the <code class="literal">groupId</code>, <code class="literal">package</code> and/or <code class="literal">artifactId</code>
            of your new project. Alternatively, you can change it by updating the new project pom.xml once it gets generated.
        </p></div><div class="section" title="1.2.&nbsp;Exploring the Newly Created Project"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-project-structure"></a>1.2.&nbsp;Exploring the Newly Created Project</h2></div></div></div><p>
            Once the project generation from a Jersey maven archetype is successfully finished, you should see the new
            <code class="literal">simple-service</code> project directory created in your current location. The directory contains
            a standard Maven project structure:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                    Project build and management configuration is described in the <code class="literal">pom.xml</code> located
                    in the project root directory.
                </td></tr><tr><td>Project sources are located under <code class="literal">src/main/java</code>.</td></tr><tr><td>Project test sources are located under <code class="literal">src/test/java</code>.</td></tr></table><p>

            There are 2 classes in the project source directory in the <code class="literal">com.example</code> package.
            The <code class="literal">Main</code> class is responsible for bootstrapping the Grizzly container as well as configuring
            and deploying the project's JAX-RS application to the container. Another class in the same package
            is <code class="literal">MyResource</code> class, that contains implementation of a simple JAX-RS resource.
            It looks like this:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">package com.example;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

/**
 * Root resource (exposed at "myresource" path)
 */
@Path("myresource")
public class MyResource {

    /**
     * Method handling HTTP GET requests. The returned object will be sent
     * to the client as "text/plain" media type.
     *
     * @return String that will be returned as a text/plain response.
     */
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String getIt() {
        return "Got it!";
    }
}</pre><p>

            A JAX-RS resource is an annotated POJO that provides so-called <span class="emphasis"><em>resource methods</em></span> that
            are able to handle HTTP requests for URI paths that the resource is bound to. See
            <a class="xref" href="#jaxrs-resources" title="Chapter&nbsp;3.&nbsp;JAX-RS Application, Resources and Sub-Resources">Chapter&nbsp;3, <i>JAX-RS Application, Resources and Sub-Resources</i></a> for a complete guide to JAX-RS resources. In our case, the resource
            exposes a single resource method that is able to handle HTTP <code class="literal">GET</code> requests, is bound to
            <code class="literal">/myresource</code> URI path and can produce responses with response message content represented
            in <code class="literal">"text/plain"</code> media type. In this version, the resource returns the same
            <code class="literal">"Got it!"</code> response to all client requests.
        </p><p>
            The last piece of code that has been generated in this skeleton project is a <code class="literal">MyResourceTest</code>
            unit test class that is located in the same <code class="literal">com.example</code> package as the
            <code class="literal">MyResource</code> class, however, this unit test class is placed into the maven project test source
            directory <code class="literal">src/test/java</code> (certain code comments and JUnit imports have been excluded for brevity):

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">package com.example;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;

import org.glassfish.grizzly.http.server.HttpServer;

...

public class MyResourceTest {

    private HttpServer server;
    private WebTarget target;

    @Before
    public void setUp() throws Exception {
        server = Main.startServer();

        Client c = ClientBuilder.newClient();
        target = c.target(Main.BASE_URI);
    }

    @After
    public void tearDown() throws Exception {
        server.stop();
    }

    /**
     * Test to see that the message "Got it!" is sent in the response.
     */
    @Test
    public void testGetIt() {
        String responseMsg = target.path("myresource").request().get(String.class);
        assertEquals("Got it!", responseMsg);
    }
}</pre><p>

            In this unit test, a Grizzly container is first started and server application is deployed in the
            test <code class="literal">setUp()</code> method by a static call to <code class="literal">Main.startServer()</code>.
            Next, a JAX-RS client components are created in the same test set-up method. First a new JAX-RS client
            instance <code class="literal">c</code> is built and then a JAX-RS web target component pointing to the context root of our
            application deployed at <code class="literal">http://localhost:8080/myapp/</code> (a value of
            <code class="literal">Main.BASE_URI</code> constant) is stored into a <code class="literal">target</code> field of the unit test class.
            This field is then used in the actual unit test method (<code class="literal">testGetIt()</code>).
        </p><p>
            In the <code class="literal">testGetIt()</code> method a fluent JAX-RS Client API is used to connect to and send
            a HTTP <code class="literal">GET</code> request to the <code class="literal">MyResource</code> JAX-RS resource class listening on
            <code class="literal">/myresource</code> URI. As part of the same fluent JAX-RS API method invocation chain, a response is
            read as a Java <code class="literal">String</code> type. On the second line in the test method, the response content string
            returned from the server is compared with the expected phrase in the test assertion. To learn more about using
            JAX-RS Client API, please see the <a class="xref" href="#client" title="Chapter&nbsp;5.&nbsp;Client API">Chapter&nbsp;5, <i>Client API</i></a> chapter.
        </p></div><div class="section" title="1.3.&nbsp;Running the Project"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="running-project"></a>1.3.&nbsp;Running the Project</h2></div></div></div><p>
            Now that we have seen the content of the project, let's try to test-run it. To do this, we need to invoke following
            command on the command line:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn clean test</pre><p>

            This will compile the project and run the project unit tests. We should see a similar output that informs about a
            successful build once the build is finished:

            </p><pre class="screen">Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 34.527s
[INFO] Finished at: Sun May 26 19:26:24 CEST 2013
[INFO] Final Memory: 17M/490M
[INFO] ------------------------------------------------------------------------</pre><p>

            Now that we have verified that the project compiles and that the unit test passes, we can execute the application
            in a standalone mode. To do this, run the following maven command:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn exec:java</pre><p>

            The application starts and you should soon see the following notification in your console:

            </p><pre class="screen">May 26, 2013 8:08:45 PM org.glassfish.grizzly.http.server.NetworkListener start
INFO: Started listener bound to [localhost:8080]
May 26, 2013 8:08:45 PM org.glassfish.grizzly.http.server.HttpServer start
INFO: [HttpServer] Started.
Jersey app started with WADL available at http://localhost:8080/myapp/application.wadl
Hit enter to stop it...</pre><p>

            This informs you that the application has been started and it's WADL descriptor is available at
            <code class="literal">http://localhost:8080/myapp/application.wadl</code> URL. You can retrieve the WADL content by
            executing a <code class="literal">curl http://localhost:8080/myapp/application.wadl</code> command in your console
            or by typing the WADL URL into your favorite browser. You should get back an XML document in describing
            your deployed RESTful application in a WADL format. To learn more about working with WADL, check the
            <a class="xref" href="#wadl" title="Chapter&nbsp;15.&nbsp;WADL Support">Chapter&nbsp;15, <i>WADL Support</i></a> chapter.
        </p><p>
            The last thing we should try before concluding this section is to see if we can communicate with our
            resource deployed at <code class="literal">/myresource</code> path. We can again either type the resource URL
            in the browser or we can use <code class="literal">curl</code>:

            </p><pre class="screen">$ curl http://localhost:8080/myapp/myresource
Got it!</pre><p>

            As we can see, the <code class="literal">curl</code> command returned with the <code class="literal">Got it!</code> message that
            was sent by our resource. We can also ask <code class="literal">curl</code> to provide more information about the response,
            for example we can let it display all response headers by using the <code class="literal">-i</code> switch:

            </p><pre class="screen">curl -i http://localhost:8080/myapp/myresource
HTTP/1.1 200 OK
Content-Type: text/plain
Date: Sun, 26 May 2013 18:27:19 GMT
Content-Length: 7

Got it!</pre><p>

            Here we see the whole content of the response message that our Jersey/JAX-RS application returned, including all
            the HTTP headers. Notice the <code class="literal">Content-Type: text/plain</code> header that was derived from the
            value of <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> annotation attached to the <code class="literal">MyResource</code> class.
        </p><p>
            In case you want to see even more details about the communication between our <code class="literal">curl</code> client
            and our resource running on Jersey in a Grizzly I/O container, feel free to try other various options and switches
            that <code class="literal">curl</code> provides. For example, this last command will make <code class="literal">curl</code> output
            a lot of additional information about the whole communication:

            </p><pre class="screen">$ curl -v http://localhost:8080/myapp/myresource
* About to connect() to localhost port 8080 (#0)
*   Trying ::1...
* Connection refused
*   Trying 127.0.0.1...
* connected
* Connected to localhost (127.0.0.1) port 8080 (#0)
&gt; GET /myapp/myresource HTTP/1.1
&gt; User-Agent: curl/7.25.0 (x86_64-apple-darwin11.3.0) libcurl/7.25.0 OpenSSL/1.0.1e zlib/1.2.7 libidn/1.22
&gt; Host: localhost:8080
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Content-Type: text/plain
&lt; Date: Sun, 26 May 2013 18:29:18 GMT
&lt; Content-Length: 7
&lt;
* Connection #0 to host localhost left intact
Got it!* Closing connection #0</pre><p>
        </p></div><div class="section" title="1.4.&nbsp;Creating a JavaEE Web Application"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-webapp"></a>1.4.&nbsp;Creating a JavaEE Web Application</h2></div></div></div><p>
            To create a Web Application that can be packaged as WAR and deployed in a Servlet container follow a similar process
            to the one described in <a class="xref" href="#new-from-archetype" title="1.1.&nbsp;Creating a New Project from Maven Archetype">Section&nbsp;1.1, &#8220;Creating a New Project from Maven Archetype&#8221;</a>.
            In addition to the Grizzly-based archetype, Jersey provides also a Maven arcehtype for creating web application
            skeletons. To create the new web application skeleton project, execute the following Maven command in the directory
            where the new project should reside:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn archetype:generate -DarchetypeArtifactId=jersey-quickstart-webapp \
                -DarchetypeGroupId=org.glassfish.jersey.archetypes -DinteractiveMode=false \
                -DgroupId=com.example -DartifactId=simple-service-webapp -Dpackage=com.example \
                -DarchetypeVersion=2.3</pre><p>

            As with the Grizzly based project, feel free to adjust the <code class="literal">groupId</code>, <code class="literal">package</code>
            and/or <code class="literal">artifactId</code> of your new web application project. Alternatively, you can change it by updating
            the new project pom.xml once it gets generated.
        </p><p>
            Once the project generation from a Jersey maven archetype is successfully finished, you should see the new
            <code class="literal">simple-service-webapp</code> project directory created in your current location. The directory contains
            a standard Maven project structure, similar to the <code class="literal">simple-service</code> project content we have seen
            earlier, except it is extended with an additional web application specific content:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                    Project build and management configuration is described in the <code class="literal">pom.xml</code> located
                    in the project root directory.
                </td></tr><tr><td>Project sources are located under <code class="literal">src/main/java</code>.</td></tr><tr><td>Project resources are located under <code class="literal">src/main/resources</code>.</td></tr><tr><td>Project web application files are located under <code class="literal">src/main/webapp</code>.</td></tr></table><p>

            The project contains the same <code class="literal">MyResouce</code> JAX-RS resource class. It does not contain any unit tests
            as well as it does not contain a <code class="literal">Main</code> class that was used to setup Grizzly container in the
            previous project. Instead, it contains the standard Java EE web application <code class="literal">web.xml</code> deployment
            descriptor under <code class="literal">src/main/webapp/WEB-INF</code>.
            The last component in the project is an <code class="literal">index.jsp</code> page that serves as a client for the
            <code class="literal">MyResource</code> resource class that is packaged and deployed with the application.
        </p><p>
            To compile and package the application into a WAR, invoke the following maven command in your console:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn clean package</pre><p>

            A successfull build output will produce an output similar to the one below:

            </p><pre class="screen">Results :

Tests run: 0, Failures: 0, Errors: 0, Skipped: 0

[INFO]
[INFO] --- maven-war-plugin:2.1.1:war (default-war) @ simple-service-webapp ---
[INFO] Packaging webapp
[INFO] Assembling webapp [simple-service-webapp] in [.../simple-service-webapp/target/simple-service-webapp]
[INFO] Processing war project
[INFO] Copying webapp resources [.../simple-service-webapp/src/main/webapp]
[INFO] Webapp assembled in [75 msecs]
[INFO] Building war: .../simple-service-webapp/target/simple-service-webapp.war
[INFO] WEB-INF/web.xml already added, skipping
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 9.067s
[INFO] Finished at: Sun May 26 21:07:44 CEST 2013
[INFO] Final Memory: 17M/490M
[INFO] ------------------------------------------------------------------------</pre><p>

            Now you are ready to take the packaged WAR (located under <code class="literal">./target/simple-service-webapp.war</code>)
            and deploy it to a Servlet container of your choice.
            </p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    To deploy a Jersey application, you will need a Servlet container that supports Servlet 2.5 or later.
                    For full set of advanced features (such as JAX-RS 2.0 Async Support) you will need a Servlet 3.0 or later
                    compliant container.
                </p></div><p>
        </p></div><div class="section" title="1.5.&nbsp;Exploring Other Jersey Examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="exploring-jersey-examples"></a>1.5.&nbsp;Exploring Other Jersey Examples</h2></div></div></div><p>
            In the sections above, we have covered an approach how to get dirty with Jersey quickly. Please consult the other
            sections of the Jersey User Guide to learn more about Jersey and JAX-RS.
            Even though we try our best to cover as much as possibly in the User Guide, there is always a chance that you would
            not be able to get a full answer to the problem you are solving. In that case, consider diving in our examples that
            provide additional tips and hints to the features you may want to use in your projects.
        </p><p>
            Jersey codebase contains a number of useful examples on how to use various JAX-RS and Jersey features.
            Feel free to browse through the code of individual
            <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples" target="_top">Jersey Examples</a> in the Jersey source repository.
            For off-line browsing, you can also download a bundle with all the examples from
            <a class="link" href="https://maven.java.net/content/repositories/releases/org/glassfish/jersey/bundles/jersey-examples/2.3/" target="_top">here</a>.
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;2.&nbsp;Modules and dependencies"><div class="titlepage"><div><div><h2 class="title"><a name="modules-and-dependencies"></a>Chapter&nbsp;2.&nbsp;Modules and dependencies</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e377">2.1. Java SE Compatibility</a></span></dt><dt><span class="section"><a href="#d0e382">2.2. Introduction to Jersey dependencies</a></span></dt><dt><span class="section"><a href="#dependencies">2.3. Common Jersey Use Cases</a></span></dt><dd><dl><dt><span class="section"><a href="#servlet-app-glassfish">2.3.1. Servlet based application on Glassfish</a></span></dt><dt><span class="section"><a href="#servlet-app-general">2.3.2. Servlet based server-side application</a></span></dt><dt><span class="section"><a href="#client-jdk">2.3.3. Client application on JDK</a></span></dt><dt><span class="section"><a href="#server-jdk">2.3.4. Server-side application on supported containers</a></span></dt></dl></dd><dt><span class="section"><a href="#modules">2.4. List of modules</a></span></dt></dl></div><div class="section" title="2.1.&nbsp;Java SE Compatibility"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e377"></a>2.1.&nbsp;Java SE Compatibility</h2></div></div></div><p>
            All Jersey components are compiled with Java SE 6 target. It means, you will also need at least Java SE 6
            to be able to compile and run your application.
        </p></div><div class="section" title="2.2.&nbsp;Introduction to Jersey dependencies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e382"></a>2.2.&nbsp;Introduction to Jersey dependencies</h2></div></div></div><p>
            Jersey is built, assembled and installed using <a class="link" href="http://maven.apache.org/" target="_top">Apache Maven</a>.
            Non-snapshot Jersey releases are deployed to the
            <a class="link" href="http://search.maven.org/" target="_top">Central Maven Repository</a>. Jersey is also being deployed to
            <a class="link" href="http://maven.java.net/" target="_top">Java.Net Maven repositories</a>, which contain also Jersey SNAPSHOT
            versions. In case you would want to test the latest development builds check out the
            <a class="link" href="https://maven.java.net/content/repositories/snapshots/org/glassfish/jersey" target="_top">
                Java.Net Snapshots Maven repository</a>.
        </p><p>
            An application that uses Jersey and depends on Jersey modules is in turn required to also include in the application
            dependencies the set of 3rd party modules that Jersey modules depend on. Jersey is designed as a pluggable component
            architecture and different applications can therefore require different sets of Jersey modules. This also means that
            the set of external Jersey dependencies required to be included in the application dependencies may vary in each
            application based on the Jersey modules that are being used by the application.
        </p><p>
            Developers using Maven or a Maven-aware build system in their projects are likely to find it easier to include and
            manage dependencies of their applications compared to developers using ant or other build systems that are not
            compatible with Maven. This document will explain to both maven and non-maven developers how to depend on
            Jersey modules in their application. Ant developers are likely to find the
            <a class="link" href="http://maven.apache.org/ant-tasks/index.html" target="_top">Ant Tasks for Maven</a> very useful.
        </p></div><div class="section" title="2.3.&nbsp;Common Jersey Use Cases"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dependencies"></a>2.3.&nbsp;Common Jersey Use Cases</h2></div></div></div><div class="section" title="2.3.1.&nbsp;Servlet based application on Glassfish"><div class="titlepage"><div><div><h3 class="title"><a name="servlet-app-glassfish"></a>2.3.1.&nbsp;Servlet based application on Glassfish</h3></div></div></div><p>If you are using Glassfish application server, you don't need to package
                anything with your application, everything is already included. You just need to declare
                (provided) dependency on JAX-RS API to be able to compile your application.
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;javax.ws.rs&lt;/groupId&gt;
    &lt;artifactId&gt;javax.ws.rs-api&lt;/artifactId&gt;
    &lt;version&gt;2.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre><p>If you are using any Jersey specific feature, you will need to depend on Jersey directly.</p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!-- if you are using Jersey client specific features --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
            </pre></div><div class="section" title="2.3.2.&nbsp;Servlet based server-side application"><div class="titlepage"><div><div><h3 class="title"><a name="servlet-app-general"></a>2.3.2.&nbsp;Servlet based server-side application</h3></div></div></div><p>Following dependencies apply to application server (servlet containers) without any
                integrated JAX-RS implementation. Then application needs to include JAX-RS API and Jersey
                implementation in deployed application.</p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;!-- if your container implements Servlet API older than 3.0, use "jersey-container-servlet-core"  --&gt;
    &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Required only when you are using JAX-RS Client --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre></div><div class="section" title="2.3.3.&nbsp;Client application on JDK"><div class="titlepage"><div><div><h3 class="title"><a name="client-jdk"></a>2.3.3.&nbsp;Client application on JDK</h3></div></div></div><p>Applications running on plain JDK using only client part of JAX-RS specification need
                to depend only on client. There are various additional modules which can be added, like
                for example grizzly or apache connector (see dependencies snipped below). Jersey client
                runs by default with plain JDK (using HttpUrlConnection). See <a class="xref" href="#client" title="Chapter&nbsp;5.&nbsp;Client API">Chapter&nbsp;5, <i>Client API</i></a>.
                for more details.
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.core&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-client&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
            </pre><p>Currently available connectors:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.connectors&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-grizzly-connector&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.connectors&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-apache-connector&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre></div><div class="section" title="2.3.4.&nbsp;Server-side application on supported containers"><div class="titlepage"><div><div><h3 class="title"><a name="server-jdk"></a>2.3.4.&nbsp;Server-side application on supported containers</h3></div></div></div><p>Apart for a standard JAX-RS Servlet-based deployment that works with any Servlet container that
                supports Servlet 2.5 and higher,
                Jersey provides support for programmatic deployment to the following containers: Grizzly 2 (HTTP and Servlet),
                JDK Http server and Simple Http server. This chapter presents only required maven dependencies,
                more information can be found in <a class="xref" href="#deployment" title="Chapter&nbsp;4.&nbsp;Deploying a RESTful Web Service">Chapter&nbsp;4, <i>Deploying a RESTful Web Service</i></a>.
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-grizzly2-http&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-grizzly2-servlet&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-jdk-http&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-container-simple-http&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><div class="section" title="2.4.&nbsp;List of modules"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="modules"></a>2.4.&nbsp;List of modules</h2></div></div></div><p>The following chapters provide an overview of all Jersey modules
            and their dependencies with links to the respective binaries (follow a link
            on a module name to get complete set of downloadable dependencies).
        </p><div class="table"><a name="dependencies-table-core"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Jersey Core</b></p><div class="table-contents"><table summary="Jersey Core" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Core</th></tr></thead><tbody><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/jersey-client/dependencies.html" target="_top">
                                jersey-client
                            </a>
                        </td><td align="left">Jersey core client implementation.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/jersey-common/dependencies.html" target="_top">
                                jersey-common
                            </a>
                        </td><td align="left">Jersey core common packages.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/jersey-server/dependencies.html" target="_top">
                                jersey-server
                            </a>
                        </td><td align="left">Jersey core server implementation.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-containers"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Jersey Containers</b></p><div class="table-contents"><table summary="Jersey Containers" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Containers</th></tr></thead><tbody><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-container-grizzly2-http/dependencies.html" target="_top">
                                jersey-container-grizzly2-http
                            </a>
                        </td><td align="left">Grizzly 2 Http Container.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-container-grizzly2-servlet/dependencies.html" target="_top">
                                jersey-container-grizzly2-servlet
                            </a>
                        </td><td align="left">Grizzly 2 Servlet Container.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-container-jdk-http/dependencies.html" target="_top">
                                jersey-container-jdk-http
                            </a>
                        </td><td align="left">JDK Http Container.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-container-servlet/dependencies.html" target="_top">
                                jersey-container-servlet
                            </a>
                        </td><td align="left">Jersey core Servlet 3.x implementation.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-container-servlet-core/dependencies.html" target="_top">
                                jersey-container-servlet-core
                            </a>
                        </td><td align="left">Jersey core Servlet 2.x implementation.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-container-simple-http/dependencies.html" target="_top">
                                jersey-container-simple-http
                            </a>
                        </td><td align="left">Simple Http Container.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-connectors"></a><p class="title"><b>Table&nbsp;2.3.&nbsp;Jersey Connectors</b></p><div class="table-contents"><table summary="Jersey Connectors" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Connectors</th></tr></thead><tbody><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-grizzly-connector/dependencies.html" target="_top">
                                jersey-grizzly-connector
                            </a>
                        </td><td align="left">Jersey Client Transport via Grizzly.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-apache-connector/dependencies.html" target="_top">
                                jersey-apache-connector
                            </a>
                        </td><td align="left">Jersey Client Transport via Apache.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-media"></a><p class="title"><b>Table&nbsp;2.4.&nbsp;Jersey Media</b></p><div class="table-contents"><table summary="Jersey Media" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Media</th></tr></thead><tbody><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-json-jackson/dependencies.html" target="_top">
                                jersey-media-json-jackson
                            </a>
                        </td><td align="left">Jersey JSON Jackson entity providers support module.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-json-jettison/dependencies.html" target="_top">
                                jersey-media-json-jettison
                            </a>
                        </td><td align="left">Jersey JSON Jettison entity providers support module.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-json-processing/dependencies.html" target="_top">
                                jersey-media-json-processing
                            </a>
                        </td><td align="left">Jersey JSON-P (JSR 353) entity providers support proxy module.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-moxy/dependencies.html" target="_top">
                                jersey-media-moxy
                            </a>
                        </td><td align="left">Jersey JSON entity providers support module based on EclipseLink MOXy.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-multipart/dependencies.html" target="_top">
                                jersey-media-multipart
                            </a>
                        </td><td align="left">Jersey Multipart entity providers support module.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-sse/dependencies.html" target="_top">
                                jersey-media-sse
                            </a>
                        </td><td align="left">Jersey Server Sent Events entity providers support module.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-extensions"></a><p class="title"><b>Table&nbsp;2.5.&nbsp;Jersey Extensions</b></p><div class="table-contents"><table summary="Jersey Extensions" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Extensions</th></tr></thead><tbody><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-bean-validation/dependencies.html" target="_top">
                                jersey-bean-validation
                            </a>
                        </td><td align="left">Jersey extension module providing support for Bean Validation (JSR-349) API.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc/dependencies.html" target="_top">
                                jersey-mvc
                            </a>
                        </td><td align="left">Jersey extension module providing support for MVC.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc-freemarker/dependencies.html" target="_top">
                                jersey-mvc-freemarker
                            </a>
                        </td><td align="left">Jersey extension module providing support for Freemarker templates.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc-jsp/dependencies.html" target="_top">
                                jersey-mvc-jsp
                            </a>
                        </td><td align="left">Jersey extension module providing support for JSP templates.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-proxy-client/dependencies.html" target="_top">
                                jersey-proxy-client
                            </a>
                        </td><td align="left">Jersey extension module providing support for (proxy-based) high-level client API.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-servlet-portability/dependencies.html" target="_top">
                                jersey-servlet-portability
                            </a>
                        </td><td align="left">Library that enables writing web applications that run with both Jersey 1.x and Jersey
                            2.x servlet containers.
                        </td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-wadl-doclet/dependencies.html" target="_top">
                                jersey-wadl-doclet
                            </a>
                        </td><td align="left">A doclet that generates a resourcedoc xml file: this file contains the javadoc documentation
                            of resource classes, so that this can be used for extending generated wadl with useful
                            documentation.
                        </td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-test-framework"></a><p class="title"><b>Table&nbsp;2.6.&nbsp;Jersey Test Framework</b></p><div class="table-contents"><table summary="Jersey Test Framework" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Test Framework</th></tr></thead><tbody><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-test-framework-core/dependencies.html" target="_top">
                                jersey-test-framework-core
                            </a>
                        </td><td align="left">Jersey Test Framework Core.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/project/jersey-test-framework-provider-bundle/dependencies.html" target="_top">
                                jersey-test-framework-provider-bundle
                            </a>
                        </td><td align="left">Jersey Test Framework Providers Bundle.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/project/jersey-test-framework-provider-default-client/dependencies.html" target="_top">
                                jersey-test-framework-provider-default-client
                            </a>
                        </td><td align="left">Jersey Test Framework Default Client Provider.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/project/jersey-test-framework-provider-external/dependencies.html" target="_top">
                                jersey-test-framework-provider-external
                            </a>
                        </td><td align="left">Jersey Test Framework - External container.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/project/jersey-test-framework-provider-grizzly2/dependencies.html" target="_top">
                                jersey-test-framework-provider-grizzly2
                            </a>
                        </td><td align="left">Jersey Test Framework - Grizzly2 container.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/project/jersey-test-framework-provider-inmemory/dependencies.html" target="_top">
                                jersey-test-framework-provider-inmemory
                            </a>
                        </td><td align="left">Jersey Test Framework - InMemory container.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/project/jersey-test-framework-provider-jdk-http/dependencies.html" target="_top">
                                jersey-test-framework-provider-jdk-http
                            </a>
                        </td><td align="left">Jersey Test Framework - JDK HTTP container.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/project/jersey-test-framework-provider-simple/dependencies.html" target="_top">
                                jersey-test-framework-provider-simple
                            </a>
                        </td><td align="left">Jersey Test Framework - Simple HTTP container.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-gf-bundles"></a><p class="title"><b>Table&nbsp;2.7.&nbsp;Jersey Glassfish Bundles</b></p><div class="table-contents"><table summary="Jersey Glassfish Bundles" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Glassfish Bundles</th></tr></thead><tbody><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/project/jersey-gf-cdi/dependencies.html" target="_top">
                                jersey-gf-cdi
                            </a>
                        </td><td align="left">Jersey CDI for GlassFish integration.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/project/jersey-gf-ejb/dependencies.html" target="_top">
                                jersey-gf-ejb
                            </a>
                        </td><td align="left">Jersey EJB for GlassFish integration.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-examples"></a><p class="title"><b>Table&nbsp;2.8.&nbsp;Jersey Examples</b></p><div class="table-contents"><table summary="Jersey Examples" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Examples</th></tr></thead><tbody><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/clipboard/dependencies.html" target="_top">
                                clipboard
                            </a>
                        </td><td align="left">Jersey clipboard example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/clipboard-programmatic/dependencies.html" target="_top">
                                clipboard-programmatic
                            </a>
                        </td><td align="left">Jersey programmatic resource API clipboard example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/exception-mapping/dependencies.html" target="_top">
                                exception-mapping
                            </a>
                        </td><td align="left">Jersey example showing exception mappers in action.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/helloworld/dependencies.html" target="_top">
                                helloworld
                            </a>
                        </td><td align="left">Jersey annotated resource class "Hello world" example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/helloworld-programmatic/dependencies.html" target="_top">
                                helloworld-programmatic
                            </a>
                        </td><td align="left">Jersey programmatic resource API "Hello world" example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/helloworld-pure-jax-rs/dependencies.html" target="_top">
                                helloworld-pure-jax-rs
                            </a>
                        </td><td align="left">Example using only the standard JAX-RS API's and the lightweight HTTP server bundled in
                            JDK.
                        </td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/http-trace/dependencies.html" target="_top">
                                http-trace
                            </a>
                        </td><td align="left">Jersey HTTP TRACE support example</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/https-clientserver-grizzly/dependencies.html" target="_top">
                                https-clientserver-grizzly
                            </a>
                        </td><td align="left">Jersey HTTPS Client/Server example on Grizzly.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jaxb/dependencies.html" target="_top">
                                jaxb
                            </a>
                        </td><td align="left">Jersey JAXB example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jaxrs-types-injection/dependencies.html" target="_top">
                                jaxrs-types-injection
                            </a>
                        </td><td align="left">Jersey JAX-RS types injection example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/json-jackson/dependencies.html" target="_top">
                                json-jackson
                            </a>
                        </td><td align="left">Jersey JSON with Jackson example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/json-jettison/dependencies.html" target="_top">
                                json-jettison
                            </a>
                        </td><td align="left">Jersey JSON with Jettison JAXB example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/json-moxy/dependencies.html" target="_top">
                                json-moxy
                            </a>
                        </td><td align="left">Jersey JSON with MOXy example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/json-with-padding/dependencies.html" target="_top">
                                json-with-padding
                            </a>
                        </td><td align="left">Jersey JSON with Padding example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/managed-client/dependencies.html" target="_top">
                                managed-client
                            </a>
                        </td><td align="left">Jersey managed client example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/osgi-helloworld-webapp/dependencies.html" target="_top">
                                osgi-helloworld-webapp
                            </a>
                        </td><td align="left">OSGi Helloworld.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/osgi-helloworld-webapp/lib-bundle/dependencies.html" target="_top">
                                osgi-helloworld-webapp
                            </a>
                        </td><td align="left">OSGi Helloworld - bundle.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/osgi-helloworld-webapp/war-bundle/dependencies.html" target="_top">
                                osgi-helloworld-webapp
                            </a>
                        </td><td align="left">OSGi Helloworld - war.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/osgi-http-service/bundle/dependencies.html" target="_top">
                                osgi-http-service
                            </a>
                        </td><td align="left">OSGi Helloworld.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/osgi-http-service/dependencies.html" target="_top">
                                osgi-http-service
                            </a>
                        </td><td align="left">OSGi Helloworld.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/reload/dependencies.html" target="_top">
                                reload
                            </a>
                        </td><td align="left">Jersey resource configuration reload example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/server-async/dependencies.html" target="_top">
                                server-async
                            </a>
                        </td><td align="left">Jersey JAX-RS asynchronous server-side example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/server-async-managed/dependencies.html" target="_top">
                                server-async-managed
                            </a>
                        </td><td align="left">Jersey JAX-RS asynchronous server-side example with custom Jersey executor providers.
                        </td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/server-async-standalone/server-async-standalone-client/dependencies.html" target="_top">
                                server-async-standalone
                            </a>
                        </td><td align="left">Standalone Jersey JAX-RS asynchronous server-side processing example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/server-sent-events/dependencies.html" target="_top">
                                server-sent-events
                            </a>
                        </td><td align="left">Jersey Server-Sent Events example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/simple-console/dependencies.html" target="_top">
                                simple-console
                            </a>
                        </td><td align="left">Jersey Simple Console example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/sse-twitter-aggregator/dependencies.html" target="_top">
                                sse-twitter-aggregator
                            </a>
                        </td><td align="left">Jersey SSE Twitter Message Aggregator Example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/system-properties-example/dependencies.html" target="_top">
                                system-properties-example
                            </a>
                        </td><td align="left">Jersey system properties example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/xml-moxy/dependencies.html" target="_top">
                                xml-moxy
                            </a>
                        </td><td align="left">Jersey XML MOXy example.</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="dependencies-table-examples-webapp"></a><p class="title"><b>Table&nbsp;2.9.&nbsp;Jersey Examples - WebApps</b></p><div class="table-contents"><table summary="Jersey Examples - WebApps" width="100%" border="1"><colgroup><col width="22%" align="left" class="c1"><col width="78%" align="left" class="c3"></colgroup><thead><tr><th colspan="2" align="center">Examples - WAR</th></tr></thead><tbody><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/bean-validation-webapp/dependencies.html" target="_top">
                                bean-validation-webapp
                            </a>
                        </td><td align="left">Jersey Bean Validation (JSR-349) example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/bookmark/dependencies.html" target="_top">
                                bookmark
                            </a>
                        </td><td align="left">Jersey Bookmark example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/bookmark-em/dependencies.html" target="_top">
                                bookmark-em
                            </a>
                        </td><td align="left">Jersey Bookmark example using EntityManager.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/bookstore-webapp/dependencies.html" target="_top">
                                bookstore-webapp
                            </a>
                        </td><td align="left">Jersey MVC Bookstore example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/cdi-webapp/dependencies.html" target="_top">
                                cdi-webapp
                            </a>
                        </td><td align="left">Jersey CDI example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/extended-wadl-webapp/dependencies.html" target="_top">
                                extended-wadl-webapp
                            </a>
                        </td><td align="left">Extended WADL example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/freemarker-webapp/dependencies.html" target="_top">
                                freemarker-webapp
                            </a>
                        </td><td align="left">Jersey Freemarker example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/helloworld-webapp/dependencies.html" target="_top">
                                helloworld-webapp
                            </a>
                        </td><td align="left">Jersey annotated resource class "Hello world" example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/https-server-glassfish/dependencies.html" target="_top">
                                https-server-glassfish
                            </a>
                        </td><td align="left">Jersey HTTPS server on GlassFish example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/jersey-ejb/dependencies.html" target="_top">
                                jersey-ejb
                            </a>
                        </td><td align="left">Jersey EJB example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/json-processing-webapp/dependencies.html" target="_top">
                                json-processing-webapp
                            </a>
                        </td><td align="left">Jersey JSON-P (JSR 353) example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/managed-beans-webapp/dependencies.html" target="_top">
                                managed-beans-webapp
                            </a>
                        </td><td align="left">Jersey Managed Beans Web Application example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/managed-client-simple-webapp/dependencies.html" target="_top">
                                managed-client-simple-webapp
                            </a>
                        </td><td align="left">Jersey Managed Client Simple Webapp example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/managed-client-webapp/dependencies.html" target="_top">
                                managed-client-webapp
                            </a>
                        </td><td align="left">Jersey managed client web application example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/multipart-webapp/dependencies.html" target="_top">
                                multipart-webapp
                            </a>
                        </td><td align="left">Jersey Multipart example.</td></tr><tr><td align="left">
                            <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/webapp-example-parent/sse-item-store-webapp/dependencies.html" target="_top">
                                sse-item-store-webapp
                            </a>
                        </td><td align="left">Jersey SSE-based item store example.</td></tr></tbody></table></div></div><br class="table-break"></div></div><div lang="en" class="chapter" title="Chapter&nbsp;3.&nbsp;JAX-RS Application, Resources and Sub-Resources"><div class="titlepage"><div><div><h2 class="title"><a name="jaxrs-resources"></a>Chapter&nbsp;3.&nbsp;JAX-RS Application, Resources and Sub-Resources</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e1201">3.1. Root Resource Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1240">3.1.1. @Path</a></span></dt><dt><span class="section"><a href="#d0e1290">3.1.2. @GET, @PUT, @POST, @DELETE, ... (HTTP Methods)</a></span></dt><dt><span class="section"><a href="#d0e1328">3.1.3. @Produces</a></span></dt><dt><span class="section"><a href="#d0e1407">3.1.4. @Consumes</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1432">3.2. Parameter Annotations (@*Param)</a></span></dt><dt><span class="section"><a href="#d0e1703">3.3. Sub-resources</a></span></dt><dt><span class="section"><a href="#d0e1850">3.4. Life-cycle of Root Resource Classes</a></span></dt><dt><span class="section"><a href="#d0e1921">3.5. Rules of Injection</a></span></dt><dt><span class="section"><a href="#d0e2029">3.6. Use of @Context</a></span></dt><dt><span class="section"><a href="#d0e2057">3.7. Programmatic resource model</a></span></dt></dl></div><p>This chapter presents an overview of the core JAX-RS concepts - resources and sub-resources.</p><p>The JAX-RS 2.0 JavaDoc can be found online <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/index.html" target="_top">here</a>.
    </p><p>The JAX-RS 2.0 specification draft can be found online <a class="link" href="http://jcp.org/en/jsr/summary?id=339" target="_top">here</a>.
    </p><div class="section" title="3.1.&nbsp;Root Resource Classes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1201"></a>3.1.&nbsp;Root Resource Classes</h2></div></div></div><p>
            <span class="emphasis"><em>Root resource classes</em></span>
            are POJOs (Plain Old Java Objects) that are annotated with <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a>
            have at least one method annotated with <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> or a resource method designator annotation such as <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/GET.html" target="_top">@GET</a>,
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/PUT.html" target="_top">@PUT</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/POST.html" target="_top">@POST</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/DELETE.html" target="_top">@DELETE</a>. Resource methods are methods of a resource class annotated with a resource
            method designator. This section shows how to use Jersey to annotate Java objects to create RESTful web services.
        </p><p>The following code example is a very simple example of a root
            resource class using JAX-RS annotations. The example code shown here is
            from one of the samples that ships with Jersey, the zip file of which can
            be found in the maven repository
            <a class="link" href="https://maven.java.net/content/repositories/releases/org/glassfish/jersey/examples/helloworld/2.3/" target="_top">here</a>.
        </p><p>
            </p><div class="example"><a name="d0e1234"></a><p class="title"><b>Example&nbsp;3.1.&nbsp;Simple hello world root resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">package org.glassfish.jersey.examples.helloworld;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

@Path("helloworld")
public class HelloWorldResource {
    public static final String CLICHED_MESSAGE = "Hello World!";

@GET
@Produces("text/plain")
    public String getHello() {
        return CLICHED_MESSAGE;
    }
}</pre></div></div><p><br class="example-break">
            Let's look at some of the JAX-RS annotations used in this example.
        </p><div class="section" title="3.1.1.&nbsp;@Path"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1240"></a>3.1.1.&nbsp;@Path</h3></div></div></div><p>The <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> annotation's value is a relative URI path. In the example above, the Java class will be hosted at the URI path
                <code class="literal">/helloworld</code>. This is an extremely simple use of the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> annotation. What makes JAX-RS so useful is that you can embed variables in the URIs.
            </p><p>
                <span class="emphasis"><em>URI path templates</em></span>
                are URIs with variables embedded within the URI syntax. These variables are substituted at runtime in order for a resource to respond to a request based on the substituted URI. Variables are denoted by curly braces. For example, look at the following <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> annotation:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">@Path("/users/{username}")</pre><p>

                In this type of example, a user will be prompted to enter their name, and then a Jersey web service configured to respond to requests to this URI path template will respond. For example, if the user entered their username as "Galileo", the web service will respond to the following URL:
                <code class="literal">http://example.com/users/Galileo</code>
            </p><p>To obtain the value of the username variable the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/PathParam.html" target="_top">@PathParam</a> may be used on method parameter of a request method, for example:
                </p><div class="example"><a name="d0e1273"></a><p class="title"><b>Example&nbsp;3.2.&nbsp;Specifying URI path parameter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/users/{username}")
public class UserResource {

    @GET
    @Produces("text/xml")
    public String getUser(@PathParam("username") String userName) {
        ...
    }
}</pre></div></div><p><br class="example-break">
                If it is required that a user name must only consist of
                lower and upper case numeric characters then it is possible to declare a
                particular regular expression, which overrides the default regular
                expression, "[^/]+?", for example:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("users/{username: [a-zA-Z][a-zA-Z_0-9]*}")</pre><p>
                In this type of example the username variable will only match user names that begin with one upper or lower case letter and zero or more alpha numeric characters and the underscore character. If a user name does not match that a 404 (Not Found) response will occur.
            </p><p>A <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> value may or may not begin with a '/', it makes no difference. Likewise, by default, a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> value may or may not end in a '/', it makes no difference, and thus request URLs that end or do not end in a '/' will both
                be matched.
            </p></div><div class="section" title="3.1.2.&nbsp;@GET, @PUT, @POST, @DELETE, ... (HTTP Methods)"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1290"></a>3.1.2.&nbsp;@GET, @PUT, @POST, @DELETE, ... (HTTP Methods)</h3></div></div></div><p><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/GET.html" target="_top">@GET</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/PUT.html" target="_top">@PUT</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/POST.html" target="_top">@POST</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/DELETE.html" target="_top">@DELETE</a> and <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/HEAD.html" target="_top">@HEAD</a>
                are
                <span class="emphasis"><em>resource method designator</em></span>
                annotations defined
                by JAX-RS and which correspond to the similarly named HTTP methods. In
                the example above, the annotated Java method will process HTTP GET
                requests. The behavior of a resource is determined by which of the HTTP
                methods the resource is responding to.
            </p><p>The following example is an extract from the storage service
                sample that shows the use of the PUT method to create or update a
                storage container:
            </p><p>
                </p><div class="example"><a name="d0e1316"></a><p class="title"><b>Example&nbsp;3.3.&nbsp;PUT method</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@PUT
public Response putContainer() {
    System.out.println("PUT CONTAINER " + container);

    URI uri = uriInfo.getAbsolutePath();
    Container c = new Container(container, uri.toString());

    Response r;
    if (!MemoryStore.MS.hasContainer(c)) {
        r = Response.created(uri).build();
    } else {
        r = Response.noContent().build();
    }

    MemoryStore.MS.createContainer(c);
    return r;
}</pre></div></div><p><br class="example-break">
                By default the JAX-RS runtime will automatically support the methods HEAD and OPTIONS, if not explicitly
                implemented. For HEAD the runtime will invoke the implemented GET method (if present) and ignore the
                response entity (if set). A response returned for the OPTIONS method depends on the requested media type
                defined in the 'Accept' header. The OPTIONS method can return a response with a set of supported
                resource methods in the 'Allow' header or return
                a <a class="link" href="http://wadl.java.net/" target="_top">WADL</a> document.
                See <a class="link" href="#wadl" title="Chapter&nbsp;15.&nbsp;WADL Support">wadl section</a> for more information.
            </p></div><div class="section" title="3.1.3.&nbsp;@Produces"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1328"></a>3.1.3.&nbsp;@Produces</h3></div></div></div><p>
                The <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> annotation is used to specify the MIME media types of representations a resource can
                produce and send back to the client. In this example, the Java method will produce representations identified
                by the MIME media type "text/plain". <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> can be applied at both the class and method levels.
                Here's an example:
            </p><p>
                </p><div class="example"><a name="d0e1341"></a><p class="title"><b>Example&nbsp;3.4.&nbsp;Specifying output MIME type</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/myResource")
@Produces("text/plain")
public class SomeResource {
    @GET
    public String doGetAsPlainText() {
        ...
    }

    @GET
    @Produces("text/html")
    public String doGetAsHtml() {
        ...
    }
}</pre></div></div><p><br class="example-break">
                The
                <code class="literal">doGetAsPlainText</code>
                method defaults to the MIME type of the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> annotation at the class level. The
                <code class="literal">doGetAsHtml</code>
                method's <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> annotation overrides the class-level <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> setting, and specifies that the
                method can produce HTML rather than plain text.
            </p><p>If a resource class is capable of producing more that one MIME
                media type then the resource method chosen will correspond to the most
                acceptable media type as declared by the client. More specifically the
                Accept header of the HTTP request declares what is most acceptable. For
                example if the Accept header is "<code class="literal">Accept: text/plain</code>" then the
                <code class="literal">doGetAsPlainText</code>
                method will be invoked.
                Alternatively if the Accept header is "
                <code class="literal">Accept: text/plain;q=0.9, text/html</code>", which declares that the client can accept media types of
                "text/plain" and "text/html" but prefers the latter, then the
                <code class="literal">doGetAsHtml</code>
                method will be invoked.
            </p><p>More than one media type may be declared in the same <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> declaration, for example:
            </p><p>
                </p><div class="example"><a name="d0e1383"></a><p class="title"><b>Example&nbsp;3.5.&nbsp;Using multiple output MIME types</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces({"application/xml", "application/json"})
public String doGetAsXmlOrJson() {
    ...
}</pre></div></div><p><br class="example-break">
                The
                <code class="literal">doGetAsXmlOrJson</code>
                method will get
                invoked if either of the media types "application/xml" and
                "application/json" are acceptable. If both are equally acceptable then
                the former will be chosen because it occurs first.
            </p><p>Optionally, server can also specify the quality factor for individual media types. These are
                considered if several are equally acceptable by the client. For example:</p><p>
                </p><div class="example"><a name="d0e1396"></a><p class="title"><b>Example&nbsp;3.6.&nbsp;Server-side content negotiation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces({"application/xml; qs=0.9", "application/json"})
public String doGetAsXmlOrJson() {
    ...
}</pre></div></div><p><br class="example-break">
                In the above sample, if client accepts both "application/xml" and "application/json" (equally),
                then a server always sends "application/json", since "application/xml" has a lower quality factor.
            </p><p>The examples above refers explicitly to MIME media types for
                clarity. It is possible to refer to constant values, which may reduce
                typographical errors, see the constant field values of <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/MediaType.html" target="_top">MediaType</a>.
            </p></div><div class="section" title="3.1.4.&nbsp;@Consumes"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1407"></a>3.1.4.&nbsp;@Consumes</h3></div></div></div><p>The <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Consumes.html" target="_top">@Consumes</a> annotation is used to specify the MIME media types of representations
                that can be consumed by a resource. The above example can be modified to set the cliched
                message as follows:
            </p><p>
                </p><div class="example"><a name="d0e1417"></a><p class="title"><b>Example&nbsp;3.7.&nbsp;Specifying input MIME type</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes("text/plain")
public void postClichedMessage(String message) {
    // Store the message
}</pre></div></div><p><br class="example-break">
            </p><p>In this example, the Java method will consume representations
                identified by the MIME media type "text/plain". Notice that the resource
                method returns void. This means no representation is returned and
                response with a status code of 204 (No Content) will be returned to the client.
            </p><p><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Consumes.html" target="_top">@Consumes</a> can be applied at both the class and the method levels and more than one media type
                may be declared in the same <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Consumes.html" target="_top">@Consumes</a> declaration.
            </p></div></div><div class="section" title="3.2.&nbsp;Parameter Annotations (@*Param)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1432"></a>3.2.&nbsp;Parameter Annotations (@*Param)</h2></div></div></div><p>Parameters of a resource method may be annotated with parameter-based annotations to extract information
            from a request. One of the previous examples presented the use of <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/PathParam.html" target="_top">@PathParam</a> to extract a path
            parameter from the path component of the request URL that matched the path declared in <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a>.
        </p><p><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/QueryParam.html" target="_top">@QueryParam</a> is used to extract query parameters from the Query component of the request URL.
            The following example is an extract from the sparklines sample:
        </p><div class="example"><a name="d0e1447"></a><p class="title"><b>Example&nbsp;3.8.&nbsp;Query parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("smooth")
@GET
public Response smooth(
    @DefaultValue("2") @QueryParam("step") int step,
    @DefaultValue("true") @QueryParam("min-m") boolean hasMin,
    @DefaultValue("true") @QueryParam("max-m") boolean hasMax,
    @DefaultValue("true") @QueryParam("last-m") boolean hasLast,
    @DefaultValue("blue") @QueryParam("min-color") ColorParam minColor,
    @DefaultValue("green") @QueryParam("max-color") ColorParam maxColor,
    @DefaultValue("red") @QueryParam("last-color") ColorParam lastColor) {
    ...
}</pre></div></div><br class="example-break"><p>If a query parameter "step" exists in the query component of the
            request URI then the "step" value will be will extracted and parsed as a
            32 bit signed integer and assigned to the step method parameter. If "step"
            does not exist then a default value of 2, as declared in the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/DefaultValue.html" target="_top">@DefaultValue</a>
            annotation, will be assigned to the step method parameter. If the "step"
            value cannot be parsed as a 32 bit signed integer then a HTTP 404 (Not
            Found) response is returned. User defined Java types such as
            <code class="literal">ColorParam</code>
            may be used, which as implemented as
            follows:
        </p><div class="example"><a name="d0e1460"></a><p class="title"><b>Example&nbsp;3.9.&nbsp;Custom Java type for consuming request parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class ColorParam extends Color {

    public ColorParam(String s) {
        super(getRGB(s));
    }

    private static int getRGB(String s) {
        if (s.charAt(0) == '#') {
            try {
                Color c = Color.decode("0x" + s.substring(1));
                return c.getRGB();
            } catch (NumberFormatException e) {
                throw new WebApplicationException(400);
            }
        } else {
            try {
                Field f = Color.class.getField(s);
                return ((Color)f.get(null)).getRGB();
            } catch (Exception e) {
                throw new WebApplicationException(400);
            }
        }
    }
}</pre></div></div><br class="example-break"><p>In general the Java type of the method parameter may:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Be a primitive type;</p></li><li class="listitem"><p>Have a constructor that accepts a single
                    <code class="literal">String</code>
                    argument;
                </p></li><li class="listitem"><p>Have a static method named
                    <code class="literal">valueOf</code>
                    or
                    <code class="literal">fromString</code>
                    that accepts a single
                    <code class="literal">String</code>
                    argument (see, for example,
                    <code class="literal">Integer.valueOf(String)</code>
                    and <code class="literal">java.util.UUID.fromString(String)</code>);
                </p></li><li class="listitem"><p>Have a registered implementation of <code class="literal">javax.ws.rs.ext.ParamConverterProvider</code> JAX-RS
                    extension SPI that returns a <code class="literal">javax.ws.rs.ext.ParamConverter</code> instance capable of
                    a "from string" conversion for the type.
                     or
                </p></li><li class="listitem"><p>Be <code class="literal">List&lt;T&gt;</code>,
                    <code class="literal">Set&lt;T&gt;</code>
                    or
                    <code class="literal">SortedSet&lt;T&gt;</code>, where
                    <code class="literal">T</code>
                    satisfies 2 or 3 above. The resulting collection is read-only.
                </p></li></ol></div><p>Sometimes parameters may contain more than one value for the same
            name. If this is the case then types in 5) may be used to obtain all
            values.
        </p><p>If the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/DefaultValue.html" target="_top">@DefaultValue</a> is not used in conjunction with <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/QueryParam.html" target="_top">@QueryParam</a>
            and the query parameter is not present in the request then value will be
            an empty collection for<code class="literal">List</code>, <code class="literal">Set</code> or <code class="literal">SortedSet</code>,
            <code class="literal">null</code> for other object types, and the Java-defined default for primitive types.
        </p><p>The <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/PathParam.html" target="_top">@PathParam</a> and the other parameter-based annotations, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/MatrixParam.html" target="_top">@MatrixParam</a>,
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/HeaderParam.html" target="_top">@HeaderParam</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/CookieParam.html" target="_top">@CookieParam</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/FormParam.html" target="_top">@FormParam</a> obey the same rules as <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/QueryParam.html" target="_top">@QueryParam</a>.
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/MatrixParam.html" target="_top">@MatrixParam</a> extracts information from URL path segments. <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/HeaderParam.html" target="_top">@HeaderParam</a> extracts information
            from the HTTP headers. <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/CookieParam.html" target="_top">@CookieParam</a> extracts information from the cookies declared in cookie related HTTP
            headers.
        </p><p><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/FormParam.html" target="_top">@FormParam</a> is slightly special because it extracts information from a request representation that
            is of the MIME media type
            <code class="literal">"application/x-www-form-urlencoded"</code>
            and conforms to the encoding
            specified by HTML forms, as described here. This parameter is very useful for extracting information that is
            POSTed by HTML forms, for example the following extracts the form parameter named "name" from the POSTed form
            data:
        </p><p>
            </p><div class="example"><a name="d0e1579"></a><p class="title"><b>Example&nbsp;3.10.&nbsp;Processing POSTed HTML form</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes("application/x-www-form-urlencoded")
public void post(@FormParam("name") String name) {
    // Store the message
}</pre></div></div><p><br class="example-break">
        </p><p>If it is necessary to obtain a general map of parameter name to
            values then, for query and path parameters it is possible to do the
            following:
        </p><p>
            </p><div class="example"><a name="d0e1589"></a><p class="title"><b>Example&nbsp;3.11.&nbsp;Obtaining general map of URI path and/or query parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public String get(@Context UriInfo ui) {
    MultivaluedMap&lt;String, String&gt; queryParams = ui.getQueryParameters();
    MultivaluedMap&lt;String, String&gt; pathParams = ui.getPathParameters();
}</pre></div></div><p><br class="example-break">
        </p><p>For header and cookie parameters the following:</p><p>
            </p><div class="example"><a name="d0e1599"></a><p class="title"><b>Example&nbsp;3.12.&nbsp;Obtaining general map of header parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public String get(@Context HttpHeaders hh) {
    MultivaluedMap&lt;String, String&gt; headerParams = hh.getRequestHeaders();
    Map&lt;String, Cookie&gt; pathParams = hh.getCookies();
}</pre></div></div><p><br class="example-break">
        </p><p>In general <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Context.html" target="_top">@Context</a> can be used to obtain contextual Java types related to the request or response.
        </p><p>Because form parameters (unlike others) are part of the message entity, it is possible to do the following:</p><p>
            </p><div class="example"><a name="d0e1614"></a><p class="title"><b>Example&nbsp;3.13.&nbsp;Obtaining general map of form parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes("application/x-www-form-urlencoded")
public void post(MultivaluedMap&lt;String, String&gt; formParams) {
    // Store the message
}</pre></div></div><p><br class="example-break">

            I.e. you don't need to use the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Context.html" target="_top">@Context</a> annotation.
        </p><p>Another kind of injection is the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/BeanParam.html" target="_top">@BeanParam</a> which allows to inject the parameters described above into a
            single bean. A bean annotated with <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/BeanParam.html" target="_top">@BeanParam</a> containing any fields and appropriate
            <code class="literal">*param</code>
            annotation(like <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/PathParam.html" target="_top">@PathParam</a>) will be initialized with corresponding request values in expected way as if these
            fields were in the resource class. Then instead of injecting request values like path param into a constructor parameters
            or class fields the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/BeanParam.html" target="_top">@BeanParam</a> can be used to inject such a bean into a resource or resource method. The
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/BeanParam.html" target="_top">@BeanParam</a> is used this way to aggregate more request parameters into a single bean.
        </p><div class="example"><a name="d0e1643"></a><p class="title"><b>Example&nbsp;3.14.&nbsp;Example of the bean which will be used as <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/BeanParam.html" target="_top">@BeanParam</a>
            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyBeanParam {
    @PathParam("p")
    private String pathParam;

    @MatrixParam("m")
    @Encoded
    @DefaultValue("default")
    private String matrixParam;

    @HeaderParam("header")
    private String headerParam;

    private String queryParam;

    public MyBeanParam(@QueryParam("q") String queryParam) {
        this.queryParam = queryParam;
    }

    public String getPathParam() {
        return pathParam;
    }
    ...
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e1651"></a><p class="title"><b>Example&nbsp;3.15.&nbsp;Injection of MyBeanParam as a method parameter:</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
public void post(@BeanParam MyBeanParam beanParam, String entity) {
    final String pathParam = beanParam.getPathParam(); // contains injected path parameter "p"
    ...
}</pre></div></div><br class="example-break"><p>The example shows aggregation of injections <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/PathParam.html" target="_top">@PathParam</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/QueryParam.html" target="_top">@QueryParam</a> <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/MatrixParam.html" target="_top">@MatrixParam</a>
            and <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/HeaderParam.html" target="_top">@HeaderParam</a> into one single bean. The rules for injections inside the bean are the same as described above
            for these injections. The <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/DefaultValue.html" target="_top">@DefaultValue</a> is used to define the default value for matrix parameter matrixParam.
            Also the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Encoded.html" target="_top">@Encoded</a> annotation has the same behaviour as if it were used for injection in the resource method
            directly. Injecting the bean parameter into @Singleton resource class fields is not allowed (injections into method
            parameter must be used instead).
        </p><p><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/BeanParam.html" target="_top">@BeanParam</a> can contain all parameters injections injections
            (<a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/PathParam.html" target="_top">@PathParam</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/QueryParam.html" target="_top">@QueryParam</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/MatrixParam.html" target="_top">@MatrixParam</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/HeaderParam.html" target="_top">@HeaderParam</a>,
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/CookieParam.html" target="_top">@CookieParam</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/FormParam.html" target="_top">@FormParam</a>). More
            beans can be injected into one resource or method parameters even if they inject the same request values. For example
            the following is possible:
        </p><div class="example"><a name="d0e1698"></a><p class="title"><b>Example&nbsp;3.16.&nbsp;Injection of more beans into one resource methods:</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
public void post(@BeanParam MyBeanParam beanParam, @BeanParam AnotherBean anotherBean, @PathParam("p") pathParam,
String entity) {
    // beanParam.getPathParam() == pathParam
    ...
}</pre></div></div><br class="example-break"></div><div class="section" title="3.3.&nbsp;Sub-resources"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1703"></a>3.3.&nbsp;Sub-resources</h2></div></div></div><p><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> may be used on classes and such classes are referred to as root resource classes. <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a>
            may also be used on methods of root resource classes. This enables common functionality for a number of resources
            to be grouped together and potentially reused.
        </p><p>The first way <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> may be used is on resource methods and such methods are referred to as
            <span class="emphasis"><em>sub-resource methods</em></span>. The following example shows the method signatures for a root
            resource class from the jmaki-backend sample:
        </p><p>
            </p><div class="example"><a name="d0e1723"></a><p class="title"><b>Example&nbsp;3.17.&nbsp;Sub-resource methods</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Singleton
@Path("/printers")
public class PrintersResource {

    @GET
    @Produces({"application/json", "application/xml"})
    public WebResourceList getMyResources() { ... }

    @GET @Path("/list")
    @Produces({"application/json", "application/xml"})
    public WebResourceList getListOfPrinters() { ... }

    @GET @Path("/jMakiTable")
    @Produces("application/json")
    public PrinterTableModel getTable() { ... }

    @GET @Path("/jMakiTree")
    @Produces("application/json")
    public TreeModel getTree() { ... }

    @GET @Path("/ids/{printerid}")
    @Produces({"application/json", "application/xml"})
    public Printer getPrinter(@PathParam("printerid") String printerId) { ... }

    @PUT @Path("/ids/{printerid}")
    @Consumes({"application/json", "application/xml"})
    public void putPrinter(@PathParam("printerid") String printerId, Printer printer) { ... }

    @DELETE @Path("/ids/{printerid}")
    public void deletePrinter(@PathParam("printerid") String printerId) { ... }
}</pre></div></div><p><br class="example-break">
        </p><p>If the path of the request URL is "printers" then the resource methods not annotated with <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a>
            will be selected. If the request path of the request URL is "printers/list" then first the root resource class
            will be matched and then the sub-resource methods that match "list" will be selected, which in this case
            is the sub-resource method<code class="literal">getListOfPrinters</code>. So, in this example hierarchical matching
            on the path of the request URL is performed.
        </p><p>The second way <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> may be used is on methods
            <span class="bold"><strong>not</strong></span>
            annotated
            with resource method designators such as <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/GET.html" target="_top">@GET</a> or <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/POST.html" target="_top">@POST</a>. Such methods are referred to as
            <span class="emphasis"><em>sub-resource locators</em></span>. The following example shows the method signatures for
            a root resource class and a resource class from the optimistic-concurrency sample:
        </p><p>
            </p><div class="example"><a name="d0e1756"></a><p class="title"><b>Example&nbsp;3.18.&nbsp;Sub-resource locators</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/item")
public class ItemResource {
    @Context UriInfo uriInfo;

    @Path("content")
    public ItemContentResource getItemContentResource() {
        return new ItemContentResource();
    }

    @GET
    @Produces("application/xml")
        public Item get() { ... }
    }
}

public class ItemContentResource {

    @GET
    public Response get() { ... }

    @PUT
    @Path("{version}")
    public void put(@PathParam("version") int version,
                    @Context HttpHeaders headers,
                    byte[] in) {
        ...
    }
}</pre></div></div><p><br class="example-break">
        </p><p>The root resource class
            <code class="literal">ItemResource</code>
            contains the
            sub-resource locator method
            <code class="literal">getItemContentResource</code>
            that
            returns a new resource class. If the path of the request URL is
            "item/content" then first of all the root resource will be matched, then
            the sub-resource locator will be matched and invoked, which returns an
            instance of the
            <code class="literal">ItemContentResource</code>
            resource class.
            Sub-resource locators enable reuse of resource classes. A method can be annotated with the
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> annotation with empty path (<code class="literal">@Path("/")</code> or <code class="literal">@Path("")</code>) which
            means that the sub resource locator is matched for the path of the enclosing resource (without sub-resource path).
        </p><p>
            </p><div class="example"><a name="d0e1784"></a><p class="title"><b>Example&nbsp;3.19.&nbsp;Sub-resource locators with empty path</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/item")
public class ItemResource {

    @Path("/")
    public ItemContentResource getItemContentResource() {
        return new ItemContentResource();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>In the example above the sub-resource locator method <code class="literal">getItemContentResource</code>
            is matched for example for request path "/item/locator" or even for only "/item".
        </p><p>In addition the processing of resource classes returned by
            sub-resource locators is performed at runtime thus it is possible to
            support polymorphism. A sub-resource locator may return different
            sub-types depending on the request (for example a sub-resource locator
            could return different sub-types dependent on the role of the principle
            that is authenticated). So for example the following sub resource locator is valid:
        </p><p>
            </p><div class="example"><a name="d0e1799"></a><p class="title"><b>Example&nbsp;3.20.&nbsp;Sub-resource locators returning sub-type</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/item")
public class ItemResource {

    @Path("/")
    public Object getItemContentResource() {
        return new AnyResource();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>Note that the runtime will not manage the life-cycle or perform any
            field injection onto instances returned from sub-resource locator methods.
            This is because the runtime does not know what the life-cycle of the
            instance is. If it is required that the runtime manages the sub-resources
            as standard resources the <code class="literal">Class</code> should be returned
            as shown in the following example:
        </p><p>
            </p><div class="example"><a name="d0e1812"></a><p class="title"><b>Example&nbsp;3.21.&nbsp;Sub-resource locators created from classes</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import javax.inject.Singleton;

@Path("/item")
public class ItemResource {
    @Path("content")
    public Class&lt;ItemContentSingletonResource&gt; getItemContentResource() {
        return ItemContentSingletonResource.class;
    }
}

@Singleton
public class ItemContentSingletonResource {
    // this class is managed in the singleton life cycle
}</pre></div></div><p><br class="example-break">
        </p><p>JAX-RS resources are managed in per-request scope by default which means that
            new resource is created for each request.
            In this example the <code class="literal">javax.inject.Singleton</code> annotation says
            that the resource will be managed as singleton and not in request scope.
            The sub-resource locator method returns a class which means that the runtime
            will managed the resource instance and its life-cycle. If the method would return instance instead,
            the <code class="literal">Singleton</code> annotation would have no effect and the returned instance
            would be used.
        </p><p>The sub resource locator can also return a <span class="emphasis"><em>programmatic resource model</em></span>. See <a class="link" href="#resource-builder" title="Chapter&nbsp;12.&nbsp;Programmatic API for Building Resources">resource builder section</a> for information of how the programmatic resource
            model is constructed. The following example shows very simple resource returned from the sub-resource locator method.
        </p><p>
            </p><div class="example"><a name="d0e1836"></a><p class="title"><b>Example&nbsp;3.22.&nbsp;Sub-resource locators returning resource model</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import org.glassfish.jersey.server.model.Resource;

@Path("/item")
public class ItemResource {

    @Path("content")
    public Resource getItemContentResource() {
        return Resource.from(ItemContentSingletonResource.class);
    }
}</pre></div></div><p><br class="example-break">
        </p><p>The code above has exactly the same effect as previous example. <code class="literal">Resource</code> is a resource
            simple resource constructed from <code class="literal">ItemContentSingletonResource</code>. More complex programmatic
            resource can be returned as long they are valid resources.
        </p></div><div class="section" title="3.4.&nbsp;Life-cycle of Root Resource Classes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1850"></a>3.4.&nbsp;Life-cycle of Root Resource Classes</h2></div></div></div><p>By default the life-cycle of root resource classes is per-request which,
            namely that a new instance of a root resource class is created every time
            the request URI path matches the root resource. This makes for a very
            natural programming model where constructors and fields can be utilized
            (as in the previous section showing the constructor of the
            <code class="literal">SparklinesResource</code>
            class) without concern for multiple
            concurrent requests to the same resource.
        </p><p>In general this is unlikely to be a cause of performance issues.
            Class construction and garbage collection of JVMs has vastly improved over
            the years and many objects will be created and discarded to serve and
            process the HTTP request and return the HTTP response.
        </p><p>Instances of singleton root resource classes can be declared by an instance of <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a>.
        </p><p>Jersey supports two further life-cycles using Jersey specific annotations.</p><div class="table"><a name="d0e1867"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Resource scopes</b></p><div class="table-contents"><table summary="Resource scopes" border="1"><colgroup><col width="11%"><col width="11%"><col width="22%"><col width="56%"></colgroup><thead><tr><th>Scope</th><th>Annotation</th><th>Annotation full class name</th><th>Description</th></tr></thead><tbody><tr><td>Request scope</td><td>@RequestScoped (or none)</td><td>org.glassfish.jersey.process.internal.RequestScoped</td><td><span class="emphasis"><em>Default lifecycle </em></span> (applied when no annotation is present). In this scope
                            the resource instance is created for each new request and used for processing of this request. If the
                            resource is used more than one time in the request processing, always the same instance will be used.
                            This can happen when a resource is a sub resource is returned more times during the matching. In this
                            situation only on instance will server the requests.</td></tr><tr><td>Per-lookup scope</td><td>@PerLookup</td><td>org.glassfish.jersey.process.internal.RequestScoped</td><td>In this scope
                            the resource instance is created every time it is needed for the processing even it handles
                            the same request.</td></tr><tr><td>Singleton</td><td>@Singleton</td><td>javax.inject.Singleton</td><td>In this scope there is only one instance per jax-rs application. Singleton resource can be either
                            annotated with @Singleton and its class can be registered using the instance of
                            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a>. You can also create singletons by registering singleton instances
                            into <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="3.5.&nbsp;Rules of Injection"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1921"></a>3.5.&nbsp;Rules of Injection</h2></div></div></div><p>Previous sections have presented examples of annotated types, mostly
            annotated method parameters but also annotated fields of a class, for the
            injection of values onto those types.
        </p><p>This section presents the rules of injection of values on annotated
            types. Injection can be performed on fields, constructor parameters,
            resource/sub-resource/sub-resource locator method parameters and bean
            setter methods. The following presents an example of all such injection
            cases:
        </p><p>
            </p><div class="example"><a name="d0e1930"></a><p class="title"><b>Example&nbsp;3.23.&nbsp;Injection</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("id: \d+")
public class InjectedResource {
    // Injection onto field
    @DefaultValue("q") @QueryParam("p")
    private String p;

    // Injection onto constructor parameter
    public InjectedResource(@PathParam("id") int id) { ... }

    // Injection onto resource method parameter
    @GET
    public String get(@Context UriInfo ui) { ... }

    // Injection onto sub-resource resource method parameter
    @Path("sub-id")
    @GET
    public String get(@PathParam("sub-id") String id) { ... }

    // Injection onto sub-resource locator method parameter
    @Path("sub-id")
    public SubResource getSubResource(@PathParam("sub-id") String id) { ... }

    // Injection using bean setter method
    @HeaderParam("X-header")
    public void setHeader(String header) { ... }
}</pre></div></div><p><br class="example-break">
        </p><p>There are some restrictions when injecting on to resource classes
            with a life-cycle of singleton scope. In such cases the class fields or
            constructor parameters cannot be injected with request specific parameters. So, for example
            the following is not allowed.</p><p>
            </p><div class="example"><a name="d0e1940"></a><p class="title"><b>Example&nbsp;3.24.&nbsp;Wrong injection into a singleton scope</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
@Singleton
public static class MySingletonResource {

    @QueryParam("query")
    String param; // WRONG: initialization of application will fail as you cannot
                  // inject request specific parameters into a singleton resource.

    @GET
    public String get() {
        return "query param: " + param;
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The example above will cause validation failure during application initialization as singleton
            resources cannot inject request specific parameters. The same example would fail if the query
            parameter would be injected into constructor parameter of such a singleton. In other words, if you
            wish one resource instance to server more requests (in the same time) it cannot be bound
            to a specific request parameter.
        </p><p>
            The exception exists for specific request objects which can injected even into
            constructor or class fields. For these objects the runtime will inject proxies
            which are able to simultaneously server more request. These request objects are
            <code class="literal">HttpHeaders</code>, <code class="literal">Request</code>, <code class="literal">UriInfo</code>,
            <code class="literal">SecurityContext</code>. These proxies can be injected using the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Context.html" target="_top">@Context</a>
            annotation. The following example shows injection of proxies into the singleton resource class.
        </p><p>
            </p><div class="example"><a name="d0e1967"></a><p class="title"><b>Example&nbsp;3.25.&nbsp;Injection of proxies into singleton</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
@Singleton
public static class MySingletonResource {
    @Context
    Request request; // this is ok: the proxy of Request will be injected into this singleton

    public MySingletonResource(@Context SecurityContext securityContext) {
        // this is ok too: the proxy of SecurityContext will be injected
    }

    @GET
    public String get() {
        return "query param: " + param;
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            To summarize the injection can be done into the following constructs:
        </p><div class="table"><a name="d0e1975"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Overview of injection types</b></p><div class="table-contents"><table summary="Overview of injection types" border="1"><colgroup><col width="16%"><col width="84%"></colgroup><thead><tr><th>Java construct</th><th>Description</th></tr></thead><tbody><tr><td>Class fields</td><td>
                            Inject value directly into the field of the class. The field can be private
                            and must not be final. Cannot be used in Singleton scope except proxiable types mentioned above.
                        </td></tr><tr><td>Constructor parameters</td><td>
                            The constructor will be invoked with injected values. If more
                            constructors exists the one with the most injectable parameters will be invoked.
                            Cannot be used in Singleton scope except proxiable types mentioned above.
                        </td></tr><tr><td>Resource methods</td><td>
                            The resource methods (these annotated with @GET, @POST, ...) can contain
                            parameters that can be injected when the resource method is executed.
                            Can be used in any scope.
                        </td></tr><tr><td>Sub resource locators</td><td>
                            The sub resource locators (methods annotated with @Path but not @GET, @POST, ...)
                            can contain parameters that can be injected when the resource method is executed.
                            Can be used in any scope.
                        </td></tr><tr><td>Setter methods</td><td>
                            Instead of injecting values directly into field the value can be injected into the
                            setter method which will initialize the field. This injection can be used only with <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Context.html" target="_top">@Context</a>
                            annotation. This means
                            it cannot be used for example for injecting of query params but it can be used for injections of
                            request. The setters will be called after the object creation and
                            only once. The name of the method does not necessary have a setter pattern. Cannot be used
                            in Singleton scope except proxiable types mentioned above.
                        </td></tr></tbody></table></div></div><br class="table-break"><p>
            The following example shows all possible java constructs into which the values can be injected.

            </p><div class="example"><a name="d0e2018"></a><p class="title"><b>Example&nbsp;3.26.&nbsp;Example of possible injections</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public static class SummaryOfInjectionsResource {
    @QueryParam("query")
    String param; // injection into a class field


    @GET
    public String get(@QueryParam("query") String methodQueryParam) {
        // injection into a resource method parameter
        return "query param: " + param;
    }

    @Path("sub-resource-locator")
    public Class&lt;SubResource&gt; subResourceLocator(@QueryParam("query") String subResourceQueryParam) {
        // injection into a sub resource locator parameter
        return SubResource.class;
    }

    public SummaryOfInjectionsResource(@QueryParam("query") String constructorQueryParam) {
        // injection into a constructor parameter
    }


    @Context
    public void setRequest(Request request) {
        // injection into a setter method
        System.out.println(request != null);
    }
}

public static class SubResource {
    @GET
    public String get() {
        return "sub resource";
    }
}</pre></div></div><p><br class="example-break">
        </p><p>The <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/FormParam.html" target="_top">@FormParam</a> annotation is special and may only be utilized on resource and sub-resource methods.
            This is because it extracts information from a request entity.
        </p></div><div class="section" title="3.6.&nbsp;Use of @Context"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2029"></a>3.6.&nbsp;Use of @Context</h2></div></div></div><p>Previous sections have introduced the use of <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Context.html" target="_top">@Context</a>. Chapter 5
            of the JAX-RS specification presents all the standard JAX-RS Java types that may be used with <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Context.html" target="_top">@Context</a>.
        </p><p>When deploying a JAX-RS application using servlet then
            <a class="link" href="http://docs.oracle.com/javaee/5/api/javax/servlet/ServletConfig.html" target="_top">ServletConfig</a>,
            <a class="link" href="http://docs.oracle.com/javaee/5/api/javax/servlet/ServletContext.html" target="_top">ServletContext</a>,
            <a class="link" href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServletRequest.html" target="_top">HttpServletRequest</a>
            and
            <a class="link" href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServletResponse.html" target="_top">HttpServletResponse</a>
            are available using <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Context.html" target="_top">@Context</a>.
        </p></div><div class="section" title="3.7.&nbsp;Programmatic resource model"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2057"></a>3.7.&nbsp;Programmatic resource model</h2></div></div></div><p>Resources can be constructed from classes or instances but also can be constructed from a programmatic resource
            model. Every resource created from from resource classes can also
            be constructed using the programmatic resource builder api. See <a class="link" href="#resource-builder" title="Chapter&nbsp;12.&nbsp;Programmatic API for Building Resources">resource builder section</a> for more information.
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;4.&nbsp;Deploying a RESTful Web Service"><div class="titlepage"><div><div><h2 class="title"><a name="deployment"></a>Chapter&nbsp;4.&nbsp;Deploying a RESTful Web Service</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#deployment.autodiscoverable">4.1. Auto-Discoverable Features</a></span></dt><dd><dl><dt><span class="section"><a href="#deployment.autodiscovery.config">4.1.1. Configuring the Feature Auto-discovery mechanism</a></span></dt></dl></dd><dt><span class="section"><a href="#deployment.classpath-scanning">4.2. Turn off classpath scanning</a></span></dt></dl></div><p>
        JAX-RS provides a deployment agnostic abstract class <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a>
        for declaring root resource and provider classes, and root resource and provider singleton instances.
        A Web service may extend this class to declare root resource and provider classes. For
        example,
    </p><p>
        </p><div class="example"><a name="d0e2076"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Deployment agnostic application model</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyApplication extends Application {
    @Override
    public Set&lt;Class&lt;?&gt;&gt; getClasses() {
        Set&lt;Class&lt;?&gt;&gt; s = new HashSet&lt;Class&lt;?&gt;&gt;();
        s.add(HelloWorldResource.class);
        return s;
    }
}</pre></div></div><p><br class="example-break">
        Alternatively it is possible to reuse one of Jersey's
        implementations that scans for root resource and provider classes given a classpath or
        a set of package names. Such classes are automatically added to the set of
        classes that are returned by<code class="literal">getClasses</code>. For example,
        the following scans for root resource and provider classes in packages "org.foo.rest",
        "org.bar.rest" and in any sub-packages of those two:
    </p><p>
        </p><div class="example"><a name="d0e2087"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Reusing Jersey implementation in your custom application model</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyApplication extends ResourceConfig {
    public MyApplication() {
        packages("org.foo.rest;org.bar.rest");
    }
}</pre></div></div><p><br class="example-break">
    </p><p>There are multiple deployment options for the class that implements <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a>
        interface in the Servlet 3.0 container. For simple deployments, no
        <code class="literal">web.xml</code>
        is needed at all. Instead, an <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ApplicationPath.html" target="_top">@ApplicationPath</a> annotation can be used to annotate the
        user defined application class and specify the base resource URI of all application resources:
    </p><p>
        </p><div class="example"><a name="d0e2106"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Deployment of a JAX-RS application using
                <code class="literal">@ApplicationPath</code>
                with Servlet 3.0
            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@ApplicationPath("resources")
public class MyApplication extends ResourceConfig {
    public MyApplication() {
        packages("org.foo.rest;org.bar.rest");
    }
    ...
}</pre></div></div><p><br class="example-break">

        Please note that there is more which can be set or called during execution of ResourceConfig descendants
        constructor, see <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> javadoc for more details.
    </p><p>
        You also need to set maven-war-plugin attribute
        <a class="link" href="http://maven.apache.org/plugins/maven-war-plugin/war-mojo.html#failOnMissingWebXml" target="_top">failOnMissingWebXml</a>
        to false in pom.xml when building .war without web.xml file using maven:
    </p><p>
        </p><div class="example"><a name="d0e2125"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Configuration of maven-war-plugin in
                <code class="literal">pom.xml</code>
                with Servlet 3.0
            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;plugins&gt;
    ...
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.3&lt;/version&gt;
        &lt;configuration&gt;
            &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
    ...
&lt;/plugins&gt;</pre></div></div><p><br class="example-break">
    </p><p>Another deployment option is to declare JAX-RS application details in the <code class="literal">web.xml</code>.
        This is usually suitable in case of more complex deployments, e.g. when security model needs to be properly defined
        or when additional initialization parameters have to be passed to Jersey runtime.
        JAX-RS 1.1 specifies that a fully qualified name of the class that
        implements <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a>
        may be declared in the
        <code class="literal">&lt;servlet-name&gt;</code>
        element of the JAX-RS application's
        <code class="literal">web.xml</code>. This is supported in a Web container implementing Servlet 3.0 as follows:
    </p><p>
        </p><div class="example"><a name="d0e2150"></a><p class="title"><b>Example&nbsp;4.5.&nbsp;Deployment of a JAX-RS application using
                <code class="literal">web.xml</code>
                with Servlet 3.0
            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;org.foo.rest.MyApplication&lt;/servlet-name&gt;
    &lt;/servlet&gt;
    ...
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;org.foo.rest.MyApplication&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/resources&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</pre></div></div><p><br class="example-break">
    </p><p>Note that the
        <code class="literal">&lt;servlet-class&gt;</code>
        element is omitted from the servlet declaration.
        This is a correct declaration utilizing the Servlet 3.0 extension mechanism. Also note that
        <code class="literal">&lt;servlet-mapping&gt;</code>
        is used to define the base resource URI.
    </p><p>When running in a Servlet 2.x then instead it is necessary to declare the Jersey
        specific servlet and pass the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a> implementation class name as
        one of the servlet's
        <code class="literal">init-param</code>
        entries:
        </p><div class="example"><a name="d0e2175"></a><p class="title"><b>Example&nbsp;4.6.&nbsp;Deployment of your application using Jersey specific servlet</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;Jersey Web Application&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
            &lt;param-value&gt;org.foo.rest.MyApplication&lt;/param-value&gt;
        &lt;/init-param&gt;
        ...
    &lt;/servlet&gt;
    ...
&lt;/web-app&gt;</pre></div></div><p><br class="example-break">
    </p><p>If there is no configuration to be set and deployed application consists only from resources and providers
        stored in particular packages, Jersey can scan them and register automatically:

        </p><div class="example"><a name="d0e2183"></a><p class="title"><b>Example&nbsp;4.7.&nbsp;Using Jersey specific servlet without an application model instance</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;web-app&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;Jersey Web Application&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;jersey.config.server.provider.packages&lt;/param-name&gt;
            &lt;param-value&gt;org.foo.rest;org.bar.rest&lt;/param-value&gt;
        &lt;/init-param&gt;
        ...
    &lt;/servlet&gt;
    ...
&lt;/web-app&gt;</pre></div></div><p><br class="example-break">
    </p><p>JAX-RS also provides the ability to obtain a container specific artifact
        from an <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a> instance. For example, Jersey supports using
        <a class="link" href="http://grizzly.java.net/" target="_top">Grizzly</a>
        as follows:
        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">HttpHandler endpoint = RuntimeDelegate.getInstance().createEndpoint(new MyApplication(), HttpHandler.class);</pre><p>
        Jersey also provides
        <a class="link" href="http://grizzly.java.net/" target="_top">Grizzly</a>
        helper classes to deploy the HttpHandler instance at a base URL for
        in-process deployment.
    </p><p>The Jersey samples provide many examples of Servlet-based and
        Grizzly-in-process-based deployments.
    </p><div class="section" title="4.1.&nbsp;Auto-Discoverable Features"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.autodiscoverable"></a>4.1.&nbsp;Auto-Discoverable Features</h2></div></div></div><p>
            For a few modules provided by Jersey there is no need to explicitly register their <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Feature.html" target="_top">Feature</a>s as these
            <code class="literal">Feature</code>s are discovered and registered in the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configuration.html" target="_top">Configuration</a> (on client/server)
            automatically by Jersey when the modules implementing these features are present on the classpath during the
            an application deployment. The modules that are automatically discovered include:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">jersey-media-moxy</code> (JSON part)</p></li><li class="listitem"><p><code class="literal">jersey-media-json-processing</code></p></li><li class="listitem"><p><code class="literal">jersey-bean-validation</code></p></li></ul></div><p>
        </p><p>
            Besides these modules there are also few features/providers present in <code class="literal">jersey-server</code> module that
            are discovered by this mechanism and their availability is affected by Jersey auto-discovery support configuration
            (see <a class="xref" href="#deployment.autodiscovery.config" title="4.1.1.&nbsp;Configuring the Feature Auto-discovery mechanism">Section&nbsp;4.1.1, &#8220;Configuring the Feature Auto-discovery mechanism&#8221;</a>):

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/wadl/WadlFeature.html" target="_top">WadlFeature</a> - enables WADL processing.</p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/filter/UriConnegFilter.html" target="_top">UriConnegFilter</a> - a URI-based content negotiation filter.</p></li></ul></div><p>
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Auto discovery functionality is in Jersey supported by implementing an internal SPI
                <code class="literal">AutoDiscoverable</code> interface. This interface is not public at the moment,
                so be careful when using it.
            </p></div><div class="section" title="4.1.1.&nbsp;Configuring the Feature Auto-discovery mechanism"><div class="titlepage"><div><div><h3 class="title"><a name="deployment.autodiscovery.config"></a>4.1.1.&nbsp;Configuring the Feature Auto-discovery mechanism</h3></div></div></div><p>
                The auto-discovery of features in Jersey that is enabled by default can be disabled by using special
                (common/server/client) properties:

                </p><div class="itemizedlist" title="Common auto discovery properties"><p class="title"><b>Common auto discovery properties</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></p><p>Disables auto discovery globally on client/server.</p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">CommonProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p><p>Disables configuration of Json Processing (JSR-353) feature.</p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">CommonProperties.MOXY_JSON_FEATURE_DISABLE</a></p><p>Disables configuration of MOXy Json feature.</p></li></ul></div><p>

                For each of these properties there is a client/server counter-part that only disables the feature on the
                client or server respectively (see <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html" target="_top">ClientProperties</a>/<a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html" target="_top">ServerProperties</a>).
                Each of these client/server specific auto-discovery related properties overrides the value of the related common
                property (if set).
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    In case an auto-discoverable feature is disabled then all the featured, components and/or properties,
                    registered with the feature by default using the auto-discovery mechanism have to be registered manually.
                </p></div></div></div><div class="section" title="4.2.&nbsp;Turn off classpath scanning"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="deployment.classpath-scanning"></a>4.2.&nbsp;Turn off classpath scanning</h2></div></div></div><p>
            Jersey uses common Service Loader or Lookup design pattern to obtain all service implementations. It means it lookups
            whole class path to find appropriate files in <code class="literal">META-INF/services/</code>. The class path lookup may be time
            consuming. The more jar or war files on class path the lookup is longer. If you count any ms of application bootstrap
            you can generally disable services lookup.
        </p><p>
            </p><div class="itemizedlist" title="Jersey is looking for implementation of following SPIs"><p class="title"><b>Jersey is looking for implementation of following SPIs</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">AutoDiscoverable</code> (server, client) -
                    it means if you disable service loading the AutoDiscoverable feature is automatically disabled too</p></li><li class="listitem"><p><code class="literal">MessageBodyReader</code> (server, client)</p></li><li class="listitem"><p><code class="literal">MessageBodyWriter</code> (server, client)</p></li><li class="listitem"><p><code class="literal">HeaderDelegateProvider</code> (server, client)</p></li><li class="listitem"><p><code class="literal">ComponentProvider</code> (server)</p></li><li class="listitem"><p><code class="literal">ContainerProvider</code> (server)</p></li><li class="listitem"><p><code class="literal">AsyncContextDelegateProvider</code> (server/servlet)</p></li></ul></div><p>
        </p><p>
            In all cases it is possible to register an SPI implementation class or instance programmatically. Therefore you can
            disable services lookup in Jersey and save dozens of ms during application initialization. The services lookup in
            Jersey that is enabled by default can be disabled by using special property
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">CommonProperties.METAINF_SERVICES_LOOKUP_DISABLE</a>.
            There is a client/server counter-part that only disables the feature on the client or server respectively:
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">ClientProperties.METAINF_SERVICES_LOOKUP_DISABLE</a>/<a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">ServerProperties.METAINF_SERVICES_LOOKUP_DISABLE</a>.
            The client/server specific property overrides the value of the related common property (if set).
        </p><p>
            For example, following code snippet registers different types of implementations: <code class="literal">ContainerRequestFilter</code>,
            <code class="literal">Feature</code>, <code class="literal">ComponentProvider</code> and <code class="literal">ContainerProvider</code>:
            </p><div class="example"><a name="d0e2369"></a><p class="title"><b>Example&nbsp;4.8.&nbsp;Registering SPI implementations using ResourceConfig</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final ResourceConfig resourceConfig = new ResourceConfig(MyResource.class);
resourceConfig.register(org.glassfish.jersey.server.filter.UriConnegFilter.class);
resourceConfig.register(org.glassfish.jersey.server.validation.ValidationFeature.class);
resourceConfig.register(org.glassfish.jersey.server.spring.SpringComponentProvider.class);
resourceConfig.register(org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpContainerProvider.class);
resourceConfig.property(ServerProperties.METAINF_SERVICES_LOOKUP_DISABLE, true);</pre></div></div><p><br class="example-break">
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;5.&nbsp;Client API"><div class="titlepage"><div><div><h2 class="title"><a name="client"></a>Chapter&nbsp;5.&nbsp;Client API</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e2402">5.1. Uniform Interface Constraint</a></span></dt><dt><span class="section"><a href="#d0e2445">5.2. Ease of use and reusing JAX-RS artifacts</a></span></dt><dt><span class="section"><a href="#d0e2561">5.3. Overview of the Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2564">5.3.1. Getting started with the client API</a></span></dt><dt><span class="section"><a href="#d0e2583">5.3.2. 
                Creating and configuring a Client instance
            </a></span></dt><dt><span class="section"><a href="#d0e2767">5.3.3. Targeting a web resource</a></span></dt><dt><span class="section"><a href="#d0e2835">5.3.4. Identifying resource on WebTarget</a></span></dt><dt><span class="section"><a href="#d0e2911">5.3.5. Invoking a HTTP request</a></span></dt><dt><span class="section"><a href="#d0e3054">5.3.6. Example summary</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3083">5.4. Java instances and types for representations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3102">5.4.1. Adding support for new representations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3136">5.5. Client Transport Connectors</a></span></dt><dt><span class="section"><a href="#d0e3210">5.6. Using client request and response filters</a></span></dt><dt><span class="section"><a href="#d0e3248">5.7. Closing connections</a></span></dt><dt><span class="section"><a href="#d0e3272">5.8. Securing a Client</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3383">5.8.1. HTTP Basic Authentication Support</a></span></dt><dt><span class="section"><a href="#d0e3394">5.8.2. HTTP Digest Authentication Support</a></span></dt></dl></dd></dl></div><p>
        This section introduces the JAX-RS Client API, which is a fluent Java based API for communication with RESTful Web
        services. This standard API that is also part of Java EE 7 is designed to make it very easy to consume a Web service
        exposed via HTTP protocol and enables developers to concisely and efficiently implement portable client-side solutions
        that leverage existing and well established client-side HTTP connector implementations.
    </p><p>
        The JAX-RS client API can be utilized to consume any Web service exposed on top of a HTTP protocol or it's
        extension (e.g. WebDAV), and is not restricted to services implemented using JAX-RS. Yet, developers familiar with JAX-RS
        should find the client API complementary to their services, especially if the client API is utilized by those services
        themselves, or to test those services.
        The JAX-RS client API finds inspiration in the proprietary Jersey 1.x Client API and developers familiar with the Jersey
        1.x Client API should find it easy to understand all the concepts introduced in the new JAX-RS Client API.
    </p><p>
        The goals of the client API are threefold:

        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    Encapsulate a key constraint of the REST architectural style, namely the Uniform Interface Constraint and
                    associated data elements, as client-side Java artifacts;
                </p></li><li class="listitem"><p>
                    Make it as easy to consume RESTful Web services exposed over HTTP, same as the JAX-RS server-side API makes
                    it easy to develop RESTful Web services; and
                </p></li><li class="listitem"><p>
                    Share common concepts and extensibility points of the JAX-RS API between the server and the client side
                    programming models.
                </p></li></ol></div><p>

        As an extension to the standard JAX-RS Client API, the  Jersey Client API supports a pluggable architecture to enable the
        use of different underlying HTTP client <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> implementations. Several such implementations are
        currently provided with Jersey. We have a default client connector using <code class="literal">Http(s)URLConnection</code> supplied
        with the JDK as well as connector implementations based on Apache HTTP Client, and Grizzly Asynchronous Client.
    </p><div class="section" title="5.1.&nbsp;Uniform Interface Constraint"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2402"></a>5.1.&nbsp;Uniform Interface Constraint</h2></div></div></div><p>
            The uniform interface constraint bounds the architecture of RESTful Web services so that a client, such
            as a browser, can utilize the same interface to communicate with any service. This is a very powerful concept
            in software engineering that makes Web-based search engines and service mash-ups possible. It induces properties
            such as:

            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>simplicity, the architecture is easier to understand and maintain; and</p></li><li class="listitem"><p>
                        evolvability or loose coupling, clients and services can evolve over time perhaps in new and
                        unexpected ways, while retaining backwards compatibility.
                    </p></li></ol></div><p>

            Further constraints are required:

            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>every resource is identified by a URI;</p></li><li class="listitem"><p>
                        a client interacts with the resource via HTTP requests and responses using a fixed set of
                        HTTP methods;
                    </p></li><li class="listitem"><p>one or more representations can be returned and are identified by media types; and</p></li><li class="listitem"><p>the contents of which can link to further resources.</p></li></ol></div><p>

            The above process repeated over and again should be familiar to anyone who has used a browser to fill
            in HTML forms and follow links. That same process is applicable to non-browser based clients.
        </p><p>
            Many existing Java-based client APIs, such as the Apache HTTP client API or <code class="literal">HttpUrlConnection</code>
            supplied with the JDK place too much focus on the Client-Server constraint for the exchanges of request and
            responses rather than a resource, identified by a URI, and the use of a fixed set of HTTP methods.
        </p><p>A resource in the JAX-RS client API is an instance of the Java class
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/WebTarget.html" target="_top">WebTarget</a>.
            and encapsulates an URI. The fixed set of HTTP methods can be invoked based on the
            <code class="literal">WebTarget</code>.
            The representations are Java types, instances of which, may contain links that new instances of
            <code class="literal">WebTarget</code> may be created from.
        </p></div><div class="section" title="5.2.&nbsp;Ease of use and reusing JAX-RS artifacts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2445"></a>5.2.&nbsp;Ease of use and reusing JAX-RS artifacts</h2></div></div></div><p>
            Since a JAX-RS component is represented as an annotated Java type, it makes it easy to configure, pass around and
            inject in ways that are not so intuitive or possible with other client-side APIs.
            The Jersey Client API reuses many aspects of the JAX-RS and the Jersey implementation such as:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                        URI building using <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriBuilder.html" target="_top">UriBuilder</a> and <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/uri/UriTemplate.html" target="_top">UriTemplate</a> to safely build URIs;
                    </p></li><li class="listitem"><p>Built-in support for Java types of representations such as
                        <code class="literal">byte[]</code>,
                        <code class="literal">String</code>,
                        <code class="literal">Number</code>,
                        <code class="literal">Boolean</code>,
                        <code class="literal">Character</code>,
                        <code class="literal">InputStream</code>,
                        <code class="literal">java.io.Reader</code>,
                        <code class="literal">File</code>,
                        <code class="literal">DataSource</code>,
                        JAXB beans as well as additional Jersey-specific JSON and <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/multipart/package-info.html" target="_top">Multi Part</a> support.
                    </p></li><li class="listitem"><p>Using the fluent builder-style API pattern to make it easier to construct requests.</p></li></ol></div><p>
            Some APIs, like the Apache HTTP Client or <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/net/HttpURLConnection.html" target="_top">HttpURLConnection</a>
            can be rather hard to use and/or require too much code to do something relatively simple, especially when
            the client needs to understand different payload representations.
            This is why the Jersey implementation of JAX-RS Client API provides support for wrapping <code class="literal">HttpUrlConnection</code>
            and the Apache HTTP client. Thus it is possible to get the benefits of the established JAX-RS implementations and
            features while getting the ease of use benefit of the simple design of the JAX-RS client API.
            For example, with a low-level HTTP client library, sending a POST request with a bunch of typed HTML form parameters
            and receiving a response de-serialized into a JAXB bean is not straightforward at all. With the new JAX-RS Client API
            supported by Jersey this task is very easy:

            </p><div class="example"><a name="client.ex.formpost"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;POST request with form parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient();
WebTarget target = client.target("http://localhost:9998").path("resource");

Form form = new Form();
form.param("x", "foo");
form.param("y", "bar");

MyJAXBBean bean =
target.request(MediaType.APPLICATION_JSON_TYPE)
    .post(Entity.entity(form,MediaType.APPLICATION_FORM_URLENCODED_TYPE),
        MyJAXBBean.class);</pre></div></div><p><br class="example-break">

            In the <a class="xref" href="#client.ex.formpost" title="Example&nbsp;5.1.&nbsp;POST request with form parameters">Example&nbsp;5.1, &#8220;POST request with form parameters&#8221;</a> a new <code class="literal">WebTarget</code> instance is created using a new
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Client.html" target="_top">Client</a> instance first, next a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Form.html" target="_top">Form</a> instance is created with two form parameters.
            Once ready, the <code class="literal">Form</code> instance is <code class="literal">POST</code>ed to the target resource.
            First, the acceptable media type is specified in the <code class="literal">request(...)</code> method. Then in the
            <code class="literal">post(...)</code> method, a call to a static method on JAX-RS <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Entity.html" target="_top">Entity</a> is made to construct
            the request entity instance and attach the proper content media type to the form entity that is being sent. The
            second parameter in the <code class="literal">post(...)</code> method specifies the Java type of the response entity that should
            be returned from the method in case of a successful response. In this case an instance of JAXB bean is requested to
            be returned on success. The Jersey client API takes care of selecting the proper <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for
            the serialization of the <code class="literal">Form</code> instance, invoking the <code class="literal">POST</code> request and producing and
            de-serialization of the response message payload into an instance of a JAXB bean using a proper
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>.
        </p><p>If the code above had to be written using <code class="literal">HttpUrlConnection</code>, the developer would have to write custom
            code to serialize the form data that are sent within the POST request and de-serialize the response input stream
            into a JAXB bean. Additionally, more code would have to be written to make it easy to reuse the logic when
            communicating with the same resource <code class="literal">&#8220;http://localhost:8080/resource&#8221;</code> that is represented by
            the JAX-RS <code class="literal">WebTarget</code> instance in our example.
        </p></div><div class="section" title="5.3.&nbsp;Overview of the Client API"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2561"></a>5.3.&nbsp;Overview of the Client API</h2></div></div></div><div class="section" title="5.3.1.&nbsp;Getting started with the client API"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2564"></a>5.3.1.&nbsp;Getting started with the client API</h3></div></div></div><p>
                Refer to the <a class="link" href="#dependencies" title="2.3.&nbsp;Common Jersey Use Cases">dependencies</a> for details on the dependencies when using the
                Jersey JAX-RS Client support.
            </p><p>
                You may also want to use a custom <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> implementation. In such case you would need to include
                additional dependencies on the module(s) containing the custom client connector that you want to use. See section
                <a class="link" href="#connectors">"Configuring custom Connectors"</a> about how to use and configure a custom
                Jersey client transport <code class="literal">Connector</code>.</p></div><div class="section" title="5.3.2.&nbsp; Creating and configuring a Client instance"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2583"></a>5.3.2.&nbsp;
                Creating and configuring a Client instance
            </h3></div></div></div><p>
                JAX-RS Client API is a designed to allow fluent programming model. This means, a construction of a
                <code class="literal">Client</code> instance, from which a <code class="literal">WebTarget</code> is created, from which a
                request <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Invocation.html" target="_top">Invocation</a> is built and invoked can be chained in a single "flow" of invocations.
                The individual steps of the flow will be shown in the following sections.
                To utilize the client API it is first necessary to build an instance of a
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Client.html" target="_top">Client</a> using one of the static <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientBuilder.html" target="_top">ClientBuilder</a> factory methods. Here's the most
                simple example:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient();</pre><p>

                The <code class="literal">ClientBuilder</code> is a JAX-RS API used to create new instances of <code class="literal">Client</code>.
                In a slightly more advanced scenarios, <code class="literal">ClientBuilder</code> can be used to configure additional
                client instance properties, such as a SSL transport settings, if needed (see <a class="xref" href="#">???</a>
                below).
            </p><p>
                A <code class="literal">Client</code> instance can be configured during creation by passing a <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientConfig.html" target="_top">ClientConfig</a>
                to the <code class="literal">newClient(Configurable)</code> <code class="literal">ClientBuilder</code> factory method.
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientConfig.html" target="_top">ClientConfig</a> implements <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a> and therefore it offers methods to register
                providers (e.g. features or individual entity providers, filters or interceptors) and setup properties.
                The following code shows a registration of custom client filters:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());
Client client = ClientBuilder.newClient(clientConfig);</pre><p>

                In the example, filters are registered using the <code class="literal">ClientConfig.register(...)</code> method. There are
                multiple overloaded versions of the method that support registration of feature and provider classes or instances.
                Once a <code class="literal">ClientConfig</code> instance is configured, it can be passed to the
                <code class="literal">ClientBuilder</code> to create a pre-configured <code class="literal">Client</code> instance.
            </p><p>
                Note that the Jersey <code class="literal">ClientConfig</code> supports the fluent API model of <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a>.
                With that the code that configures a new client instance can be also written using a more compact style as shown
                below.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
Client client = ClientBuilder.newClient(new ClientConfig()
        .register(MyClientResponseFilter.class)
        .register(new AnotherClientFilter());</pre><p>

                The ability to leverage this compact pattern is inherent to all JAX-RS and Jersey Client API components.
            </p><p>
                Since <code class="literal">Client</code> implements <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a> interface too, it can be configured further
                even after it has been created. Important is to mention that any configuration change done on a
                <code class="literal">Client</code> instance will not influence the <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientConfig.html" target="_top">ClientConfig</a> instance that was used to
                provide the initial <code class="literal">Client</code> instance configuration at the instance creation time.
                The next piece of code shows a configuration of an existing <code class="literal">Client</code> instance.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.register(ThirdClientFilter.class);</pre><p>

                Similarly to earlier examples, since <code class="literal">Client.register(...)</code> method supports the fluent API style,
                multiple client instance configuration calls can be chained:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.register(FilterA.class)
      .register(new FilterB())
      .property("my-property", true);</pre><p>

                To get the current configuration of the <code class="literal">Client</code> instance a <code class="literal">getConfiguration()</code>
                method can be used.

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());
Client client = ClientBuilder.newClient(clientConfig);
client.register(ThirdClientFilter.class);
Configuration newConfiguration = client.getConfiguration();</pre><p>

                In the code, an additional <code class="literal">MyClientResponseFilter</code> class and
                <code class="literal">AnotherClientFilter</code> instance are registered in the <code class="literal">clientConfig</code>. The
                <code class="literal">clientConfig</code> is then used to construct a new <code class="literal">Client</code> instance. The
                <code class="literal">ThirdClientFilter</code> is added separately to the constructed <code class="literal">Client</code> instance.
                This does not influence the configuration represented by the original <code class="literal">clientConfig</code>.
                In the last step a <code class="literal">newConfiguration</code> is retrieved from the <code class="literal">client</code>. This
                configuration contains all three registered filters while the original <code class="literal">clientConfig</code> instance
                still contains only two filters. Unlike <code class="literal">clientConfig</code> created separately, the
                <code class="literal">newConfiguration</code> retrieved from the <code class="literal">client</code> instance represents a live
                client configuration view. Any additional configuration changes made to the <code class="literal">client</code> instance
                are also reflected in the <code class="literal">newConfiguration</code>. So, <code class="literal">newConfiguration</code> is really
                a view of the <code class="literal">client</code> configuration and not a configuration state copy. These principles are
                important in the client API and will be used in the following sections too. For example, you can construct a
                common base configuration for all clients (in our case it would be <code class="literal">clientConfig</code>) and
                then reuse this common configuration instance to configure multiple <code class="literal">client</code> instances that can
                be further specialized. Similarly, you can use an existing <code class="literal">client</code> instance configuration to
                configure another client instance without having to worry about any side effects in the original
                <code class="literal">client</code> instance.
            </p></div><div class="section" title="5.3.3.&nbsp;Targeting a web resource"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2767"></a>5.3.3.&nbsp;Targeting a web resource</h3></div></div></div><p>
                Once you have a <code class="literal">Client</code> instance you can create a <code class="literal">WebTarget</code> from it.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget webTarget = client.target("http://example.com/rest");</pre><p>

                A <code class="literal">Client</code> contains several <code class="literal">target(...)</code> methods that allow for creation of
                <code class="literal">WebTarget</code> instance. In this case we're using <code class="literal">target(String uri)</code> version.
                The <code class="literal">uri</code> passed to the method as a <code class="literal">String</code> is the URI of the targeted
                web resource. In more complex scenarios it could be the context root URI of the whole RESTful application, from
                which <code class="literal">WebTarget</code> instances representing individual resource targets can be derived and
                individually configured. This is possible, because JAX-RS <code class="literal">WebTarget</code> also implements
                <code class="literal">Configurable</code>:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget webTarget = client.target("http://example.com/rest");
webTarget.register(FilterForExampleCom.class);</pre><p>

                The configuration principles used in JAX-RS client API apply to <code class="literal">WebTarget</code> as well. Each
                <code class="literal">WebTarget</code> instance inherits a configuration from it's parent (either a client or another
                web target) and can be further custom-configured without affecting the configuration of the parent component.
                In this case, the <code class="literal">FilterForExampleCom</code> will be registered only in the
                <code class="literal">webTarget</code> and not in <code class="literal">client</code>. So, the <code class="literal">client</code>
                can still be used to create new <code class="literal">WebTarget</code> instances pointing at other URIs using just the
                common client configuration, which <code class="literal">FilterForExampleCom</code> filter is not part of.
            </p></div><div class="section" title="5.3.4.&nbsp;Identifying resource on WebTarget"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2835"></a>5.3.4.&nbsp;Identifying resource on WebTarget</h3></div></div></div><p>
                Let's assume we have a <code class="literal">webTarget</code> pointing at <code class="literal">"http://example.com/rest"</code> URI
                that represents a context root of a RESTful application and there is a resource exposed on the URI
                <code class="literal">"http://example.com/rest/resource"</code>. As already mentioned, a <code class="literal">WebTarget</code>
                instance can be used to derive other web targets. Use the following code to define a path to the resource.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget resourceWebTarget = webTarget.path("resource");</pre><p>

                The <code class="literal">resourceWebTarget</code> now points to the resource on URI
                <code class="literal">"http://example.com/rest/resource"</code>. Again if we configure the
                <code class="literal">resourceWebTarget</code> with a filter specific to the <code class="literal">resource</code>,
                it will not influence the original <code class="literal">webTarget</code> instance. However, the filter
                <code class="literal">FilterForExampleCom</code> registration will still be inherited by the
                <code class="literal">resourceWebTarget</code> as it has been created from <code class="literal">webTarget</code>. This mechanism
                allows you to share the common configuration of related resources (typically hosted under the same URI root,
                in our case represented by the <code class="literal">webTarget</code> instance), while allowing for further configuration
                specialization based on the specific requirements of each individual resource. The same configuration principles
                of inheritance (to allow common config propagation) and decoupling (to allow individual config customization)
                applies to all components in JAX-RS Client API discussed below.
            </p><p>
                Let's say there is a sub resource on the path <code class="literal">"http://example.com/rest/resource/helloworld"</code>.
                You can derive a <code class="literal">WebTarget</code> for this resource simply by:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");</pre><p>

                Let's assume that the <code class="literal">helloworld</code> resource accepts a query param for <code class="literal">GET</code>
                requests which defines the greeting message. The next code snippet shows a code that creates
                a new <code class="literal">WebTarget</code> with the query param defined.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget helloworldWebTargetWithQueryParam =
        helloworldWebTarget.queryParam("greeting", "Hi World!");</pre><p>

                Please note that apart from methods that can derive new <code class="literal">WebTarget</code> instance based on a URI path
                or query parameters, the JAX-RS <code class="literal">WebTarget</code> API contains also methods for working with matrix
                parameters too.
            </p></div><div class="section" title="5.3.5.&nbsp;Invoking a HTTP request"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2911"></a>5.3.5.&nbsp;Invoking a HTTP request</h3></div></div></div><p>
                Let's now focus on invoking a <code class="literal">GET</code> HTTP request on the created web targets. To start building a new
                HTTP request invocation, we need to create a new <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Invocation.Builder.html" target="_top">Invocation.Builder</a>.

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Invocation.Builder invocationBuilder =
        helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);
invocationBuilder.header("some-header", "true");</pre><p>

                A new invocation builder instance is created using one of the <code class="literal">request(...)</code> methods that are
                available on <code class="literal">WebTarget</code>. A couple of these methods accept parameters that let you define
                the media type of the representation requested to be returned from the resource. Here we are saying that we
                request a <code class="literal">"text/plain"</code> type. This tells Jersey to add a <code class="literal">Accept: text/plain</code>
                HTTP header to our request.
            </p><p>
                The <code class="literal">invocationBuilder</code> is used to setup request specific parameters. Here we can setup headers
                for the request or for example cookie parameters. In our example we set up a <code class="literal">"some-header"</code>
                header to value <code class="literal">true</code>.
            </p><p>
                Once finished with request customizations, it's time to invoke the request. We have two options now.
                We can use the <code class="literal">Invocation.Builder</code> to build a generic <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Invocation.html" target="_top">Invocation</a> instance
                that will be invoked some time later. Using <code class="literal">Invocation</code> we will be able to e.g. set additional
                request properties which are properties in a batch of several requests and use the generic JAX-RS
                <code class="literal">Invocation</code> API to invoke the batch of requests without actually knowing all the details
                (such as request HTTP method, configuration etc.). Any properties set on an invocation instance can be read
                during the request processing. For example, in a custom <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/RequestFilter.html" target="_top">ClientRequestFilter</a> you can call
                <code class="literal">getProperty()</code> method on the supplied <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientRequestContext.html" target="_top">ClientRequestContext</a> to read a request
                property. Note that these request properties are different from the configuration properties set on
                <code class="literal">Configurable</code>. As mentioned earlier, an <code class="literal">Invocation</code> instance provides generic
                invocation API to invoke the HTTP request it represents either synchronously or asynchronously. See
                the <a class="xref" href="#async" title="Chapter&nbsp;10.&nbsp;Asynchronous Services and Clients">Chapter&nbsp;10, <i>Asynchronous Services and Clients</i></a> for more information on asynchronous invocations.
            </p><p>
                In case you do not want to do any batch processing on your HTTP request invocations prior to invoking them, there
                is another, more convenient approach that you can use to invoke your requests directly from an
                <code class="literal">Invocation.Builder</code> instance. This approach is demonstrated in the next Java code listing.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Response response = invocationBuilder.get();</pre><p>

                While short, the code in the example performs multiple actions. First, it will build the the request from the
                <code class="literal">invocationBuilder</code>. The URI of request will be
                <code class="literal">http://example.com/rest/resource/helloworld?greeting="Hi%20World!"</code> and the request will contain
                <code class="literal">some-header: true</code> and <code class="literal">Accept: text/plain</code> headers. The request will then pass
                trough all configured request filters ( <code class="literal">AnotherClientFilter</code>,
                <code class="literal">ThirdClientFilter</code> and
                <code class="literal">FilterForExampleCom</code>). Once processed by the filters, the request will be sent to the remote
                resource. Let's say the resource then returns an HTTP 200 message with a plain text response content that contains
                the value sent in the request <code class="literal">greeting</code> query parameter. Now we can observe the returned
                response:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));</pre><p>

                which will produce the following output to the console:

                </p><pre class="screen">200
Hi World!</pre><p>

                As we can see, the request was successfully processed (code 200) and returned an entity (representation) is
                <code class="literal">"Hi World!"</code>. Note that since ve have configured a <code class="literal">MyClientResponseFilter</code>
                in the resource target, when <code class="literal">response.readEntity(String.class)</code> gets called, the response
                returned from the remote endpoint is passed through the response filter chain (including the
                <code class="literal">MyClientResponseFilter</code>) and entity interceptor chain and at last a proper
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> is located to read the response content bytes from the response stream into a
                Java <code class="literal">String</code> instance. Check <a class="xref" href="#filters-and-interceptors" title="Chapter&nbsp;9.&nbsp;Filters and Interceptors">Chapter&nbsp;9, <i>Filters and Interceptors</i></a> to lear more about
                request and response filters and entity interceptors.
            </p><p>
                Imagine now that you would like to invoke a <code class="literal">POST</code> request but without any query parameters. You would
                just use the <code class="literal">helloworldWebTarget</code> instance created earlier and call the
                <code class="literal">post()</code> instead of <code class="literal">get()</code>.
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Response postResponse =
        helloworldWebTarget.request(MediaType.TEXT_PLAIN_TYPE)
                .post(Entity.entity("A string entity to be POSTed", MediaType.TEXT_PLAIN));</pre><p>
            </p></div><div class="section" title="5.3.6.&nbsp;Example summary"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3054"></a>5.3.6.&nbsp;Example summary</h3></div></div></div><p>
                The following code puts together the pieces used in the earlier examples.

                </p><div class="example"><a name="d0e3059"></a><p class="title"><b>Example&nbsp;5.2.&nbsp;Using JAX-RS Client API</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
clientConfig.register(MyClientResponseFilter.class);
clientConfig.register(new AnotherClientFilter());

Client client = ClientBuilder.newClient(clientConfig);
client.register(ThirdClientFilter.class);

WebTarget webTarget = client.target("http://example.com/rest");
webTarget.register(FilterForExampleCom.class);
WebTarget resourceWebTarget = webTarget.path("resource");
WebTarget helloworldWebTarget = resourceWebTarget.path("helloworld");
WebTarget helloworldWebTargetWithQueryParam =
        helloworldWebTarget.queryParam("greeting", "Hi World!");

Invocation.Builder invocationBuilder =
        helloworldWebTargetWithQueryParam.request(MediaType.TEXT_PLAIN_TYPE);
invocationBuilder.header("some-header", "true");

Response response = invocationBuilder.get();
System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));</pre></div></div><p><br class="example-break">

                Now we can try to leverage the fluent API style to write this code in a more compact way.

                </p><div class="example"><a name="d0e3065"></a><p class="title"><b>Example&nbsp;5.3.&nbsp;Using JAX-RS Client API fluently</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newClient(new ClientConfig()
            .register(MyClientResponseFilter.class)
            .register(new AnotherClientFilter()));

String entity = client.target("http://example.com/rest")
            .register(FilterForExampleCom.class)
            .path("resource/helloworld")
            .queryParam("greeting", "Hi World!")
            .request(MediaType.TEXT_PLAIN_TYPE)
            .header("some-header", "true")
            .get(String.class);</pre></div></div><p><br class="example-break">

                The code above does the same thing except it skips the generic <code class="literal">Response</code> processing and directly
                requests an entity in the last <code class="literal">get(String.class)</code> method call. This shortcut method let's you
                specify that (in case the response was returned successfully with a HTTP 2xx status code) the response entity
                should be returned as Java <code class="literal">String</code> type. This compact example demonstrates another advantage of
                the JAX-RS client API. The fluency of JAX-RS Client API is convenient especially with simple use cases.
                Here is another a very simple GET request returning a String representation (entity):

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">String responseEntity = ClientBuilder.newClient()
            .target("http://example.com").path("resource/rest")
                        .request().get(String.class);</pre><p>
            </p></div></div><div class="section" title="5.4.&nbsp;Java instances and types for representations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3083"></a>5.4.&nbsp;Java instances and types for representations</h2></div></div></div><p>
            All the Java types and representations supported by default on the Jersey server side for
            requests and responses are also supported on the client side.
            For example, to process a response entity (or representation) as a stream of bytes use InputStream as follows:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">InputStream in = response.readEntity(InputStream.class);

... // Read from the stream

in.close();
            </pre><p>

            Note that it is important to close the stream after processing so that resources are freed up.
        </p><p>
            To <code class="literal">POST</code> a file use a <code class="literal">File</code> instance as follows:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">File f = ...

...

webTarget.request().post(Entity.entity(f, MediaType.TEXT_PLAIN_TYPE));
            </pre><p>
        </p><div class="section" title="5.4.1.&nbsp;Adding support for new representations"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3102"></a>5.4.1.&nbsp;Adding support for new representations</h3></div></div></div><p>
                The support for new application-defined representations as Java types requires the
                implementation of the same JAX-RS entity provider extension interfaces as for the server side JAX-RS API, namely
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> and <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>
                respectively, for request and response entities (or inbound and outbound representations).
            </p><p>
                Classes or implementations of the provider-based interfaces need to be registered as providers within the
                JAX-RS or Jersey Client API components that implement <code class="literal">Configurable</code> contract
                (<code class="literal">ClientBuilder</code>, <code class="literal">Client</code>, <code class="literal">WebTarget</code> or
                <code class="literal">ClientConfig</code>), as was shown in the earlier sections.
                Some media types are provided in the form of JAX-RS <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Feature.html" target="_top">Feature</a> a concept that allows the extension
                providers to group together multiple different extension providers and/or configuration properties in order
                to simplify the registration and configuration of the provided feature by the end users. For example,
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/moxy/json/MoxyJsonFeature.html" target="_top">MoxyJsonFeature</a> can be register to enable and configure JSON binding support via MOXy
                library.
            </p></div></div><div class="section" title="5.5.&nbsp;Client Transport Connectors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3136"></a>5.5.&nbsp;<a name="connectors"></a>Client Transport Connectors</h2></div></div></div><p>
            By default, the transport layer in Jersey is provided by <code class="literal">HttpUrlConnection</code>. This transport is implemented
            in Jersey via <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/HttpUrlConnector.html" target="_top">HttpUrlConnector</a> that implements Jersey-specific <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> SPI.
            You can implement and/or register your own <code class="literal">Connector</code> instance to the Jersey
            <code class="literal">Client</code> implementation, that will replace the default <code class="literal">HttpUrlConnection</code>-based
            transport layer. Jersey provides several alternative client transport connector implementations that are ready-to-use.
            You can use <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/apache/connector/ApacheConnector.html" target="_top">ApacheConnector</a> (add a maven dependency to
            <code class="literal">org.glassfish.jersey.connectors:jersey-apache-connector</code>)
            or <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/grizzly/connector/GrizzlyConnector.html" target="_top">GrizzlyConnector</a> (add a maven dependency to
            <code class="literal">org.glassfish.jersey.connectors:jersey-grizzly-connector</code>) alternatively. Please, note again, that
            the <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/spi/Connector.html" target="_top">Connector</a> SPI is not a feature of JAX-RS but is a Jersey-specific extension API that will only
            work with Jersey. Following example shows how to setup the custom <code class="literal">Connector</code> to the Jersey client.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientConfig clientConfig = new ClientConfig();
Connector connector = new GrizzlyConnector(clientConfig);
clientConfig.connector(connector);
Client client = ClientBuilder.newClient(clientConfig);</pre><p>

            <code class="literal">Client</code> accepts as as a constructor argument a <code class="literal">Configurable</code> instance. Jersey
            implementation of the <code class="literal">Configurable</code> provider for the client is <code class="literal">ClientConfig</code>.
            By using the Jersey <code class="literal">ClientConfig</code> you can configure the custom <code class="literal">Connector</code>
            into the <code class="literal">ClientConfig</code>. The <code class="literal">GrizzlyConnector</code> is used as a custom connector
            in the example above. Please note that the connector cannot be registered as a provider
            using <code class="literal">Configurable</code><code class="literal">.register(...)</code> at the moment.
        </p></div><div class="section" title="5.6.&nbsp;Using client request and response filters"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3210"></a>5.6.&nbsp;Using client request and response filters</h2></div></div></div><p>
            Filtering requests and responses can provide useful lower-level concept focused on a certain independent aspect or
            domain that is decoupled from the application layer of building and sending requests, and processing responses.
            Filters can read/modify the request URI, headers and entity or read/modify the response status, headers and entity.
        </p><p>
            Jersey contains the following useful client-side filters that you may want to use in your applications:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/filter/CsrfProtectionFilter.html" target="_top">CsrfProtectionFilter</a>: Cross-site request forgery protection filter (adds
                    <code class="literal">X-Requested-By</code> to each state changing request).</td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/filter/EncodingFeature.html" target="_top">EncodingFeature</a>: Feature that registers encoding filter which use registered
                    <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/common/spi/ContentEncoder.html" target="_top">ContentEncoder</a>s to encode and decode the communication. The encoding/decoding is performed
                    in interceptor (you don't need to register this interceptor). Check the javadoc of the
                    <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/filter/EncodingFeature.html" target="_top">EncodingFeature</a> in order to use it.</td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/filter/HttpBasicAuthFilter.html" target="_top">HttpBasicAuthFilter</a>: HTTP Basic Authentication filter (see <a class="xref" href="#">???</a>
                    below).</td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/filter/HttpDigestAuthFilter.html" target="_top">HttpDigestAuthFilter</a>: HTTP Digest Authentication filter.</td></tr></table><p>

            Note that these features are provided by Jersey, but since they use and implement JAX-RS API, the features should
            be portable and run in any JAX-RS implementation, not just Jersey. See <a class="xref" href="#filters-and-interceptors" title="Chapter&nbsp;9.&nbsp;Filters and Interceptors">Chapter&nbsp;9, <i>Filters and Interceptors</i></a>
            chapter for more information on filters and interceptors.
        </p></div><div class="section" title="5.7.&nbsp;Closing connections"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3248"></a>5.7.&nbsp;Closing connections</h2></div></div></div><p>
            The underlying connections are opened for each request
            and closed after the response is received and entity is processed (entity is read). See the
            following example:
        </p><div class="example"><a name="d0e3253"></a><p class="title"><b>Example&nbsp;5.4.&nbsp;Closing connections</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final WebTarget target = ... some web target
Response response = target.path("resource").request().get();
System.out.println("Connection is still open.");
System.out.println("string response: " + response.readEntity(String.class));
System.out.println("Now the connection is closed.");</pre></div></div><br class="example-break"><p>
            If you don't read the entity, then you need to close the response manually by
            <code class="literal">response.close()</code>. Also if the entity is read into an <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/InputStream.html" target="_top">InputStream</a>
            (by <code class="literal">response.readEntity(InputStream.class)</code>), the connection stays open until
            you finish reading from the <code class="literal">InputStream</code>. In that case, the InputStream
            or the Response should be closed manually at the end of reading from InputStream.
        </p></div><div class="section" title="5.8.&nbsp;Securing a Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3272"></a>5.8.&nbsp;Securing a Client</h2></div></div></div><p>
            This section describes how to setup SSL configuration on Jersey client (using JAX-RS API). The SSL configuration is
            setup in <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientBuilder.html" target="_top">ClientBuilder</a>. The client builder contains methods for definition of <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/security/KeyStore.html" target="_top">KeyStore</a>,
            <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/security/TrustStore.html" target="_top">TrustStore</a> or entire <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/SslContext.html" target="_top">SslContext</a>. See the following example:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">SSLContext ssl = ... your configured SSL context;
Client client = ClientBuilder.newBuilder().sslContext(ssl).build();
Response response = client.target("https://example.com/resource").request().get();</pre><p>

            The example above shows how to setup a custom <code class="literal">SslContext</code> to the <code class="literal">ClientBuilder</code>.
            Creating a <code class="literal">SslContext</code> can be more difficult as you might need to init instance properly with the protocol,
            <code class="literal">KeyStore</code>, <code class="literal">TrustStore</code>, etc. Jersey offers a utility <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/SslConfigurator.html" target="_top">SslConfigurator</a> class that
            can be used to setup the <code class="literal">SslContext</code>. The <code class="literal">SslConfigurator</code> can be configured based on
            standardized system properties for SSL configuration, so for example you can configure the <code class="literal">KeyStore</code> file
            name using a environment variable <code class="literal">javax.net.ssl.keyStore</code> and <code class="literal">SslConfigurator</code>
            will use such a variable to setup the <code class="literal">SslContext</code>. See javadoc of <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/SslConfigurator.html" target="_top">SslConfigurator</a> for more
            details. The following code shows how a <code class="literal">SslConfigurator</code> can be used to create a custom SSL
            context.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">SslConfigurator sslConfig = SslConfigurator.newInstance()
        .trustStoreFile("./truststore_client")
        .trustStorePassword("secret-password-for-truststore")
        .keyStoreFile("./keystore_client")
        .keyPassword("secret-password-for-keystore");

SSLContext sslContext = sslConfig.createSSLContext();
Client client = ClientBuilder.newBuilder().sslContext(sslContext).build();</pre><p>
        </p><p>
            Note that you can also setup <code class="literal">KeyStore</code> and <code class="literal">TrustStore</code> directly on a
            <code class="literal">ClientBuilder</code> instance without wrapping them into the <code class="literal">SslContext</code>. However, if you setup
            a <code class="literal">SslContext</code> it will override any previously defined <code class="literal">KeyStore</code> and <code class="literal">TrustStore</code>
            settings.
            <code class="literal">ClientBuilder</code> also offers a method for defining a custom <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/HostnameVerifier.html" target="_top">HostnameVerifier</a> implementation.
            <code class="literal">HostnameVerifier</code> implementations are invoked when default host URL verification fails.
        </p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                Note that to utilize HTTP with SSL it is necessary to utilize the <code class="literal">&#8220;https&#8221;</code> scheme.
            </p></div><p>
            Currently the default connector <code class="literal">HttpUrlConnector</code> based on <code class="literal">HttpUrlConnection</code> implements
            support for SSL defined by JAX-RS configuration discussed in this sample.
        </p><div class="section" title="5.8.1.&nbsp;HTTP Basic Authentication Support"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3383"></a>5.8.1.&nbsp;HTTP Basic Authentication Support</h3></div></div></div><p>
                Jersey contains a filter that allows client to authenticate to servers which requires HTTP Basic Authentication.
                Use <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/filter/HttpBasicAuthFilter.html" target="_top">HttpBasicAuthFilter</a> to add authentication header to requests initiated from from the client.
                See the example of how to configure and register the filter:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.register(new HttpBasicAuthFilter("Homer", "SecretPassword"));</pre><p>
            </p></div><div class="section" title="5.8.2.&nbsp;HTTP Digest Authentication Support"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3394"></a>5.8.2.&nbsp;HTTP Digest Authentication Support</h3></div></div></div><p>
                Jersey contains a filter that allows client to authenticate to servers which requires HTTP Digest Authentication.
                Use <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/filter/HttpDigestAuthFilter.html" target="_top">HttpDigestAuthFilter</a> to add authentication header to requests initiated from from the client.
                See the example of how to configure and register the filter:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">client.register(new HttpDigestAuthFilter("Homer", "SecretPassword"));</pre><p>
            </p></div></div></div><div lang="en" class="chapter" title="Chapter&nbsp;6.&nbsp;Representations and Responses"><div class="titlepage"><div><div><h2 class="title"><a name="representations"></a>Chapter&nbsp;6.&nbsp;Representations and Responses</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#reps-and-types">6.1. Representations and Java Types</a></span></dt><dt><span class="section"><a href="#d0e3548">6.2. Building Responses</a></span></dt><dt><span class="section"><a href="#d0e3585">6.3. WebApplicationException and Mapping Exceptions to Responses</a></span></dt><dt><span class="section"><a href="#d0e3666">6.4. Conditional GETs and Returning 304 (Not Modified) Responses</a></span></dt></dl></div><div class="section" title="6.1.&nbsp;Representations and Java Types"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="reps-and-types"></a>6.1.&nbsp;Representations and Java Types</h2></div></div></div><p>Previous sections on <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> and <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Consumes.html" target="_top">@Consumes</a> annotations
            referred to media type of an entity representation. Examples above depicted resource
            methods that could consume and/or produce String Java type for a number of
	    different media types. This approach is easy to understand and relatively
	    straightforward when applied to simple use cases.
	    </p><p>To cover also other cases, handling non-textual data for example or handling data stored in the file system, etc.,
            JAX-RS implementations are required to support also other kinds of media type
            conversions where additional, non-String, Java types are being utilized. Following is a short listing of the Java types
            that are supported out of the box with respect to supported media type:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">All media types (<code class="literal">*/*</code>)
            		<div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><code class="literal">byte[]</code></li><li class="listitem"><code class="literal">java.lang.String</code></li><li class="listitem"><code class="literal">java.io.Reader</code> (inbound only)</li><li class="listitem"><code class="literal">java.io.File</code></li><li class="listitem"><code class="literal">javax.activation.DataSource</code></li><li class="listitem"><code class="literal">javax.ws.rs.core.StreamingOutput</code> (outbound only)</li></ul></div></li><li class="listitem">XML media types (<code class="literal">text/xml</code>, <code class="literal">application/xml</code> and <code class="literal">application/...+xml</code>)
            		<div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><code class="literal">javax.xml.transform.Source</code></li><li class="listitem"><code class="literal">javax.xml.bind.JAXBElement</code></li><li class="listitem">Application supplied JAXB classes (types annotated with
	    <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/xml/bind/annotation/XmlRootElement.html" target="_top">@XmlRootElement</a>
	    or<a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/xml/bind/annotation/XmlType.html" target="_top">@XmlType</a>)</li></ul></div></li><li class="listitem">Form content (<code class="literal">application/x-www-form-urlencoded</code>)
                        <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><code class="literal">MultivaluedMap&lt;String,String&gt;</code></li></ul></div></li><li class="listitem">Plain text (<code class="literal">text/plain</code>)
                        <div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><code class="literal">java.lang.Boolean</code></li><li class="listitem"><code class="literal">java.lang.Character</code></li><li class="listitem"><code class="literal">java.lang.Number</code></li></ul></div></li></ul></div><p>
        </p><p>Unlike method parameters that are associated with the extraction of
            request parameters, the method parameter associated with the
            representation being consumed does not require annotating. In other words the
            representation (entity) parameter does not require a specific 'entity' annotation. A method parameter
            without a annotation is an entity. A maximum of
            one such unannotated method parameter may exist since there may only be a
            maximum of one such representation sent in a request.
        </p><p>The representation being produced corresponds to what is returned by
            the resource method. For example JAX-RS makes it simple to produce images
            that are instance of
            <code class="literal">File</code>
            as follows:
        </p><p>
            </p><div class="example"><a name="d0e3509"></a><p class="title"><b>Example&nbsp;6.1.&nbsp;Using
                    <code class="code">File</code>
                    with a specific media type to produce a response
                </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Path("/images/{image}")
@Produces("image/*")
public Response getImage(@PathParam("image") String image) {
  File f = new File(image);

  if (!f.exists()) {
    throw new WebApplicationException(404);
  }

  String mt = new MimetypesFileTypeMap().getContentType(f);
  return Response.ok(f, mt).build();
}</pre></div></div><p><br class="example-break">
        </p><p>The
            <code class="literal">File</code> type can also be used when consuming a representation (request entity).
            In that case a temporary file will be created from the incoming request entity and passed as a
            parameter to the resource method.
        </p><p>
            The <code class="literal">Content-Type</code> response header
            (if not set programmatically as described in the next section)
            will be automatically set based on the media types declared by <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> annotation.
 Given the following method, the most acceptable media type is used when multiple output media types are allowed:
        </p><p>
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces({"application/xml", "application/json"})
public String doGetAsXmlOrJson() {
  ...
}</pre><p>

            If <code class="literal">application/xml</code> is the most acceptable media type defined
            by the request (e.g. by header <code class="literal">Accept: application/xml</code>), then the
            <code class="literal">Content-Type</code> response header
            will be set to <code class="literal">application/xml</code>.
        </p></div><div class="section" title="6.2.&nbsp;Building Responses"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3548"></a>6.2.&nbsp;Building Responses</h2></div></div></div><p>Sometimes it is necessary to return additional
            information in response to a HTTP request. Such information may be built
            and returned using <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Response.html" target="_top">Response</a> and <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Response.ResponseBuilder.html" target="_top">Response.ResponseBuilder</a>.
            For example, a common RESTful pattern for the creation of a new resource
            is to support a POST request that returns a 201 (Created) status code and
            a
            <code class="literal">Location</code>
            header whose value is the URI to the newly
            created resource. This may be achieved as follows:
        </p><p>
            </p><div class="example"><a name="d0e3564"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;Returning 201 status code and adding
                    <code class="literal">Location</code>
                    header in response to POST request
                </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes("application/xml")
public Response post(String content) {
  URI createdUri = ...
  create(content);
  return Response.created(createdUri).build();
}</pre></div></div><p><br class="example-break">
        </p><p>In the above no representation produced is returned, this can be
            achieved by building an entity as part of the response as follows:
        </p><p>
            </p><div class="example"><a name="d0e3577"></a><p class="title"><b>Example&nbsp;6.3.&nbsp;Adding an entity body to a custom response</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes("application/xml")
public Response post(String content) {
  URI createdUri = ...
  String createdContent = create(content);
  return Response.created(createdUri).entity(Entity.text(createdContent)).build();
}</pre></div></div><p><br class="example-break">
        </p><p>Response building provides other functionality such as setting the
            entity tag and last modified date of the representation.
        </p></div><div class="section" title="6.3.&nbsp;WebApplicationException and Mapping Exceptions to Responses"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3585"></a>6.3.&nbsp;WebApplicationException and Mapping Exceptions to Responses</h2></div></div></div><p>Previous section shows how to return HTTP responses,
              that are built up programmatically.
            It is possible to use the very same mechanism
            to return HTTP errors directly,
            e.g. when handling exceptions in a try-catch block.
            However, to better align with the Java programming model,
            JAX-RS allows to define direct mapping of Java exceptions to HTTP error responses.
        </p><p>The following example shows throwing
            <code class="literal">CustomNotFoundException</code>
            from a resource method in order to return an error HTTP response to the client:
        </p><p>
            </p><div class="example"><a name="d0e3597"></a><p class="title"><b>Example&nbsp;6.4.&nbsp;Throwing exceptions to control response</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("items/{itemid}/")
public Item getItem(@PathParam("itemid") String itemid) {
  Item i = getItems().get(itemid);
  if (i == null) {
    throw new CustomNotFoundException("Item, " + itemid + ", is not found");
  }

  return i;
}</pre></div></div><p><br class="example-break">
        </p><p>This exception is an application specific exception that extends <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/WebApplicationException.html" target="_top">WebApplicationException</a>
            and builds a HTTP response with the 404 status code and an optional
            message as the body of the response:
        </p><p>
            </p><div class="example"><a name="d0e3610"></a><p class="title"><b>Example&nbsp;6.5.&nbsp;Application specific exception implementation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class CustomNotFoundException extends WebApplicationException {

  /**
  * Create a HTTP 404 (Not Found) exception.
  */
  public CustomNotFoundException() {
    super(Responses.notFound().build());
  }

  /**
  * Create a HTTP 404 (Not Found) exception.
  * @param message the String that is the entity of the 404 response.
  */
  public CustomNotFoundException(String message) {
    super(Response.status(Responses.NOT_FOUND).
    entity(message).type("text/plain").build());
  }
}</pre></div></div><p><br class="example-break">
        </p><p>In other cases it may not be appropriate to throw instances of <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/WebApplicationException.html" target="_top">WebApplicationException</a>,
            or classes that extend <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/WebApplicationException.html" target="_top">WebApplicationException</a>, and instead it may be preferable to map an existing exception to a
            response. For such cases it is possible to use a custom exception mapping provider. The provider must implement
            the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/ExceptionMapper.html" target="_top">ExceptionMapper&lt;E extends Throwable&gt;</a> interface. For example, the following
            maps the
            <a class="link" href="http://docs.oracle.com/javaee/5/api/javax/persistence/EntityNotFoundException.html" target="_top">EntityNotFoundException</a>
            to a HTTP 404 (Not Found) response:
        </p><p>
            </p><div class="example"><a name="d0e3632"></a><p class="title"><b>Example&nbsp;6.6.&nbsp;Mapping generic exceptions to responses</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class EntityNotFoundMapper implements ExceptionMapper&lt;javax.persistence.EntityNotFoundException&gt; {
  public Response toResponse(javax.persistence.EntityNotFoundException ex) {
    return Response.status(404).
      entity(ex.getMessage()).
      type("text/plain").
      build();
  }
}</pre></div></div><p><br class="example-break">
        </p><p>The above class is annotated with <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/Provider.html" target="_top">@Provider</a>, this declares that the class is of interest to the JAX-RS runtime. Such a
            class may be added to the set of classes of the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a> instance that is configured. When an application throws an
            <a class="link" href="http://docs.oracle.com/javaee/6/api/javax/persistence/EntityNotFoundException.html" target="_top">EntityNotFoundException</a>
            the
            <code class="literal">toResponse</code>
            method of the
            <code class="literal">EntityNotFoundMapper</code>
            instance will be invoked.
        </p><p>
            Jersey supports extension of the exception mappers. These extended mappers must implement
            the <code class="literal">org.glassfish.jersey.spi.ExtendedExceptionMapper</code> interface. This interface additionally
            defines method <code class="literal">isMappable(Throwable)</code> which will be invoked by the Jersey runtime
            when exception is thrown and this provider is considered as mappable based on the exception type. Using this
            method the provider can reject mapping of the exception before the method <code class="literal">toResponse</code>
            is invoked. The provider can for example check the exception parameters and based on them return false
            and let other provider to be chosen for the exception mapping.
        </p></div><div class="section" title="6.4.&nbsp;Conditional GETs and Returning 304 (Not Modified) Responses"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3666"></a>6.4.&nbsp;Conditional GETs and Returning 304 (Not Modified) Responses</h2></div></div></div><p>Conditional GETs are a great way to reduce bandwidth, and
            potentially improve on the server-side performance, depending on how the information used
            to determine conditions is calculated. A well-designed web site may for example return
            304 (Not Modified) responses for many of static images it serves.
        </p><p>JAX-RS provides support for conditional GETs using the contextual interface <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Request.html" target="_top">Request</a>.
        </p><p>The following example shows conditional GET support:</p><p>
            </p><div class="example"><a name="d0e3680"></a><p class="title"><b>Example&nbsp;6.7.&nbsp;Conditional GET support</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public SparklinesResource(
  @QueryParam("d") IntegerList data,
  @DefaultValue("0,100") @QueryParam("limits") Interval limits,
  @Context Request request,
  @Context UriInfo ui) {
  if (data == null) {
    throw new WebApplicationException(400);
  }

  this.data = data;
  this.limits = limits;

  if (!limits.contains(data)) {
    throw new WebApplicationException(400);
  }

  this.tag = computeEntityTag(ui.getRequestUri());

  if (request.getMethod().equals("GET")) {
    Response.ResponseBuilder rb = request.evaluatePreconditions(tag);
    if (rb != null) {
      throw new WebApplicationException(rb.build());
    }
  }
}</pre></div></div><p><br class="example-break">
        </p><p>The constructor of the
            <code class="literal">SparklinesResouce</code>
            root
            resource class computes an entity tag from the request URI and then calls
            the
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Request.html#evaluatePreconditions(javax.ws.rs.core.EntityTag)" target="_top">request.evaluatePreconditions</a>
            with that entity tag. If a client request contains an
            <code class="literal">If-None-Match</code>
            header with a value that contains the
            same entity tag that was calculated then the
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Request.html#evaluatePreconditions(javax.ws.rs.core.EntityTag)" target="_top">evaluatePreconditions</a>
            returns a pre-filled out response, with the 304 status code and entity tag
            set, that may be built and returned. Otherwise,
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Request.html#evaluatePreconditions(javax.ws.rs.core.EntityTag)" target="_top">evaluatePreconditions</a>
            returns
            <code class="literal">null</code>
            and the normal response can be
            returned.
        </p><p>Notice that in this example the constructor of a resource class is used
            to perform actions that may otherwise have to be duplicated to
            invoked for each resource method. The life cycle of resource classes is per-request
            which means that the resource instance is created for each request and therefore
            can work with request parameters and for example make changes to the request processing by
            throwing an exception as it is shown in this example.
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;7.&nbsp;JAX-RS Entity Providers"><div class="titlepage"><div><div><h2 class="title"><a name="message-body-workers"></a>Chapter&nbsp;7.&nbsp;JAX-RS Entity Providers</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e3712">7.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e3746">7.2. How to Write Custom Entity Providers</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3783">7.2.1. MessageBodyWriter</a></span></dt><dt><span class="section"><a href="#d0e4071">7.2.2. MessageBodyReader</a></span></dt></dl></dd><dt><span class="section"><a href="#providers-selection">7.3. Entity Provider Selection</a></span></dt><dt><span class="section"><a href="#d0e4632">7.4. Jersey <code class="literal">MessageBodyWorkers</code> API</a></span></dt><dt><span class="section"><a href="#d0e4716">7.5. Default Jersey Entity Providers</a></span></dt></dl></div><div class="section" title="7.1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3712"></a>7.1.&nbsp;Introduction</h2></div></div></div><p>
            Entity payload, if present in an received HTTP message, is passed to Jersey from an I/O container as an input stream.
            The stream may, for example, contain data represented as a plain text, XML or JSON document. However, in many JAX-RS
            components that process these inbound data, such as resource methods or client responses, the JAX-RS API user can
            access the inbound entity as an arbitrary Java object that is created from the content of the input stream based on
            the representation type information. For example, an entity created from an input stream that contains data
            represented as a XML document, can be converted to a custom JAXB bean.
            Similar concept is supported for the outbound entities. An entity returned from the resource method in the form
            of an arbitrary Java object can be serialized by Jersey into a container output stream as a specified representation.
            Of course, while JAX-RS implementations do provide default support for most common combinations of Java type and it's
            respective on-the-wire representation formats, JAX-RS implementations do not support the conversion described above
            for any arbitrary Java type and any arbitrary representation format by default. Instead, a generic extension concept
            is exposed in JAX-RS API to allow application-level customizations of this JAX-RS runtime to support for entity
            conversions. The JAX-RS extension API components that provide the user-level extensibility are typically referred to
            by several terms with the same meaning, such as <span class="emphasis"><em>entity providers</em></span>,
            <span class="emphasis"><em>message body providers</em></span>, <span class="emphasis"><em>message body workers</em></span> or
            <span class="emphasis"><em>message body readers and writers</em></span>. You may find all these terms used interchangeably throughout
            the user guide and they all refer to the same concept.
        </p><p>
            In JAX-RS extension API (or SPI - service provider interface, if you like) the concept is captured in 2 interfaces.
            One for handling inbound entity representation-to-Java de-serialization - <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> and the other
            one for handling the outbound entity Java-to-representation serialization - <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>.
            A <code class="literal">MessageBodyReader&lt;T&gt;</code>, as the name suggests, is an extension that supports reading the message body
            representation from an input stream and converting the data into an instance of a specific Java type.
            A <code class="literal">MessageBodyWriter&lt;T&gt;</code> is then responsible for converting a message payload from an instance of a
            specific Java type into a specific representation format that is sent over the wire to the other party as part of an
            HTTP message exchange.
            Both of these providers can be used to provide message payload serialization and de-serialization support on the
            server as well as the client side. A message body reader or writer is always used whenever a HTTP request or
            response contains an entity and the entity is either requested by the application code (e.g. injected as a parameter
            of JAX-RS resource method or a response entity read on the client from a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Response.html" target="_top">Response</a>) or has to be
            serialized and sent to the other party (e.g. an instance returned from a JAX-RS resource method or a request
            entity sent by a JAX-RS client).
        </p></div><div class="section" title="7.2.&nbsp;How to Write Custom Entity Providers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3746"></a>7.2.&nbsp;How to Write Custom Entity Providers</h2></div></div></div><p>
            A best way how to learn about entity providers is to walk through an example of writing one. Therefore we will
            describe here the process of implementing a custom <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> and
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> using a practical example. Let's first setup the stage by defining a JAX-RS
            resource class for the server side story of our application.

            </p><div class="example"><a name="d0e3757"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;Example resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public class MyResource {
    @GET
    @Produces("application/xml")
    public MyBean getMyBean() {
        return new MyBean("Hello World!", 42);
    }

    @POST
    @Consumes("application/xml")
    public String postMyBean(MyBean myBean) {
        return myBean.anyString;
    }
}</pre></div></div><p><br class="example-break">

            The resource class defines <code class="literal">GET</code> and <code class="literal">POST</code> resource methods. Both methods work with an entity
            that is an instance of <code class="literal">MyBean</code>.
        </p><p>
            The <code class="literal">MyBean</code> class is defined in the next example:

            </p><div class="example"><a name="d0e3777"></a><p class="title"><b>Example&nbsp;7.2.&nbsp;MyBean entity class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class MyBean {
    @XmlElement
    public String anyString;
    @XmlElement
    public int anyNumber;

    public MyBean(String anyString, int anyNumber) {
        this.anyString = anyString;
        this.anyNumber = anyNumber;
    }

    // empty constructor needed for deserialization by JAXB
    public MyBean() {
    }

    @Override
    public String toString() {
        return "MyBean{" +
            "anyString='" + anyString + '\'' +
            ", anyNumber=" + anyNumber +
            '}';
    }
}</pre></div></div><p><br class="example-break">
        </p><div class="section" title="7.2.1.&nbsp;MessageBodyWriter"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3783"></a>7.2.1.&nbsp;MessageBodyWriter</h3></div></div></div><p>
                The <code class="literal">MyBean</code> is a JAXB-annotated POJO. In <code class="literal">GET</code> resource method we return
                the instance of MyBean and we would like Jersey runtime to serialize it into XML and write
                it as an entity body to the response output stream. We design a custom <code class="literal">MessageBodyWriter&lt;T&gt;</code>
                that can serialize this POJO into XML. See the following code sample:

                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Please note, that this is only a demonstration of how to write a custom entity provider.
                        Jersey already contains default support for entity providers that can serialize JAXB beans
                        into XML.
                    </p></div><p>

                </p><div class="example"><a name="d0e3801"></a><p class="title"><b>Example&nbsp;7.3.&nbsp;MessageBodyWriter example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Produces("application/xml")
public class MyBeanMessageBodyWriter implements MessageBodyWriter&lt;MyBean&gt; {

    @Override
    public boolean isWriteable(Class&lt;?&gt; type, Type genericType,
                               Annotation[] annotations, MediaType mediaType) {
        return type == MyBean.class;
    }

    @Override
    public long getSize(MyBean myBean, Class&lt;?&gt; type, Type genericType,
                        Annotation[] annotations, MediaType mediaType) {
        // deprecated by JAX-RS 2.0 and ignored by Jersey runtime
        return 0;
    }

    @Override
    public void writeTo(MyBean myBean,
                        Class&lt;?&gt; type,
                        Type genericType,
                        Annotation[] annotations,
                        MediaType mediaType,
                        MultivaluedMap&lt;String, Object&gt; httpHeaders,
                        OutputStream entityStream)
                        throws IOException, WebApplicationException {

        try {
            JAXBContext jaxbContext = JAXBContext.newInstance(MyBean.class);

            // serialize the entity myBean to the entity output stream
            jaxbContext.createMarshaller().marshal(myBean, entityStream);
        } catch (JAXBException jaxbException) {
            throw new ProcessingException(
                "Error serializing a MyBean to the output stream", jaxbException);
        }
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                The <code class="literal">MyBeanMessageBodyWriter</code> implements the <code class="literal">MessageBodyWriter&lt;T&gt;</code>
                interface that contains three methods. In the next sections we'll explore these methods more closely.
            </p><div class="section" title="7.2.1.1.&nbsp; MessageBodyWriter.isWriteable"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3815"></a>7.2.1.1.&nbsp;
                    <code class="literal">MessageBodyWriter.isWriteable</code>
                </h4></div></div></div><p>
                    A method <code class="literal">isWriteable</code>
                    should return true if the <code class="literal">MessageBodyWriter&lt;T&gt;</code> is able to write the given type. Method
                    does not decide only based on the Java type of the entity but also on annotations attached to the entity
                    and the requested representation media type.
                </p><p>
                    Parameters <code class="literal">type</code> and <code class="literal">genericType</code> both define the entity,
                    where <code class="literal">type</code> is a raw Java type
                    (for example, a <code class="literal">java.util.List</code> class&gt; and <code class="literal">genericType</code> is a
                    <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/ParameterizedType.html" target="_top">ParameterizedType</a> including generic information (for example <code class="literal">List&lt;String&gt;</code>).
                </p><p>
                    Parameter <code class="literal">annotations</code> contains annotations that are either attached to the resource
                    method and/or annotations that are attached to the entity by building response like in the following piece
                    of code:

                    </p><div class="example"><a name="d0e3857"></a><p class="title"><b>Example&nbsp;7.4.&nbsp;Example of assignment of annotations to a response entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public static class AnnotatedResource {

    @GET
    public Response get() {
        Annotation annotation = AnnotatedResource.class
                            .getAnnotation(Path.class);
        return Response.ok()
                .entity("Entity", new Annotation[] {annotation}).build();
    }
}</pre></div></div><p><br class="example-break">

                    In the example above, the <code class="literal">MessageBodyWriter&lt;T&gt;</code> would get
                    <code class="literal">annotations</code> parameter containing a JAX-RS <code class="literal">@GET</code> annotation
                    as it annotates the resource method and also a <code class="literal">@Path</code> annotation as it
                    is passed in the response (but not because it annotates the resource; only resource
                    method annotations are included). In the case of <code class="literal">MyResource</code>
                    and method <code class="literal">getMyBean</code> the annotations would contain the
                    <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/GET.html" target="_top">@GET</a> and the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> annotation.
                </p><p>
                    The last parameter of the <code class="literal">isWriteable</code> method is the <code class="literal">mediaType</code>
                    which is the media type attached to the response entity by annotating the resource method with a
                    <code class="literal">@Produces</code> annotation or the request media type specified in the JAX-RS Client API.
                    In our example, the media type passed to providers for the resource <code class="literal">MyResource</code> and method
                    <code class="literal">getMyBean</code> would be <code class="literal">"application/xml"</code>.
                </p><p>
                    In our implementation of the <code class="literal">isWriteable</code> method, we
                    just check that the type is <code class="literal">MyBean</code>. Please note, that
                    this method might be executed multiple times by Jersey runtime as Jersey needs to check
                    whether this provider can be used for a particular combination of entity Java type, media type, and attached
                    annotations, which may be potentially a performance hog. You can limit the number of execution by
                    properly defining the <code class="literal">@Produces</code> annotation on the <code class="literal">MessageBodyWriter&lt;T&gt;</code>.
                    In our case thanks to <code class="literal">@Produces</code> annotation, the provider will be considered
                    as writeable (and the method <code class="literal">isWriteable</code> might be executed) only if the
                    media type of the outbound message is <code class="literal">"application/xml"</code>. Additionally, the provider
                    will only be considered as possible candidate and its <code class="literal">isWriteable</code> method will
                    be executed, if the generic type of the provider is either a sub class or super class of
                    <code class="literal">type</code> parameter.
                </p></div><div class="section" title="7.2.1.2.&nbsp; MessageBodyWriter.writeTo"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3936"></a>7.2.1.2.&nbsp;
                <code class="literal">MessageBodyWriter.writeTo</code>
            </h4></div></div></div><p>
                Once a message body writer is selected as the most appropriate (see the <a class="xref" href="#providers-selection" title="7.3.&nbsp;Entity Provider Selection">Section&nbsp;7.3, &#8220;Entity Provider Selection&#8221;</a>
                for more details on entity provider selection), its <code class="literal">writeTo</code> method is invoked. This method
                receives parameters with the same meaning as in <code class="literal">isWriteable</code> as well as a few additional ones.
            </p><p>
                In addition to the parameters already introduced, the <code class="literal">writeTo</code> method defies also
                <code class="literal">httpHeaders</code> parameter, that contains HTTP headers associated with the
                outbound message.

                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        When a <code class="literal">MessageBodyWriter&lt;T&gt;</code> is invoked, the headers still can be modified in this point
                        and any modification will be reflected in the outbound HTTP message being sent. The modification of
                        headers must however happen before a first byte is written to the supplied output stream.
                    </p></div><p>
            </p><p>
                Another new parameter, <code class="literal">myBean</code>, contains the entity instance to be serialized (the type of
                entity corresponds to generic type of <code class="literal">MessageBodyWriter&lt;T&gt;</code>). Related parameter
                <code class="literal">entityStream</code> contains the entity output stream to which the method should serialize the entity.
                In our case we use JAXB to marshall the entity into the <code class="literal">entityStream</code>. Note, that the
                <code class="literal">entityStream</code> is not closed at the end of method; the stream will be closed by Jersey.
                </p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                        Do not close the entity output stream in the <code class="literal">writeTo</code> method of your
                        <code class="literal">MessageBodyWriter&lt;T&gt;</code> implementation.
                    </p></div><p>
            </p></div><div class="section" title="7.2.1.3.&nbsp; MessageBodyWriter.getSize"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3994"></a>7.2.1.3.&nbsp;
                <code class="literal">MessageBodyWriter.getSize</code>
            </h4></div></div></div><p>
                The method is deprecated since JAX-RS 2.0 and Jersey 2 ignores the return value. In JAX-RS 1.0 the
                method could return the size of the entity that would be then used for "Content-Length" response
                header. In Jersey 2.0 the "Content-Length" parameter is computed automatically using an internal
                outbound entity buffering. For details about configuration options of outbound entity buffering see the javadoc
                of <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/MessageProperties.html" target="_top">MessageProperties</a>, property <code class="literal">OUTBOUND_CONTENT_LENGTH_BUFFER</code>
                which configures the size of the buffer.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        You can disable the Jersey outbound entity buffering by setting the buffer size to 0.
                    </p></div><p>
            </p></div><div class="section" title="7.2.1.4.&nbsp;Testing a MessageBodyWriter<T&gt;"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4012"></a>7.2.1.4.&nbsp;Testing a <code class="literal">MessageBodyWriter&lt;T&gt;</code></h4></div></div></div><p>
                Before testing the <code class="literal">MyBeanMessageBodyWriter</code>, the writer must
                be registered as a custom JAX-RS extension provider. It should either be added to your application
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a>, or returned from your custom <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a> sub-class, or
                annotated with <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/Provider.html" target="_top">@Provider</a> annotation to leverage JAX-RS provider auto-discovery feature.
            </p><p>
                After registering the <code class="literal">MyBeanMessageBodyWriter</code> and <code class="literal">MyResource</code> class
                in our application, the request can be initiated (in this example from Client API).

                </p><div class="example"><a name="client-get-call"></a><p class="title"><b>Example&nbsp;7.5.&nbsp;Client code testing MyBeanMessageBodyWriter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">WebTarget webTarget = // initialize web target to the context root
            // of example application
Response response = webTarget.path("resource")
                        .request(MediaType.APPLICATION_XML).get();
System.out.println(response.getStatus());
String myBeanXml = response.readEntity(String.class);
System.out.println(myBeanXml);</pre></div></div><p><br class="example-break">

                The client code initiates the <code class="literal">GET</code> which will be matched to the resource method
                <code class="literal">MyResource.getMyBean()</code>. The response entity is de-serialized as a <code class="literal">String</code>.
            </p><p>
                The result of console output is:

                </p><div class="example"><a name="d0e4056"></a><p class="title"><b>Example&nbsp;7.6.&nbsp;Result of MyBeanMessageBodyWriter test</b></p><div class="example-contents"><pre class="screen">200
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;myBean&gt;
&lt;anyString&gt;Hello World!&lt;/anyString&gt;&lt;anyNumber&gt;42&lt;/anyNumber&gt;&lt;/myBean&gt;</pre></div></div><p><br class="example-break">

                The returned status is 200 and the entity is stored in the response in a <code class="literal">XML</code> format.
                Next, we will look at how the Jersey de-serializes this XML document into a <code class="literal">MyBean</code> consumed by
                our <code class="literal">POST</code> resource method.
            </p></div></div><div class="section" title="7.2.2.&nbsp;MessageBodyReader"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4071"></a>7.2.2.&nbsp;MessageBodyReader</h3></div></div></div><p>
                In order to de-serialize the entity of <code class="literal">MyBean</code> on the server or the client, we need to implement
                a custom <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Please note, that this is only a demonstration of how to write a custom entity provider.
                        Jersey already contains default support for entity providers that can serialize JAXB beans
                        into XML.
                    </p></div><p>
            </p><p>
                Our <code class="literal">MessageBodyReader&lt;T&gt;</code> implementation is listed in <a class="xref" href="#mbw.ex.mbr" title="Example&nbsp;7.7.&nbsp;MessageBodyReader example">Example&nbsp;7.7, &#8220;MessageBodyReader example&#8221;</a>.

                </p><div class="example"><a name="mbw.ex.mbr"></a><p class="title"><b>Example&nbsp;7.7.&nbsp;MessageBodyReader example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public static class MyBeanMessageBodyReader
        implements MessageBodyReader&lt;MyBean&gt; {

@Override
public boolean isReadable(Class&lt;?&gt; type, Type genericType,
    Annotation[] annotations, MediaType mediaType) {
    return type == MyBean.class;
}

@Override
public MyBean readFrom(Class&lt;MyBean&gt; type,
    Type genericType,
    Annotation[] annotations, MediaType mediaType,
    MultivaluedMap&lt;String, String&gt; httpHeaders,
    InputStream entityStream)
        throws IOException, WebApplicationException {

    try {
        JAXBContext jaxbContext = JAXBContext.newInstance(MyBean.class);
        MyBean myBean = (MyBean) jaxbContext.createUnmarshaller()
            .unmarshal(entityStream);
        return myBean;
    } catch (JAXBException jaxbException) {
        throw new ProcessingException("Error deserializing a MyBean.",
            jaxbException);
    }
}
}</pre></div></div><p><br class="example-break">

                It is obvious that the <code class="literal">MessageBodyReader&lt;T&gt;</code> interface is similar to <code class="literal">MessageBodyWriter&lt;T&gt;</code>.
                In the next couple of sections we will explore it's API methods.
            </p><div class="section" title="7.2.2.1.&nbsp;MessageBodyReader.isReadable"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4105"></a>7.2.2.1.&nbsp;<code class="literal">MessageBodyReader.isReadable</code></h4></div></div></div><p>
                    It defines the method <code class="literal">isReadable()</code> which has a very simliar meaning as method
                    <code class="literal">isWriteable()</code> in <code class="literal">MessageBodyWriter&lt;T&gt;</code>. The method returns <code class="literal">true</code>
                    if it is able to de-serialize the given type. The <code class="literal">annotations</code> parameter contains annotations
                    that are attached to the entity parameter in the resource method. In our <code class="literal">POST</code> resource
                    method <code class="literal">postMyBean</code> the entity parameter <code class="literal">myBean</code> is not
                    annotated, therefore no annotation will be passed to the isReadable. The <code class="literal">mediaType</code>
                    parameter contains the entity media type. The media type, in our case, must be consumable by the <code class="literal">POST</code>
                    resource method, which is specified by placing a JAX-RS <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Consumes.html" target="_top">@Consumes</a> annotation to the method.
                    The resource method <code class="literal">postMyBean()</code> is annotated with
                    <code class="literal">@Consumes("application/xml")</code>,
                    therefore for purpose of de-serialization of entity for the <code class="literal">postMyBean()</code> method,
                    only requests with entities represented as <code class="literal">"application/xml"</code>
                    media type will match the method. However, this method might be executed for for entity types that are sub classes
                    or super classes of the declared generic type on the <code class="literal">MessageBodyReader&lt;T&gt;</code> will be also considered.
                    It is a responsibility of the <code class="literal">isReadable</code> method to decide whether it is able
                    to de-serialize the entity and type comparison is one of the basic decision steps.
                    </p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                            In order to reduce number of <code class="literal">isReadable</code> executions, always define correctly the consumable
                            media type(s) with the <code class="literal">@Consumes</code> annotation on your custom <code class="literal">MessageBodyReader&lt;T&gt;</code>.
                        </p></div><p>
                </p></div><div class="section" title="7.2.2.2.&nbsp;MessageBodyReader.readFrom"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4175"></a>7.2.2.2.&nbsp;<code class="literal">MessageBodyReader.readFrom</code></h4></div></div></div><p>
                    The <code class="literal">readForm()</code> method gets the parameters with the same meaning as in
                    <code class="literal">isReadable()</code>. The additional <code class="literal">entityStream</code> parameter provides a handle
                    to the entity input stream from which the entity bytes should be read and de-serialized into a Java entity which
                    is then returned from the method. Our <code class="literal">MyBeanMessageBodyReader</code> de-serializes the incoming
                    XML data into an instance of <code class="literal">MyBean</code> using JAXB.

                    </p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                            Do not close the entity input stream in your <code class="literal">MessageBodyReader&lt;T&gt;</code> implementation. The stream
                            will be automatically closed by Jersey runtime.
                        </p></div><p>
                </p></div><div class="section" title="7.2.2.3.&nbsp;Testing a MessageBodyWriter<T&gt;"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4203"></a>7.2.2.3.&nbsp;Testing a <code class="literal">MessageBodyWriter&lt;T&gt;</code></h4></div></div></div><p>
                    Now let's send a test request using the JAX-RS Client API.

                    </p><div class="example"><a name="d0e4210"></a><p class="title"><b>Example&nbsp;7.8.&nbsp;Testing MyBeanMessageBodyReader</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final MyBean myBean = new MyBean("posted MyBean", 11);
Response response = webTarget.path("resource").request("application/xml")
        .post(Entity.entity(myBean, "application/xml"));

System.out.println(response.getStatus());
final String responseEntity = response.readEntity(String.class);
System.out.println(responseEntity);
</pre></div></div><p><br class="example-break">
                </p><p>
                    The console output is:

                    </p><div class="example"><a name="d0e4218"></a><p class="title"><b>Example&nbsp;7.9.&nbsp;Result of testing MyBeanMessageBodyReader</b></p><div class="example-contents"><pre class="screen">200
posted MyBean</pre></div></div><p><br class="example-break">
                </p></div><div class="section" title="7.2.2.4.&nbsp;Using Entity Providers with JAX-RS Client API"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4224"></a>7.2.2.4.&nbsp;Using Entity Providers with JAX-RS Client API</h4></div></div></div><p>
                    Both, <code class="literal">MessageBodyReader&lt;T&gt;</code> and <code class="literal">MessageBodyWriter&lt;T&gt;</code> can be registered in a
                    configuration of JAX-RS Client API components typically without any need to change their code. The example
                    <a class="xref" href="#mbw.ex.client.mbr.reg" title="Example&nbsp;7.10.&nbsp;MessageBodyReader registered on a JAX-RS client">Example&nbsp;7.10, &#8220;MessageBodyReader registered on a JAX-RS client&#8221;</a> is a variation on the <a class="xref" href="#client-get-call" title="Example&nbsp;7.5.&nbsp;Client code testing MyBeanMessageBodyWriter">Example&nbsp;7.5, &#8220;Client code testing MyBeanMessageBodyWriter&#8221;</a>
                    listed in one of the previous sections.

                    </p><div class="example"><a name="mbw.ex.client.mbr.reg"></a><p class="title"><b>Example&nbsp;7.10.&nbsp;MessageBodyReader registered on a JAX-RS client</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
    .register(MyBeanMessageBodyReader.class).build();

Response response = client.target("http://example/comm/resource")
    .request(MediaType.APPLICATION_XML).get();
System.out.println(response.getStatus());
MyBean myBean = response.readEntity(MyBean.class);
System.out.println(myBean);</pre></div></div><p><br class="example-break">
                </p><p>
                    The code above registers <code class="literal">MyBeanMessageBodyReader</code> to the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Client.html" target="_top">Client</a> configuration
                    using a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientBuilder.html" target="_top">ClientBuilder</a> which means that the provider will be used for any <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/WebTarget.html" target="_top">WebTarget</a>
                    produced by the <code class="literal">client</code> instance.
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                            You could also register the JAX-RS entity (and any other) providers to individual
                            <code class="literal">WebTarget</code> instances produced by the client.
                        </p></div><p>

                    Then, using the fluent chain of method invocations, a resource target pointing to our
                    <code class="literal">MyResource</code> is defined, a HTTP <code class="literal">GET</code> request is invoked.
                    The response entity is then read as an instance of a <code class="literal">MyBean</code> type by invoking the
                    <code class="literal">response.readEntity</code> method, that internally locates the registered
                    <code class="literal">MyBeanMessageBodyReader</code> and uses it for entity de-serialization.
                </p><p>
                    The console output for the example is:
                    </p><div class="example"><a name="d0e4286"></a><p class="title"><b>Example&nbsp;7.11.&nbsp;Result of client code execution</b></p><div class="example-contents"><pre class="screen">200
MyBean{anyString='Hello World!', anyNumber=42}</pre></div></div><p><br class="example-break">
                </p></div></div></div><div class="section" title="7.3.&nbsp;Entity Provider Selection"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="providers-selection"></a>7.3.&nbsp;Entity Provider Selection</h2></div></div></div><p>
            Usually there are many entity providers registered on the server or client side (be default there must be
            at least providers mandated by the JAX-RS specification, such as providers for primitive types, byte array,
            JAXB beans, etc.).
            JAX-RS defines an algorithm for selecting the most suitable provider for entity processing. This algorithm
            works with information such as entity Java type and on-the-wire media type representation of entity, and searches
            for the most suitable entity provider from the list of available providers based on the supported media type
            declared on each provider (defined by <code class="literal">@Produces</code> or <code class="literal">@Consumes</code> on the provider class)
            as well as based on the generic type declaration of the available providers. When a list of suitable candidate
            entity providers is selected and sorted based on the rules defined in JAX-RS specification, a JAX-RS runtime
            then it invokes <code class="literal">isReadable</code> or <code class="literal">isWriteable</code> method respectively on each
            provider in the list until a first provider is found that returns <code class="literal">true</code>. This provider is then used to
            process the entity.
        </p><p>
            The following steps describe the algorithm for selecting a <code class="literal">MessageBodyWriter&lt;T&gt;</code> (extracted
            from JAX-RS with little modifications). The steps refer to the previously discussed example application.
            The <code class="literal">MessageBodyWriter&lt;T&gt;</code> is searched for purpose of deserialization of <code class="literal">MyBean</code>
            entity returned from the method <code class="literal">getMyBean</code>. So, <span class="emphasis"><em>type is <code class="literal">MyBean</code>
            and media type <code class="literal">"application/xml"</code></em></span>. Let's assume the runtime contains also
            registered providers, namely:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                    <code class="literal">A</code>: <code class="literal">@Produces("application/*")</code> with generic type
                    <code class="literal">&lt;Object&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">B</code>: <code class="literal">@Produces("*/*")</code> with generic type <code class="literal">&lt;MyBean&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">C</code>: <code class="literal">@Produces("text/plain")</code> with generic type
                    <code class="literal">&lt;MyBean&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">D</code>: <code class="literal">@Produces("application/xml")</code> with generic type
                    <code class="literal">&lt;Object&gt;</code>
                </td></tr><tr><td>
                    <code class="literal">MyBeanMessageBodyWriter</code>: <code class="literal">@Produces("application/xml")</code> with generic
                    type <code class="literal">&lt;MyBean&gt;</code>
                </td></tr></table><p>
        </p><p>
            The algorithm executed by a JAX-RS runtime to select a proper <code class="literal">MessageBodyWriter&lt;T&gt;</code> implementation
            is illustrated in <a class="xref" href="#mbw.writer.selection.algorithm" title="Procedure&nbsp;7.1.&nbsp;MessageBodyWriter<T&gt; Selection Algorithm">Procedure&nbsp;7.1, &#8220;<code class="literal">MessageBodyWriter&lt;T&gt;</code> Selection Algorithm&#8221;</a>.
        </p><div class="procedure" title="Procedure&nbsp;7.1.&nbsp;MessageBodyWriter<T&gt; Selection Algorithm"><a name="mbw.writer.selection.algorithm"></a><p class="title"><b>Procedure&nbsp;7.1.&nbsp;<code class="literal">MessageBodyWriter&lt;T&gt;</code> Selection Algorithm</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>
                    Obtain the object that will be mapped to the message entity body. For a return type of Response
                    or subclasses, the object is the value of the entity property, for other return types it is the returned
                    object.
                </p><p>
                    So in our case, for the resource method <code class="literal">getMyBean</code> the type will
                    be <code class="literal">MyBean</code>.
                </p></li><li class="step" title="Step 2"><p>
                    Determine the media type of the response.
                </p><p>
                    In our case. for resource method <code class="literal">getMyBean</code>
                    annotated with <code class="literal">@Produces("application/xml")</code>, the media type will be
                    <code class="literal">"application/xml"</code>.
                </p></li><li class="step" title="Step 3"><p>
                    Select the set of MessageBodyWriter providers that support the object and media
                    type of the message entity body.
                </p><p>
                    In our case, for entity media type <code class="literal">"application/xml"</code>
                    and type <code class="literal">MyBean</code>, the appropriate <code class="literal">MessageBodyWriter&lt;T&gt;</code> will
                    be the <code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">D</code>
                    and <code class="literal">MyBeanMessageBodyWriter</code>. The provider <code class="literal">C</code> does
                    not define the appropriate
                    media type. <code class="literal">A</code> and <code class="literal">B</code> are fine as
                    their type is more generic and compatible with <code class="literal">"application/xml"</code>.
                </p></li><li class="step" title="Step 4"><a name="mbw.writer.selection.algorithm.sortStep"></a><p>
                    Sort the selected MessageBodyWriter providers with a primary key of generic type where providers
                    whose generic type is the nearest superclass of the object class are sorted first and a secondary key of
                    media type. Additionally, JAX-RS specification mandates that custom, user registered providers have to
                    be sorted ahead of default providers provided by JAX-RS implementation. This is used as a tertiary
                    comparison key. User providers are places prior to Jersey internal providers in to the final ordered list.
                </p><p>
                    The sorted providers will be: <code class="literal">MyBeanMessageBodyWriter</code>,
                    <code class="literal">B</code>. <code class="literal">D</code>, <code class="literal">A</code>.
                </p></li><li class="step" title="Step 5"><p>
                    Iterate through the sorted <code class="literal">MessageBodyWriter&lt;T&gt;</code> providers and, utilizing the
                    <code class="literal">isWriteable</code> method of each until you find a <code class="literal">MessageBodyWriter&lt;T&gt;</code> that
                    returns <code class="literal">true</code>.
                </p><p>
                    The first provider in the list - our <code class="literal">MyBeanMessageBodyWriter</code> returns <code class="literal">true</code> as
                    it compares types and the types matches. If it would return <code class="literal">false</code>, the next provider
                    <code class="literal">B</code> would by check by invoking its <code class="literal">isWriteable</code> method.
                </p></li><li class="step" title="Step 6"><p>
                    If step 5 locates a suitable <code class="literal">MessageBodyWriter&lt;T&gt;</code> then use its writeTo method to map the
                    object to the entity body.
                </p><p>
                    <code class="literal">MyBeanMessageBodyWriter.writeTo</code> will be executed and it will serialize the
                    entity.
                </p><ul class="stepalternatives">
                    <li class="step" title="Step 6.1"><p>
                            Otherwise, the server runtime MUST generate a generate an
                            <code class="literal">InternalServerErrorException</code>, a subclass of
                            <code class="literal">WebApplicationException</code> with its status set to 500, and no entity and the client
                            runtime MUST generate a <code class="literal">ProcessingException</code>.
                        </p><p>
                            We have successfully found a provider, thus no exception is generated.
                        </p></li>
                </ul></li></ol></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                JAX-RS 2.0 is incompatible with JAX-RS 1.x in one step of the entity provider selection algorithm.
                JAX-RS 1.x defines sorting keys priorities in the <a class="xref" href="#mbw.writer.selection.algorithm.sortStep" title="Step 4">Step 4</a>
                in exactly opposite order. So, in JAX-RS 1.x the keys are defined in the order: primary media type,
                secondary type declaration distance where custom providers have always precedence to internal providers.
                If you want to force Jersey to use the algorithm compatible with JAX-RS 1.x, setup the property
                (to <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> or return from <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a> from its
                <code class="literal">getProperties</code> method):

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">jersey.config.workers.legacyOrdering=true</pre><p>

                Documentation of this property can be found in the javadoc of <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/MessageProperties.html" target="_top">MessageProperties</a>.
            </p></div><p>
            The algorithm for selection of <code class="literal">MessageBodyReader&lt;T&gt;</code> is similar, including the incompatibility
            between JAX-RS 2.0 and JAX-RS 1.x and the property to workaround it. The algorithm is defined as follows:
        </p><div class="procedure" title="Procedure&nbsp;7.2.&nbsp;MessageBodyReader<T&gt; Selection Algorithm"><a name="mbw.reader.selection.algorithm"></a><p class="title"><b>Procedure&nbsp;7.2.&nbsp;<code class="literal">MessageBodyReader&lt;T&gt;</code> Selection Algorithm</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>
                    Obtain the media type of the request. If the request does not contain a <code class="literal">Content-Type</code>
                    header then use <code class="literal">application/octet-stream</code> media type.
                </p></li><li class="step" title="Step 2"><p>
                    Identify the Java type of the parameter whose value will be mapped from the entity body. The
                    Java type on the server is the type of the entity parameter of the resource method. On the client
                    it is the <code class="literal">Class</code> passed to <code class="literal">readFrom</code> method.
                </p></li><li class="step" title="Step 3"><p>
                    Select the set of available <code class="literal">MessageBodyReader&lt;T&gt;</code> providers that support the media type
                    of the request.
                </p></li><li class="step" title="Step 4"><a name="mbw.reader.selection.algorithm.selectStep"></a><p>
                    Iterate through the selected <code class="literal">MessageBodyReader&lt;T&gt;</code> classes and, utilizing their
                    <code class="literal">isReadable</code> method, choose the first <code class="literal">MessageBodyReader&lt;T&gt;</code> provider that
                    supports the desired combination of Java type/media type/annotations parameters.
                </p></li><li class="step" title="Step 5"><p>
                    If <a class="xref" href="#mbw.reader.selection.algorithm.selectStep" title="Step 4">Step 4</a> locates a suitable
                    <code class="literal">MessageBodyReader&lt;T&gt;</code>, then use its <code class="literal">readFrom</code> method to map the entity
                    body to the desired Java type.
                </p><ul class="stepalternatives">
                    <li class="step" title="Step 5.1"><p>
                            Otherwise, the server runtime MUST generate a <code class="literal">NotSupportedException</code>
                            (HTTP 415 status code) and no entity and the client runtime MUST generate an instance
                            of <code class="literal">ProcessingException</code>.
                        </p></li>
                </ul></li></ol></div></div><div class="section" title="7.4.&nbsp;Jersey MessageBodyWorkers API"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4632"></a>7.4.&nbsp;Jersey <code class="literal">MessageBodyWorkers</code> API</h2></div></div></div><p>
            In case you need to directly work with JAX-RS entity providers, for example to serialize an entity in your resource
            method, filter or in a composite entity provider, you would need to perform quite a lot of steps.
            You would need to choose the appropriate <code class="literal">MessageBodyWriter&lt;T&gt;</code> based on the type, media type and
            other parameters. Then you would need to instantiate it, check it by <code class="literal">isWriteable</code> method and
            basically perform all the steps that are normally performed by Jersey
            (see <a class="xref" href="#mbw.reader.selection.algorithm" title="Procedure&nbsp;7.2.&nbsp;MessageBodyReader<T&gt; Selection Algorithm">Procedure&nbsp;7.2, &#8220;<code class="literal">MessageBodyReader&lt;T&gt;</code> Selection Algorithm&#8221;</a>).
        </p><p>
            To remove this burden from developers, Jersey exposes a proprietary public API that simplifies the manipulation
            of entity providers. The API is defined by <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/MessageBodyWorkers.html" target="_top">MessageBodyWorkers</a> interface and Jersey provides an
            implementation that can be injected using the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Context.html" target="_top">@Context</a> injection annotation. The interface declares
            methods for selection of most appropriate <code class="literal">MessageBodyReader&lt;T&gt;</code> and <code class="literal">MessageBodyWriter&lt;T&gt;</code>
            based on the rules defined in JAX-RS spec, methods for writing and reading entity that ensure proper and timely
            invocation of interceptors and other useful methods.
        </p><p>
            See the following example of usage of <code class="literal">MessageBodyWorkers</code>.

            </p><div class="example"><a name="d0e4667"></a><p class="title"><b>Example&nbsp;7.12.&nbsp;Usage of MessageBodyWorkers interface</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("workers")
public static class WorkersResource {

    @Context
    private MessageBodyWorkers workers;

    @GET
    @Produces("application/xml")
    public String getMyBeanAsString() {

        final MyBean myBean = new MyBean("Hello World!", 42);

        // buffer into which myBean will be serialized
        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        // get most appropriate MBW
        final MessageBodyWriter&lt;MyBean&gt; messageBodyWriter =
                workers.getMessageBodyWriter(MyBean.class, MyBean.class,
                        new Annotation[]{}, MediaType.APPLICATION_XML_TYPE);

        try {
            // use the MBW to serialize myBean into baos
            messageBodyWriter.writeTo(myBean,
                MyBean.class, MyBean.class, new Annotation[] {},
                MediaType.APPLICATION_XML_TYPE, new MultivaluedHashMap&lt;String, Object&gt;(),
                baos);
        } catch (IOException e) {
            throw new RuntimeException(
                "Error while serializing MyBean.", e);
        }

        final String stringXmlOutput = baos.toString();
        // stringXmlOutput now contains XML representation:
        // "&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
        // &lt;myBean&gt;&lt;anyString&gt;Hello World!&lt;/anyString&gt;
        // &lt;anyNumber&gt;42&lt;/anyNumber&gt;&lt;/myBean&gt;"

        return stringXmlOutput;
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            In the example a resource injects <code class="literal">MessageBodyWorkers</code> and uses it for selection
            of the most appropriate <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Then the writer is utilized to serialize the entity
            into the buffer as XML document. The <code class="literal">String</code> content of the buffer is then returned.
            This will cause that Jersey will not use <code class="literal">MyBeanMessageBodyWriter</code>
            to serialize the entity as it is already in the <code class="literal">String</code> type
            (<code class="literal">MyBeanMessageBodyWriter</code> does not support <code class="literal">String</code>). Instead, a simple
            <code class="literal">String</code>-based  <code class="literal">MessageBodyWriter&lt;T&gt;</code> will be chosen and it will only serialize the
            <code class="literal">String</code> with XML to the output entity stream by writing out the bytes of the
            <code class="literal">String</code>.
        </p><p>
            Of course, the code in the example does not bring any benefit as the entity could
            have been serialized by <code class="literal">MyBeanMessageBodyWriter</code> by Jersey as in previous examples;
            the purpose of the example was to show how to use <code class="literal">MessageBodyWorkers</code> in a resource method.
        </p></div><div class="section" title="7.5.&nbsp;Default Jersey Entity Providers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4716"></a>7.5.&nbsp;Default Jersey Entity Providers</h2></div></div></div><p>
            Jersey internally contains entity providers for these types with combination of media types (in brackets):
        </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <code class="literal">byte[]</code> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/String.html" target="_top">String</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/InputStream.html" target="_top">InputStream</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/Reader.html" target="_top">Reader</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/io/File.html" target="_top">File</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/activation/DataSource.html" target="_top">DataSource</a> (<code class="literal">*/*</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Source.html" target="_top">Source</a> (<code class="literal">text/xml</code>, <code class="literal">application/xml</code> and media types of the form
                <code class="literal">application/*+xml</code>)
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/xml/bind/JAXBElement.html" target="_top">JAXBElement</a> (<code class="literal">text/xml</code>, <code class="literal">application/xml</code> and media types of the form
                <code class="literal">application/*+xml</code>)
            </td></tr><tr><td>
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/MultivaluedMap.html" target="_top">MultivaluedMap&lt;K,V&gt;</a> (<code class="literal">application/x-www-form-urlencoded</code>)
            </td></tr><tr><td>
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Form.html" target="_top">Form</a> (<code class="literal">application/x-www-form-urlencoded</code>)
            </td></tr><tr><td>
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/StreamingOutput.html" target="_top">StreamingOutput</a> ((<code class="literal">*/*</code>)) - this class can be used as an lightweight
                <code class="literal">MessageBodyWriter&lt;T&gt;</code> that can be returned from a resource method
            </td></tr><tr><td>
                <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Boolean.html" target="_top">Boolean</a>, <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Character.html" target="_top">Character</a> and <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Number.html" target="_top">Number</a> (<code class="literal">text/plain</code>) - corresponding
                primitive types supported via boxing/unboxing conversion
            </td></tr></table><p>
            For other media type supported in jersey please see the <a class="xref" href="#media" title="Chapter&nbsp;8.&nbsp;Support for Common Media Type Representations">Chapter&nbsp;8, <i>Support for Common Media Type Representations</i></a> which describes
            additional Jersey entity provider extensions for serialization to JSON, XML, serialization of collections,
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/multipart/package-info.html" target="_top">Multi Part</a> and others.
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;8.&nbsp;Support for Common Media Type Representations"><div class="titlepage"><div><div><h2 class="title"><a name="media"></a>Chapter&nbsp;8.&nbsp;Support for Common Media Type Representations</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#json">8.1. JSON</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4883">8.1.1. Approaches to JSON Support</a></span></dt><dt><span class="section"><a href="#json.moxy">8.1.2. MOXy</a></span></dt><dt><span class="section"><a href="#json.json-p">8.1.3. Java API for JSON Processing (JSON-P)</a></span></dt><dt><span class="section"><a href="#json.jackson">8.1.4. Jackson</a></span></dt><dt><span class="section"><a href="#json.jettison">8.1.5. Jettison</a></span></dt><dt><span class="section"><a href="#d0e5633">8.1.6. <code class="literal">@JSONP</code> - JSON with Padding Support</a></span></dt></dl></dd><dt><span class="section"><a href="#xml">8.2. XML</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e5800">8.2.1. Low level XML support</a></span></dt><dt><span class="section"><a href="#d0e5848">8.2.2. Getting started with JAXB</a></span></dt><dt><span class="section"><a href="#d0e5936">8.2.3. POJOs</a></span></dt><dt><span class="section"><a href="#d0e5974">8.2.4. Using custom JAXBContext</a></span></dt><dt><span class="section"><a href="#d0e6006">8.2.5. MOXy</a></span></dt></dl></dd><dt><span class="section"><a href="#multipart">8.3. Multipart</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6059">8.3.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e6160">8.3.2. Client</a></span></dt><dt><span class="section"><a href="#d0e6277">8.3.3. Server</a></span></dt></dl></dd></dl></div><div class="section" title="8.1.&nbsp;JSON"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="json"></a>8.1.&nbsp;JSON</h2></div></div></div><p>
            Jersey JSON support comes as a set of extension modules where each of these modules contains an implementation of
            a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Feature.html" target="_top">Feature</a> that needs to be registered into your <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a> instance (client/server).
            There are multiple frameworks that provide support for JSON processing and/or JSON-to-Java binding.
            The modules listed bellow provide support for JSON representations by integrating the individual JSON frameworks into
            Jersey. At present, Jersey integrates with the following modules to provide JSON support:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        <a class="link" href="#json.moxy" title="8.1.2.&nbsp;MOXy">MOXy</a> - JSON binding support via MOXy is a default and preferred way of supporting JSON binding
                        in your Jersey applications since Jersey 2.0. When JSON MOXy module is on the class-path, Jersey will
                        automatically discover the module and seamlessly enable JSON binding support via MOXy in your
                        applications. (See <a class="xref" href="#deployment.autodiscoverable" title="4.1.&nbsp;Auto-Discoverable Features">Section&nbsp;4.1, &#8220;Auto-Discoverable Features&#8221;</a>.)
                    </p></li><li class="listitem"><p><a class="link" href="#json.json-p" title="8.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a></p></li><li class="listitem"><p><a class="link" href="#json.jackson" title="8.1.4.&nbsp;Jackson">Jackson</a></p></li><li class="listitem"><p><a class="link" href="#json.jettison" title="8.1.5.&nbsp;Jettison">Jettison</a></p></li></ul></div><p>
        </p><div class="section" title="8.1.1.&nbsp;Approaches to JSON Support"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4883"></a>8.1.1.&nbsp;Approaches to JSON Support</h3></div></div></div><p>
                Each of the aforementioned extension modules uses one or more of the three basic approaches available when
                working with JSON representations:

                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>POJO based JSON binding support</p></li><li class="listitem"><p>JAXB based JSON binding support</p></li><li class="listitem"><p>Low-level JSON parsing &amp; processing support</p></li></ul></div><p>

                The first method is pretty generic and allows you to map any Java Object to JSON and vice versa.
                The other two approaches limit you in Java types your resource methods could produce and/or consume.
                JAXB based approach is useful if you plan to utilize certain JAXB features and support both XML and JSON
                representations. The last, low-level, approach gives you the best fine-grained control over the out-coming
                JSON data format.
            </p><div class="section" title="8.1.1.1.&nbsp;POJO support"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4899"></a>8.1.1.1.&nbsp;POJO support</h4></div></div></div><p>POJO support represents the easiest way to convert your Java Objects to JSON and back.</p><p>Media modules that support this approach are <a class="link" href="#json.moxy" title="8.1.2.&nbsp;MOXy">MOXy</a> and <a class="link" href="#json.jackson" title="8.1.4.&nbsp;Jackson">Jackson</a></p></div><div class="section" title="8.1.1.2.&nbsp;JAXB based JSON support"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4911"></a>8.1.1.2.&nbsp;JAXB based JSON support</h4></div></div></div><p>
                    Taking this approach will save you a lot of time, if you want to easily produce/consume both JSON and XML
                    data format. With JAXB beans you will be able to use a the same Java model to generate JSON as well as XML
                    representations.
                    Another advantage is simplicity of working with such a model and availability of the API in Java SE Platform.
                    JAXB leverages annotated POJOs and these could be handled as simple Java beans.
                </p><p>
                    A disadvantage of JAXB based approach could be if you need to work with a very specific JSON format. Then it
                    might be difficult to find a proper way to get such a format produced and consumed. This is a reason why a
                    lot of configuration options are provided, so that you can control how JAXB beans get serialized and
                    de-serialized. The extra configuration options however requires you to learn more details about the framework
                    you are using.
                </p><p>
                    Following is a very simple example of how a JAXB bean could look like.

                    </p><div class="example"><a name="d0e4920"></a><p class="title"><b>Example&nbsp;8.1.&nbsp;Simple JAXB bean implementation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class MyJaxbBean {
    public String name;
    public int age;

    public MyJaxbBean() {} // JAXB needs this

    public MyJaxbBean(String name, int age) {
        this.name = name;
        this.age = age;
    }
}</pre></div></div><p><br class="example-break">

                    Using the above JAXB bean for producing JSON data format from you resource method, is then as simple as:

                    </p><div class="example"><a name="d0e4926"></a><p class="title"><b>Example&nbsp;8.2.&nbsp;JAXB bean used to generate JSON representation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces("application/json")
public MyJaxbBean getMyBean() {
    return new MyJaxbBean("Agamemnon", 32);
}</pre></div></div><p><br class="example-break">

                    Notice, that JSON specific mime type is specified in <code class="literal">@Produces</code> annotation, and the method returns
                    an instance of <code class="literal">MyJaxbBean</code>, which JAXB is able to process. Resulting JSON in this case
                    would look like:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: text;&#xA;    gutter: false;">{"name":"Agamemnon", "age":"32"}</pre><p>
                </p><p>
                    A proper use of JAXB annotations itself enables you to control output JSON format to certain extent.
                    Specifically, renaming and omitting items is easy to do directly just by using JAXB annotations.
                    For example, the following example depicts changes in the above mentioned MyJaxbBean that will result in
                    <code class="literal">{"king":"Agamemnon"}</code> JSON output.

                    </p><div class="example"><a name="d0e4946"></a><p class="title"><b>Example&nbsp;8.3.&nbsp;Tweaking JSON format using JAXB</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class MyJaxbBean {

    @XmlElement(name="king")
    public String name;

    @XmlTransient
    public int age;

    // several lines removed
}</pre></div></div><p><br class="example-break">
                </p><p>Media modules that support this approach are <a class="link" href="#json.moxy" title="8.1.2.&nbsp;MOXy">MOXy</a>, <a class="link" href="#json.jackson" title="8.1.4.&nbsp;Jackson">Jackson</a>, <a class="link" href="#json.jettison" title="8.1.5.&nbsp;Jettison">Jettison</a></p></div><div class="section" title="8.1.1.3.&nbsp;Low-level based JSON support"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4962"></a>8.1.1.3.&nbsp;Low-level based JSON support</h4></div></div></div><p>
                    JSON Processing API is a new standard API for parsing and processing JSON structures in similar way to what
                    SAX and StAX parsers provide for XML. The API is part of Java EE 7 and later. Another such JSON
                    parsing/processing API is provided by Jettison framework. Both APIs provide a low-level access to producing
                    and consuming JSON data structures. By adopting this low-level approach you would be working with
                    <code class="literal">JsonObject</code> (or <code class="literal">JSONObject</code> respectively) and/or
                    <code class="literal">JsonArray</code> (or <code class="literal">JSONArray</code> respectively) classes when processing your
                    JSON data representations.
                </p><p>
                    The biggest advantage of these low-level APIs is that you will gain full control over the JSON format
                    produced and consumed. You will also be able to produce and consume very large JSON structures using
                    streaming JSON parser/generator APIs.
                    On the other hand, dealing with your data model objects will probably be a lot more complex, compared
                    to the POJO or JAXB based binding approach. Differences are depicted at the following code snippets.
                </p><p>
                    Let's start with JAXB-based approach.

                    </p><div class="example"><a name="d0e4983"></a><p class="title"><b>Example&nbsp;8.4.&nbsp;JAXB bean creation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">MyJaxbBean myBean = new MyJaxbBean("Agamemnon", 32);</pre></div></div><p><br class="example-break">

                    Above you construct a simple JAXB bean, which could be written in JSON as
                    <code class="literal">{"name":"Agamemnon", "age":32}</code>
                </p><p>
                    Now to build an equivalent <code class="literal">JsonObject</code>/<code class="literal">JSONObject</code> (in terms of
                    resulting JSON expression), you would need several more lines of code. The following example illustrates
                    how to construct the same JSON data using the standard Java EE 7 JSON-Processing API.
                    </p><div class="example"><a name="d0e5000"></a><p class="title"><b>Example&nbsp;8.5.&nbsp;Constructing a <code class="literal">JsonObject</code> (JSON-Processing)</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">JsonObject myObject = Json.createObjectBuilder()
        .add("name", "Agamemnon")
        .add("age", 32)
        .build();</pre></div></div><p><br class="example-break">

                    And at last, here's how the same work can be done with Jettison API.
                    </p><div class="example"><a name="d0e5009"></a><p class="title"><b>Example&nbsp;8.6.&nbsp;Constructing a <code class="literal">JSONObject</code> (Jettison)</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">JSONObject myObject = new JSONObject();
try {
    myObject.put("name", "Agamemnon");
    myObject.put("age", 32);
} catch (JSONException ex) {
    LOGGER.log(Level.SEVERE, "Error ...", ex);
}</pre></div></div><p><br class="example-break">
                </p><p>
                    Media modules that support the low-level JSON parsing and generating approach are <a class="link" href="#json.json-p" title="8.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a>
                    and <a class="link" href="#json.jettison" title="8.1.5.&nbsp;Jettison">Jettison</a>. Unless you have a strong reason for using the non-standard <a class="link" href="#json.jettison" title="8.1.5.&nbsp;Jettison">Jettison</a> API,
                    we recommend you to use the new standard <a class="link" href="#json.json-p" title="8.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a> API instead.
                </p></div></div><div class="section" title="8.1.2.&nbsp;MOXy"><div class="titlepage"><div><div><h3 class="title"><a name="json.moxy"></a>8.1.2.&nbsp;MOXy</h3></div></div></div><div class="section" title="8.1.2.1.&nbsp;Dependency"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5035"></a>8.1.2.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use MOXy as your JSON provider you need to add <code class="literal">jersey-media-moxy</code> module to your <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-moxy&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-moxy/dependencies.html" target="_top">jersey-media-moxy</a>) on the classpath.
                </p></div><div class="section" title="8.1.2.2.&nbsp;Configure and register"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5052"></a>8.1.2.2.&nbsp;Configure and register</h4></div></div></div><p>
                    As stated in the <a class="xref" href="#deployment.autodiscoverable" title="4.1.&nbsp;Auto-Discoverable Features">Section&nbsp;4.1, &#8220;Auto-Discoverable Features&#8221;</a> as well as earlier in this chapter, MOXy media
                    module is one of the modules where you don't need to explicitly register it's <code class="literal">Feature</code>s
                    (<code class="literal">MoxyJsonFeature</code>) in your client/server <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a> as this feature is
                    automatically discovered and registered when you add <code class="literal">jersey-media-moxy</code> module to your class-path.
                </p><p>
                    The auto-discoverable <code class="literal">jersey-media-moxy</code> module defines a few properties that can be used to control the
                    automatic registration of <code class="literal">MoxyJsonFeature</code> (besides the generic
                    <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a> an the its client/server variants):

                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">CommonProperties.MOXY_JSON_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">ServerProperties.MOXY_JSON_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">ClientProperties.MOXY_JSON_FEATURE_DISABLE</a></p></li></ul></div><p>
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        A manual registration of any other Jersey JSON provider feature (except for <a class="link" href="#json.json-p" title="8.1.3.&nbsp;Java API for JSON Processing (JSON-P)">Java API for JSON Processing (JSON-P)</a>)
                        disables the automated enabling and configuration of <code class="literal">MoxyJsonFeature</code>.
                    </p></div><p>
                    To configure <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>s / <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>s provided by MOXy you can simply
                    create an instance of <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html" target="_top">MoxyJsonConfig</a> and set values of needed properties. For most common
                    properties you can use a particular method to set the value of the property or you can use more generic
                    methods to set the property:

                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html#property(java.lang.String, java.lang.Object)" target="_top">MoxyJsonConfig#property(java.lang.String, java.lang.Object)</a> - sets a property value for both Marshaller and Unmarshaller.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html#marshallerProperty(java.lang.String, java.lang.Object)" target="_top">MoxyJsonConfig#marshallerProperty(java.lang.String, java.lang.Object)</a> - sets a property value for Marshaller.
                            </p></li><li class="listitem"><p>
                                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html#unmarshallerProperty(java.lang.String, java.lang.Object)" target="_top">MoxyJsonConfig#unmarshallerProperty(java.lang.String, java.lang.Object)</a> - sets a property value for Unmarshaller.
                            </p></li></ul></div><p>

                    </p><div class="example"><a name="d0e5136"></a><p class="title"><b>Example&nbsp;8.7.&nbsp;<a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html" target="_top">MoxyJsonConfig</a> - Setting properties.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Map&lt;String, String&gt; namespacePrefixMapper = new HashMap&lt;String, String&gt;();
namespacePrefixMapper.put("http://www.w3.org/2001/XMLSchema-instance", "xsi");

final MoxyJsonConfig configuration = new MoxyJsonConfig()
        .setNamespacePrefixMapper(namespacePrefixMapper)
        .setNamespaceSeparator(':');
                        </pre></div></div><p><br class="example-break">

                    In order to make <code class="literal">MoxyJsonConfig</code> visible for MOXy you need to create and register
                    <code class="literal">ContextResolver&lt;T&gt;</code> in your client/server code.

                    </p><div class="example"><a name="d0e5150"></a><p class="title"><b>Example&nbsp;8.8.&nbsp;<code class="literal">ContextResolver&lt;MoxyJsonConfig&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class JsonMoxyConfigurationContextResolver implements ContextResolver&lt;MoxyJsonConfig&gt; {

    private final MoxyJsonConfig config;

    public JsonMoxyConfigurationContextResolver() {
        final Map&lt;String, String&gt; namespacePrefixMapper = new HashMap&lt;String, String&gt;();
        namespacePrefixMapper.put("http://www.w3.org/2001/XMLSchema-instance", "xsi");

        config = MoxyJsonConfig()
            .setNamespacePrefixMapper(namespacePrefixMapper)
            .setNamespaceSeparator(':');
    }

    @Override
    public MoxyJsonConfig getContext(Class&lt;?&gt; objectType) {
        return config;
    }
}</pre></div></div><p><br class="example-break">
                </p><p>
                    Another way to pass configuration properties to the underlying <code class="literal">MOXyJsonProvider</code> is to set
                    them directly into your <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a> instance (see an example below). These are overwritten by
                    properties set into the <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/moxy/json/MoxyJsonConfig.html" target="_top">MoxyJsonConfig</a>.

                    </p><div class="example"><a name="d0e5168"></a><p class="title"><b>Example&nbsp;8.9.&nbsp;Setting properties for MOXy providers into <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
                            .property(MarshallerProperties.JSON_NAMESPACE_SEPARATOR, ".")
                            // further configuration</pre></div></div><p><br class="example-break">
                </p><p>
                    There are some properties for which Jersey sets the default value when
                    <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> / <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> from MOXy is used and they are:

                    </p><div class="table"><a name="d0e5184"></a><p class="title"><b>Table&nbsp;8.1.&nbsp;Default property values for MOXy <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> / <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a></b></p><div class="table-contents"><table summary="Default property values for MOXy MessageBodyReader<T&gt; / MessageBodyWriter<T&gt;" border="1"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><td align="left"><code class="literal">javax.xml.bind.Marshaller#JAXB_FORMATTED_OUTPUT</code></td><td align="left"><code class="literal">false</code></td></tr><tr><td align="left">
                                        <code class="literal">org.eclipse.persistence.jaxb.JAXBContextProperties#JSON_INCLUDE_ROOT</code>
                                    </td><td align="left"><code class="literal">false</code></td></tr><tr><td align="left">
                                        <code class="literal">org.eclipse.persistence.jaxb.MarshallerProperties#JSON_MARSHAL_EMPTY_COLLECTIONS</code>
                                    </td><td align="left"><code class="literal">true</code></td></tr><tr><td align="left">
                                        <code class="literal">org.eclipse.persistence.jaxb.JAXBContextProperties#JSON_NAMESPACE_SEPARATOR</code>
                                    </td><td align="left"><code class="literal">org.eclipse.persistence.oxm.XMLConstants#DOT</code></td></tr></tbody></table></div></div><p><br class="table-break">
                </p><div class="example"><a name="d0e5229"></a><p class="title"><b>Example&nbsp;8.10.&nbsp;Building client with MOXy JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
        // The line bellow that registers MOXy feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is
        // not disabled.
        .register(MoxyJsonFeature.class)
        .register(JsonMoxyConfigurationContextResolver.class)
        .build();</pre></div></div><br class="example-break"><div class="example"><a name="d0e5234"></a><p class="title"><b>Example&nbsp;8.11.&nbsp;Creating JAX-RS application with MOXy JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        .packages("org.glassfish.jersey.examples.jsonmoxy")
        // The line bellow that registers MOXy feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is
        // not disabled.
        .register(MoxyJsonFeature.class)
        .register(JsonMoxyConfigurationContextResolver.class);</pre></div></div><br class="example-break"></div><div class="section" title="8.1.2.3.&nbsp;Examples"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5239"></a>8.1.2.3.&nbsp;Examples</h4></div></div></div><p>
                    Jersey provides an <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/json-moxy" target="_top">JSON MOXy example</a> on how to use MOXy to consume/produce JSON.
                </p></div></div><div class="section" title="8.1.3.&nbsp;Java API for JSON Processing (JSON-P)"><div class="titlepage"><div><div><h3 class="title"><a name="json.json-p"></a>8.1.3.&nbsp;Java API for JSON Processing (JSON-P)</h3></div></div></div><div class="section" title="8.1.3.1.&nbsp;Dependency"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5250"></a>8.1.3.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use JSON-P as your JSON provider you need to add <code class="literal">jersey-media-json-processing</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-processing&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-json-processing/dependencies.html" target="_top">jersey-media-json-processing</a>)
                    on the class-path.
                </p></div><div class="section" title="8.1.3.2.&nbsp;Configure and register"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5267"></a>8.1.3.2.&nbsp;Configure and register</h4></div></div></div><p>
                    As stated in <a class="xref" href="#deployment.autodiscoverable" title="4.1.&nbsp;Auto-Discoverable Features">Section&nbsp;4.1, &#8220;Auto-Discoverable Features&#8221;</a> JSON-Processing media module is one of the
                    modules where you don't need to explicitly register it's
                    <code class="literal">Feature</code>s (<code class="literal">JsonProcessingFeature</code>) in your client/server
                    <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a> as this feature is automatically discovered and registered when you add
                    <code class="literal">jersey-media-json-processing</code> module to your classpath.
                </p><p>
                    As for the other modules, <code class="literal">jersey-media-json-processing</code> has also few properties that can affect the
                    registration of <code class="literal">JsonProcessingFeature</code>
                    (besides <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a> and the like):

                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">CommonProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">ServerProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">ClientProperties.JSON_PROCESSING_FEATURE_DISABLE</a></p></li></ul></div><p>
                </p><p>
                    To configure <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>s / <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>s provided by JSON-P you can simply
                    add values for supported properties into the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configuration.html" target="_top">Configuration</a> instance (client/server). Currently
                    supported are these properties:

                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                                <code class="literal">JsonGenerator.PRETTY_PRINTING</code>
                                ("<code class="literal">javax.json.stream.JsonGenerator.prettyPrinting</code>")
                            </p></li></ul></div><p>
                </p><div class="example"><a name="d0e5333"></a><p class="title"><b>Example&nbsp;8.12.&nbsp;Building client with JSON-Processing JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientBuilder.newClient(new ClientConfig()
        // The line bellow that registers JSON-Processing feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is not disabled.
        .register(JsonProcessingFeature.class)
        .property(JsonGenerator.PRETTY_PRINTING, true)
);</pre></div></div><br class="example-break"><div class="example"><a name="d0e5338"></a><p class="title"><b>Example&nbsp;8.13.&nbsp;Creating JAX-RS application with JSON-Processing JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        // The line bellow that registers JSON-Processing feature can be
        // omitted if FEATURE_AUTO_DISCOVERY_DISABLE is not disabled.
        .register(JsonProcessingFeature.class)
        .packages("org.glassfish.jersey.examples.jsonp")
        .property(JsonGenerator.PRETTY_PRINTING, true);</pre></div></div><br class="example-break"></div><div class="section" title="8.1.3.3.&nbsp;Examples"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5343"></a>8.1.3.3.&nbsp;Examples</h4></div></div></div><p>Jersey provides an <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/json-processing-webapp" target="_top">JSON Processing example</a> on how to use JSON-Processing to
                    consume/produce JSON.</p></div></div><div class="section" title="8.1.4.&nbsp;Jackson"><div class="titlepage"><div><div><h3 class="title"><a name="json.jackson"></a>8.1.4.&nbsp;Jackson</h3></div></div></div><div class="section" title="8.1.4.1.&nbsp;Dependency"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5354"></a>8.1.4.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use Jackson as your JSON provider you need to add <code class="literal">jersey-media-json-jackson</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-jackson&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-json-jackson/dependencies.html" target="_top">jersey-media-json-jackson</a>) on
                    the classpath.
                </p></div><div class="section" title="8.1.4.2.&nbsp;Configure and register"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5371"></a>8.1.4.2.&nbsp;Configure and register</h4></div></div></div><p>
                    Jackson JSON processor could be controlled via providing a custom Jackson <a class="link" href="http://jackson.codehaus.org/1.9.11/javadoc/org/codehaus/jackson/map/ObjectMapper.html" target="_top">ObjectMapper</a>
                    instance.
                    This could be handy if you need to redefine the default Jackson behaviour and to fine-tune how your JSON data
                    structures look like. Detailed description of all Jackson features is out of scope of this guide. The example
                    bellow gives you a hint on how to wire your <code class="literal">ObjectMapper</code> instance into your Jersey
                    application.
                </p><p>
                    In order to use Jackson as your JSON (JAXB/POJO) provider you need to register <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/jackson/JacksonFeature.html" target="_top">JacksonFeature</a>
                    and a <code class="literal">ContextResolver&lt;T&gt;</code> for <code class="literal">ObjectMapper</code> (if needed) in your
                    <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a> (client/server).

                    </p><div class="example"><a name="d0e5396"></a><p class="title"><b>Example&nbsp;8.14.&nbsp;<code class="literal">ContextResolver&lt;ObjectMapper&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class MyObjectMapperProvider implements ContextResolver&lt;ObjectMapper&gt; {

    final ObjectMapper defaultObjectMapper;
    final ObjectMapper combinedObjectMapper;

    public MyObjectMapperProvider() {
        defaultObjectMapper = createDefaultMapper();
        combinedObjectMapper = createCombinedObjectMapper();
    }

    @Override
    public ObjectMapper getContext(Class&lt;?&gt; type) {
        if (type == CombinedAnnotationBean.class) {
            return combinedObjectMapper;
        } else {
            return defaultObjectMapper;
        }
    }

    private static ObjectMapper createDefaultMapper() {
        final ObjectMapper result = new ObjectMapper();
        result.configure(Feature.INDENT_OUTPUT, true);

        return result;
    }

    // ...
}</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e5403"></a><p class="title"><b>Example&nbsp;8.15.&nbsp;Building client with Jackson JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
        .register(MyObjectMapperProvider.class)  // No need to register this provider if no special configuration is required.
        .register(JacksonFeature.class)
        .build();</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e5409"></a><p class="title"><b>Example&nbsp;8.16.&nbsp;Creating JAX-RS application with Jackson JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        .packages("org.glassfish.jersey.examples.jackson")
        .register(MyObjectMapperProvider.class)  // No need to register this provider if no special configuration is required.
        .register(JacksonFeature.class);</pre></div></div><p><br class="example-break">
                </p></div><div class="section" title="8.1.4.3.&nbsp;Examples"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5415"></a>8.1.4.3.&nbsp;Examples</h4></div></div></div><p>
                    Jersey provides an <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/json-jackson" target="_top">JSON Jackson example</a> on how to use Jackson to consume/produce JSON.
                </p></div></div><div class="section" title="8.1.5.&nbsp;Jettison"><div class="titlepage"><div><div><h3 class="title"><a name="json.jettison"></a>8.1.5.&nbsp;Jettison</h3></div></div></div><p>
                JAXB approach for (de)serializing JSON in Jettison module provides, in addition to using pure JAXB,
                configuration options that could be set on an <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/jettison/JettisonConfig.html" target="_top">JettisonConfig</a> instance. The instance could be then
                further used to create a <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/jettison/JettisonJaxbContext.html" target="_top">JettisonJaxbContext</a>, which serves as a main configuration point in this
                area.
                To pass your specialized <code class="literal">JettisonJaxbContext</code> to Jersey, you will finally need to implement
                a JAXBContext <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/ContextResolver.html" target="_top">ContextResolver&lt;T&gt;</a> (see below).
            </p><div class="section" title="8.1.5.1.&nbsp;Dependency"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5440"></a>8.1.5.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use Jettison as your JSON provider you need to add <code class="literal">jersey-media-json-jettison</code> module to your
                    <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-json-jettison&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-json-jettison/dependencies.html" target="_top">jersey-media-json-jettison</a>) on
                    the classpath.
                </p></div><div class="section" title="8.1.5.2.&nbsp;JSON Notations"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5457"></a>8.1.5.2.&nbsp;JSON Notations</h4></div></div></div><p>
                    <code class="literal">JettisonConfig</code> allows you to use two JSON notations. Each of these notations serializes
                    JSON in a different way. Following is a list of supported notations:

                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>JETTISON_MAPPED (default notation)</p></li><li class="listitem"><p>BADGERFISH</p></li></ul></div><p>

                    You might want to use one of these notations, when working with more complex XML documents. Namely when you
                    deal with multiple XML namespaces in your JAXB beans.
                </p><p>
                    Individual notations and their further configuration options are described bellow. Rather then explaining
                    rules for mapping XML constructs into JSON, the notations will be described using a simple example. Following
                    are JAXB beans, which will be used.

                    </p><div class="example"><a name="d0e5475"></a><p class="title"><b>Example&nbsp;8.17.&nbsp;JAXB beans for JSON supported notations description, simple address bean</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class Address {
    public String street;
    public String town;

    public Address(){}

    public Address(String street, String town) {
        this.street = street;
        this.town = town;
    }
}</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e5481"></a><p class="title"><b>Example&nbsp;8.18.&nbsp;JAXB beans for JSON supported notations description, contact bean</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class Contact {

    public int id;
    public String name;
    public List&lt;Address&gt; addresses;

    public Contact() {};

    public Contact(int id, String name, List&lt;Address&gt; addresses) {
        this.name = name;
        this.id = id;
        this.addresses =
            (addresses != null) ? new LinkedList&lt;Address&gt;(addresses) : null;
    }
}</pre></div></div><p><br class="example-break">
                </p><p>
                    Following text will be mainly working with a contact bean initialized with:

                    </p><div class="example"><a name="d0e5489"></a><p class="title"><b>Example&nbsp;8.19.&nbsp;JAXB beans for JSON supported notations description, initialization</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Address[] addresses = {new Address("Long Street 1", "Short Village")};
Contact contact = new Contact(2, "Bob", Arrays.asList(addresses));</pre></div></div><p><br class="example-break">

                    I.e. contact bean with <code class="literal">id=2</code>, <code class="literal">name="Bob"</code> containing
                    a single address (<code class="literal">street="Long Street 1"</code>, <code class="literal">town="Short Village"</code>).
                </p><p>
                    All bellow described configuration options are documented also in api-docs at <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/jettison/JettisonConfig.html" target="_top">JettisonConfig</a>.
                </p><div class="section" title="8.1.5.2.1.&nbsp;Jettison mapped notation"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5512"></a>8.1.5.2.1.&nbsp;Jettison mapped notation</h5></div></div></div><p>
                        If you need to deal with various XML namespaces, you will find Jettison <code class="literal">mapped</code>
                        notation pretty useful. Lets define a particular namespace for <code class="code">id</code> item:

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
@XmlElement(namespace="http://example.com")
public int id;
...</pre><p>

                        Then you simply configure a mapping from XML namespace into JSON prefix as follows:

                        </p><div class="example"><a name="json.jaxb.jettison.mapped.ns.def"></a><p class="title"><b>Example&nbsp;8.20.&nbsp;
                                XML namespace to JSON mapping configuration for Jettison based <code class="literal">mapped</code> notation
                            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Map&lt;String,String&gt; ns2json = new HashMap&lt;String, String&gt;();
ns2json.put("http://example.com", "example");
context = new JettisonJaxbContext(
    JettisonConfig.mappedJettison().xml2JsonNs(ns2json).build(),
    types);</pre></div></div><p><br class="example-break">

                        Resulting JSON will look like in the example bellow.

                        </p><div class="example"><a name="d0e5535"></a><p class="title"><b>Example&nbsp;8.21.&nbsp;JSON expression with XML namespaces mapped into JSON</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "contact":{
      "example.id":2,
      "name":"Bob",
      "addresses":{
         "street":"Long Street 1",
         "town":"Short Village"
      }
   }
}</pre></div></div><p><br class="example-break">

                        Please note, that <code class="code">id</code> item became <code class="code">example.id</code> based on the XML namespace mapping.
                        If you have more XML namespaces in your XML, you will need to configure appropriate mapping for all of
                        them.
                    </p><p>
                        Another configurable option introduced in Jersey version 2.2 is related to serialization of JSON arrays with Jettison's
                        mapped notation. When serializing elements representing single item lists/arrays, you might want to utilise
                        the following Jersey configuration method to explicitly name which elements to treat as arrays no matter what the actual content is.

                        </p><div class="example"><a name="json.jaxb.jettison.mapped.array.def"></a><p class="title"><b>Example&nbsp;8.22.&nbsp;
                                JSON Array configuration for Jettison based <code class="literal">mapped</code> notation
                            </b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">context = new JettisonJaxbContext(
    JettisonConfig.mappedJettison().serializeAsArray("name").build(),
    types);</pre></div></div><p><br class="example-break">

                        Resulting JSON will look like in the example bellow, unimportant lines removed for sanity.

                        </p><div class="example"><a name="d0e5558"></a><p class="title"><b>Example&nbsp;8.23.&nbsp;JSON expression with JSON arrays explicitly configured via Jersey</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "contact":{
      ...
      "name":["Bob"],
      ...
   }
}</pre></div></div><p><br class="example-break">

                    </p></div><div class="section" title="8.1.5.2.2.&nbsp;Badgerfish notation"><div class="titlepage"><div><div><h5 class="title"><a name="d0e5564"></a>8.1.5.2.2.&nbsp;Badgerfish notation</h5></div></div></div><p>
                        From JSON and JavaScript perspective, this notation is definitely the worst readable one.
                        You will probably not want to use it, unless you need to make sure your JAXB beans could be flawlessly
                        written and read back to and from JSON, without bothering with any formatting configuration, namespaces,
                        etc.
                    </p><p>
                        <code class="literal">JettisonConfig</code> instance using <code class="literal">badgerfish</code> notation could be built
                        with

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">JettisonConfig.badgerFish().build()</pre><p>

                        and the JSON output JSON will be as follows.

                        </p><div class="example"><a name="d0e5580"></a><p class="title"><b>Example&nbsp;8.24.&nbsp;JSON expression produced using <code class="literal">badgerfish</code> notation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "contact":{
      "id":{
         "$":"2"
      },
      "name":{
         "$":"Bob"
      },
      "addresses":{
         "street":{
            "$":"Long Street 1"
         },
         "town":{
            "$":"Short Village"
         }
      }
   }
}</pre></div></div><p><br class="example-break">
                    </p></div></div><div class="section" title="8.1.5.3.&nbsp;Configure and register"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5589"></a>8.1.5.3.&nbsp;Configure and register</h4></div></div></div><p>
                    In order to use Jettison as your JSON (JAXB/POJO) provider you need to register <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/jettison/JettisonFeature.html" target="_top">JettisonFeature</a>
                    and a <code class="literal">ContextResolver&lt;T&gt;</code> for <code class="literal">JAXBContext</code> (if needed) in your <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a>
                    (client/server).

                    </p><div class="example"><a name="d0e5606"></a><p class="title"><b>Example&nbsp;8.25.&nbsp;<code class="literal">ContextResolver&lt;ObjectMapper&gt;</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class JaxbContextResolver implements ContextResolver&lt;JAXBContext&gt; {

    private final JAXBContext context;
    private final Set&lt;Class&lt;?&gt;&gt; types;
    private final Class&lt;?&gt;[] cTypes = {Flights.class, FlightType.class, AircraftType.class};

    public JaxbContextResolver() throws Exception {
        this.types = new HashSet&lt;Class&lt;?&gt;&gt;(Arrays.asList(cTypes));
        this.context = new JettisonJaxbContext(JettisonConfig.DEFAULT, cTypes);
    }

    @Override
    public JAXBContext getContext(Class&lt;?&gt; objectType) {
        return (types.contains(objectType)) ? context : null;
    }
}</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e5613"></a><p class="title"><b>Example&nbsp;8.26.&nbsp;Building client with Jettison JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
        .register(JaxbContextResolver.class)  // No need to register this provider if no special configuration is required.
        .register(JettisonFeature.class)
        .build();</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e5619"></a><p class="title"><b>Example&nbsp;8.27.&nbsp;Creating JAX-RS application with Jettison JSON feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
        .packages("org.glassfish.jersey.examples.jettison")
        .register(JaxbContextResolver.class)  // No need to register this provider if no special configuration is required.
        .register(JettisonFeature.class);</pre></div></div><p><br class="example-break">
                </p></div><div class="section" title="8.1.5.4.&nbsp;Examples"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5625"></a>8.1.5.4.&nbsp;Examples</h4></div></div></div><p>
                    Jersey provides an <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/json-jettison" target="_top">JSON Jettison example</a> on how to use Jettison to consume/produce JSON.
                </p></div></div><div class="section" title="8.1.6.&nbsp;@JSONP - JSON with Padding Support"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5633"></a>8.1.6.&nbsp;<code class="literal">@JSONP</code> - JSON with Padding Support</h3></div></div></div><p>
                Jersey provides out-of-the-box support for <a class="link" href="http://en.wikipedia.org/wiki/JSONP" target="_top">JSONP</a> - JSON with padding. The following conditions has to be
                met to take advantage of this capability:

                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            Resource method, which should return wrapped JSON, needs to be annotated with <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/JSONP.html" target="_top">@JSONP</a>
                            annotation.
                        </p></li><li class="listitem"><p>
                            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for <code class="literal">application/json</code> media type, which also accepts
                            the return type of the resource method, needs to be registered (see <a class="link" href="#json" title="8.1.&nbsp;JSON">JSON</a>
                            section of this chapter).
                        </p></li><li class="listitem"><p>
                            User's request has to contain <code class="literal">Accept</code> header with one of the JavaScript media types
                            defined (see below).
                        </p></li></ul></div><p>

                Acceptable media types compatible with <code class="literal">@JSONP</code> are: <code class="literal">application/javascript</code>,
                <code class="literal">application/x-javascript</code>, <code class="literal">application/ecmascript</code>,
                <code class="literal">text/javascript</code>, <code class="literal">text/x-javascript</code>, <code class="literal">text/ecmascript</code>,
                <code class="literal">text/jscript</code>.

                </p><div class="example"><a name="d0e5693"></a><p class="title"><b>Example&nbsp;8.28.&nbsp;Simplest case of using <code class="literal">@JSONP</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@JSONP
@Produces({"application/json", "application/javascript"})
public JaxbBean getSimpleJSONP() {
    return new JaxbBean("jsonp");
}</pre></div></div><p><br class="example-break">

                Assume that we have registered a JSON providers and that the <code class="literal">JaxbBean</code> looks like:

                </p><div class="example"><a name="d0e5704"></a><p class="title"><b>Example&nbsp;8.29.&nbsp;JaxbBean for @JSONP example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class JaxbBean {

    private String value;

    public JaxbBean() {}

    public JaxbBean(final String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    public void setValue(final String value) {
        this.value = value;
    }
}</pre></div></div><p><br class="example-break">

                When you send a <code class="literal">GET</code> request with <code class="literal">Accept</code> header set to
                <code class="literal">application/javascript</code> you'll get a result entity that look like:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">callback({
    "value" : "jsonp",
})</pre><p>
            </p><p>
                There are, of course, ways to configure wrapping method of the returned entity which defaults to
                <code class="literal">callback</code> as you can see in the previous example.
                <code class="literal">@JSONP</code> has two parameters that can be configured: <code class="literal">callback</code> and
                <code class="literal">queryParam</code>.
                <code class="literal">callback</code> stands for the name of the JavaScript callback function defined by the application.
                The second parameter, <code class="literal">queryParam</code>, defines the name of the query parameter holding the name of
                the callback function to be used (if present in the request). Value of <code class="literal">queryParam</code> defaults to
                <code class="literal">__callback</code> so even if you do not set the name of the query parameter yourself, client can
                always affect the result name of the wrapping JavaScript callback method.

                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        <code class="literal">queryParam</code> value (if set) always takes precedence over <code class="literal">callback</code>
                        value.
                    </p></div><p>
            </p><p>
                Lets modify our example a little bit:

                </p><div class="example"><a name="d0e5760"></a><p class="title"><b>Example&nbsp;8.30.&nbsp;Example of <code class="literal">@JSONP</code> with configured parameters.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
@Produces({"application/json", "application/javascript"})
@JSONP(callback = "eval", queryParam = "jsonpCallback")
public JaxbBean getSimpleJSONP() {
    return new JaxbBean("jsonp");
}</pre></div></div><p><br class="example-break">

                And make two requests:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">curl -X GET http://localhost:8080/jsonp</pre><p>

                will return

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">eval({
    "value" : "jsonp",
})</pre><p>

                and the

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">curl -X GET http://localhost:8080/jsonp?jsonpCallback=alert</pre><p>

                will return

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">alert({
    "value" : "jsonp",
})</pre><p>
            </p><p title="Example"><b>Example.&nbsp;</b>
                    You can take a look at a provided example available at <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/json-with-padding" target="_top">JSON with Padding example</a>.
                </p></div></div><div class="section" title="8.2.&nbsp;XML"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xml"></a>8.2.&nbsp;XML</h2></div></div></div><p>
            As you probably already know, Jersey uses <code class="literal">MessageBodyWriter&lt;T&gt;</code>s and <code class="literal">MessageBodyReader&lt;T&gt;</code>s to
            parse incoming requests and create outgoing responses. Every user can create its own representation but... this is not
            recommended way how to do things. XML is proven standard for interchanging information, especially in web services.
            Jerseys supports low level data types used for direct manipulation and JAXB XML entities.
        </p><div class="section" title="8.2.1.&nbsp;Low level XML support"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5800"></a>8.2.1.&nbsp;Low level XML support</h3></div></div></div><p>
                Jersey currently support several low level data types: <a class="link" href="http://docs.oracle.com/javase/7/docs/api/javax/xml/transform/stream/StreamSource.html" target="_top">StreamSource</a>, <a class="link" href="http://docs.oracle.com/javase/7/docs/api/javax/xml/transform/sax/SAXSource.html" target="_top">SAXSource</a>, <a class="link" href="http://docs.oracle.com/javase/7/docs/api/javax/xml/transform/dom/DOMSource.html" target="_top">DOMSource</a>
                and <a class="link" href="http://docs.oracle.com/javase/7/docs/api/org/w3c/dom/Document.html" target="_top">Document</a>. You can use these types as the return type or as a method (resource) parameter.
                Lets say we want to test this feature and we have <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/helloworld" target="_top">helloworld example</a> as a starting point.
                All we need to do is add methods (resources) which consumes and produces XML and types mentioned above will be
                used.
            </p><div class="example"><a name="d0e5820"></a><p class="title"><b>Example&nbsp;8.31.&nbsp;Low level XML test - methods added to <code class="literal">HelloWorldResource.java</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Path("StreamSource")
public StreamSource getStreamSource(StreamSource streamSource) {
    return streamSource;
}

@POST
@Path("SAXSource")
public SAXSource getSAXSource(SAXSource saxSource) {
    return saxSource;
}

@POST
@Path("DOMSource")
public DOMSource getDOMSource(DOMSource domSource) {
    return domSource;
}

@POST
@Path("Document")
public Document getDocument(Document document) {
    return document;
}</pre></div></div><br class="example-break"><p>
                Both <code class="literal">MessageBodyWriter&lt;T&gt;</code> and <code class="literal">MessageBodyReader&lt;T&gt;</code> are used in this case, all we need is
                a <code class="literal">POST</code> request with some XML document as a request entity. To keep this as simple as possible only root
                element with no content will be sent: <code class="literal">"&lt;test /&gt;"</code>. You can create JAX-RS client to do that
                or use some other tool, for example <code class="literal">curl</code>:
                </p><div class="informalexample"><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">curl -v http://localhost:8080/base/helloworld/StreamSource -d "&lt;test/&gt;"</pre></div><p>
                You should get exactly the same XML from our service as is present in the request; in this case, XML headers are
                added to response but content stays. Feel free to iterate through all resources.
            </p></div><div class="section" title="8.2.2.&nbsp;Getting started with JAXB"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5848"></a>8.2.2.&nbsp;Getting started with JAXB</h3></div></div></div><p>
                Good start for people which already have some experience with JAXB annotations
                is <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/jaxb" target="_top">JAXB example</a>. You can see various use-cases there. This text is mainly meant for those who
                don't have prior experience with JAXB. Don't expect that all possible annotations and their combinations will be
                covered in this chapter,
                <a class="link" href="http://jaxb.java.net" target="_top">JAXB (JSR 222 implementation)</a>
                is pretty complex and comprehensive. But if you just want to know how you can interchange XML messages with your
                REST service, you are looking at the right chapter.
            </p><p>
                Lets start with simple example. Lets say we have class <code class="literal">Planet</code> and service which produces
                "Planets".
            </p><div class="example"><a name="d0e5864"></a><p class="title"><b>Example&nbsp;8.32.&nbsp;Planet class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public class Planet {
    public int id;
    public String name;
    public double radius;
}</pre></div></div><br class="example-break"><div class="example"><a name="d0e5869"></a><p class="title"><b>Example&nbsp;8.33.&nbsp;Resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("planet")
public class Resource {

    @GET
    @Produces(MediaType.APPLICATION_XML)
    public Planet getPlanet() {
        final Planet planet = new Planet();

        planet.id = 1;
        planet.name = "Earth";
        planet.radius = 1.0;

        return planet;
    }
}</pre></div></div><br class="example-break"><p>
                You can see there is some extra annotation declared on <code class="literal">Planet</code> class, particularly
                <a class="link" href="http://jaxb.java.net/nonav/2.2.7/docs/api/javax/xml/bind/annotation/XmlRootElement.html" target="_top">@XmlRootElement</a>. This is an JAXB annotation which maps java classes
                to XML elements. We don't need to specify anything else, because <code class="literal">Planet</code> is very simple class
                and all fields are public. In this case, XML element name will be derived from the class name or
                you can set the name property: <code class="literal">@XmlRootElement(name="yourName")</code>.
            </p><p>
                Our resource class will respond to <code class="literal">GET /planet</code> with

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;planet&gt;
    &lt;id&gt;1&lt;/id&gt;
    &lt;name&gt;Earth&lt;/name&gt;
    &lt;radius&gt;1.0&lt;/radius&gt;
&lt;/planet&gt;</pre><p>

                which might be exactly what we want... or not. Or we might not really care, because we
                can use JAX-RS client for making requests to this resource and this is easy as:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">
                    Planet planet = webTarget.path("planet").request(MediaType.APPLICATION_XML_TYPE).get(Planet.class);
                </pre><p>
                There is pre-created <code class="literal">WebTarget</code> object which points to our applications context root and
                we simply add path (in our case its <code class="literal">planet</code>), accept header (not mandatory, but service could
                provide different content based on this header; for example <code class="literal">text/html</code> can be served for web
                browsers) and at the end we specify that we are expecting <code class="literal">Planet</code> class via <code class="literal">GET</code>
                request.
            </p><p>
                There may be need for not just producing XML, we might want to consume it as well.

                </p><div class="example"><a name="d0e5916"></a><p class="title"><b>Example&nbsp;8.34.&nbsp;Method for consuming Planet</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes(MediaType.APPLICATION_XML)
public void setPlanet(Planet planet) {
    System.out.println("setPlanet " + planet);
}</pre></div></div><p><br class="example-break">

                After valid request is made, service will print out string representation of <code class="literal">Planet</code>, which can
                look like <code class="literal">Planet{id=2, name='Mars', radius=1.51}</code>. With JAX-RS client you can do:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">
                    webTarget.path("planet").post(planet);
                </pre><p>
            </p><p>
                If there is a need for some other (non default) XML representation, other JAXB annotations would
                need to be used. This process is usually simplified by generating java source from XML Schema which is
                done by <code class="literal">xjc</code> which is XML to java compiler and it is part of JAXB.
            </p></div><div class="section" title="8.2.3.&nbsp;POJOs"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5936"></a>8.2.3.&nbsp;POJOs</h3></div></div></div><p>
                Sometimes you can't / don't want to add JAXB annotations to source code and you still want to have resources
                consuming and producing XML representation of your classes. In this case, <a class="link" href="http://jaxb.java.net/nonav/2.2.7/docs/api/javax/xml/bind/JAXBElement.html" target="_top">JAXBElement</a> class should help
                you. Let's redo planet resource but this time we won't have an <a class="link" href="http://jaxb.java.net/nonav/2.2.7/docs/api/javax/xml/bind/annotation/XmlRootElement.html" target="_top">@XmlRootElement</a> annotation on
                <code class="literal">Planet</code> class.
            </p><div class="example"><a name="d0e5950"></a><p class="title"><b>Example&nbsp;8.35.&nbsp;Resource class - JAXBElement</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("planet")
public class Resource {

    @GET
    @Produces(MediaType.APPLICATION_XML)
    public JAXBElement&lt;Planet&gt; getPlanet() {
        Planet planet = new Planet();

        planet.id = 1;
        planet.name = "Earth";
        planet.radius = 1.0;

        return new JAXBElement&lt;Planet&gt;(new QName("planet"), Planet.class, planet);
    }

    @POST
    @Consumes(MediaType.APPLICATION_XML)
    public void setPlanet(JAXBElement&lt;Planet&gt; planet) {
        System.out.println("setPlanet " + planet.getValue());
    }
}</pre></div></div><br class="example-break"><p>
                As you can see, everything is little more complicated with <code class="literal">JAXBElement</code>. This is because now you need
                to explicitly set element name for <code class="literal">Planet</code> class XML representation. Client side is even more
                complicated than server side because you can't do <code class="literal">JAXBElement&lt;Planet&gt;</code> so JAX-RS client
                API provides way how to workaround it by declaring subclass of <code class="literal">GenericType&lt;T&gt;</code>.
            </p><div class="example"><a name="d0e5969"></a><p class="title"><b>Example&nbsp;8.36.&nbsp;Client side - JAXBElement</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// GET
GenericType&lt;JAXBElement&lt;Planet&gt;&gt; planetType = new GenericType&lt;JAXBElement&lt;Planet&gt;&gt;() {};

Planet planet = (Planet) webTarget.path("planet").request(MediaType.APPLICATION_XML_TYPE).get(planetType).getValue();
System.out.println("### " + planet);

// POST
planet = new Planet();

// ...

webTarget.path("planet").post(new JAXBElement&lt;Planet&gt;(new QName("planet"), Planet.class, planet));</pre></div></div><br class="example-break"></div><div class="section" title="8.2.4.&nbsp;Using custom JAXBContext"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5974"></a>8.2.4.&nbsp;Using custom JAXBContext</h3></div></div></div><p>In some scenarios you can take advantage of using custom <a class="link" href="http://jaxb.java.net/nonav/2.2.7/docs/api/javax/xml/bind/JAXBContext.html" target="_top">JAXBContext</a>. Creating
                <code class="literal">JAXBContext</code> is an expensive operation and if you already have one created, same instance
                can be used by Jersey. Other possible use-case for this is when you need to set some specific things
                to <code class="literal">JAXBContext</code>, for example to set a different class loader.
            </p><div class="example"><a name="d0e5988"></a><p class="title"><b>Example&nbsp;8.37.&nbsp;PlanetJAXBContextProvider</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
public class PlanetJAXBContextProvider implements ContextResolver&lt;JAXBContext&gt; {
    private JAXBContext context = null;

    public JAXBContext getContext(Class&lt;?&gt; type) {
        if (type != Planet.class) {
            return null; // we don't support nothing else than Planet
        }

        if (context == null) {
            try {
                context = JAXBContext.newInstance(Planet.class);
            } catch (JAXBException e) {
                // log warning/error; null will be returned which indicates that this
                // provider won't/can't be used.
            }
        }

        return context;
    }
}</pre></div></div><br class="example-break"><p>
                Sample above shows simple <code class="literal">JAXBContext</code> creation, all you need to do is put
                this <code class="literal">@Provider</code> annotated class somewhere where Jersey can find it. Users sometimes
                have problems with using provider classes on client side, so just to reminder - you have to
                declare them in the client config (client does not do anything like package scanning done by server).
            </p><div class="example"><a name="d0e6001"></a><p class="title"><b>Example&nbsp;8.38.&nbsp;Using Provider with JAX-RS client</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
ClientConfig config = new ClientConfig();
config.register(PlanetJAXBContextProvider.class);

Client client = ClientBuilder.newClient(config);
                </pre></div></div><br class="example-break"></div><div class="section" title="8.2.5.&nbsp;MOXy"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6006"></a>8.2.5.&nbsp;MOXy</h3></div></div></div><p>
                If you want to use <a class="link" href="http://www.eclipse.org/eclipselink/moxy.php" target="_top">MOXy</a> as your JAXB
                implementation instead of JAXB RI you have two options. You can either use the standard JAXB mechanisms to define
                the <code class="literal">JAXBContextFactory</code> from which a <code class="literal">JAXBContext</code> instance would be obtained (for more
                on this topic, read JavaDoc on <a class="link" href="http://jaxb.java.net/nonav/2.2.7/docs/api/javax/xml/bind/JAXBContext.html" target="_top">JAXBContext</a>) or you can add <code class="literal">jersey-media-moxy</code> module to
                your project and register/configure
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/moxy/xml/MoxyXmlFeature.html" target="_top">MoxyXmlFeature</a> class/instance in
                the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a>.
            </p><div class="example"><a name="d0e6032"></a><p class="title"><b>Example&nbsp;8.39.&nbsp;Add <code class="literal">jersey-media-moxy</code> dependency.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-moxy&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><br class="example-break"><div class="example"><a name="d0e6040"></a><p class="title"><b>Example&nbsp;8.40.&nbsp;Register the <code class="literal">MoxyXmlFeature</code> class.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final ResourceConfig config = new ResourceConfig()
    .packages("org.glassfish.jersey.examples.xmlmoxy")
    .register(MoxyXmlFeature.class);</pre></div></div><br class="example-break"><div class="example"><a name="d0e6048"></a><p class="title"><b>Example&nbsp;8.41.&nbsp;Configure and register an <code class="literal">MoxyXmlFeature</code> instance.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Configure Properties.
final Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;();
// ...

// Obtain a ClassLoader you want to use.
final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();

final ResourceConfig config = new ResourceConfig()
    .packages("org.glassfish.jersey.examples.xmlmoxy")
    .register(new MoxyXmlFeature(
        properties,
        classLoader,
        true, // Flag to determine whether eclipselink-oxm.xml file should be used for lookup.
        CustomClassA.class, CustomClassB.class  // Classes to be bound.
    ));</pre></div></div><br class="example-break"></div></div><div class="section" title="8.3.&nbsp;Multipart"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="multipart"></a>8.3.&nbsp;Multipart</h2></div></div></div><div class="section" title="8.3.1.&nbsp;Overview"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6059"></a>8.3.1.&nbsp;Overview</h3></div></div></div><p>
                The classes in this module provide an integration of <code class="literal">multipart/*</code> request and response bodies
                in a JAX-RS runtime environment. The set of registered providers is leveraged, in that the content type for a body
                part of such a message reuses the same <code class="literal">MessageBodyReader&lt;T&gt;</code>/<code class="literal">MessageBodyWriter&lt;T&gt;</code>
                implementations as would be used for that content type as a standalone entity.
            </p><p>
                The following list of general MIME MultiPart features is currently supported:

                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            The <code class="literal">MIME-Version: 1.0</code> HTTP header is included on generated responses.
                            It is accepted, but not required, on processed requests.
                        </p></li><li class="listitem"><p>
                            A <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> implementation for consuming MIME MultiPart entities.
                        </p></li><li class="listitem"><p>
                            A <code class="literal">MessageBodyWriter&lt;T&gt;</code> implementation for producing MIME MultiPart entities.
                            The appropriate <code class="literal">@Provider</code> is used to serialize each body part, based on its media type.
                        </p></li><li class="listitem"><p>
                            Optional creation of an appropriate <code class="literal">boundary</code> parameter on a generated
                            <code class="literal">Content-Type</code> header, if not already present.
                        </p></li></ul></div><p>
            </p><p>
                For more information refer to <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/multipart/package-info.html" target="_top">Multi Part</a>.
            </p><div class="section" title="8.3.1.1.&nbsp;Dependency"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6112"></a>8.3.1.1.&nbsp;Dependency</h4></div></div></div><p>
                    To use multipart features you need to add <code class="literal">jersey-media-multipart</code> module to your <code class="literal">pom.xml</code> file:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-multipart&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                    If you're not using Maven make sure to have all needed dependencies (see <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-media-multipart/dependencies.html" target="_top">jersey-media-multipart</a>) on the
                    class-path.
                </p></div><div class="section" title="8.3.1.2.&nbsp;Registration"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6129"></a>8.3.1.2.&nbsp;Registration</h4></div></div></div><p>
                    Before you can use capabilities of the <code class="literal">jersey-media-multipart</code> module in your client/server code, you
                    need to register <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/multipart/MultiPartFeature.html" target="_top">MultiPartFeature</a>.

                    </p><div class="example"><a name="d0e6140"></a><p class="title"><b>Example&nbsp;8.42.&nbsp;Building client with MultiPart feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Client client = ClientBuilder.newBuilder()
    .register(MultiPartFeature.class)
    .build();</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e6146"></a><p class="title"><b>Example&nbsp;8.43.&nbsp;Creating JAX-RS application with MultiPart feature enabled.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// Create JAX-RS application.
final Application application = new ResourceConfig()
    .packages("org.glassfish.jersey.examples.multipart")
    .register(MultiPartFeature.class)</pre></div></div><p><br class="example-break">
                </p></div><div class="section" title="8.3.1.3.&nbsp;Examples"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6152"></a>8.3.1.3.&nbsp;Examples</h4></div></div></div><p>Jersey provides an <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/multipart-webapp" target="_top">multipart-webapp example</a> on how to use multipart features.</p></div></div><div class="section" title="8.3.2.&nbsp;Client"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6160"></a>8.3.2.&nbsp;Client</h3></div></div></div><p>
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/multipart/MultiPart.html" target="_top">MultiPart</a> class (or it's subclasses) can be used as an entry point to using
                <code class="literal">jersey-media-multipart</code> module on the client side. This class represents a <a class="link" href="http://en.wikipedia.org/wiki/MIME#Multipart_messages" target="_top">MIME multipart message</a> and is able
                to hold an arbitrary number of <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/multipart/BodyPart.html" target="_top">BodyPart</a>s. Default media type is <a class="link" href="http://en.wikipedia.org/wiki/MIME#Mixed" target="_top">multipart/mixed</a>
                for <code class="literal">MultiPart</code> entity and <code class="literal">text/plain</code> for
                <code class="literal">BodyPart</code>.

                </p><div class="example"><a name="d0e6189"></a><p class="title"><b>Example&nbsp;8.44.&nbsp;<code class="literal">MultiPart</code> entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final MultiPart multiPartEntity = new MultiPart()
        .bodyPart(new BodyPart().entity("hello"))
        .bodyPart(new BodyPart(new JaxbBean("xml"), MediaType.APPLICATION_XML_TYPE))
        .bodyPart(new BodyPart(new JaxbBean("json"), MediaType.APPLICATION_JSON_TYPE));

final WebTarget target = // Create WebTarget.
final Response response = target
        .request()
        .post(Entity.entity(multiPartEntity, multiPartEntity.getMediaType()));</pre></div></div><p><br class="example-break">

                If you send a <code class="literal">multiPartEntity</code> to the server the entity with <code class="literal">Content-Type</code>
                header in HTTP message would look like (don't forget to register a JSON provider):

                </p><div class="example"><a name="d0e6203"></a><p class="title"><b>Example&nbsp;8.45.&nbsp;<code class="literal">MultiPart</code> entity in HTTP message.</b></p><div class="example-contents"><pre class="screen"><span class="emphasis"><em>Content-Type: multipart/mixed; boundary=Boundary_1_829077776_1369128119878</em></span>

--Boundary_1_829077776_1369128119878
Content-Type: text/plain

hello
--Boundary_1_829077776_1369128119878
Content-Type: application/xml

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;jaxbBean&gt;&lt;value&gt;xml&lt;/value&gt;&lt;/jaxbBean&gt;
--Boundary_1_829077776_1369128119878
Content-Type: application/json

{"value":"json"}
--Boundary_1_829077776_1369128119878--</pre></div></div><p><br class="example-break">
            </p><p>
                When working with forms (e.g. media type <code class="literal">multipart/form-data</code>) and various fields in them,
                there is a more convenient class to be used - <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/multipart/FormDataMultiPart.html" target="_top">FormDataMultiPart</a>. It automatically sets
                the media type for the <code class="literal">FormDataMultiPart</code> entity to
                <code class="literal">multipart/form-data</code> and <code class="literal">Content-Disposition</code> header to
                <code class="literal">FormDataBodyPart</code> body parts.

                </p><div class="example"><a name="d0e6233"></a><p class="title"><b>Example&nbsp;8.46.&nbsp;<code class="literal">FormDataMultiPart</code> entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final FormDataMultiPart multipart = new FormDataMultiPart()
    .field("hello", "hello")
    .field("xml", new JaxbBean("xml"))
    .field("json", new JaxbBean("json"), MediaType.APPLICATION_JSON_TYPE);

final WebTarget target = // Create WebTarget.
final Response response = target.request().post(Entity.entity(multipart, multipart.getMediaType()));</pre></div></div><p><br class="example-break">

                To illustrate the difference when using <code class="literal">FormDataMultiPart</code> instead of
                <code class="literal">FormDataBodyPart</code> you can take a look at the
                <code class="literal">FormDataMultiPart</code> entity from HTML message:

                </p><div class="example"><a name="d0e6250"></a><p class="title"><b>Example&nbsp;8.47.&nbsp;<code class="literal">FormDataMultiPart</code> entity in HTTP message.</b></p><div class="example-contents"><pre class="screen"><span class="emphasis"><em>Content-Type: multipart/form-data; boundary=Boundary_1_511262261_1369143433608</em></span>

--Boundary_1_511262261_1369143433608
Content-Type: text/plain
Content-Disposition: form-data; name="hello"

hello
--Boundary_1_511262261_1369143433608
Content-Type: application/xml
Content-Disposition: form-data; name="xml"

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;jaxbBean&gt;&lt;value&gt;xml&lt;/value&gt;&lt;/jaxbBean&gt;
--Boundary_1_511262261_1369143433608
Content-Type: application/json
Content-Disposition: form-data; name="json"

{"value":"json"}
--Boundary_1_511262261_1369143433608--</pre></div></div><p><br class="example-break">
            </p><p>
                A common use-case for many users is sending files from client to server. For this purpose you can use classes from
                <code class="literal">org.glassfish.jersey.jersey.media.multipart</code> package, such as
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/multipart/file/FileDataBodyPart.html" target="_top">FileDataBodyPart</a> or <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/multipart/file/StreamDataBodyPart.html" target="_top">StreamDataBodyPart</a>.

                </p><div class="example"><a name="d0e6271"></a><p class="title"><b>Example&nbsp;8.48.&nbsp;Multipart - sending files.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">// MediaType of the body part will be derived from the file.
final FileDataBodyPart filePart = new FileDataBodyPart("my_pom", new File("pom.xml"));

final FormDataMultiPart multipart = new FormDataMultiPart()
    .field("foo", "bar")
    .bodyPart(filePart);

final WebTarget target = // Create WebTarget.
final Response response = target.request()
    .post(Entity.entity(multipart, multipart.getMediaType()));</pre></div></div><p><br class="example-break">
            </p></div><div class="section" title="8.3.3.&nbsp;Server"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6277"></a>8.3.3.&nbsp;Server</h3></div></div></div><p>
                Returning a multipart response from server to client is not much different from the parts described in the client
                section above. To obtain a multipart entity, sent by a client, in the application you can use two approaches:

                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Injecting the whole <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/multipart/MultiPart.html" target="_top">MultiPart</a> entity.</p></li><li class="listitem"><p>
                            Injecting particular parts of a <code class="literal">form-data</code> multipart request via
                            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/multipart/FormDataParam.html" target="_top">@FormDataParam</a> annotation.
                        </p></li></ul></div><p>
            </p><div class="section" title="8.3.3.1.&nbsp;Injecting and returning the MultiPart entity"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6299"></a>8.3.3.1.&nbsp;Injecting and returning the <code class="literal">MultiPart</code> entity</h4></div></div></div><p>
                    Working with <code class="literal">MultiPart</code> types is no different from injecting/returning other
                    entity types.
                    Jersey provides <code class="literal">MessageBodyReader&lt;T&gt;</code> for reading the request entity and injecting this entity
                    into a method parameter of a resource method and <code class="literal">MessageBodyWriter&lt;T&gt;</code> for writing output entities.
                    You can expect that either <code class="literal">MultiPart</code> or
                    <code class="literal">FormDataMultiPart</code> (<code class="literal">multipart/form-data</code> media type) object
                    to be injected into a resource method.
                </p><div class="example"><a name="d0e6325"></a><p class="title"><b>Example&nbsp;8.49.&nbsp;Resource method using <code class="literal">MultiPart</code> as input parameter / return value.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Produces("multipart/mixed")
public MultiPart post(final FormDataMultiPart multiPart) {
    return multiPart;
}</pre></div></div><br class="example-break"></div><div class="section" title="8.3.3.2.&nbsp;Injecting with @FormDataParam"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6333"></a>8.3.3.2.&nbsp;Injecting with <code class="literal">@FormDataParam</code></h4></div></div></div><p>
                    If you just need to bin the named body part(s) of a <code class="literal">multipart/form-data</code> request
                    entity body to a resource method parameter you can use <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/multipart/FormDataParam.html" target="_top">@FormDataParam</a> annotation.
                </p><p>
                    This annotation in conjunction with the media type <code class="literal">multipart/form-data</code> should be used for
                    submitting and consuming forms that contain files, non-ASCII data, and binary data.
                </p><p>
                    The type of the annotated parameter can be one of the following (for more detailed description see
                    javadoc to <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/multipart/FormDataParam.html" target="_top">@FormDataParam</a>):

                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                                <code class="literal">FormDataBodyPart</code> - The value of the parameter will be the first
                                named body part or <code class="literal">null</code> if such a named body part is not present.
                            </p></li><li class="listitem"><p>
                                A <code class="literal">List</code> or <code class="literal">Collection</code> of
                                <code class="literal">FormDataBodyPart</code>.
                                The value of the parameter will one or more named body parts with the same name or
                                <code class="literal">null</code> if such a named body part is not present.
                            </p></li><li class="listitem"><p>
                                <code class="literal">FormDataContentDisposition</code> - The value of the parameter will be the
                                content disposition of the first named body part part or <code class="literal">null</code> if such a named body part
                                is not present.
                            </p></li><li class="listitem"><p>
                                A <code class="literal">List</code> or <code class="literal">Collection</code> of
                                <code class="literal">FormDataContentDisposition</code>.
                                The value of the parameter will one or more content dispositions of the named body parts with the
                                same name or <code class="literal">null</code> if such a named body part is not present.
                            </p></li><li class="listitem"><p>
                                A type for which a message body reader is available given the media type of the first named body
                                part. The value of the parameter will be the result of reading using the message body reader given
                                the type <code class="literal">T</code>, the media type of the named part, and the bytes of the named body
                                part as input.
                            </p><p>
                                If there is no named part present and there is a default value present as declared by
                                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/DefaultValue.html" target="_top">@DefaultValue</a> then the media type will be set to <code class="literal">text/plain</code>.
                                The value of the parameter will be the result of reading using the message body reader given the
                                type <code class="literal">T</code>, the media type <code class="literal">text/plain</code>, and the UTF-8 encoded
                                bytes of the default value as input.
                            </p><p>
                                If there is no message body reader available and the type <code class="literal">T</code> conforms
                                to a type specified by <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/FormParam.html" target="_top">@FormParam</a> then processing is performed as specified by
                                <code class="literal">@FormParam</code>, where the values of the form parameter are <code class="literal">String</code>
                                instances produced by reading the bytes of the named body parts utilizing a message body reader
                                for the <code class="literal">String</code> type and the media type <code class="literal">text/plain</code>.
                            </p><p>
                                If there is no named part present then processing is performed as specified by
                                <code class="literal">@FormParam</code>.
                            </p></li></ul></div><p>
                </p><div class="example"><a name="d0e6451"></a><p class="title"><b>Example&nbsp;8.50.&nbsp;Use of <code class="literal">@FormDataParam</code> annotation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@POST
@Consumes(MediaType.MULTIPART_FORM_DATA_TYPE)
public String postForm(
    @DefaultValue("true") @FormDataParam("enabled") boolean enabled,
    @FormDataParam("data") FileData bean,
    @FormDataParam("file") InputStream file,
    @FormDataParam("file") FormDataContentDisposition fileDisposition) {

    // ...
}</pre></div></div><br class="example-break"><p>
                    In the example above the server consumes a <code class="literal">multipart/form-data</code> request entity body that
                    contains one optional named body part <code class="literal">enabled</code> and two required named body parts
                    <code class="literal">data</code> and <code class="literal">file</code>.
                </p><p>
                    The optional part <code class="literal">enabled</code> is processed
                    as a <code class="literal">boolean</code> value, if the part is absent then the value will be <code class="literal">true</code>.
                </p><p>
                    The part <code class="literal">data</code> is processed as a JAXB bean and contains some meta-data about the following
                    part.
                </p><p>
                    The part <code class="literal">file</code> is a file that is uploaded, this is processed as an
                    <code class="literal">InputStream</code>. Additional information about the file from the
                    <code class="literal">Content-Disposition</code> header can be accessed by the parameter
                    <code class="literal">fileDisposition</code>.
                </p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p><code class="literal">@FormDataParam</code> annotation can be also used on fields.</p></div></div></div></div></div><div lang="en" class="chapter" title="Chapter&nbsp;9.&nbsp;Filters and Interceptors"><div class="titlepage"><div><div><h2 class="title"><a name="filters-and-interceptors"></a>Chapter&nbsp;9.&nbsp;Filters and Interceptors</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e6512">9.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e6517">9.2. Filters</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e6546">9.2.1. Server filters</a></span></dt><dt><span class="section"><a href="#d0e6651">9.2.2. Client fillers</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e6686">9.3. Interceptors</a></span></dt><dt><span class="section"><a href="#d0e6795">9.4. Filter and interceptor execution order</a></span></dt><dt><span class="section"><a href="#d0e6856">9.5. Name binding</a></span></dt><dt><span class="section"><a href="#d0e6929">9.6. Dynamic binding</a></span></dt><dt><span class="section"><a href="#d0e6997">9.7. Priorities</a></span></dt></dl></div><div class="section" title="9.1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6512"></a>9.1.&nbsp;Introduction</h2></div></div></div><p>This chapter describes filters, interceptors and their configuration. Filters and interceptors
            can be used on both sides, on the client and the server side. Filters can modify inbound and outbound requests
            and responses including modification of headers, entity and other request/response parameters. Interceptors
            are used primarily for modification of entity input and output streams. You can use interceptors for example
            to zip and unzip output and input entity streams.
        </p></div><div class="section" title="9.2.&nbsp;Filters"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6517"></a>9.2.&nbsp;Filters</h2></div></div></div><p>
            Filters can be used when you want to modify any request or response parameters like headers. For example
            you would like to add a response header "X-Powered-By" to each generated response. Instead of adding this header
            in each resource method you would use a response filter to add this header.
        </p><p>
            There are filters on the server side and the client side.
        </p><p>
            Server filters:
            </p><table border="0" summary="Simple list" class="simplelist"><tr><td><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ContainerRequestFilter.html" target="_top">ContainerRequestFilter</a>
                </td></tr><tr><td><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ContainerResponseFilter.html" target="_top">ContainerResponseFilter</a>
                </td></tr></table><p>
            Client filters:
            </p><table border="0" summary="Simple list" class="simplelist"><tr><td><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientResponseFilter.html" target="_top">ClientResponseFilter</a>
                </td></tr><tr><td><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientResponseFilter.html" target="_top">ClientResponseFilter</a>
                </td></tr></table><p>
        </p><div class="section" title="9.2.1.&nbsp;Server filters"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6546"></a>9.2.1.&nbsp;Server filters</h3></div></div></div>
            The following example shows a simple container response filter adding a header to each response.

            <p>
                </p><div class="example"><a name="d0e6552"></a><p class="title"><b>Example&nbsp;9.1.&nbsp;Container response filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import java.io.IOException;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerResponseContext;
import javax.ws.rs.container.ContainerResponseFilter;
import javax.ws.rs.core.Response;

public class PoweredByResponseFilter implements ContainerResponseFilter {

    @Override
    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext)
        throws IOException {

            responseContext.getHeaders().add("X-Powered-By", "Jersey :-)");
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                In the example above the <code class="literal">PoweredByResponseFilter</code>
                always adds a header "X-Powered-By" to the
                response. The filter must inherit from the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ContainerResponseFilter.html" target="_top">ContainerResponseFilter</a> and must be registered
                as a provider. The filter will be executed for every response which is in most cases after the resource method
                is executed. Response filters are executed even if the resource method is not run, for example when
                the resource method is not found and 404 "Not found" response code is returned by the Jersey runtime. In this case
                the filter will be executed and will process the 404 response.
            </p><p>
                The <code class="literal">filter()</code> method has two arguments, the container request and container response. The
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ContainerRequestContext.html" target="_top">ContainerRequestContext</a> is accessible only for read only purposes as the filter is executed already
                in response phase. The modifications can be done in the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ContainerResponseContext.html" target="_top">ContainerResponseContext</a>.
            </p><p>
                The following example shows the usage of a request filter.
            </p><div class="example"><a name="d0e6579"></a><p class="title"><b>Example&nbsp;9.2.&nbsp;Container request filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">import java.io.IOException;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.SecurityContext;

public class AuthorizationRequestFilter implements ContainerRequestFilter {

    @Override
    public void filter(ContainerRequestContext requestContext)
                    throws IOException {

        final SecurityContext securityContext =
                    requestContext.getSecurityContext();
        if (securityContext == null ||
                    !securityContext.isUserInRole("privileged")) {

                requestContext.abortWith(Response
                    .status(Response.Status.UNAUTHORIZED)
                    .entity("User cannot access the resource.")
                    .build());
        }
    }
}</pre></div></div><br class="example-break"><p>
                The request filter is similar to the response filter but does not have access to the ContainerResponseContext
                as no response is accessible yet. Response filter inherits from <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientResponseFilter.html" target="_top">ClientResponseFilter</a>.
                Request filter is executed before the resource method is run and before the
                response is created. The filter has possibility to manipulate the request parameters including request
                headers or entity.
            </p><p>
                The <code class="literal">AuthorizationRequestFilter</code> in the example checks whether the
                authenticated user is in the privileged role. If it is not then the request is <span class="emphasis"><em>aborted</em></span>
                by calling <code class="literal">ContainerRequestContext.abortWith(Response response)</code> method. The method
                is intended to be called from the request filter in situation when the request should not be processed further in the standard processing chain.
                When the <code class="literal">filter</code> method is finished the response passed as a parameter to the
                <code class="literal">abortWith</code> method is used to respond to the request. Response filters, if any are registered,
                will be executed and will have possibility to process the aborted response.
            </p><div class="section" title="9.2.1.1.&nbsp;Pre-matching and post-matching filters"><div class="titlepage"><div><div><h4 class="title"><a name="d0e6606"></a>9.2.1.1.&nbsp;Pre-matching and post-matching filters</h4></div></div></div></div><p>
                All the request filters shown above was implemented as post-matching filters. It means that the filters
                would be applied only after a suitable resource method has been selected to process the actual request
                i.e. after request matching happens. Request matching is the process of finding a resource method that
                should be executed based on the request path and other request parameters. Since post-matching request
                filters are invoked when a particular resource method has already been selected, such filters can not
                influence the resoure method matching process.
            </p><p>
                To overcome the above described limitation, there is a possibility to mark
                a server request filter as a <span class="emphasis"><em>pre-matching</em></span> filter,
                i.e. to annotate the filter class with the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/PreMatching.html" target="_top">@PreMatching</a> annotation.
                Pre-matching filters are request filters that are executed before
                the request matching is started. Thanks to this, pre-matching request filters have
                the possibility to influence which method will be matched. Such a pre-matching request filter example is shown
                here:
            </p><p>
                </p><div class="example"><a name="d0e6621"></a><p class="title"><b>Example&nbsp;9.3.&nbsp;Pre-matching request filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.container.PreMatching;
...

@PreMatching
public class PreMatchingFilter implements ContainerRequestFilter {

    @Override
    public void filter(ContainerRequestContext requestContext)
                        throws IOException {
        // change all PUT methods to POST
        if (requestContext.getMethod().equals("PUT")) {
            requestContext.setMethod("POST");
        }
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                The <code class="literal">PreMatchingFilter</code> is a simple pre-matching filter which changes all PUT HTTP
                methods to POST. This might be useful when you want to always handle these PUT and POST HTTP methods
                with the same Java code. After the <code class="literal">PreMatchingFilter</code> has been invoked, the rest
                of the request processing will behave as if the POST HTTP method was originally used.
                You cannot do this in post-matching filters
                (standard filters without <code class="literal">@PreMatching</code> annotation)
                as the resource method is already matched (selected). An attempt to tweak the original HTTP method in
                a post-matching filter would cause an <code class="literal">IllegalArgumentException</code>.
            </p><p>
                As written above, pre-matching filters can fully influence the request matching process, which means
                you can even modify request URI in a pre-matching filter by invoking
                the <code class="literal">setRequestUri(URI)</code> method of <code class="literal">ContainerRequestFilter</code>
                so that a different resource would be matched.
            </p><p>
                Like in post-matching filters you can abort a response in pre-matching filters too.
            </p></div><div class="section" title="9.2.2.&nbsp;Client fillers"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6651"></a>9.2.2.&nbsp;Client fillers</h3></div></div></div><p>
                Client filters are similar to container filters. The response can also be aborted
                in the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientRequestFilter.html" target="_top">ClientRequestFilter</a> which would cause that no request will actually be sent to the server at all.
                A new response is passed to the <code class="literal">abort</code> method. This response will be used and delivered
                as a result of the request invocation. Such a response goes through the client response filters.
                This is similar to what happens on the server side. The process is shown in the following example:
            </p><p>
                </p><div class="example"><a name="d0e6664"></a><p class="title"><b>Example&nbsp;9.4.&nbsp;Client request filter</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class CheckRequestFilter implements ClientRequestFilter {

    @Override
    public void filter(ClientRequestContext requestContext)
                        throws IOException {
        if (requestContext.getHeaders(
                        ).get("Client-Name") == null) {
            requestContext.abortWith(
                        Response.status(Response.Status.BAD_REQUEST)
                .entity("Client-Name header must be defined.")
                        .build());
         }
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                The <code class="literal">CheckRequestFilter</code> validates the outgoing request. It is checked for presence of
                a <code class="literal">Client-Name</code> header. If the header is not present the request will be aborted
                with a made up response with an appropriate code and message in the entity body. This will cause that
                the original request will not be effectivelly sent to the server but the actual invocation
                will still end up with a response as if it would be generated by the
                server side. If there would be any client response filter it would be executed on this response.
            </p><p>
                To summarize the workflow, for any client request invoked from the client API
                the client request filters (<a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientRequestFilter.html" target="_top">ClientRequestFilter</a>)
                are executed that could manipulate the request.
                If not aborted, the outcoming request is then physically sent over to the server side
                and once a response is received back from the server the client response
                filters (<a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientResponseFilter.html" target="_top">ClientResponseFilter</a>)
                are executed that might again manipulate the returned response.
                Finally the response is passed back to the code that invoked the request.
                If the request was aborted in any client request filter then the
                client/server communication is skipped and the aborted response
                is used in the response filters.
            </p></div></div><div class="section" title="9.3.&nbsp;Interceptors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6686"></a>9.3.&nbsp;Interceptors</h2></div></div></div><p>
            Interceptors share a common API for the server and the client side. Whereas filters are primarily intended to manipulate
            request and response parameters like HTTP headers, URIs and/or HTTP methods, interceptors are intended to manipulate entities, via manipulating
            entity input/output streams. If you for example need to encode entity body of a client request then you could
            implement an interceptor to do the work for you.
         </p><p>
            There are two kinds of interceptors, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/ReaderInterceptor.html" target="_top">ReaderInterceptor</a> and <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/WriterInterceptor.html" target="_top">WriterInterceptor</a>.
            Reader interceptors are used to manipulate inbound entity streams. These are the streams coming from
            the "wire". So, using a reader interceptor you
            can manipulate request entity stream on the server side (where
            an entity is read from the client request) and response entity stream on the client side (where an entity
            is read from the server response). Writer interceptors are used for cases where entity is written to the
            "wire" which on the server means when writing out a response entity and on the client side when writing
            request entity for a request to be sent out to the server. Writer and reader interceptors are executed before message body
            readers or writers are executed and their primary intention is to wrap the entity streams that will be used in message body
            reader and writers.
        </p><p>
            The following example shows a writer interceptor that enables GZIP compression of the whole entity body.
        </p><p>
            </p><div class="example"><a name="d0e6703"></a><p class="title"><b>Example&nbsp;9.5.&nbsp;GZIP writer interceptor</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class GZIPWriterInterceptor implements WriterInterceptor {

    @Override
    public void aroundWriteTo(WriterInterceptorContext context)
                    throws IOException, WebApplicationException {
        final OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(new GZIPOutputStream(outputStream));
        context.proceed();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The interceptor gets a output stream from the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/WriterInterceptorContext.html" target="_top">WriterInterceptorContext</a> and sets
            a new one which is a GZIP wrapper of the original output stream. After all interceptors are executed the
            output stream lastly set to the <code class="literal">WriterInterceptorContext</code> will be used for serialization of the entity. In the
            example above the entity bytes will be written to the GZIPOutputStream which will compress the stream data
            and write them to the original output stream. The original stream is always the stream which writes the data to
            the "wire". When the interceptor is used on the server, the original output stream is the stream into which writes
            data to the underlying server container stream that sends the response to the client.
        </p><p>
            The interceptors wrap the streams and they itself work as wrappers. This means that each interceptor is a wrapper
            of another interceptor and it is responsibility of each interceptor implementation to call the wrapped interceptor.
            This is achieved by calling the <code class="literal">proceed()</code> method on the <code class="literal">WriterInterceptorContext</code>.
            This method will call the next registered interceptor in the chain, so effectivelly this will call all remaining registered interceptors. Calling <code class="literal">proceed()</code> from the last
            interceptor in the chain will call the appropriate message body reader. Therefore every interceptor must call the
            <code class="literal">proceed()</code> method otherwise the entity would not be written. The wrapping principle is reflected
            also in the method name, aroundWriteTo, which says that the method is wrapping the writing of the entity.
        </p><p>
            The method aroundWriteTo() gets <code class="literal">WriterInterceptorContext</code> as a parameter. This context contains getters
            and setters for header parameters, request properties, entity, entity stream and other properties. These are the
            properties which will be passed to the final <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Interceptors are allowed to modify
            all these properties. This could influence writing of an entity by <code class="literal">MessageBodyWriter&lt;T&gt;</code> and even
            selection of such a writer. By changing media type (<code class="literal">WriterInterceptorContext</code>.setMediaType())
            the interceptor can cause that different message body writer will be chosen. The interceptor can also
            completely replace the entity if it is needed. However, for modification of headers, request
            properties and such, the filters are usually more preferable choice. Interceptors are executed
            only when there is any entity and when the entity is to be written. So, when you always want to add a new
            header to a response no matter what, use filters as interceptors might not be executed when no entity is
            present. Interceptors should modify properties only for entity serialization
            and deserialization purposes.
        </p><p>
            Let's now look at an example of a <code class="literal">WriterInterceptor</code>
        </p><p>
            </p><div class="example"><a name="d0e6752"></a><p class="title"><b>Example&nbsp;9.6.&nbsp;GZIP reader interceptor</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class GZIPReaderInterceptor implements ReaderInterceptor {

    @Override
    public Object aroundReadFrom(ReaderInterceptorContext context)
                    throws IOException, WebApplicationException {
        final InputStream originalInputStream = context.getInputStream();
        context.setInputStream(new GZIPInputStream(originalInputStream));
        return context.proceed();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The <code class="literal">GZIPReaderInterceptor</code> wraps the original input stream with the
            <code class="literal">GZIPInputStream</code>. All further reads from the entity stream will cause that data will be decompressed
            by this stream. The interceptor method <code class="literal">aroundReadFrom()</code> must return an entity. The entity
            is returned from the <code class="literal">proceed</code> method of the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/ReaderInterceptorContext.html" target="_top">ReaderInterceptorContext</a>. The
            <code class="literal">proceed</code> method internally calls the wrapped interceptor which must also return an entity.
            The <code class="literal">proceed</code> method invoked from the last interceptor in the chain calls message body reader which deserializes
            the entity end returns it. Every interceptor can change this entity if there is a need but in the most cases
            interceptors will just return the entity as returned from the <code class="literal">proceed</code> method.
        </p><p>
            As already mentioned above, interceptors should be primarily used to manipulate entity body.
            Similar to methods exposed by <code class="literal">WriterInterceptorContext</code> the <code class="literal">ReaderInterceptorContext</code>
            introduces a set of methods for modification of request/response properties like HTTP headers,
            URIs and/or HTTP methods (excluding getters and setters for entity as entity has not been read yet).
            Again the same rules as for <code class="literal">WriterInterceptor</code> applies for changing these properties (change only
            properties in order to influence reading of an entity).
        </p></div><div class="section" title="9.4.&nbsp;Filter and interceptor execution order"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6795"></a>9.4.&nbsp;Filter and interceptor execution order</h2></div></div></div><p>
            Let's look closer at the context of execution of filters and interceptors. The following steps describes scenario
            where a JAX-RS client makes a POST request to the server. The server receives an entity and sends a response back
            with the same entity. GZIP reader and writer interceptors are registered on the
            client and the server. Also filters are registered on client and server which change the headers of request
            and response.
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Client request invoked: The POST request with attached entity is built on the client and invoked.</li><li class="listitem">ClientRequestFilters: client request filters are executed on the client and they
                    manipulate the request headers.</li><li class="listitem">Client <code class="literal">WriterInterceptor</code>: As the request contains an entity, writer interceptor registered on the client is executed before
                    a MessageBodyWriter is executed. It wraps the entity output stream with the GZipOutputStream.</li><li class="listitem">Client MessageBodyWriter: message body writer is executed on the client which serializes the entity
                    into the new GZipOutput stream. This stream zips the data and sends it to the "wire".</li><li class="listitem">Server: server receives a request. Data of entity is compressed which means that pure read from
                    the entity input stream would return compressed data.</li><li class="listitem">Server pre-matching ContainerRequestFilters: ContainerRequestFilters are executed that can manipulate
                    resource method matching process.</li><li class="listitem">Server: matching: resource method matching is done.</li><li class="listitem">Server: post-matching ContainerRequestFilters: ContainerRequestFilters post matching filters are executed.
                    This include execution of all global filters (without name binding) and filters name-bound to the matched
                    method.</li><li class="listitem">Server <code class="literal">ReaderInterceptor</code>: reader interceptors are executed on the server. The GZIPReaderInterceptor
                    wraps the input stream (the stream from the "wire") into the GZipInputStream and set it to context.</li><li class="listitem">Server MessageBodyReader: server message body reader is executed and it deserializes the entity
                    from new GZipInputStream (get from the context). This means the reader will read unzipped data and not
                    the compressed data from the "wire".</li><li class="listitem">Server resource method is executed: the deserialized entity object is passed to the matched resource
                    method as a parameter. The method returns this entity as a response entity.</li><li class="listitem">Server ContainerResponseFilters are executed: response filters are executed on the server and
                    they manipulate the response headers. This include all global bound filters (without name binding) and all filters name-bound to the resource method.</li><li class="listitem">Server <code class="literal">WriterInterceptor</code>: is executed on the server. It wraps the original
                    output stream with a new GZIPOuptutStream. The original stream is the stream that "goes to the wire" (output
                    stream for response from the underlying server container).
                </li><li class="listitem">Server MessageBodyWriter: message body writer is executed on the server which serializes the entity
                    into the GZIPOutputStream. This stream compresses the data and writes it to the original stream which sends
                    this compressed data back to the client.
                </li><li class="listitem">Client receives the response: the response contains compressed entity data.</li><li class="listitem">Client ClientResponseFilters: client response filters are executed and they manipulate the response headers.</li><li class="listitem">Client response is returned: the javax.ws.rs.core.Response is returned from the request invocation.</li><li class="listitem">Client code calls response.readEntity(): read entity is executed on the client to extract the entity from the response.</li><li class="listitem">Client <code class="literal">ReaderInterceptor</code>: the client reader interceptor is executed when readEntity(Class) is called. The interceptor
                        wraps the entity input stream with GZIPInputStream. This will decompress the data from the original input stream.
                </li><li class="listitem">Client MessageBodyReaders: client message body reader is invoked which reads decompressed data from
                    GZIPInputStream and deserializes the entity.</li><li class="listitem">Client: The entity is returned from the readEntity().</li></ol></div><p>
            It is worth to mention that in the scenario above the reader and writer interceptors are invoked only if the
            entity is present (it does not make sense to wrap entity stream when no entity will be written). The same behaviour
            is there for message body readers and writers. As mentioned above, interceptors are executed before
            the message body reader/writer as a part of their execution and they can wrap the input/output stream
            before the entity is read/written. There are exceptions when interceptors are not run before message body
            reader/writers but this is not the case of simple scenario above. This happens for example when the entity is
            read many times from client response using internal buffering. Then the data are intercepted only once and kept
            'decoded' in the buffer.
        </p></div><div class="section" title="9.5.&nbsp;Name binding"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6856"></a>9.5.&nbsp;Name binding</h2></div></div></div><p>
            Filters and interceptors can be <span class="emphasis"><em>name-bound</em></span>. Name binding is a concept that allows to say to a JAX-RS
            runtime that a specific filter or interceptor will be executed only for a specific resource method. When a filter or
            an interceptor is limited only to a specific resource method we say that it is <span class="emphasis"><em>name-bound</em></span>.
            Filters and interceptors that do not have such a limitation are called <span class="emphasis"><em>global</em></span>.
        </p><p>
            Filter or interceptor can be assigned to a resource method using the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/NameBinding.html" target="_top">@NameBinding</a> annotation. The annotation
            is used as meta annotation for other user implemented annotations that are applied to a providers and resource
            methods. See the following example:
        </p><p>
            </p><div class="example"><a name="d0e6877"></a><p class="title"><b>Example&nbsp;9.7.&nbsp;<code class="literal">@NameBinding</code> example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.zip.GZIPInputStream;

import javax.ws.rs.GET;
import javax.ws.rs.NameBinding;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
...


// @Compress annotation is the name binding annotation
@NameBinding
@Retention(RetentionPolicy.RUNTIME)
public @interface Compress {}


@Path("helloworld")
public class HelloWorldResource {

    @GET
    @Produces("text/plain")
    public String getHello() {
        return "Hello World!";
    }

    @GET
    @Path("too-much-data")
    @Compress
    public String getVeryLongString() {
        String str = ... // very long string
        return str;
    }
}

// interceptor will be executed only when resource methods
// annotated with @Compress annotation will be executed
@Compress
public class GZIPWriterInterceptor implements WriterInterceptor {
    @Override
    public void aroundWriteTo(WriterInterceptorContext context)
                    throws IOException, WebApplicationException {
        final OutputStream outputStream = context.getOutputStream();
        context.setOutputStream(new GZIPOutputStream(outputStream));
        context.proceed();
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The example above defines a new <code class="literal">@Compress</code> annotation which is a name binding annotation as
            it is annotated with <code class="literal">@NameBinding</code>. The <code class="literal">@Compress</code> is applied on the
            resource method <code class="literal">getVeryLongString()</code> and on the interceptor
            <code class="literal">GZIPWriterInterceptor</code>. The interceptor will be executed only if any resource method
            with such a annotation will be executed. In our example case the interceptor will be executed only for
            the <code class="literal">getVeryLongString()</code> method. The interceptor will not be executed for method
            <code class="literal">getHello()</code>. In this example the reason is probably clear. We would like to compress
            only long data and we do not need to compress the short response of "Hello World!".
        </p><p>
            Name binding can be applied on a resource class. In the example <code class="literal">HelloWorldResource</code>
            would be annotated with <code class="literal">@Compress</code>. This would mean that all resource
            methods will use compression in this case.
        </p><p>
            There might be many name binding annotations defined in an application. When any provider (filter
            or interceptor) is annotated with more than one name binding annotation, then it will be executed for
            resource methods which contain ALL these annotations. So, for example if our interceptor would be
            annotated with another name binding annotation @GZIP then the resource method would need to have both annotations attached,
            @Compress and @GZIP, otherwise the interceptor would not be executed. Based on the previous paragraph we can
            even use the combination when the
            resource method <code class="literal">getVeryLongString()</code> would be annotated with @Compress and resource class
            <code class="literal">HelloWorldResource</code> would be annotated from with @GZIP. This would also trigger the interceptor as
            annotations of resource methods are aggregated from resource method and from resource class. But this is probably
            just an edge case which will not be used so often.
        </p><p>
            Note that <span class="emphasis"><em>global filters are executed always</em></span>, so even for resource methods
            which have any name binding annotations.
        </p></div><div class="section" title="9.6.&nbsp;Dynamic binding"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6929"></a>9.6.&nbsp;Dynamic binding</h2></div></div></div><p>Dynamic binding is a way how to assign filters and interceptors to the resource methods in a dynamic
        manner. Name binding from the previous chapter uses a static approach and changes to binding require source
        code change and recompilation. With dynamic binding you can implement code which defines bindings during the application
        initialization time. The following example shows how to implement dynamic binding.</p><p>
            </p><div class="example"><a name="d0e6936"></a><p class="title"><b>Example&nbsp;9.8.&nbsp;Dynamic binding example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import javax.ws.rs.core.FeatureContext;
import javax.ws.rs.container.DynamicFeature;
...

@Path("helloworld")
public class HelloWorldResource {

    @GET
    @Produces("text/plain")
    public String getHello() {
        return "Hello World!";
    }

    @GET
    @Path("too-much-data")
    public String getVeryLongString() {
        String str = ... // very long string
        return str;
    }
}

// This dynamic binding provider registers GZIPWriterInterceptor
// only for HelloWorldResource and methods that contain
// "VeryLongString" in their name. It will be executed during
// application initialization phase.
public class CompressionDynamicBinding implements DynamicFeature {

    @Override
    public void configure(ResourceInfo resourceInfo, FeatureContext context) {
        if (HelloWorldResource.class.equals(resourceInfo.getResourceClass())
                &amp;&amp; resourceInfo.getResourceMethod()
                    .getName().contains("VeryLongString")) {
            context.register(GZIPWriterInterceptor.class);
        }
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            The example contains one <code class="literal">HelloWorldResource</code> which is known from the previous name binding example.
            The difference is in the <code class="literal">getVeryLongString</code> method, which now does not define
            the <code class="literal">@Compress</code> name binding annotations. The binding is done
            using the provider which implements <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/DynamicFeature.html" target="_top">DynamicFeature</a> interface. The interface defines
            one <code class="literal">configure</code>
            method with two arguments, <code class="literal">ResourceInfo</code> and <code class="literal">FeatureContext</code>.
            <code class="literal">ResourceInfo</code> contains information about the resource and method to which the binding can be done.
            The <code class="literal">configure</code> method will be executed once for each resource method that is defined in the application.
            In the example above the provider will be executed twice, once for the <code class="literal">getHello()</code> method
            and once for <code class="literal">getVeryLongString()</code> (
            once the resourceInfo will contain information about getHello() method and once it will point to
            getVeryLongString()). If a dynamic binding provider wants to register any provider for the actual resource method
            it will do that using provided <code class="literal">FeatureContext</code> which extends
            JAX-RS <code class="literal">Configurable</code> API. All methods for registration of filter or interceptor classes or instances can be used.
            Such dynamically registered filters or interceptors will be bound only to the actual resource method. In the example above the
            <code class="literal">GZIPWriterInterceptor</code> will be bound only to the method <code class="literal">getVeryLongString()</code>
            which will cause that data will be compressed only for this method and not for the method
            <code class="literal">getHello()</code>. The code of <code class="literal">GZIPWriterInterceptor</code> is in the examples above.
        </p><p>
            Note that filters and interceptors registered using dynamic binding are only additional filters run for the
            resource method. If there are any name bound providers or global providers they will still be executed.
        </p></div><div class="section" title="9.7.&nbsp;Priorities"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6997"></a>9.7.&nbsp;Priorities</h2></div></div></div><p>In case you register more filters and interceptors you might want to define an exact order in which
            they should be invoked. The order can be controlled by the <code class="literal">@Priority</code> annotation defined
            by the <code class="literal">javax.annotation.Priority</code> class. The annotation accepts an integer parameter of priority.
            Providers used in request processing (<code class="literal">ContainerRequestFilter</code>,
            <code class="literal">ClientRequestFilter</code>) as well as entity interceptors (<code class="literal">ReaderInterceptor</code>,
            <code class="literal">WriterInterceptor</code>) are sorted based on the priority in an ascending manner. So, a request filter with
            priority defined with <code class="literal">@Priority(1000)</code>
            will be executed before another request filter with priority  defined as <code class="literal">@Priority(2000)</code>. Providers
            used during response processing (<code class="literal">ContainerResponseFilter</code>,
            <code class="literal">ClientResponseFilter</code>) are executed
            in the reverse order (using descending manner), so a provider with the priority defined with
            <code class="literal">@Priority(2000)</code> will be executed before another provider with
             priority defined with <code class="literal">@Priority(1000)</code>.
        </p><p>
            It's a good practice to assign a priority to filters and interceptors. Use <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Priorities.html" target="_top">Priorities</a> class which
            defines standardized priorities in JAX-RS for different usages, rather than inventing your
            own priorities. So, when you for example write an authentication filter you would assign a priority 1000 which
            is the value of <code class="literal">Priorities</code><code class="literal">.AUTHENTICATION</code>. The following example
            shows the filter from the beginning
            of this chapter with a priority assigned.
        </p><p>
            </p><div class="example"><a name="d0e7050"></a><p class="title"><b>Example&nbsp;9.9.&nbsp;Priorities example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import javax.annotation.Priority;
import javax.ws.rs.Priorities;
...

@Priority(Priorities.HEADER_DECORATOR)
public class ResponseFilter implements ContainerResponseFilter {

    @Override
    public void filter(ContainerRequestContext requestContext,
                    ContainerResponseContext responseContext)
                    throws IOException {

        responseContext.getHeaders().add("X-Powered-By", "Jersey :-)");
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            As this is a response filter and response filters are executed in the reverse order,
            any other filter with priority lower than 3000 (<code class="literal">Priorities.HEADER_DECORATOR</code> is 3000) will be executed after
            this filter. So, for example <code class="literal">AUTHENTICATION</code> filter (priority 1000) would be run after this filter.
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;10.&nbsp;Asynchronous Services and Clients"><div class="titlepage"><div><div><h2 class="title"><a name="async"></a>Chapter&nbsp;10.&nbsp;Asynchronous Services and Clients</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e7076">10.1. Asynchronous Server API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7197">10.1.1. Asynchronous Server-side Callbacks</a></span></dt><dt><span class="section"><a href="#chunked-output">10.1.2. Chunked Output</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7330">10.2. Client API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7393">10.2.1. Asynchronous Client Callbacks</a></span></dt><dt><span class="section"><a href="#d0e7469">10.2.2. Chunked input</a></span></dt></dl></dd></dl></div><p>
        This chapter describes the usage of asynchronous API on the client and server side. The term <span class="emphasis"><em>async</em></span>
        will be sometimes used interchangeably with the term <span class="emphasis"><em>asynchronous</em></span> in this chapter.
    </p><div class="section" title="10.1.&nbsp;Asynchronous Server API"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7076"></a>10.1.&nbsp;Asynchronous Server API</h2></div></div></div><p>
            Request processing on the server works by default in a synchronous processing mode, which means that a client
            connection of a request is processed in a single I/O container thread. Once the thread processing the request
            returns to the I/O container, the container can safely assume that the request processing is finished and that
            the client connection can be safely released including all the resources associated with the connection. This model
            is typically sufficient for processing of requests for which the processing resource method execution takes
            a relatively short time. However, in cases where a resource method execution is known to take a long time to compute
            the result, server-side asynchronous processing model should be used. In this model, the association between a
            request processing thread and client connection is broken. I/O container that handles incoming request may no longer
            assume that a client connection can be safely closed when a request processing thread returns. Instead a facility for
            explicitly suspending, resuming and closing client connections needs to be exposed.
            Note that the use of server-side asynchronous processing model will not improve the request processing time perceived
            by the client. It will however increase the throughput of the server, by releasing the
            initial request processing thread back to the I/O container while the request may still be waiting in a queue for
            processing or the processing may still be running on another dedicated thread. The released I/O container thread
            can be used to accept and process new incoming request connections.
        </p><p>
            The following example shows a simple asynchronous resource method defined using the new JAX-RS async API:
            </p><div class="example"><a name="d0e7083"></a><p class="title"><b>Example&nbsp;10.1.&nbsp;Simple async resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/resource")
public class AsyncResource {
    @GET
    public void asyncGet(@Suspended final AsyncResponse asyncResponse) {

        new Thread(new Runnable() {
            @Override
            public void run() {
                String result = veryExpensiveOperation();
                asyncResponse.resume(result);
            }

            private String veryExpensiveOperation() {
                // ... very expensive operation
            }
        }).start();
    }
}</pre></div></div><p><br class="example-break">
            In the example above, a resource <code class="literal">AsyncResource</code>
            with one <code class="literal">GET</code> method <code class="literal">asyncGet</code> is defined. The <code class="literal">asyncGet</code> method
            injects a JAX-RS <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/AsyncResponse.html" target="_top">AsyncResponse</a> instance using a JAX-RS <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/Suspended.html" target="_top">@Suspended</a> annotation.
            Please note that <code class="literal">AsyncResponse</code> must be injected by the <code class="literal">@Suspended</code>
            annotation and not by <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Context.html" target="_top">@Context</a> as <code class="literal">@Suspended</code> does not only inject response but also
            says that the method is executed in the asynchronous mode. By the <code class="literal">AsyncResponse</code> parameter into
            a resource method we tell the Jersey runtime that the method is supposed to be invoked using the asynchronous
            processing mode, that is the client connection should not be automatically closed by the underlying I/O container
            when the method returns. Instead, the injected <code class="literal">AsyncResponse</code> instance (that represents the
            suspended client request connection) will be used to explicitly send the response back to the client using some other
            thread. In other words, Jersey runtime knows that when the <code class="literal">asyncGet</code> method completes, the response
            to the client may not be ready yet and the processing must be suspended and wait to be explictly resumed with a
            response once it becomes available. Note that the method <code class="literal">asyncGet</code> returns <code class="literal">void</code>
            in our example. This is perfectly valid in case of an asynchronous JAX-RS resource method, even for a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/GET.html" target="_top">@GET</a>
            method, as the response is never returned directly from the resource method as its return value. Instead, the response
            is later returned using <code class="literal">AsyncResponse</code> instance as it is demonstrated in the example. The
            <code class="literal">asyncGet</code> resource method starts a new thread and exits from the method. In that state the
            request processing is suspended and the container thread (the one which entered the resource method) is returned back
            to the container's thread pool and it can process other requests. New thread started in the resource method may
            execute an expensive operation which might take a long time to finish. Once a result is ready it is resumed using
            the <code class="literal">resume()</code> method on the <code class="literal">AsyncResponse</code> instance.
            The resumed response is then processed in the new thread by Jersey in a same way as any other synchronous response,
            including execution of filters and interceptors, use of exception mappers as necessary and sending the response
            back to the client.
        </p><p>
            It is important to note that the asynchronous response (<code class="literal">asyncResponse</code> in the example)
            does not need to be resumed from the thread started from the resource method. The asynchronous
            response can be resumed even from different request processing thread as it is shown in the
            the example of the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/AsyncResponse.html" target="_top">AsyncResponse</a> javadoc. In the javadoc example the
            async response suspended from the <code class="literal">GET</code> method is resumed later on from
            the <code class="literal">POST</code> method. The suspended async response is passed between requests using
            a static field and is resumed from the other resource method running on a different request processing thread.
        </p><p>
            Imagine now a situation when there is a long delay between two requests and you would not like to let
            the client wait for the response "forever" or at least for an unacceptable long time. In asynchronous processing
            model, occurrences of such situations should be carefully considered with client connections not being automatically
            closed when the processing method returns and the response needs to be resumed explicitly based on an event that
            may actually even never happen. To tackle these situations asynchronous <span class="emphasis"><em>timeouts</em></span> can be used.
        </p><p>
            The following example shows the usage of timeouts:
            </p><div class="example"><a name="d0e7170"></a><p class="title"><b>Example&nbsp;10.2.&nbsp;Simple async method with timeout</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public void asyncGetWithTimeout(@Suspended final AsyncResponse asyncResponse) {
    asyncResponse.setTimeoutHandler(new TimeoutHandler() {

        @Override
        public void handleTimeout(AsyncResponse asyncResponse) {
            asyncResponse.resume(Response.status(Response.Status.SERVICE_UNAVAILABLE)
                    .entity("Operation time out.").build());
        }
    });
    asyncResponse.setTimeout(20, TimeUnit.SECONDS);

    new Thread(new Runnable() {

        @Override
        public void run() {
            String result = veryExpensiveOperation();
            asyncResponse.resume(result);
        }

        private String veryExpensiveOperation() {
            // ... very expensive operation that typically finishes within 20 seconds
        }
    }).start();
}</pre></div></div><p><br class="example-break">
            By default, there is no timeout defined on the suspended <code class="literal">AsyncResponse</code> instance.
            A custom timeout and timeout event handler may be defined using <code class="literal">setTimeoutHandler(TimeoutHandler)</code>
            and <code class="literal">setTimeout(long, TimeUnit)</code> methods. The <code class="literal">setTimeoutHandler(TimeoutHandler)</code>
            method defines the handler that will be invoked when timeout is reached. The handler resumes the response with the
            response code 503 (from Response.Status.<code class="literal">SERVICE_UNAVAILABLE</code>).
            A timeout interval can be also defined without specifying a custom timeout handler (using just the
            <code class="literal">setTimeout(long, TimeUnit)</code> method).
            In such case the default behaviour of Jersey runtime is to throw a <code class="literal">ServiceUnavailableException</code>
            that gets mapped into 503, "Service Unavailable" HTTP error response, as defined by the JAX-RS specification.
        </p><div class="section" title="10.1.1.&nbsp;Asynchronous Server-side Callbacks"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7197"></a>10.1.1.&nbsp;Asynchronous Server-side Callbacks</h3></div></div></div><p>
                As operations in asynchronous cases might take long time and they are not always finished within
                a single resource method invocation, JAX-RS offers facility to register callbacks to be invoked
                based on suspended async response state changes. In Jersey you can register two JAX-RS callbacks:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                        <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/CompletionCallback.html" target="_top">CompletionCallback</a> that is executed when request finishes or fails, and
                    </li><li class="listitem">
                        <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ConnectionCallback.html" target="_top">ConnectionCallback</a> executed when a connection to a client is closed or lost.
                    </li></ul></div><p>
                </p><div class="example"><a name="d0e7216"></a><p class="title"><b>Example&nbsp;10.3.&nbsp;CompletionCallback example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/resource")
public class AsyncResource {
    private static int numberOfSuccessResponses = 0;
    private static int numberOfFailures = 0;
    private static Throwable lastException = null;

    @GET
    public void asyncGetWithTimeout(@Suspended final AsyncResponse asyncResponse) {
        asyncResponse.register(new CompletionCallback() {
            @Override
            public void onComplete(Throwable throwable) {
                if (throwable == null) {
                    // no throwable - the processing ended successfully
                    // (response already written to the client)
                    numberOfSuccessResponses++;
                } else {
                    numberOfFailures++;
                    lastException = throwable;
                }
            }
        });

        new Thread(new Runnable() {
            @Override
            public void run() {
                String result = veryExpensiveOperation();
                asyncResponse.resume(result);
            }

            private String veryExpensiveOperation() {
                // ... very expensive operation
            }
        }).start();
    }
}</pre></div></div><p><br class="example-break">
                A completion callback is registered using <code class="literal">register(...)</code> method
                on the <code class="literal">AsyncResponse</code> instance. A registered completion callback is bound only
                to the response(s) to which it has been registered. In the example the <code class="literal">CompletionCallback</code>
                is used to calculate successfully processed responses, failures and to store last exception. This is only a
                simple case demonstrating the usage of the callback. You can use completion callback to release the resources,
                change state of internal resources or representations or handle failures. The method has an argument
                <code class="literal">Throwable</code> which is set only in case of an error. Otherwise the parameter
                will be <code class="literal">null</code>, which means that the response was successfully written. The callback is executed
                only after the response is written to the client (not immediately after the response is resumed).
            </p><p>
                The <code class="literal">AsyncResponse</code> <code class="literal">register(...)</code> method is overloaded and offers options
                to register a single callback as an <code class="literal">Object</code> (in the example), as a <code class="literal">Class</code> or
                multiple callbacks using varags.
            </p><p>
                As some async requests may take long time to process the client may decide to terminate it's connection to the
                server before the response has been resumed or before it has been fully written to the client. To deal with these
                use cases a <code class="literal">ConnectionCallback</code> can be used. This callback will be executed only if the
                connection was prematurely terminated or lost while the response is being written to the back client. Note that
                this callback will not be invoked when a response is written successfully and the client connection is closed
                as expected. See javadoc of <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ConnectionCallback.html" target="_top">ConnectionCallback</a> for more information.
            </p></div><div class="section" title="10.1.2.&nbsp;Chunked Output"><div class="titlepage"><div><div><h3 class="title"><a name="chunked-output"></a>10.1.2.&nbsp;Chunked Output</h3></div></div></div><p>Jersey offers a facility for sending response to the client in multiple more-or-less independent chunks using a
                <span class="emphasis"><em>chunked output</em></span>. Each response chunk usually takes some (longer) time to prepare before
                sending it to the client. The most important fact about response chunks is that you want
                to send them to the client immediately as they become available without waiting for the remaining chunks to become
                available too. The first bytes of each chunked response consists of the HTTP headers that are sent to the client.
                The size -1 is set in the response <code class="literal">Content-Length</code> header to indicate that the response
                is chunked. As noted above, the entity of the response is then sent in chunks as they become available.
                Client knows that the response is going to be chunked, so it reads each chunk of the response separately,
                processes it, and waits for more chunks to arrive on the same connection. After some time, the server generates
                another response chunk and send it again to the client. Server keeps on sending response chunks until
                it closes the connection after sending the last chunk when the response processing is finished.
            </p><p>
                In Jersey you can use <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ChunkedOuptut.html" target="_top">ChunkedOutput</a> to send response to a client in chunks. Chunks are strictly
                defined pieces of a response body can be marshalled as a separate entities using Jersey/JAX-RS
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> providers. A chunk can be String, Long or JAXB bean serialized to XML or JSON or
                any other dacustom type for which a <code class="literal">MessageBodyWriter&lt;T&gt;</code> is available.
            </p><p>
                The resource method
                that returns <code class="literal">ChunkedOutput</code> informs the Jersey runtime that the response will be chunked
                and that the processing works asynchronously as such. You do not need to inject
                <code class="literal">AsyncResponse</code> to start the asynchronous processing mode in this case.
                Returning a <code class="literal">ChunkedOutput</code> instance from the method is enough to indicate the asynchronous
                processing. Response headers will be sent to a client when the resource method returns and the client will wait
                for the stream of chunked data which you will be able to write from different thread using the same
                <code class="literal">ChunkedOutput</code> instance returned from the resource method earlier. The following example
                demonstrates this use case:
                </p><div class="example"><a name="d0e7295"></a><p class="title"><b>Example&nbsp;10.4.&nbsp;ChunkedOutput example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/resource")
public class AsyncResource {
    @GET
    public ChunkedOutput&lt;String&gt; getChunkedResponse() {
        final ChunkedOutput&lt;String&gt; output = new ChunkedOutput&lt;String&gt;(String.class);

        new Thread() {
            public void run() {
                try {
                    String chunk;

                    while ((chunk = getNextString()) != null) {
                        output.write(chunk);
                    }
                } catch (IOException e) {
                    // IOException thrown when writing the
                    // chunks of response: should be handled
                } finally {
                    output.close();
                        // simplified: IOException thrown from
                        // this close() should be handled here...
                }
            }
        }.start();

        // the output will be probably returned even before
        // a first chunk is written by the new thread
        return output;
    }

    private String getNextString() {
        // ... long running operation that returns
        //     next string or null if no other string is accessible
    }
}</pre></div></div><p><br class="example-break">
                The example above defines a <code class="literal">GET</code> method that returns a <code class="literal">ChunkedOutput</code> instance.
                The generic type of <code class="literal">ChunkedOutput</code> defines the chunk types (in this case chunks are Strings).
                Before the instance is returned a new thread is started that writes individual chunks into
                the chunked output instance named <code class="literal">output</code>. Once the original
                thread returns from the resource method, Jersey runtime writes headers to the container response but does not
                close the client connection yet and waits for the response data to be written to the chunked
                <code class="literal">output</code>.
                New thread in a loop calls the method <code class="literal">getNextString()</code> which returns a
                next String or <code class="literal">null</code> if no other String exists (the method could for example load latest data
                from the database). Returned Strings are written to the chunked <code class="literal">output</code>. Such a written
                chunks are internally written to the container response and client can read them. At the end the
                chunked output is closed which determines the end of the chunked response. Please note that you must close
                the output explicitly in order to close the client connection as Jersey does not implicitly know when
                you are finished with writing the chunks.
            </p><p>
                A chunked output can be processed also from threads created from another request as it is explained in the
                sections above. This means that one resource method may e.g. only return a <code class="literal">ChunkedOutput</code>
                instance and other resource method(s) invoked from another request thread(s) can write data into the chunked
                output and/or close the chunked response.
            </p></div></div><div class="section" title="10.2.&nbsp;Client API"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7330"></a>10.2.&nbsp;Client API</h2></div></div></div><p>The client API supports asynchronous processing too. Simple usage of asynchronous client API is shown in the
        following example:
            </p><div class="example"><a name="d0e7335"></a><p class="title"><b>Example&nbsp;10.5.&nbsp;Simple client async invocation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final AsyncInvoker asyncInvoker = target().path("http://example.com/resource/")
        .request().async();
final Future&lt;Response&gt; responseFuture = asyncInvoker.get();
System.out.println("Request is being processed asynchronously.");
final Response response = responseFuture.get();
    // get() waits for the response to be ready
System.out.println("Response received.");</pre></div></div><p><br class="example-break">
            The difference against synchronous invocation is that the http method call <code class="literal">get()</code>
            is not called on <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/SyncInvoker.html" target="_top">SyncInvoker</a> but on <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/AsyncInvoker.html" target="_top">AsyncInvoker</a>. The
            <code class="literal">AsyncInvoker</code> is returned from the call of method
            <code class="literal">Invocation.Builder.async()</code> as shown above. <code class="literal">AsyncInvoker</code>
            offers methods similar to <code class="literal">SyncInvoker</code> only these methods do not return a response
            synchronously. Instead a <code class="literal">Future&lt;...&gt;</code> representing response data is returned.
            These method calls also return immediately without waiting for the actual request to complete.
            In order to get the response of the invoked <code class="literal">get()</code> method, the
            <code class="literal">responseFuture.get()</code> is invoked which waits for the response to be finished
            (this call is blocking as defined by the Java SE <code class="literal">Future</code> contract).
        </p><p>
            Asynchronous Client API in JAX-RS is fully integrated in the fluent JAX-RS Client API flow, so that
            the async client-side invocations can be written fluently just like in the following example:
            </p><div class="example"><a name="d0e7376"></a><p class="title"><b>Example&nbsp;10.6.&nbsp;Simple client fluent async invocation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Future&lt;Response&gt; responseFuture = target().path("http://example.com/resource/")
        .request().async().get();</pre></div></div><p><br class="example-break">
        </p><p>
            To work with asynchronous results on the client-side, all standard <code class="literal">Future</code> API facilities
            can be used. For example, you can use the <code class="literal">isDone()</code> method
            to determine whether a response has finished to avoid the use of a blocking call to <code class="literal">Future.get()</code>.
        </p><div class="section" title="10.2.1.&nbsp;Asynchronous Client Callbacks"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7393"></a>10.2.1.&nbsp;Asynchronous Client Callbacks</h3></div></div></div><p>Similarly to the server side, in the client API you can register asynchronous callbacks too. You can use
                these callbacks to be notified when a response arrives instead of waiting for the
                response on <code class="literal">Future.get()</code> or checking the status by <code class="literal">Future.isDone()</code> in
                a loop.
                A client-side asynchronous invocation callback can be registered as shown in the following example:
                </p><div class="example"><a name="d0e7404"></a><p class="title"><b>Example&nbsp;10.7.&nbsp;Client async callback</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Future&lt;Response&gt; responseFuture = target().path("http://example.com/resource/")
        .request().async().get(new InvocationCallback&lt;Response&gt;() {
            @Override
            public void completed(Response response) {
                System.out.println("Response status code "
                        + response.getStatus() + " received.");
            }

            @Override
            public void failed(Throwable throwable) {
                System.out.println("Invocation failed.");
                throwable.printStackTrace();
            }
        });</pre></div></div><p><br class="example-break">

                The registered callback is expected to implement the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/InvocationCallback.html" target="_top">InvocationCallback</a> interface that defines
                two methods.
                First method <code class="literal">completed(Response)</code> gets invoked when an invocation successfully
                finishes. The result response is passed as a parameter to the callback method. The second method
                <code class="literal">failed(Throwable)</code> is invoked in case the invocation fails and the exception describing
                the failure is passed to the method as a parameter. In this case since the callback generic type is
                <code class="literal">Response</code>, the <code class="literal">failed(Throwable)</code> method would  only invoked in case
                the invocation fails because of an internal client-side processing error. It would not be invoked
                in case a server responds with an HTTP error code, for example if the requested resource
                is not found on the server and HTTP <code class="literal">404</code> response code is returned. In such case
                <code class="literal">completed(Response)</code> callback method would be invoked and the response passed to the method
                would contain the returned error response with HTTP <code class="literal">404</code> error code. This is a special
                behavior in case the generic callback return type is <code class="literal">Response</code>. In the next example an
                exception is thrown (or <code class="literal">failed(Throwable)</code> method on the invocation callback is invoked)
                even in case a non-<code class="literal">2xx</code> HTTP error code is returned.
            </p><p>
                As with the synchronous client API, you can retrieve the response entity as a Java type directly without
                requesting a <code class="literal">Response</code> first. In case of an <code class="literal">InvocationCallback</code>, you need
                to set its generic type to the expected response entity type instead of using the <code class="literal">Response</code>
                type as demonstrated in the example bellow:
                </p><div class="example"><a name="d0e7454"></a><p class="title"><b>Example&nbsp;10.8.&nbsp;Client async callback for specific entity</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Future&lt;String&gt; entityFuture = target().path("http://example.com/resource/")
        .request().async().get(new InvocationCallback&lt;String&gt;() {
            @Override
            public void completed(String response) {
                System.out.println("Response entity '" + response + "' received.");
            }

            @Override
            public void failed(Throwable throwable) {
                System.out.println("Invocation failed.");
                throwable.printStackTrace();
            }
        });
System.out.println(entityFuture.get());</pre></div></div><p><br class="example-break">
                Here, the generic type of the invocation callback information is used to unmarshall the HTTP response content
                into a desired Java type.
            </p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    Please note that in this case the method <code class="literal">failed(Throwable throwable)</code> would be invoked even
                    for cases when a server responds with a non HTTP-<code class="literal">2xx</code> HTTP error code. This is because in this
                    case the user does not have any other means of finding out that the server returned an error response.
                </p></div></div><div class="section" title="10.2.2.&nbsp;Chunked input"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7469"></a>10.2.2.&nbsp;Chunked input</h3></div></div></div><p>
                In an <a class="link" href="#chunked-output" title="10.1.2.&nbsp;Chunked Output">earlier section</a> the <code class="literal">ChunkedOutput</code> was
                described. It was shown how to use a chunked output on the server. In order to read chunks on the client the
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ChunkedInput.html" target="_top">ChunkedInput</a> can be used to complete the story.
            </p><p>
                You can, of course, process input on the client as a standard input stream but if you would like to
                leverage Jersey infrastructure to provide support of translating message chunk data into Java types
                using a <code class="literal">ChunkedInput</code> is much more straightforward. See the usage of the
                <code class="literal">ChunkedInput</code> in the following example:

                </p><div class="example"><a name="d0e7491"></a><p class="title"><b>Example&nbsp;10.9.&nbsp;ChunkedInput example</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Response response = target().path("http://example.com/resource/")
        .request().get();
final ChunkedInput&lt;String&gt; chunkedInput =
        response.readEntity(new GenericType&lt;ChunkedInput&lt;String&gt;&gt;() {});
String chunk;
while ((chunk = chunkedInput.read()) != null) {
    System.out.println("Next chunk received: " + chunk);
}
</pre></div></div><p><br class="example-break">

                The response is retrieved in a standard way from the server. The entity is read as a
                <code class="literal">ChunkedInput</code> entity. In order to do that the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/GenericEntity.html" target="_top">GenericEntity&lt;T&gt;</a> is used to preserve
                a generic information at run time. If you would not use <code class="literal">GenericEntity&lt;T&gt;</code>, Java language generic type
                erasure would cause that the generic information would get lost at compile time and an exception would be thrown
                at run time complaining about the missing chunk type definition.
            </p><p>
                In the next lines in the example, individual chunks are being read from the response. Chunks can come with some
                delay, so they will be written to the console as they come from the server. After receiving last chunk the
                <code class="literal">null</code> will be returned from the <code class="literal">read()</code> method. This will mean that the server has sent
                the last chunk and closed the connection. Note that the <code class="literal">read()</code> is a blocking operation and the
                invoking thread is blocked until a new chunk comes.
            </p><p>
                Writing chunks with <code class="literal">ChunkedOutput</code> is simple, you only call method <code class="literal">write()</code>
                which writes exactly one chunk to the output. With the input reading it is slightly more complicated. The
                <code class="literal">ChunkedInput</code> does not know how to distinguish chunks in the byte stream unless being told by
                the developer. In order to define custom chunks boundaries,
                the <code class="literal">ChunkedInput</code> offers possibility to register a <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ChunkParser.html" target="_top">ChunkParser</a> which
                reads chunks from the input stream and separates them. Jersey provides several chunk parser implementation and
                you can implement your own parser to separate your chunks if you need. In our example above the default parser
                provided by Jersey is used that separates chunks based on presence of a <code class="literal">\r\n</code> delimiting
                character sequence.
            </p><p>
                Each incoming input stream is firstly parsed by the <code class="literal">ChunkParser</code>, then each chunk is processed
                by the proper <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>.
                You can define the media type of chunks to aid the selection of a proper <code class="literal">MessageBodyReader&lt;T&gt;</code> in
                order to read chunks correctly into the requested entity types (in our case into Strings).
            </p></div></div></div><div lang="en" class="chapter" title="Chapter&nbsp;11.&nbsp;URIs and Links"><div class="titlepage"><div><div><h2 class="title"><a name="uris-and-links"></a>Chapter&nbsp;11.&nbsp;URIs and Links</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e7552">11.1. Building URIs</a></span></dt><dt><span class="section"><a href="#d0e7626">11.2. Resolve and Relativize</a></span></dt><dt><span class="section"><a href="#d0e7669">11.3. Link</a></span></dt></dl></div><div class="section" title="11.1.&nbsp;Building URIs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7552"></a>11.1.&nbsp;Building URIs</h2></div></div></div><p>
            A very important aspect of REST is hyperlinks, URIs, in representations that clients can use to transition the
            Web service to new application states (this is otherwise known as "hypermedia as the engine of application state").
            HTML forms present a good example of this in practice.
        </p><p>
            Building URIs and building them safely is not easy with <a class="link" href="http://docs.oracle.com/javase/6/docs/api/java/net/URI.html" target="_top">URI</a>, which is why JAX-RS has the
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriBuilder.html" target="_top">UriBuilder</a> class that makes it simple and easy to build URIs safely.
            <code class="literal">UriBuilder</code> can be used to build new URIs or build from existing URIs. For resource
            classes it is more than likely that URIs will be built from the base URI the web service is deployed at
            or from the request URI. The class <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriInfo.html" target="_top">UriInfo</a> provides such information (in addition to further
            information, see next section).
        </p><p>The following example shows URI building with <code class="literal">UriInfo</code> and <code class="literal">UriBuilder</code>
            from the bookmark example:

            </p><div class="example"><a name="d0e7579"></a><p class="title"><b>Example&nbsp;11.1.&nbsp;URI building</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/users/")
public class UsersResource {

    @Context
    UriInfo uriInfo;

    ...

    @GET
    @Produces("application/json")
    public JSONArray getUsersAsJsonArray() {
        JSONArray uriArray = new JSONArray();
        for (UserEntity userEntity : getUsers()) {
            UriBuilder ub = uriInfo.getAbsolutePathBuilder();
            URI userUri = ub.
                    path(userEntity.getUserid()).
                    build();
            uriArray.put(userUri.toASCIIString());
        }
        return uriArray;
    }
}</pre></div></div><p><br class="example-break">

            <code class="literal">UriInfo</code> is obtained using the @Context annotation, and in this particular example injection onto
            the field of the root resource class is performed, previous examples showed the use of @Context on resource method
            parameters.
        </p><p>
            <code class="literal">UriInfo</code> can be used to obtain URIs and associated <code class="literal">UriBuilder</code> instances for
            the following URIs: the base URI the application is deployed at; the request URI; and the absolute path URI, which
            is the request URI minus any query components.
        </p><p>
            The <code class="literal">getUsersAsJsonArray</code> method constructs a <code class="literal">JSONArrray</code>, where each element
            is a URI identifying a specific user resource. The URI is built from the absolute path of the request URI by
            calling
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriInfo.html#getAbsolutePathBuilder()" target="_top">UriInfo.getAbsolutePathBuilder()</a>.
            A new path segment is added, which is the user ID, and then the URI is built. Notice that it is not necessary to
            worry about the inclusion of <code class="literal">'/'</code> characters or that the user ID may contain characters that need
            to be percent encoded. <code class="literal">UriBuilder</code> takes care of such details.
        </p><p><code class="literal">UriBuilder</code> can be used to build/replace query or matrix parameters. URI templates can also be
            declared, for example the following will build the URI <code class="literal">"http://localhost/segment?name=value"</code>:

            </p><div class="example"><a name="d0e7620"></a><p class="title"><b>Example&nbsp;11.2.&nbsp;Building URIs using query parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">UriBuilder.fromUri("http://localhost/")
    .path("{a}")
    .queryParam("name", "{value}")
    .build("segment", "value");</pre></div></div><p><br class="example-break">
        </p></div><div class="section" title="11.2.&nbsp;Resolve and Relativize"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7626"></a>11.2.&nbsp;Resolve and Relativize</h2></div></div></div><p>JAX-RS 2.0 introduced additional URI resolution and relativization methods in the <code class="literal">UriBuilder</code>:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriInfo.html#resolve(java.net.URI)" target="_top">UriInfo.resolve(java.net.URI)</a></p></li><li class="listitem"><p><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriInfo.html#relativize(java.net.URI)" target="_top">UriInfo.relativize(java.net.URI)</a></p></li><li class="listitem"><p><a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriBuilder.html#resolveTemplate(java.lang.String, java.lang.Object)" target="_top">UriBuilder.resolveTemplate(...)</a> (various arguments)</p></li></ul></div><p>

            Resolve and relativize methods in <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriInfo.html" target="_top">UriInfo</a> are essentially counterparts to the methods listed above -
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriInfo.html#resolve(java.net.URI)" target="_top">UriInfo.resolve(java.net.URI)</a>
            resolves given relative URI to an absolute URI using application context URI as the base URI;
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriInfo.html#relativize(java.net.URI)" target="_top">UriInfo.relativize(java.net.URI)</a>
            then transforms an absolute URI to a relative one, using again the applications context URI as the base URI.
        </p><p>
            <code class="literal">UriBuilder</code> also introduces a set of methods that provide ways of resolving URI templates by replacing
            individual templates with a provided value(s). A short example:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final URI uri = UriBuilder.fromUri("http://{host}/{path}?q={param}")
    .resolveTemplate("host", "localhost")
    .resolveTemplate("path", "myApp")
    .resolveTemplate("param", "value").build();

uri.toString(); // returns "http://localhost/myApp?q=value"</pre><p>

            See the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/UriBuilder.html" target="_top">UriBuilder</a> javadoc for more details.
        </p></div><div class="section" title="11.3.&nbsp;Link"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7669"></a>11.3.&nbsp;Link</h2></div></div></div><p>
            JAX-RS 2.0 introduces <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Link.html" target="_top">Link</a> class, which serves as a representation of Web Link defined in
            <a class="link" href="http://tools.ietf.org/html/rfc5988" target="_top">RFC 5988</a>.
            The JAX-RS <code class="literal">Link</code> class adds API support for providing additional metadata in HTTP messages,
            for example, if you are consuming a REST interface of a public library, you might have a resource returning
            description of a single book. Then you can include links to related resources, such as a book category,
            author, etc. to make the produced response concise but complete at the same time. Clients are then able to
            query all the additional information they are interested in and are not forced to consume details they are
            not interested in. At the same time, this approach relieves the server resources as only the information that
            is truly requested is being served to the clients.
        </p><p>
            A <code class="literal">Link</code> can be serialized to an HTTP message (tyically a response) as additional HTTP header
            (there might be multiple <code class="literal">Link</code> headers provided, thus multiple links can be served in a single
            message). Such HTTP header may look like:
            </p><pre class="screen">Link: &lt;http://example.com/TheBook/chapter2&gt;; rel="prev"; title="previous chapter"</pre><p>
        </p><p>
            Producing and consuming Links with JAX-RS API is demonstrated in the following example:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">// server side - adding links to a response:
Response r = Response.ok().
    link("http://oracle.com", "parent").
    link(new URI("http://jersey.java.net"), "framework").
    build();

...

// client-side processing:
final Response response = target.request().get();

URI u = response.getLink("parent").getUri();
URI u = response.getLink("framework").getUri();</pre><p>
        </p><p>
            Instances of <code class="literal">Link</code> can be also created directly by invoking one of the factory methods on the
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Link.html" target="_top">Link</a> API that returns a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Link.Builder.html" target="_top">Link.Builder</a> that can be used to configure and produce new
            links.
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;12.&nbsp;Programmatic API for Building Resources"><div class="titlepage"><div><div><h2 class="title"><a name="resource-builder"></a>Chapter&nbsp;12.&nbsp;Programmatic API for Building Resources</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e7714">12.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e7759">12.2. Programmatic Hello World example</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e7831">12.2.1. Deployment of programmatic resources</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e7893">12.3. Additional examples</a></span></dt><dt><span class="section"><a href="#d0e7952">12.4. Model processors</a></span></dt></dl></div><div class="section" title="12.1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7714"></a>12.1.&nbsp;Introduction</h2></div></div></div><p>A standard approach of developing JAX-RS application is to implement resource classes annotated with <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a>
            with resource methods annotated with HTTP method annotations like <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/GET.html" target="_top">@GET</a> or <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/POST.html" target="_top">@POST</a> and
            implement needed functionality. This approach is described in the chapter
            <a class="link" href="jaxrs-resources.html" target="_top">JAX-RS Application, Resources and Sub-Resources</a>. Besides this standard
            JAX-RS approach, Jersey offers an API for constructing resources programmatically.
            </p><p>
            Imagine a situation where a deployed JAX-RS application consists of many resource classes. These resources implement
            standard HTTP methods like  <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/GET.html" target="_top">@GET</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/POST.html" target="_top">@POST</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/DELETE.html" target="_top">@DELETE</a>. In some situations it would be useful to add
            an <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/OPTIONS.html" target="_top">@OPTIONS</a> method which would return some kind of meta data about the deployed resource. Ideally, you would
            want to expose the functionality as an additional feature and you want to decide at the deploy time whether you want
            to add your custom <code class="literal">OPTIONS</code> method. However, when custom <code class="literal">OPTIONS</code> method are not
            enabled you would like to be <code class="literal">OPTIONS</code> requests handled in the standard way by JAX-RS runtime. To
            achieve this you would need to modify the code to add or remove custom <code class="literal">OPTIONS</code> methods before
            deployment. Another way would be to use programmatic API to build resource according to your needs.
        </p><p>
            Another use case of programmatic resource builder API is when you build any generic RESTful interface which
            depends on lot of configuration parameters or for example database structure. Your resource classes would
            need to have different methods, different structure for every new application deploy. You could use more solutions
            including approaches where your resource classes would be built using Java byte code manipulation.
            However, this is exactly the case when you can solve the problem cleanly with the programmatic resource builder API.
            Let's have a closer look at how the API can be utilized.
        </p></div><div class="section" title="12.2.&nbsp;Programmatic Hello World example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7759"></a>12.2.&nbsp;Programmatic Hello World example</h2></div></div></div><p>
            Jersey Programmatic API was designed to fully support JAX-RS resource model. In other words, every resource that can
            be designed using standard JAX-RS approach via annotated resource classes can be also modelled using Jersey
            programmatic API. Let's try to build simple hello world resource using standard approach first and
            then using the Jersey programmatic resource builder API.
        </p><p>
            The following example shows standard JAX-RS "Hello world!" resource class.
            </p><div class="example"><a name="d0e7766"></a><p class="title"><b>Example&nbsp;12.1.&nbsp;A standard resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    @Path("helloworld")
                    public class HelloWorldResource {

                        @GET
                        @Produces("text/plain")
                        public String getHello() {
                            return "Hello World!";
                        }
                    }
                </pre></div></div><p><br class="example-break">
            This is just a simple resource class with one GET method returning "Hello World!" string that will be serialized
            as text/plain media type.
        </p><p>
            Now we will design this simple resource using programmatic API.
            </p><div class="example"><a name="d0e7774"></a><p class="title"><b>Example&nbsp;12.2.&nbsp;A programmatic resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    package org.glassfish.jersey.examples.helloworld;

                    import javax.ws.rs.container.ContainerRequestContext;
                    import javax.ws.rs.core.Application;
                    import javax.ws.rs.core.Response;
                    import org.glassfish.jersey.process.Inflector;
                    import org.glassfish.jersey.server.ResourceConfig;
                    import org.glassfish.jersey.server.model.Resource;
                    import org.glassfish.jersey.server.model.ResourceMethod;


                    public static class MyResourceConfig extends ResourceConfig {

                        public MyResourceConfig() {
                            final Resource.Builder resourceBuilder = Resource.builder();
                            resourceBuilder.path("helloworld");

                            final ResourceMethod.Builder methodBuilder = resourceBuilder.addMethod("GET");
                            methodBuilder.produces(MediaType.TEXT_PLAIN_TYPE)
                                    .handledBy(new Inflector&lt;ContainerRequestContext, String&gt;() {

                                @Override
                                public String apply(ContainerRequestContext containerRequestContext) {
                                    return "Hello World!";
                                }
                            });

                            final Resource resource = resourceBuilder.build();
                            registerResources(resource);
                        }
                    }
                </pre></div></div><p><br class="example-break">
            First, focus on the content of the <code class="literal">MyResourceConfig</code> constructor in the example.
            The Jersey programmatic resource model is constructed from <code class="literal">Resource</code>s that contain
            <code class="literal">ResourceMethod</code>s. In the example, a single resource would be constructed from a
            <code class="literal">Resource</code> containing one <code class="literal">GET</code> resource method that returns "Hello World!".
            The main entry point for building programmatic resources in Jersey is the
            <span class="emphasis"><em><code class="literal">Resource.Builder</code></em></span> class. <code class="literal">Resource.Builder</code> contains just
            a few methods like the <code class="literal">path</code> method used in the example, which sets the name of the path. Another
            useful method is a <code class="literal">addMethod(String path)</code> which adds a new method to the resource builder and
            returns a resource method builder for the new method. Resource method builder contains methods which
            set consumed and produced media type, define name bindings, timeout for asynchronous executions, etc. It is always
            necessary to define a resource method handler (i.e. the code of the resource method that will return "Hello World!").
            There are more options how a resource method can be handled. In the example the implementation of
            <code class="literal">Inflector</code> is used. The Jersey <code class="literal">Inflector</code> interface defines a simple contract for
            transformation of a request into a response. An inflector can either return a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Response.html" target="_top">Response</a> or directly
            an entity object, the way it is shown in the example. Another option is to setup a Java method handler using
            <code class="literal">handledBy(Class&lt;?&gt; handlerClass, Method method)</code> and pass it the chosen
            <code class="literal">java.lang.reflect.Method</code> instance together with the enclosing class.
        </p><p>
            A resource method model construction can be explicitly completed by invoking <code class="literal">build()</code> on the
            resource method builder. It is however not necessary to do so as the new resource method model will be built
            automatically once the parent resource is built. Once a resource model is built, it is registered
            into the resource config at the last line of the <code class="literal">MyResourceConfig</code> constructor in the example.
        </p><div class="section" title="12.2.1.&nbsp;Deployment of programmatic resources"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7831"></a>12.2.1.&nbsp;Deployment of programmatic resources</h3></div></div></div><p>
                Let's now look at how a programmatic resources are deployed.
                The easiest way to setup your application as well as register any programmatic resources in Jersey
                is to use a Jersey <code class="literal">ResourceConfig</code> utility class, an extension of <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a>
                class.
                If you deploy your Jersey application into a Servlet container you will need to provide a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a>
                subclass that will be used for configuration. You may use a <code class="literal">web.xml</code> where you would define a
                <code class="literal">org.glassfish.jersey.servlet.ServletContainer</code> Servlet entry there and specify initial parameter
                <code class="literal">javax.ws.rs.Application</code> with the class name of your JAX-RS Application that you
                wish to deploy. In the example above, this application will be <code class="literal">MyResourceConfig</code> class. This is
                the reason why <code class="literal">MyResourceConfig</code> extends the <code class="literal">ResourceConfig</code> (which, if you
                remember extends the <code class="literal">javax.ws.rs.Application</code>).
            </p><p>
                The following example shows a fragment of <code class="literal">web.xml</code> that can be used to deploy the
                <code class="literal">ResourceConfig</code> JAX-RS application.
                </p><div class="example"><a name="d0e7874"></a><p class="title"><b>Example&nbsp;12.3.&nbsp;A programmatic resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">
                        ...
                        &lt;servlet&gt;
                            &lt;servlet-name&gt;org.glassfish.jersey.examples.helloworld.MyApplication&lt;/servlet-name&gt;
                            &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt;
                            &lt;init-param&gt;
                                &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
                                &lt;param-value&gt;org.glassfish.jersey.examples.helloworld.MyResourceConfig&lt;/param-value&gt;
                            &lt;/init-param&gt;
                            &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
                        &lt;/servlet&gt;
                        &lt;servlet-mapping&gt;
                            &lt;servlet-name&gt;org.glassfish.jersey.examples.helloworld.MyApplication&lt;/servlet-name&gt;
                            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
                        &lt;/servlet-mapping&gt;
                        ...
                    </pre></div></div><p><br class="example-break">
            </p><p>
                If you use another deployment options and you have accessible instance of ResourceConfig which you use
                for configuration, you can register programmatic resources directly by <code class="literal">registerResources()</code>
                method called on the ResourceConfig. Please note that the method registerResources() replaces all the previously
                registered resources.
            </p><p>
                Because Jersey programmatic API is not a standard JAX-RS feature the <code class="literal">ResourceConfig</code> must be
                used to register programmatic resources as shown above. See <a class="link" href="#deployment" title="Chapter&nbsp;4.&nbsp;Deploying a RESTful Web Service">deployment chapter</a>
                for more information.
            </p></div></div><div class="section" title="12.3.&nbsp;Additional examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7893"></a>12.3.&nbsp;Additional examples</h2></div></div></div><p>
            </p><div class="example"><a name="d0e7898"></a><p class="title"><b>Example&nbsp;12.4.&nbsp;A programmatic resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    final Resource.Builder resourceBuilder = Resource.builder(HelloWorldResource.class);
                    resourceBuilder.addMethod("OPTIONS")
                        .handledBy(new Inflector&lt;ContainerRequestContext, Response&gt;() {
                            @Override
                            public Response apply(ContainerRequestContext containerRequestContext) {
                                return Response.ok("This is a response to an OPTIONS method.").build();
                            }
                        });
                    final Resource resource = resourceBuilder.build();
                </pre></div></div><p><br class="example-break">
        </p><p>
            In the example above the <code class="literal">Resource</code> is built from
            a <code class="literal">HelloWorldResource</code> resource class. The resource model built this way
            contains a <code class="literal">GET</code> method producing <code class="literal">'text/plain'</code> responses with "Hello World!" entity.
            This is quite important as it allows you to whatever Resource objects based on introspecting
            existing JAX-RS resources and use builder API to enhance such these standard resources.
            In the example we used already implemented <code class="literal">HelloWorldResource</code> resource class
            and enhanced it by <code class="literal">OPTIONS</code> method. The <code class="literal">OPTIONS</code> method is handled by an Inflector which
            returns <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Response.html" target="_top">Response</a>.
         </p><p>
            The following sample shows how to define sub-resource methods (methods that contains sub-path).
        </p><p>
            </p><div class="example"><a name="d0e7934"></a><p class="title"><b>Example&nbsp;12.5.&nbsp;A programmatic resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    final Resource.Builder resourceBuilder = Resource.builder("helloworld");

                    final Resource.Builder childResource = resourceBuilder.addChildResource("subresource");
                    childResource.addMethod("GET").handledBy(new GetInflector());

                    final Resource resource = resourceBuilder.build();
                </pre></div></div><p><br class="example-break">
        </p><p>
            Sub-resource methods are defined using so called <span class="emphasis"><em>child resource models</em></span>. Child
            resource models (or child resources) are programmatic resources build in the same way as any other
            programmatic resource but they are registered as a child resource of a parent resource. The child resource
            in the example is build directly from the parent builder using method
            <code class="literal">addChildResource(String path)</code>.
            However, there is also an option to build a child resource model separately as a standard resource and then
            add it as a child resource to a selected parent resource. This means that child resource objects
            can be reused to define child resources in different parent resources (you just build a single child resource
            and then register it in multiple parent resources). Each child resource groups methods with the same sub-resource
            path. Note that a child resource cannot have any child resources as there is nothing like sub-sub-resource
            method concept in JAX-RS. For example if a sub resource method contains more path segments in its path
            (e.g. "/root/sub/resource/method" where "root" is a path of the resource and "sub/resource/method" is the sub
            resource method path) then parent resource will have path "root" and child resource will have path
            "sub/resource/method" (so, there will not be any separate nested sub-resources for "sub", "resource" and "method").
        </p><p>
            See the javadocs of the resource builder API for more information.
            
        </p></div><div class="section" title="12.4.&nbsp;Model processors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7952"></a>12.4.&nbsp;Model processors</h2></div></div></div><p>
            Jersey gives you an option to register so called <span class="emphasis"><em>model processor providers</em></span>. These providers
            are able to modify or enhance the application resource model during application deployment. This is an advanced
            feature and will not be needed in most use cases. However, imagine you would like to add <code class="literal">OPTIONS</code> resource
            method to each deployed resource as it is described at the top of this chapter. You would want to do it for every
            programmatic resource that is registered as well as for all standard JAX-RS resources.
        </p><p>
            To do that, you first need to register a model processor provider in your application, which implements
            <code class="literal">org.glassfish.jersey.server.model.ModelProcessor</code> extension contract. An example of
            a model processor implementation is shown here:
            </p><div class="example"><a name="d0e7968"></a><p class="title"><b>Example&nbsp;12.6.&nbsp;A programmatic resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">
                    import javax.ws.rs.GET;
                    import javax.ws.rs.Path;
                    import javax.ws.rs.Produces;
                    import javax.ws.rs.container.ContainerRequestContext;
                    import javax.ws.rs.core.Application;
                    import javax.ws.rs.core.Configuration;
                    import javax.ws.rs.core.MediaType;
                    import javax.ws.rs.core.Response;
                    import javax.ws.rs.ext.Provider;

                    import org.glassfish.jersey.process.Inflector;
                    import org.glassfish.jersey.server.model.ModelProcessor;
                    import org.glassfish.jersey.server.model.Resource;
                    import org.glassfish.jersey.server.model.ResourceMethod;
                    import org.glassfish.jersey.server.model.ResourceModel;

                    @Provider
                    public static class MyOptionsModelProcessor implements ModelProcessor {

                        @Override
                        public ResourceModel processResourceModel(ResourceModel resourceModel, Configuration configuration) {
                            // we get the resource model and we want to enhance each resource by OPTIONS method
                            ResourceModel.Builder newResourceModelBuilder = new ResourceModel.Builder(false);
                            for (final Resource resource : resourceModel.getResources()) {
                                // for each resource in the resource model we create a new builder which is based on the old resource
                                final Resource.Builder resourceBuilder = Resource.builder(resource);

                                // we add a new OPTIONS method to each resource
                                // note that we should check whether the method does not yet exist to avoid failures
                                resourceBuilder.addMethod("OPTIONS")
                                    .handledBy(new Inflector&lt;ContainerRequestContext, String&gt;() {
                                        @Override
                                        public String apply(ContainerRequestContext containerRequestContext) {
                                            return "On this path the resource with " + resource.getResourceMethods().size()
                                                + " methods is deployed.";
                                        }
                                        }).produces(MediaType.TEXT_PLAIN);

                                // we add to the model new resource which is a combination of the old resource enhanced
                                // by the OPTIONS method
                                newResourceModelBuilder.addResource(resourceBuilder.build());
                            }

                            final ResourceModel newResourceModel = newResourceModelBuilder.build();
                            // and we return new model
                            return newResourceModel;
                        };

                        @Override
                        public ResourceModel processSubResource(ResourceModel subResourceModel, Configuration configuration) {
                            // we just return the original subResourceModel which means we do not want to do any modification
                            return subResourceModel;
                        }
                    }
                </pre></div></div><p><br class="example-break">
            The <code class="literal">MyOptionsModelProcessor</code> from the example is a relatively simple model processor which
            iterates over all registered resources and for all of them builds a new resource that is equal to the old resource
            except it is enhanced with a new <code class="literal">OPTIONS</code> method.
        </p><p>
            Note that you only need to register such a ModelProcessor as your custom extension provider in the same way as you
            would register any standard JAX-RS extension provider. During an application deployment, Jersey will look for any
            registered model processor and execute them. As you can seem, model processors are very powerful as they can do
            whatever manipulation with the resource model they like. A model processor can even, for example, completely ignore
            the old resource model and return a new custom resource model with a single "Hello world!" resource, which would
            result in only the "Hello world!" resource being deployed in your application. Of course, it would not not make
            much sense to implement such model processor, but the scenario demonstrates how powerful the model processor concept
            is. A better, real-life use case scenario would, for example, be to always add some custom new resource to each
            application that might return additional metadata about the deployed application. Or, you might want to
            filter out particular resources or resource methods, which is another situation where a model processor could
            be used successfully.
        </p><p>
            Also note that <code class="literal">processSubResource(ResourceModel subResourceModel, Configuration configuration)</code>
            method is executed for each sub resource returned from the sub resource locator. The example is simplified and does
            not do any manipulation but probably in such a case you would want to enhance all sub resources with
            a new <code class="literal">OPTIONS</code> method handlers too.
        </p><p>
            It is important to remember that any model processor must always return valid resource model. As you might have
            already noticed, in the example above this important rule is not followed. If any of the resources in the original
            resource model would already have an <code class="literal">OPTIONS</code> method handler defined, adding another handler would cause
            the application fail during the deployment in the resource model validation phase. In order to retain the consistency
            of the final model, a model processor implementation would have to be more robust than what is shown in the example.
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;13.&nbsp;Server-Sent Events (SSE) Support"><div class="titlepage"><div><div><h2 class="title"><a name="sse"></a>Chapter&nbsp;13.&nbsp;Server-Sent Events (SSE) Support</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e7999">13.1. What are Server-Sent Events</a></span></dt><dt><span class="section"><a href="#d0e8042">13.2. When to use Server-Sent Events</a></span></dt><dt><span class="section"><a href="#overview">13.3. Jersey Server-Sent Events API</a></span></dt><dt><span class="section"><a href="#d0e8182">13.4. Implementing SSE support in a JAX-RS resource</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8185">13.4.1. Simple SSE resource method</a></span></dt><dt><span class="section"><a href="#d0e8342">13.4.2. Broadcasting with Jersey SSE</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8450">13.5. Consuming SSE events with Jersey clients</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8466">13.5.1. Reading SSE events with <code class="literal">EventInput</code></a></span></dt><dt><span class="section"><a href="#d0e8540">13.5.2. Asynchronous SSE processing with <code class="literal">EventSource</code></a></span></dt></dl></dd></dl></div><div class="section" title="13.1.&nbsp;What are Server-Sent Events"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e7999"></a>13.1.&nbsp;What are Server-Sent Events</h2></div></div></div><p>
            In a standard HTTP request-response scenario a client opens a connection, sends a HTTP request to the server (for
            example a HTTP <code class="literal">GET</code> request), then receives a HTTP response back and the server closes the connection once
            the response is fully sent/received. The initiative <span class="emphasis"><em>always</em></span> comes from a client when the client
            requests all the data. In contrast, <span class="emphasis"><em>Server-Sent Events (SSE)</em></span> is a mechanism that allows server
            to asynchronously push the data from the server to the client once the client-server connection is established by the
            client. Once the connection is established by the client, it is the server who provides the data and decides
            to send it to the client whenever new "chunk" of data is available. When a new data event occurs on the server,
            the data event is sent by the server to the client. Thus the name Server-Sent Events. Note that at high level there
            are more technologies working on this principle, a short overview of the technologies supporting server-to-client
            communication is in this list:

            </p><div class="variablelist"><dl><dt><span class="term">Polling</span></dt><dd><p>
                            With polling a client repeatedly sends new requests to a server. If the server has no new data,
                            then it send appropriate indication and closes the connection. The client then waits a bit and sends
                            another request after some time (after one second, for example).
                        </p></dd><dt><span class="term">Long-polling</span></dt><dd><p>
                            With long-polling a client sends a request to a server. If the server has no new data,
                            it just holds the connection open and waits until data is available. Once the server has data
                            (message) for the client, it uses the connection and sends it back to the client. Then the connection
                            is closed.
                        </p></dd><dt><span class="term">Server-Sent events</span></dt><dd><p>
                            SSE is similar to the long-polling mechanism, except it does not send only one message per connection.
                            The client sends a request and server holds a connection until a new message is ready, then it sends
                            the message back to the client while still keeping the connection open so that it can be used
                            for another message once it becomes available. Once a new message is ready, it is sent back to the
                            client on the same initial connection. Client processes the messages sent back from the server
                            individually without closing the connection after processing each message.
                            So, SSE typically reuses one connection for more messages (called events). SSE also defines a
                            dedicated media type that describes a simple format of individual evnets sent from the server to the
                            client. SSE also offers standard javascript client API implemented most modern browsers. For more
                            information about SSE, see the <a class="link" href="http://www.w3.org/TR/2009/WD-eventsource-20091029/" target="_top">SSE API specification</a>.
                        </p></dd><dt><span class="term">WebSocket</span></dt><dd><p>
                            WebSocket technology is different from previous technologies as it provides a real full duplex
                            connection. The initiator is again a client which sends a request to a server with a special HTTP
                            header that informs the server that the HTTP connection may be "upgraded" to a full duplex TCP/IP
                            WebSocket connection. If server supports WebSocket, it may choose to do so. Once a WebSocket
                            connection is established, it can be used for bi-directional communication between the client and the
                            server. Both client and server can then send data to the other party at will whenever it is needed.
                            The communication on the new WebSocket connection is no longer based on HTTP protocol and can be
                            used for example for for online gaming or any other applications that require fast exchange of small
                            chunks of data in flowing in both directions.
                        </p></dd></dl></div><p>
        </p></div><div class="section" title="13.2.&nbsp;When to use Server-Sent Events"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8042"></a>13.2.&nbsp;When to use Server-Sent Events</h2></div></div></div><p>
            As explained above, SSE is a technology that allows clients to subscribe to event notifications that originate on
            a server. Server generates new events and sends these events back to the clients subscribed to receive the
            notifications. In other words, SSE offers a solution for a one-way publish-subscribe model.
        </p><p>
            A good example of the use case where SSE can be used is a simple message exchange RESTful service. Clients
            <code class="literal">POST</code> new messages to the service and subscribe to receive messages from other clients.
            Let's call the resource <code class="literal">messages</code>. While <code class="literal">POST</code>ing a new message to this resource involves
            a typical HTTP request-response communication between a client and the <code class="literal">messages</code> resource,
            subscribing to receive all new message notifications would be hard and impractical to model with a sequence of
            standard request-response message exchanges. Using Server-sent events provides a much more practical approach here.
            You can use SSE to let clients subscribe to the <code class="literal">messages</code> resource via standard <code class="literal">GET</code>
            request (use a SSE client API, for example javascript API or Jersey Client SSE API) and let the server broadcast
            new messages to all connected clients in the form of individual events (in our case using Jersey Server SSE API).
            Note that with Jersey a SSE support is implemented as an usual JAX-RS resource method. There's no need to do anything
            special to provide a SSE support in your Jersey/JAX-RS applications, your SSE-enabled resources are a standard part of
            your RESTful Web application that defines the REST API of your application. The following chapters describes SSE
            support in Jersey in more details.
        </p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                Note, that while SSE in Jersey is supported with standard JAX-RS resources, Jersey SSE APIs are not part of
                the JAX-RS specification. SSE support and related APIs are a Jersey specific feature that extends JAX-RS.
            </p></div></div><div class="section" title="13.3.&nbsp;Jersey Server-Sent Events API"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview"></a>13.3.&nbsp;Jersey Server-Sent Events API</h2></div></div></div><p>
            This chapter briefly describes the Jersey support for SSE. Details and examples will be covered
            in chapters below.
        </p><p>
            Jersey contains support for SSE for both - server and client. SSE in Jersey is implemented as an extension
            supporting a new media type, which means that SSE really treated as just another media type that can be returned from
            a resource method and processed by the client. There is only a minimal additional support for "chunked" messages
            added to Jersey which could not be implemented as standard JAX-RS media type extension.
        </p><p>
            Before you start working with Jersey SSE, in order to add support for SSE you need to include the dependency to the
            <span class="emphasis"><em>SSE media type module</em></span>:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-media-sse&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><p>
            Then you need register <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a>. The <code class="literal">SseFeature</code> is a feature that can be registered
            for both, the client and the server.
        </p><p>
            <code class="literal">SseFeature</code> adds new supported entity (representation) Java types, namely <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/OutboundEvent.html" target="_top">OutboundEvent</a>
            for the outbound server events and <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/InboundEvent.html" target="_top">InboundEvent</a> for inbound client events. These types are serialized by
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/OutboundEventWriter.html" target="_top">OutboundEventWriter</a> and de-serialized by <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/InboundEventReader.html" target="_top">InboundEventReader</a>.
            There is no restriction for a media type used in individual event messages; however the media type used for a SSE
            stream as whole is <span class="emphasis"><em>"text/event-stream"</em></span> and this media type should be set on messages that
            are used to serve SSE events (for example on the server side using <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> on the method that returns an
            <code class="literal">EventOutput</code> - see bellow).
            The <code class="literal">InboundEvent</code> and <code class="literal">OutboundEvent</code> contain all the fields needed for composing
            and processing individual SSE events. These entities represent the <span class="emphasis"><em>chunks</em></span> sent or received over
            an open server-to-client connection that is represented by an <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ChunkedOuptut.html" target="_top">ChunkedOutput</a> on the servers side and
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ChunkedInput.html" target="_top">ChunkedInput</a> on the client side (if you are not familiar with
            <code class="literal">ChunkedOutput</code> and <code class="literal">ChunkedInput</code>, see the
            <a class="link" href="#async" title="Chapter&nbsp;10.&nbsp;Asynchronous Services and Clients">Async chapter</a> first for more details). In other words, our resource method that is used
            to open a SSE connection to a client does not return individual <code class="literal">OutboundEvent</code>s. Instead, a new
            instance of <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a> is returned. <code class="literal">EventOutput</code> is a typed extension of
            <code class="literal">ChunkedOutput&lt;OutboundEvent&gt;</code>. Similarly, to receive <code class="literal">InboundEvent</code>s on a
            client side, Jersey SSE API provides a <code class="literal">EventInput</code> that represents a typed extension of
            <code class="literal">ChunkedInput&lt;InboundEvent&gt;</code>.
        </p><p>
            The Jersey server SSE API also contains a <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/SseBroadcaster.html" target="_top">SseBroadcaster</a> utility, that provides a convenient way of
            grouping multiple <code class="literal">EventOutput</code> instances that represent individual client connections into a
            group, and exposes methods for broadcasting new events to all the client connections grouped in the broadcaster.
            The <code class="literal">SseBroadcaster</code> inherits from <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/Broadcaster.html" target="_top">Broadcaster</a> which is the generic broadcaster
            implementation of the Jersey chunked message processing facility.
            On the he client side, the Jersey SSE API contains additional <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventSource.html" target="_top">EventSource</a> and <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventListener.html" target="_top">EventListener</a>
            classes that further improve convenience of processing new inbound SSE events.
        </p></div><div class="section" title="13.4.&nbsp;Implementing SSE support in a JAX-RS resource"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8182"></a>13.4.&nbsp;Implementing SSE support in a JAX-RS resource</h2></div></div></div><div class="section" title="13.4.1.&nbsp;Simple SSE resource method"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8185"></a>13.4.1.&nbsp;Simple SSE resource method</h3></div></div></div><p>
                Firstly you need to add a <a class="link" href="#sse.dependency">Jersey SSE module dependency</a> to your project
                as shown in the earlier section and register the <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a> from this module in your
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a> or <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a>. Once done, you are ready to add SSE support
                to your resource:

                </p><div class="example"><a name="example-simple-sse"></a><p class="title"><b>Example&nbsp;13.1.&nbsp;Simple SSE resource method</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import org.glassfish.jersey.media.sse.EventOutput;
import org.glassfish.jersey.media.sse.OutboundEvent;
import org.glassfish.jersey.media.sse.SseFeature;
...

@Path("events")
public static class SseResource {

    @GET
    @Produces(SseFeature.SERVER_SENT_EVENTS)
    public EventOutput getServerSentEvents() {
        final EventOutput eventOutput = new EventOutput();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    for (int i = 0; i &lt; 10; i++) {
                        // ... code that waits 1 second
                        final OutboundEvent.Builder eventBuilder
                        = new OutboundEvent.Builder();
                        eventBuilder.name("message-to-client");
                        eventBuilder.data(String.class,
                            "Hello world " + i + "!");
                        final OutboundEvent event = eventBuilder.build();
                        eventOutput.write(event);
                    }
                } catch (IOException e) {
                    throw new RuntimeException(
                        "Error when writing the event.", e);
                } finally {
                    try {
                        eventOutput.close();
                    } catch (IOException ioClose) {
                        throw new RuntimeException(
                            "Error when closing the event output.", ioClose);
                    }
                }
            }
        }).start();
        return eventOutput;
    }
}</pre></div></div><p><br class="example-break">

                The code above defines the resource deployed on URI <code class="literal">"/events"</code>. This resource has a single
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/GET.html" target="_top">@GET</a> resource method which returns as an entity <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a> - an extension of generic Jersey
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ChunkedOuptut.html" target="_top">ChunkedOutput</a> API for output chunked message processing.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If you are not familiar with
                        <code class="literal">ChunkedOutput</code> and <code class="literal">ChunkedInput</code>, see the
                        <a class="link" href="#async" title="Chapter&nbsp;10.&nbsp;Asynchronous Services and Clients">Async chapter</a> first for more details.
                    </p></div><p>
                After the <code class="literal">eventOutput</code> is returned from the method, the Jersey runtime recognizes that this is
                a <code class="literal">ChunkedOutput</code> extension and does not close the client connection immediately. Instead, it
                writes the HTTP headers to the response stream and waits for more chunks (SSE events) to be sent. At this point
                the client can read headers and starts listening for individual events.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Since Jersey runtime does not implicitly close the connection to the client (similarly to asynchronous
                        processing), closing the connection is a responsibility of the resource method or the client listening
                        on the open connection for new events (see following example).
                    </p></div><p>
            </p><p>
                In the <a class="xref" href="#example-simple-sse" title="Example&nbsp;13.1.&nbsp;Simple SSE resource method">Example&nbsp;13.1, &#8220;Simple SSE resource method&#8221;</a>, the resource method creates a new thread that sends a sequence of
                10 events. There is a 1 second delay between two subsequent events as indicated in a comment. Each event is
                represented by <code class="literal">OutboundEvent</code> type and is built with a helpf of an outbound event
                <code class="literal">Builder</code>. The <code class="literal">OutboundEvent</code> reflects the standardized format of SSE messages
                and contains properties that represent <code class="literal">name</code> (for named
                events), <code class="literal">comment</code>, <code class="literal">data</code> or <code class="literal">id</code>. The code also sets the
                event data media type using the <code class="literal">mediaType(MediaType)</code> method on the
                <code class="literal">eventBuilder</code>. The media type, together with the data type set by the
                <code class="literal">data(Class, Object&gt;</code> method (in our case <code class="literal">String.class</code>), is used
                for serialization of the event data. Note that the event data media type will not be written to any headers as
                the response <code class="literal">Content-type</code> header is already defined by the <code class="literal">@Produces</code> and set to
                <code class="literal">"text/event-stream"</code> using constant from the <code class="literal">SseFeature</code>.
                The event media type is used for serialization of event <code class="literal">data</code>. Event data media type and Java
                type are used to select the proper <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a> for event data serialization and are passed
                to the selected writer that serializes the event <code class="literal">data</code> content. In our case the string
                <code class="literal">"Hello world " + i + "!"</code> is serialized as <code class="literal">"text/plain"</code>. In event
                <code class="literal">data</code> you can send any Java entity and associate it with any media type that you would be able
                to serialize with an available <code class="literal">MessageBodyWriter&lt;T&gt;</code>. Typically, you may want to send e.g. JSON data,
                so you would fill the <code class="literal">data</code> with a JAXB annotated bean instance and define media type to JSON.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        If the event media type is not set explicitly, the <code class="literal">"text/plain"</code> media type is used
                        by default.
                    </p></div><p>
            </p><p>
                Once an outbound event is ready, it can be written to the <code class="literal">eventOutput</code>. At that point the event
                is serialized by internal <code class="literal">OutboundEventWriter</code> which uses an appropriate
                <code class="literal">MessageBodyWriter&lt;T&gt;</code> to serialize the <code class="literal">"Hello world " + i + "!"</code> string. You can
                send as many messages as you like. At the end of the thread execution the response is closed which also closes
                the connection to the client. After that, no more messages can be send to the client on this connection. If the
                client would like to receive more messages, it would have to send a new request to the server to initiate a
                new SSE streaming connection.
            </p><p>
                A client connecting to our SSE-enabled resource will receive the following data from the entity stream:

                </p><pre class="screen">event: message-to-client
data: Hello world 0!

event: message-to-client
data: Hello world 1!

event: message-to-client
data: Hello world 2!

event: message-to-client
data: Hello world 3!

event: message-to-client
data: Hello world 4!

event: message-to-client
data: Hello world 5!

event: message-to-client
data: Hello world 6!

event: message-to-client
data: Hello world 7!

event: message-to-client
data: Hello world 8!

event: message-to-client
data: Hello world 9!</pre><p>

                Each message is received with a delay of one second.
            </p></div><div class="section" title="13.4.2.&nbsp;Broadcasting with Jersey SSE"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8342"></a>13.4.2.&nbsp;Broadcasting with Jersey SSE</h3></div></div></div><p>
                Jersey SSE server API defines <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/SseBroadcaster.html" target="_top">SseBroadcaster</a> which allows to broadcast individual events to multiple
                clients. A simple broadcasting implementation is shown in the following example:

                </p><div class="example"><a name="d0e8350"></a><p class="title"><b>Example&nbsp;13.2.&nbsp;Broadcasting SSE messages</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">...
import org.glassfish.jersey.media.sse.SseBroadcaster;
...

@Singleton
@Path("broadcast")
public static class BroadcasterResource {

    private SseBroadcaster broadcaster = new SseBroadcaster();

    @POST
    @Produces(MediaType.TEXT_PLAIN)
    @Consumes(MediaType.TEXT_PLAIN)
    public String broadcastMessage(String message) {
        OutboundEvent.Builder eventBuilder = new OutboundEvent.Builder();
        OutboundEvent event = eventBuilder.name("message")
            .mediaType(MediaType.TEXT_PLAIN_TYPE)
            .data(String.class, message)
            .build();

        broadcaster.broadcast(event);

        return "Message was '" + message + "' broadcast.";
    }

    @GET
    @Produces(SseFeature.SERVER_SENT_EVENTS)
    public EventOutput listenToBroadcast() {
        final EventOutput eventOutput = new EventOutput();
        this.broadcaster.add(eventOutput);
        return eventOutput;
    }
}</pre></div></div><p><br class="example-break">

                Let's explore the example together. The <code class="literal">BroadcasterResource</code> resource class is annotated with
                <a class="link" href="http://docs.oracle.com/javaee/6/api/javax/inject/Singleton.html" target="_top">@Singleton</a> annotation which tells Jersey runtime that only a single instance of the resource
                class should be used to serve all the incoming requests to <code class="literal">/broadcast</code> path. This is needed as
                we want to keep an application-wide single reference to the private <code class="literal">broadcaster</code> field so that
                we can use the same instance for all requests. Clients that want to listen to SSE events first send a
                <code class="literal">GET</code> request to the <code class="literal">BroadcasterResource</code>, that is handled by the
                <code class="literal">listenToBroadcast()</code> resource method.
                The method creates a new <code class="literal">EventOutput</code> representing the connection to the requesting client
                and registers this <code class="literal">eventOutput</code> instance with the singleton <code class="literal">broadcaster</code>,
                using its <code class="literal">add(EventOutput)</code> method. The method then returns the <code class="literal">eventOutput</code>
                which causes Jersey to bind the <code class="literal">eventOutput</code> instance with the requesting client and send the
                response HTTP headers to the client. The client connection remains open and the client is now waiting ready to
                receive new SSE events. All the events are written to the <code class="literal">eventOutput</code> by
                <code class="literal">broadcaster</code> later on. This way developers can conveniently handle sending new events to
                all the clients that subscribe to them.
            </p><p>
                When a client wants to broadcast new message to all the clients listening on their SSE connections,
                it sends a <code class="literal">POST</code> request to <code class="literal">BroadcasterResource</code> resource with the message content.
                The method <code class="literal">broadcastMessage(String)</code> is invoked on <code class="literal">BroadcasterResource</code>
                resource with the message content as an input parameter. A new SSE outbound event is built in the standard way
                and passed to the broadcaster. The broadcaster internally invokes <code class="literal">write(OutboundEvent)</code> on all
                registered <code class="literal">EventOutput</code>s. After that the method just return a standard text response
                to the <code class="literal">POST</code>ing client to inform the client that the message was successfully broadcast. As you can see,
                the <code class="literal">broadcastMessage(String)</code> resource method is just a simple JAX-RS resource method.
            </p><p>
                In order to implement such a scenario, you may have noticed, that the Jersey  <code class="literal">SseBroadcaster</code>
                is not mandatory to complete the use case. individual <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a>s can be just stored in a collection
                and iterated over in the <code class="literal">broadcastMessage</code> method. However, the <code class="literal">SseBroadcaster</code>
                internally identifies and handles also client disconnects. When a client closes the connection the broadcaster
                detects this and removes the stale connection from the internal collection of the registered
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a>s as well as it frees all the server-side resources associated with the stale connection.
                Additionally, the <code class="literal">SseBroadcaster</code> is implemented to be thread-safe, so that clients can connect
                and disconnect in any time and <code class="literal">SseBroadcaster</code> will always broadcast messages to the most recent
                collection of registered and active set of clients.
            </p></div></div><div class="section" title="13.5.&nbsp;Consuming SSE events with Jersey clients"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8450"></a>13.5.&nbsp;Consuming SSE events with Jersey clients</h2></div></div></div><p>
            On the client side, Jersey exposes APIs that support receiving and processing SSE events using two programming models:

            </p><table border="0" summary="Simple list" class="simplelist"><tr><td>Pull model - pulling events from a <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventInput.html" target="_top">EventInput</a>, or</td></tr><tr><td>Push model - listening for asynchronous notifications of <code class="literal">EventSource</code></td></tr></table><p>

            Both models will be described.
        </p><div class="section" title="13.5.1.&nbsp;Reading SSE events with EventInput"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8466"></a>13.5.1.&nbsp;Reading SSE events with <code class="literal">EventInput</code></h3></div></div></div><p>
                The events can be read on the client side from a <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventInput.html" target="_top">EventInput</a>. See the following code:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
        .register(SseFeature.class).build();
WebTarget target = client.target("http://localhost:9998/events");

EventInput eventInput = target.request().get(EventInput.class);
while (!eventInput.isClosed()) {
    final InboundEvent inboundEvent = eventInput.read();
    if (inboundEvent == null) {
        // connection has been closed
        break;
    }
    System.out.println(inboundEvent.getName() + "; "
        + inboundEvent.readData(String.class));
}</pre><p>

                In this example, a client connects to the server where the <code class="literal">SseResource</code> from the
                <a class="xref" href="#example-simple-sse" title="Example&nbsp;13.1.&nbsp;Simple SSE resource method">Example&nbsp;13.1, &#8220;Simple SSE resource method&#8221;</a> is deployed. At first, a new JAX-RS/Jersey <code class="literal">client</code>
                instance is created with a <code class="literal">SseFeature</code> registered. Then a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> instance is
                retrieved from the <code class="literal">client</code> and is used to invoke a HTTP request. The returned response entity
                is directly read as a <code class="literal">EventInput</code> Java type, which is an extension of Jersey
                <code class="literal">ChunkedInput</code> that provides generic support for consuming chunked message payloads. The
                code in the example then process starts a loop to process the inbound SSE events read from the
                <code class="literal">eventInput</code> response stream. Each chunk read from the input is a <code class="literal">InboundEvent</code>.
                The method <code class="literal">InboundEvent.readData(Class)</code> provides a way for the client to indicate what Java type
                should be used for the event data de-serialization. In our example, individual events are de-serialized as
                 <code class="literal">String</code> Java type instances. This method internally finds and executes a proper
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> which is the used to do the actual de-serialization. This is similar to reading an
                entity from the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Response.html" target="_top">Response</a> by <code class="literal">readEntity(Class)</code>. The method
                <code class="literal">readData</code> can also throw a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ProcessingException.html" target="_top">ProcessingException</a>.
            </p><p>
                The <code class="literal">null</code> check on <code class="literal">inboundEvent</code> is necessary to make sure that the chunk was properly
                read and connection has not been closed by the server. Once the connection is closed, the loop terminates and
                the program completes execution. The client code produces the following console output:

                </p><pre class="screen">message-to-client; Hello world 0!
message-to-client; Hello world 1!
message-to-client; Hello world 2!
message-to-client; Hello world 3!
message-to-client; Hello world 4!
message-to-client; Hello world 5!
message-to-client; Hello world 6!
message-to-client; Hello world 7!
message-to-client; Hello world 8!
message-to-client; Hello world 9!</pre><p>
            </p></div><div class="section" title="13.5.2.&nbsp;Asynchronous SSE processing with EventSource"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8540"></a>13.5.2.&nbsp;Asynchronous SSE processing with <code class="literal">EventSource</code></h3></div></div></div><p>
                The main Jersey SSE client API component used to read SSE events asynchronously is <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventSource.html" target="_top">EventSource</a>.
                The usage of the <code class="literal">EventSource</code> is shown on the following example.
                </p><div class="example"><a name="sse.ex.client.eventListener"></a><p class="title"><b>Example&nbsp;13.3.&nbsp;Registering <code class="literal">EventListener</code> with <code class="literal">EventSource</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
                        .register(SseFeature.class).build();
WebTarget target = client.target("http://example.com/events");
EventSource eventSource = EventSource.target(target).build();
EventListener listener = new EventListener() {
        @Override
        public void onEvent(InboundEvent inboundEvent) {
            System.out.println(inboundEvent.getName() + "; "
                    + inboundEvent.readData(String.class));
        }
    };
eventSource.register(listener, "message-to-client");
eventSource.open();
...
eventSource.close();</pre></div></div><p><br class="example-break">

                In this example, the client code again connects to the server where the <code class="literal">SseResource</code> from the
                <a class="xref" href="#example-simple-sse" title="Example&nbsp;13.1.&nbsp;Simple SSE resource method">Example&nbsp;13.1, &#8220;Simple SSE resource method&#8221;</a> is deployed. The <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Client.html" target="_top">Client</a> instance
                is again created and initialized with <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/SseFeature.html" target="_top">SseFeature</a>. Then the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> is built.
                In this case a request to the web target is not made directly in the code, instead, the web target instance
                is used to initialize a new <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventSource.Builder.html" target="_top">EventSource.Builder</a> instance that is used to build a new
                <code class="literal">EventSource</code>. The choice of <code class="literal">build()</code> method is important, as it tells
                the <code class="literal">EventSource.Builder</code> to create a new <code class="literal">EventSource</code> that is not automatically
                connected to the <code class="literal">target</code>. The connection is established only later by manually invoking
                the <code class="literal">eventSource.open()</code> method. A custom <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventListener.html" target="_top">EventListener</a>
                implementation is used to listen to and process incoming SSE events. The method readData(Class) says that the
                event data should be de-serialized from a received <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/InboundEvent.html" target="_top">InboundEvent</a> instance into a
                <code class="literal">String</code> Java type. This method call internally executes <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a> which
                de-serializes the event data. This is similar to reading an entity from the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Response.html" target="_top">Response</a> by
                <code class="literal">readEntity(Class)</code>. The method <code class="literal">readData</code> can throw a
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ProcessingException.html" target="_top">ProcessingException</a>.
            </p><p>
                The custom event source listener is registered in the event source via
                <code class="literal">EventSource</code><code class="literal">.register(EventListener, String)</code> method. The next method
                arguments define the names of the events to receive and can be omitted. If names are defined, the listener
                will be associated with the named events and will only invoked for events with a name from the set of defined
                event names. It will not be invoked for events with any other name or for events without a name.

                </p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                        It is a common mistake to think that unnamed events will be processed by listeners that are registered
                        to process events from a particular name set. That is NOT the case! Unnamed events are only processed
                        by listeners that are not name-bound. The same limitation applied to HTML5 Javascript SSE Client API
                        supported by modern browsers.
                    </p></div><p>

                After a connection to the server is opened by calling the <code class="literal">open()</code> method on the event source,
                the <code class="literal">eventSource</code> starts listening to events. When an event named
                <code class="literal">"message-to-client"</code> comes, the listener will be executed by the event source. If any other
                event comes (with a name different from <code class="literal">"message-to-client"</code>), the registered listener is not
                invoked. Once the client is done with processing and does not want to receive events anymore, it closes the
                connection by calling the <code class="literal">close()</code> method on the event source.
            </p><p>
                The listener from the example above will print the following output:
                </p><pre class="screen">message-to-client; Hello world 0!
message-to-client; Hello world 1!
message-to-client; Hello world 2!
message-to-client; Hello world 3!
message-to-client; Hello world 4!
message-to-client; Hello world 5!
message-to-client; Hello world 6!
message-to-client; Hello world 7!
message-to-client; Hello world 8!
message-to-client; Hello world 9!</pre><p>
            </p><p>
                When browsing through the Jersey SSE API documentation, you may have noticed that the <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventSource.html" target="_top">EventSource</a>
                implements <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventListener.html" target="_top">EventListener</a> and provides an empty implementation for the
                <code class="literal">onEvent(InboundEvent inboundEvent)</code> listener method. This adds more flexibility to the
                Jersey client-side SSE API. Instead of defining and registering a separate event listener, in simple scenarios
                you can also choose to derive directly from the <code class="literal">EventSource</code> and override the empty listener
                method to handle the incoming events. This programming model is shown in the following example:

                </p><div class="example"><a name="d0e8668"></a><p class="title"><b>Example&nbsp;13.4.&nbsp;Overriding <code class="literal">EventSource.onEvent(InboundEvent)</code> method</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Client client = ClientBuilder.newBuilder()
                        .register(SseFeature.class).build();
WebTarget target = client.target("http://example.com/events");
EventSource eventSource = new EventSource(target) {
    @Override
    public void onEvent(InboundEvent inboundEvent) {
        if ("message-to-client".equals(inboundEvent.getName())) {
            System.out.println(inboundEvent.getName() + "; "
                    + inboundEvent.readData(String.class));
        }
    }
};
...
eventSource.close();</pre></div></div><p><br class="example-break">

                The code above is very similar to the code in <a class="xref" href="#sse.ex.client.eventListener" title="Example&nbsp;13.3.&nbsp;Registering EventListener with EventSource">Example&nbsp;13.3, &#8220;Registering <code class="literal">EventListener</code> with <code class="literal">EventSource</code>&#8221;</a>. In this example
                however, the <code class="literal">EventSource</code> is constructed directly using a single-parameter constructor.
                This way, the connection to the SSE endpoint is by default automatically opened at the event source
                creation. The implementation of the <code class="literal">EventListener</code> has been moved into the overridden
                <code class="literal">EventSource.onEvent(...)</code> method. However, this time, the listener method will be executed for
                all events - unnamed as well as with any <code class="literal">name</code>. Therefore the code checks the name whether it is
                an event with the name "message-to-client" that we want to handle. Note that you can still register
                additional <code class="literal">EventListener</code>s later on. The overridden method on the event source allows you to
                handle messages even when no additional listeners are registered yet.
            </p><div class="section" title="13.5.2.1.&nbsp;EventSource reconnect support"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8694"></a>13.5.2.1.&nbsp;<code class="literal">EventSource</code> reconnect support</h4></div></div></div><p>
                    Starting in Jersey 2.3, the <code class="literal">EventSource</code> implementation supports automated recuperation
                    from a connection loss, including negotiation of delivery of any missed events based on the last received
                    SSE event <code class="literal">id</code> field value, provided this field is set by the server and the negotiation
                    facility is supported by the server. In case of a connection loss, the last received SSE event
                    <code class="literal">id</code> field value is send in the <code class="literal">Last-Event-ID</code> HTTP request
                    header as part of a new connection request sent to the SSE endpoint. Upon a receipt of such reconnect request,
                    the SSE endpoint that supports this negotiation facility is expected to replay all missed events.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Note, that SSE lost event negotiation facility is a best-effort mechanism which does not provide
                        any guaranty that all events would be delivered without a loss. You should therefore not
                        rely on receiving every single event and design your client application code accordingly.
                    </p></div><p>
                    By default, when a connection the the SSE endpoint is lost, the event source will use a default delay
                    before attempting to reconnect to the SSE endpoint. The SSE endpoint can however control the client-side
                    retry delay by including a special <code class="literal">retry</code> field value in the any send event.
                    Jersey <code class="literal">EventSource</code> implementation automatically tracks any received SSE event
                    <code class="literal">retry</code> field values set by the endpoint and adjusts the reconnect delay accordingly,
                    using the last received <code class="literal">retry</code> field value as the new reconnect delay.
                </p><p>
                    In addition to handling the standard connection losses, Jersey <code class="literal">EventSource</code> automatically
                    deals with any <code class="literal">HTTP 503 Service Unavailable</code> responses received from the SSE endpoint,
                    that include a <code class="literal">Retry-After</code> HTTP header with a valid value. The
                    <code class="literal">HTTP 503 + Retry-After</code> technique is often used by HTTP endpoints as a means of
                    connection and traffic throttling. In case a <code class="literal">HTTP 503 + Retry-After</code> response is received
                    in return to a connection request from SSE endpoint, Jersey {@code EventSource} will automatically
                    schedule a reconnect attempt  and use the received <code class="literal">Retry-After</code> HTTP header value as a
                    one-time override of the reconnect delay.
                </p></div></div></div></div><div lang="en" class="chapter" title="Chapter&nbsp;14.&nbsp;Security"><div class="titlepage"><div><div><h2 class="title"><a name="security"></a>Chapter&nbsp;14.&nbsp;Security</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e8754">14.1. Securing server</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e8757">14.1.1. SecurityContext</a></span></dt><dt><span class="section"><a href="#d0e8865">14.1.2. Authorization - securing resources</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e8969">14.2. Client Security</a></span></dt><dt><span class="section"><a href="#d0e8986">14.3. OAuth</a></span></dt></dl></div><div class="section" title="14.1.&nbsp;Securing server"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8754"></a>14.1.&nbsp;Securing server</h2></div></div></div><div class="section" title="14.1.1.&nbsp;SecurityContext"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8757"></a>14.1.1.&nbsp;SecurityContext</h3></div></div></div><p>
                Security information is available by injecting a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/SecurityContext.html" target="_top">SecurityContext</a> instance using <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Context.html" target="_top">@Context</a>
                annotation, that provides essentially the equivalent of the functionality available on
                <a class="link" href="http://docs.oracle.com/javaee/5/api/javax/servlet/http/HttpServletRequest.html" target="_top">HttpServletRequest</a>
                API. The injected security context depends on the actual Jersey application deployment. For example, if a
                Jersey application is deployed in a Servlet container, the Jersey <code class="literal">SecurityContext</code> will return
                information of the security context retrieved from Servlet request. For Jersey applications
                deployed on a Grizzly server, the <code class="literal">SecurityContext</code> will return information retrieved from the
                Grizzly request.
            </p><p>
                <code class="literal">SecurityContext</code> can be used in conjunction with sub-resource locators to return different
                resources if the user principle is included in a certain role. For example, a sub-resource locator could return
                a different resource if a user is a preferred customer:

                </p><div class="example"><a name="d0e8782"></a><p class="title"><b>Example&nbsp;14.1.&nbsp;Accessing <code class="code">SecurityContext</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("basket")
public ShoppingBasketResource get(@Context SecurityContext sc) {
    if (sc.isUserInRole("PreferredCustomer") {
        return new PreferredCustomerShoppingBasketResource();
    } else {
        return new ShoppingBasketResource();
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                <code class="literal">SecurityContext</code> can be injected also to singleton resources and
                providers as a class field. In such case the proxy of the request-scoped <code class="literal">SecurityContext</code>
                will be injected.

                </p><div class="example"><a name="d0e8798"></a><p class="title"><b>Example&nbsp;14.2.&nbsp;Injecting <code class="code">SecurityContext</code> into a singleton resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
@Singleton
public static class MyResource {
    @Context
    // Jersey will inject proxy of Security Context
    SecurityContext securityContext;

    @GET
    public String getUserPrincipal() {
        return securityContext.getUserPrincipal().getName();
    }
}</pre></div></div><p><br class="example-break">
            </p><div class="section" title="14.1.1.1.&nbsp;Initialize SecurityContext with Servlets"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8807"></a>14.1.1.1.&nbsp;Initialize SecurityContext with Servlets</h4></div></div></div><p>
                    As described above, the <code class="literal">SecurityContext</code> by default (if not overwritten by filters)
                    only offers information from an underlying container. In the case you deploy a Jersey application
                    in a Servlet container, you need to setup the <code class="literal">&lt;security-constraint&gt;</code>,
                    <code class="literal">&lt;auth-constraint&gt;</code> and user to roles mappings in order to pass correct information
                    to the <code class="literal">SecurityContext</code>.
                </p></div><div class="section" title="14.1.1.2.&nbsp;SecurityContext in ContainerRequestContext"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8824"></a>14.1.1.2.&nbsp;SecurityContext in ContainerRequestContext</h4></div></div></div><p>
                    The <code class="literal">SecurityContext</code> can be retrieved also from <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ContainerRequestContext.html" target="_top">ContainerRequestContext</a> via
                    <code class="literal">getSecurityContext()</code> method. You can also set the <code class="literal">SecurityContext</code> into
                    the request using method <code class="literal">setSecurityContext(SecurityContext)</code>. If you set a
                    new <code class="literal">SecurityContext</code> in the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/container/ContainerRequestFilter.html" target="_top">ContainerRequestFilter</a> into the
                    <code class="literal">ContainerRequestContext</code>, then this security context will be used for injections in resource
                    classes (wrapped into the proxy). This way you can implement a custom authentication filter that
                    may setup your own <code class="literal">SecurityContext</code> to be used. To ensure the early execution of your custom
                    authentication request filter, set the filter priority to <code class="literal">AUTHENTICATION</code> using
                    constants from <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Priorities.html" target="_top">Priorities</a>. An early execution of you authentication filter will ensure that all
                    other filters, resources, resource methods and sub-resource locators will execute with your custom
                    <code class="literal">SecurityContext</code> instance.
                </p></div></div><div class="section" title="14.1.2.&nbsp;Authorization - securing resources"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8865"></a>14.1.2.&nbsp;Authorization - securing resources</h3></div></div></div><div class="section" title="14.1.2.1.&nbsp;Security resources with web.xml"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8868"></a>14.1.2.1.&nbsp;Security resources with <code class="literal">web.xml</code></h4></div></div></div><p>
                    In cases where a Jersey application is deployed in a Servlet container you can rely only on
                    the standard Java EE Web application security mechanisms offered by the Servlet container and
                    configurable via application's <code class="literal">web.xml</code> descriptor.
                    You need to define the <code class="literal">&lt;security-constraint&gt;</code> elements in the
                    <code class="literal">web.xml</code> and assign roles which are able to access these resources. You can also
                    define HTTP methods that are allowed to be executed. See the following example.

                    </p><div class="example"><a name="d0e8884"></a><p class="title"><b>Example&nbsp;14.3.&nbsp;Securing resources using <code class="literal">web.xml</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;url-pattern&gt;/rest/admin/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
        &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;
&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;url-pattern&gt;/rest/orders/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
        &lt;role-name&gt;customer&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;
&lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
    &lt;realm-name&gt;my-default-realm&lt;/realm-name&gt;
&lt;/login-config&gt;</pre></div></div><p><br class="example-break">

                    The example secures two kinds of URI namespaces using the HTTP Basic Authentication.
                    <code class="literal">rest/admin/*</code> will be accessible only for user group "admin" and
                    <code class="literal">rest/orders/*</code> will be accessible for "customer" user group. This security configuration
                    does not use JAX-RS or Jersey features at all as it is enforced by the Servlet container even before
                    a request reaches the Jersey application. Keeping this security constrains up to date with your JAX-RS
                    application might not be easy as whenever you change the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Path.html" target="_top">@Path</a> annotations on your resource classes
                    you may need to update also the <code class="literal">web.xml</code> security configurations to reflect the changed
                    JAX-RS resource paths. Therefore Jersey offers a
                    <a class="link" href="#annotation-based-security" title="14.1.2.2.&nbsp;Securing JAX-RS resources with annotations">more flexible solution</a> based on placing standard Java EE
                    security annotations directly on JAX-RS resource classes and methods.
                </p></div><div class="section" title="14.1.2.2.&nbsp;Securing JAX-RS resources with annotations"><div class="titlepage"><div><div><h4 class="title"><a name="annotation-based-security"></a>14.1.2.2.&nbsp;Securing JAX-RS resources with annotations</h4></div></div></div><p>
                    With Jersey you can define the access to resources based on the user group using annotations. You can for
                    example define that only a user group "admin" can execute specific resource method. To do that you firstly
                    need to register <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/RolesAllowedDynamicFeature.html" target="_top">RolesAllowedDynamicFeature</a> as a provider. The following example shows how
                    to register the feature if your deployment is based on a <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a>.

                    </p><div class="example"><a name="d0e8918"></a><p class="title"><b>Example&nbsp;14.4.&nbsp;Registering RolesAllowedDynamicFeature using ResourceConfig</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final ResourceConfig resourceConfig = new ResourceConfig(MyResource.class);
resourceConfig.register(RolesAllowedDynamicFeature.class);</pre></div></div><p><br class="example-break">
                </p><p>
                    Then you can use annotations from package <code class="literal">javax.annotation.security</code> defined by JSR-250.
                    See the following example.

                    </p><div class="example"><a name="d0e8929"></a><p class="title"><b>Example&nbsp;14.5.&nbsp;Injecting <code class="code">SecurityContext</code> into singletons</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
@PermitAll
public class Resource {
    @RolesAllowed("user")
    @GET
    public String get() { return "GET"; }

    @RolesAllowed("admin")
    @POST
    public String post(String content) { return content; }

    @Path("sub")
    public SubResource getSubResource() {
        return new SubResource();
    }
}</pre></div></div><p><br class="example-break">

                    The resource class <code class="literal">Resource</code> defined in the example is annotated with a
                    <a class="link" href="http://docs.oracle.com/javaee/6/api/javax/annotation/security/PermitAll.html" target="_top">@PermitAll</a> annotation. This means that all methods in the class which do not override this
                    annotation will be permitted for all user groups (no restrictions are defined). In our example, the
                    annotation will only apply to the <code class="literal">getSubResource()</code> method as it is the only method
                    that does not override the annotation by defining custom role-based security settings using the
                    <a class="link" href="http://docs.oracle.com/javaee/6/api/javax/annotation/security/RolesAllowed.html" target="_top">@RolesAllowed</a> annotation.
                    <code class="literal">@RolesAllowed</code> annotation present on other methods defines a role or a set of roles
                    that are allowed to execute a particular method.
                </p><p>
                    These Java EE security annotations are processed internally in the request filter registered using the
                    Jersey <code class="literal">RolesAllowedDynamicFeature</code>. The roles defined in the annotations are tested against
                    current roles set in the <code class="literal">SecurityContext</code> using
                    the <code class="literal">SecurityContext</code><code class="literal">.isUserInRole(String role)</code> method. In case the caller
                    is not in the role specified by the annotation, the HTTP <code class="literal">403 (Forbidden)</code> error response is
                    returned.
                </p></div></div></div><div class="section" title="14.2.&nbsp;Client Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8969"></a>14.2.&nbsp;Client Security</h2></div></div></div><p>
            For details about client security please see the <a class="link" href="#client" title="Chapter&nbsp;5.&nbsp;Client API">Client chapter</a>. Jersey
            client allows to define parameters of SSL communication using <code class="literal">HTTPS</code> protocol.
            You can also use jersey built-in authentication filters which perform <span class="emphasis"><em>HTTP Basic Authentication</em></span>
            or <span class="emphasis"><em>HTTP Digest Authentication</em></span>.
            See the client chapter for more details.
        </p></div><div class="section" title="14.3.&nbsp;OAuth"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8986"></a>14.3.&nbsp;OAuth</h2></div></div></div><p>
            OAuth 1.x support has not been migrated from Jersey 1.x to Jersey 2.x yet. The documentation will be updated
            once the OAuth support feature will be released in Jersey 2.
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;15.&nbsp;WADL Support"><div class="titlepage"><div><div><h2 class="title"><a name="wadl"></a>Chapter&nbsp;15.&nbsp;WADL Support</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e8995">15.1. WADL introduction</a></span></dt><dt><span class="section"><a href="#d0e9247">15.2. Configuration</a></span></dt><dt><span class="section"><a href="#d0e9302">15.3. Extended WADL support</a></span></dt></dl></div><div class="section" title="15.1.&nbsp;WADL introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e8995"></a>15.1.&nbsp;WADL introduction</h2></div></div></div><p>
            Jersey contains support for Web Application Description Language (<a class="link" href="http://wadl.java.net/" target="_top">WADL</a>). WADL is
            a XML description of a deployed RESTful web application. It contains model of the deployed resources, their
            structure, supported media types, HTTP methods and so on. In a sense, WADL is a similar to the WSDL
            (Web Service Description Language) which describes SOAP web services. WADL is however specifically designed
            to describe RESTful Web resources.
        </p><p>
            Let's start with the simple WADL example. In the example there is a simple <code class="literal">CountryResource</code>
            deployed and we request a wadl of this resource. The context root path of the application is
            <code class="literal">http://localhost:9998</code>.
            </p><div class="example"><a name="d0e9011"></a><p class="title"><b>Example&nbsp;15.1.&nbsp;A simple WADL example - JAX-RS resource definition</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("country/{id}")
public static class CountryResource {

    private CountryService countryService;

    public CountryResource() {
        // init countryService
    }

    @GET
    @Produces(MediaType.APPLICATION_XML)
    public Country getCountry(@PathParam("countryId") int countryId) {
        return countryService.getCountry(countryId);
    }
}</pre></div></div><p><br class="example-break">

            The WADL of a Jersey application that contains the resource above can be requested by a
            HTTP <code class="literal">GET</code> request to <code class="literal">http://localhost:9998/application.wadl</code>.
            The Jersey will return a response with a WADL content similar to the one in the following example:

            </p><div class="example"><a name="d0e9023"></a><p class="title"><b>Example&nbsp;15.2.&nbsp;A simple WADL example - WADL content</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
    &lt;doc xmlns:jersey="http://jersey.java.net/" jersey:generatedBy="Jersey: 2.0-SNAPSHOT ${buildNumber}"/&gt;
    &lt;grammars/&gt;
    &lt;resources base="http://localhost:9998/"&gt;
        &lt;resource path="country/{id}"&gt;
            &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                type="xs:int" style="template" name="countryId"/&gt;
            &lt;method name="GET" id="getCountry"&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/vnd.sun.wadl+xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="text/plain"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
        &lt;/resource&gt;
        &lt;resource path="application.wadl"&gt;
            &lt;method name="GET" id="getWadl"&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/vnd.sun.wadl+xml"/&gt;
                    &lt;representation mediaType="application/xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="text/plain"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;resource path="{path}"&gt;
                &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                    type="xs:string" style="template" name="path"/&gt;
                &lt;method name="GET" id="geExternalGrammar"&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="application/xml"/&gt;
                    &lt;/response&gt;
                &lt;/method&gt;
                &lt;method name="OPTIONS" id="apply"&gt;
                    &lt;request&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/request&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="text/plain"/&gt;
                    &lt;/response&gt;
                &lt;/method&gt;
                &lt;method name="OPTIONS" id="apply"&gt;
                    &lt;request&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/request&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/response&gt;
                &lt;/method&gt;
            &lt;/resource&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/application&gt;</pre></div></div><p><br class="example-break">
            In the example above the returned application WADL is shown in full. WADL schema is defined by the
            WADL specification. The root WADL document element is the <code class="literal">application</code>. It contains global
            information about the deployed JAX-RS application. Under this element there is a nested element
            <code class="literal">resources</code> which contains zero or more <code class="literal">resource</code> elements. Each
            <code class="literal">resource</code> element describes a single deployed resource. In our example, there are only two root
            resources - <code class="literal">"country/{id}"</code> and <code class="literal">"application.wadl"</code>. The
            <code class="literal">"application.wadl"</code> resource is the resource that was just requested in order to receive the
            application WADL document. Even though WADL support is an additional feature in Jersey it is still
            a resource deployed in the resource model and therefore it is itself present in the returned WADL document.
            The first resource element with the <code class="literal">path="country/{id}"</code> is the element that describes our
            custom deployed resource.
            This resource contains a <code class="literal">GET</code> method and three <code class="literal">OPTIONS</code> methods.
            The <code class="literal">GET</code> method is our getCountry() method defined in the sample. There is a method name
            in the <code class="literal">id</code> attribute and <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/Produces.html" target="_top">@Produces</a> is described in the
            <code class="literal">response/representation</code> WADL element. <code class="literal">OPTIONS</code> methods are the methods that
            are automatically added by Jersey to each resource. There is an <code class="literal">OPTIONS</code> method
            returning <code class="literal">"text/plain"</code> media type, that will return a response with a string entity containing
            the list of methods deployed on this resource (this means that instead of WADL you can use this <code class="literal">OPTIONS</code>
            method to get similar information in a textual representation).
            Another <code class="literal">OPTIONS</code> method returning <code class="literal">*/*</code> will return a response with no entity
            and <code class="literal">Allow</code> header that will contain list of methods as a String.
            The last <code class="literal">OPTIONS</code> method producing <code class="literal">"application/vnd.sun.wadl+xml"</code> returns a
            WADL description of the resource <code class="literal">"country/{id}"</code>. As you can see, all <code class="literal">OPTIONS</code> methods
            return information about the resource to which the HTTP <code class="literal">OPTIONS</code> request is made.
        </p><p>
            Second resource with a path "application.wadl" has, again, similar <code class="literal">OPTIONS</code> methods
            and one <code class="literal">GET</code> method which return this WADL. There is also
            a sub-resource with a path defined by path param <code class="literal">{path}</code>. This means that you can request
            a resource on the URI <code class="literal">http://localhost:9998/application.wadl/something</code>.
            This is used only to return an external grammar if there is any attached. Such a external grammar can be
            for example an <code class="literal">XSD</code> schema of the response entity which if the response entity is a JAXB bean.
            An external grammar support via Jersey <span class="emphasis"><em>extended WADL support</em></span> is described in sections below.
        </p><p>
            Let's now send an HTTP <code class="literal">OPTIONS</code> request to <code class="literal">"country/{id}"</code> resource using the the
            <code class="literal">curl</code> command:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    gutter: false;">curl -X OPTIONS -H "Allow: application/vnd.sun.wadl+xml" \
    -v http://localhost:9998/country/15</pre><p>

            We should see a WADL returned similar to this one:

            </p><div class="example"><a name="d0e9141"></a><p class="title"><b>Example&nbsp;15.3.&nbsp;OPTIONS method returning WADL</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
    &lt;doc xmlns:jersey="http://jersey.java.net/"
        jersey:generatedBy="Jersey: 2.0-SNAPSHOT ${buildNumber}"/&gt;
    &lt;grammars/&gt;
    &lt;resources base="http://localhost:9998/"&gt;
        &lt;resource path="country/15"&gt;
            &lt;method name="GET" id="getCountry"&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/vnd.sun.wadl+xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="text/plain"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/application&gt;</pre></div></div><p><br class="example-break">
            The returned WADL document has the standard WADL structure that we saw in the WADL document returned for the
            whole Jersey application earlier. The main difference here is that the only <code class="literal">resource</code> is the
            resource to which the <code class="literal">OPTIONS</code> HTTP request was sent. The resource has now path
            <code class="literal">"country/15"</code> and not <code class="literal">"country/{id}"</code> as the path parameter
            <code class="literal">{id}</code> was already specified in the request to this concrete resource.
        </p><p>
            Another, a more complex WADL example is shown in the next example.

            </p><div class="example"><a name="d0e9164"></a><p class="title"><b>Example&nbsp;15.4.&nbsp;More complex WADL example - JAX-RS resource definition</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("customer/{id}")
public static class CustomerResource {
    private CustomerService customerService;

    @GET
    public Customer get(@PathParam("id") int id) {
        return customerService.getCustomerById(id);
    }

    @PUT
    public Customer put(Customer customer) {
        return customerService.updateCustomer(customer);
    }

    @Path("address")
    public CustomerAddressSubResource getCustomerAddress(@PathParam("id") int id) {
        return new CustomerAddressSubResource(id);
    }

    @Path("additional-info")
    public Object getAdditionalInfoSubResource(@PathParam("id") int id) {
        return new CustomerAddressSubResource(id);
    }

}


public static class CustomerAddressSubResource {
    private final int customerId;
    private CustomerService customerService;

    public CustomerAddressSubResource(int customerId) {
        this.customerId = customerId;
        this.customerService = null; // init customer service here
    }

    @GET
    public String getAddress() {
        return customerService.getAddressForCustomer(customerId);
    }

    @PUT
    public void updateAddress(String address) {
        customerService.updateAddressForCustomer(customerId, address);
    }

    @GET
    @Path("sub")
    public String getDeliveryAddress() {
        return customerService.getDeliveryAddressForCustomer(customerId);
    }
}</pre></div></div><p><br class="example-break">

            The <code class="literal">GET</code> request to <code class="literal">http://localhost:9998/application.wadl</code> will
            return the following WADL document:

            </p><div class="example"><a name="d0e9176"></a><p class="title"><b>Example&nbsp;15.5.&nbsp;More complex WADL example - WADL content</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;application xmlns="http://wadl.dev.java.net/2009/02"&gt;
    &lt;doc xmlns:jersey="http://jersey.java.net/"
        jersey:generatedBy="Jersey: 2.0-SNAPSHOT ${buildNumber}"/&gt;
    &lt;grammars/&gt;
    &lt;resources base="http://localhost:9998/"&gt;
        &lt;resource path="customer/{id}"&gt;
            &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                type="xs:int" style="template" name="id"/&gt;
            &lt;method name="GET" id="get"&gt;
                &lt;response/&gt;
            &lt;/method&gt;
            &lt;method name="PUT" id="put"&gt;
                &lt;response/&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/vnd.sun.wadl+xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="text/plain"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;resource path="additional-info"&gt;
                &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                    type="xs:int" style="template" name="id"/&gt;
            &lt;/resource&gt;
            &lt;resource path="address"&gt;
                &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                    type="xs:int" style="template" name="id"/&gt;
                &lt;method name="GET" id="getAddress"&gt;
                    &lt;response/&gt;
                &lt;/method&gt;
                &lt;method name="PUT" id="updateAddress"/&gt;
                &lt;resource path="sub"&gt;
                    &lt;method name="GET" id="getDeliveryAddress"&gt;
                        &lt;response/&gt;
                    &lt;/method&gt;
                &lt;/resource&gt;
            &lt;/resource&gt;
        &lt;/resource&gt;
        &lt;resource path="application.wadl"&gt;
            &lt;method name="GET" id="getWadl"&gt;
                &lt;response&gt;
                    &lt;representation mediaType="application/vnd.sun.wadl+xml"/&gt;
                    &lt;representation mediaType="application/xml"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="text/plain"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;method name="OPTIONS" id="apply"&gt;
                &lt;request&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/request&gt;
                &lt;response&gt;
                    &lt;representation mediaType="*/*"/&gt;
                &lt;/response&gt;
            &lt;/method&gt;
            &lt;resource path="{path}"&gt;
                &lt;param xmlns:xs="http://www.w3.org/2001/XMLSchema"
                    type="xs:string" style="template" name="path"/&gt;
                &lt;method name="GET" id="geExternalGrammar"&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="application/xml"/&gt;
                    &lt;/response&gt;
                &lt;/method&gt;
                &lt;method name="OPTIONS" id="apply"&gt;
                    &lt;request&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/request&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="text/plain"/&gt;
                    &lt;/response&gt;
                &lt;/method&gt;
                &lt;method name="OPTIONS" id="apply"&gt;
                    &lt;request&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/request&gt;
                    &lt;response&gt;
                        &lt;representation mediaType="*/*"/&gt;
                    &lt;/response&gt;
                &lt;/method&gt;
            &lt;/resource&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/application&gt;</pre></div></div><p><br class="example-break">

            The <code class="literal">resource</code> with <code class="literal">path="customer/{id}"</code> is similar to the
            country resource from the previous example. There is a path parameter which identifies the customer
            by <code class="literal">id</code>. The resource contains 2 user-declared methods and again auto-generated
            <code class="literal">OPTIONS</code> methods added by Jersey. THe resource declares 2 sub-resource locators which are
            represented in the returned WADL document as nested <code class="literal">resource</code> elements. Note that the sub-resource
            locator <code class="literal">getCustomerAddress()</code> returns a type CustomerAddressSubResource in the
            method declaration and also in the WADL there is a <code class="literal">resource</code> element for such
            a sub resource with full internal description. The second method
            <code class="literal">getAdditionalInfoSubResource()</code> returns only an <code class="literal">Object</code> in the method declaration.
            While this is correct from the JAX-RS perspective as the real returned type can be computed from a request
            information, it creates a problem for WADL generator because WADL is generated based on the static configuration
            of the JAX-RS application resources. The WADL generator does not know what type would be actually returned to
            a request at run time.
            That is the reason why the nested <code class="literal">resource</code> element with <code class="literal">path="additional-info"</code>
            does not contain any information about the supported resource representations.
        </p><p>
            The <code class="literal">CustomerAddressSubResource</code> sub-resource described in the nested element
            <code class="literal">&lt;resource path="address"&gt;</code> does not contain an <code class="literal">OPTIONS</code> method.
            While these methods are in fact generated by Jersey for the sub-resource, Jersey WADL generator does not currently
            support adding these methods to the sub-resource description. This should be addressed in the near future.
            Still, there are two user-defined resource methods handling HTTP <code class="literal">GET</code> and <code class="literal">PUT</code> requests.
            The sub-resource method <code class="literal">getDeliveryAddress()</code> is represented as a separate nested resource with
            <code class="literal">path="sub"</code>. Should there be more sub-resource methods defined with <code class="literal">path="sub"</code>,
            then all these method descriptions would be placed into the same <code class="literal">resource</code> element.
            In other words, sub-resource methods are grouped in WADL as sub-resources based on their <code class="literal">path</code>
            value.
        </p></div><div class="section" title="15.2.&nbsp;Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9247"></a>15.2.&nbsp;Configuration</h2></div></div></div><p>
            WADL generation is enabled in Jersey by default. This means that <code class="literal">OPTIONS</code>
            methods are added by default to each resource and an auto-generated <code class="literal">/application.wadl</code>
            resource is deployed too. To override this default behavior and disable WADL generation in Jersey, setup the
            configuration property in your application:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: ;&#xA;    ">jersey.config.server.wadl.disableWadl=true</pre><p>

            This property can be setup in a <code class="literal">web.xml</code> if the Jersey application is deployed
            in the servlet with <code class="literal">web.xml</code> or the property can be returned from the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a>.
            <code class="literal">getProperties()</code>. See <a class="link" href="#deployment" title="Chapter&nbsp;4.&nbsp;Deploying a RESTful Web Service">Deployment chapter</a> for more information
            on setting the application configuration properties in various deployments.
        </p><p>
            WADL support in Jersey is implemented via <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/model/ModelProcessor.html" target="_top">ModelProcessor</a> extension. This implementation enhances
            the application resource model by adding the WADL providing resources. WADL <code class="literal">ModelProcessor</code>
            priority value is high (i.e. the priority is low) as it should be executed as one of the last model processors.
            Therefore, any <code class="literal">ModelProcessor</code> executed before will not see WADL extensions in the resource model.
            WADL handling resource model extensions (resources and <code class="literal">OPTIONS</code> resource methods) are not added to the
            application resource model if there is already a matching resource or a resource method detected in the model.
            In other words, if you define for example your own <code class="literal">OPTIONS</code> method that would produce
            <code class="literal">"application.wadl"</code> response content, this method will not be overridden by WADL model processor.
            See <a class="link" href="#resource-builder" title="Chapter&nbsp;12.&nbsp;Programmatic API for Building Resources">Resource builder chapter</a> for more information on
            <code class="literal">ModelProcessor</code> extension mechanism.
        </p></div><div class="section" title="15.3.&nbsp;Extended WADL support"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9302"></a>15.3.&nbsp;Extended WADL support</h2></div></div></div><p>
            <span class="strong"><strong>Please note that the API of extended WADL support is going to be changed in one of the future
            releases of Jersey 2.x (see below).</strong></span>
        </p><p>
            Jersey supports extension of WADL generation called <span class="emphasis"><em>extended WADL</em></span>. Using the extended WADL
            support you can enhance the generated WADL document with additional information, such as
            resource method javadoc-based documentation of your REST APIs, adding general documentation,
            adding external grammar support, or adding any custom WADL extension information.
        </p><p>
            The documentation of the existing extended WADL can be found here:
            <a class="link" href="https://wikis.oracle.com/display/Jersey/WADL" target="_top">Extended WADL in Jersey 1</a>. This contains
            description of an extended WADL generation in Jersey 1.x that is currently supported also by Jersey 2.x.
        </p><p>
            <span class="strong"><strong>Again, note that the extended WADL in Jersey 2.x is NOT the intended final version and
            API is going to be changed.</strong></span> The existing set of features and functionality will be preserved but the
            APIs will be significantly re-designed to support additional use cases. This impacts mainly the APIs of
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/wadl/WadlGenerator.html" target="_top">WadlGenerator</a>, <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/wadl/WadlGeneratorConfig.html" target="_top">WadlGeneratorConfig</a> as well as any related classes. The API changes
            may impact your code if you are using a custom <code class="literal">WadlGenerator</code> or plan to implement one.
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;16.&nbsp;Bean Validation Support"><div class="titlepage"><div><div><h2 class="title"><a name="bean-validation"></a>Chapter&nbsp;16.&nbsp;Bean Validation Support</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e9346">16.1. Bean Validation Dependencies</a></span></dt><dt><span class="section"><a href="#d0e9372">16.2. Enabling Bean Validation in Jersey</a></span></dt><dt><span class="section"><a href="#d0e9406">16.3. Configuring Bean Validation Support</a></span></dt><dt><span class="section"><a href="#d0e9527">16.4. Validating JAX-RS resources and methods</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e9556">16.4.1. Constraint Annotations</a></span></dt><dt><span class="section"><a href="#d0e9642">16.4.2. Annotation constraints and Validators</a></span></dt><dt><span class="section"><a href="#d0e9692">16.4.3. Entity Validation</a></span></dt><dt><span class="section"><a href="#d0e9773">16.4.4. Annotation Inheritance</a></span></dt></dl></dd><dt><span class="section"><a href="#bv.ValidateOnExecution">16.5. @ValidateOnExecution</a></span></dt><dt><span class="section"><a href="#bv.injecting">16.6. Injecting</a></span></dt><dt><span class="section"><a href="#d0e9897">16.7. Error Reporting</a></span></dt><dd><dl><dt><span class="section"><a href="#bv.ValidationError">16.7.1. ValidationError</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e10055">16.8. Example</a></span></dt></dl></div><p>
        Validation is a process of verifying that some data obeys one or more pre-defined constraints. This chapter describes
        support for <a class="link" href="http://beanvalidation.org/" target="_top">Bean Validation</a> in Jersey in terms of the needed dependencies, configuration, registration and usage.
        For more detailed description on how JAX-RS provides native support for validating resource classes based on the
        Bean Validation refer to the chapter in the <a class="link" href="http://jcp.org/en/jsr/detail?id=339" target="_top">JAX-RS spec</a>.
    </p><div class="section" title="16.1.&nbsp;Bean Validation Dependencies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9346"></a>16.1.&nbsp;Bean Validation Dependencies</h2></div></div></div><p>
            Bean Validation support in Jersey is provided as an extension module and needs to be mentioned explicitly in your
            <code class="literal">pom.xml</code> file (in case of using Maven):

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-bean-validation&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    If you're not using Maven make sure to have also all the transitive dependencies (see <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-bean-validation/dependencies.html" target="_top">jersey-bean-validation</a>) on
                    the classpath.
                </p></div><p>

            This module depends directly on
            <a class="link" href="http://www.hibernate.org/subprojects/validator.html" target="_top">Hibernate Validator</a>
            which provides a most commonly used implementation of the Bean Validation API spec.
        </p><p>
            If you want to use a different implementation of the Bean Validation API, use standard Maven mechanisms to exclude
            Hibernate Validator from the modules dependencies and add a dependency of your own.

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-bean-validation&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;</pre><p>
        </p></div><div class="section" title="16.2.&nbsp;Enabling Bean Validation in Jersey"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9372"></a>16.2.&nbsp;Enabling Bean Validation in Jersey</h2></div></div></div><p>
            As stated in <a class="xref" href="#deployment.autodiscoverable" title="4.1.&nbsp;Auto-Discoverable Features">Section&nbsp;4.1, &#8220;Auto-Discoverable Features&#8221;</a>, Jersey Bean Validation is one of the modules where you
            don't need to explicitly register it's <code class="literal">Feature</code>s (<a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/validation/ValidationFeature.html" target="_top">ValidationFeature</a>) on the
            server as it's features are automatically discovered and registered when you add the
            <code class="literal">jersey-bean-validation</code> module to your classpath.
            There are three Jersey specific properties that could disable automatic discovery and registration of Jersey Bean
            Validation integration module:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">ServerProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_FEATURE_DISABLE" target="_top">ServerProperties.BV_FEATURE_DISABLE</a></p></li></ul></div><p>

            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Jersey does not support Bean Validation on the client at the moment.</p></div><p>
        </p></div><div class="section" title="16.3.&nbsp;Configuring Bean Validation Support"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9406"></a>16.3.&nbsp;Configuring Bean Validation Support</h2></div></div></div><p>
            Configuration of Bean Validation support in Jersey is twofold - there are few specific properties that affects Jersey
            behaviour (e.g. sending validation error entities to the client) and then there is <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/validation/ValidationConfig.html" target="_top">ValidationConfig</a> class
            that configures <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/Validator.html" target="_top">Validator</a> used for validating resources in JAX-RS application.
        </p><p>
            To configure Jersey specific behaviour you can use the following properties:

            </p><div class="variablelist"><dl><dt><span class="term"><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK" target="_top">ServerProperties.BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK</a></span></dt><dd><p>
                            Disables <code class="literal">@ValidateOnExecution</code> check. More on this is described in
                            <a class="xref" href="#bv.ValidateOnExecution" title="16.5.&nbsp;@ValidateOnExecution">Section&nbsp;16.5, &#8220;@ValidateOnExecution&#8221;</a>.
                        </p></dd><dt><span class="term"><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_SEND_ERROR_IN_RESPONSE" target="_top">ServerProperties.BV_SEND_ERROR_IN_RESPONSE</a></span></dt><dd><p>
                            Enables sending validation errors in response entity to the client. More on this in
                            <a class="xref" href="#bv.ValidationError" title="16.7.1.&nbsp;ValidationError">Section&nbsp;16.7.1, &#8220;ValidationError&#8221;</a>.
                        </p></dd></dl></div><p>

            </p><div class="example"><a name="bv.example.jersey.properties"></a><p class="title"><b>Example&nbsp;16.1.&nbsp;Configuring Jersey specific properties for Bean Validation.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    // Now you can expect validation errors to be sent to the client.
    .property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true)
    // @ValidateOnExecution annotations on subclasses won't cause errors.
    .property(ServerProperties.BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK, true)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            Customization of the <code class="literal">Validator</code> used in validation of resource classes/methods can be done using
            <code class="literal">ValidationConfig</code> class and exposing it via <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/ContextResolver.html" target="_top">ContextResolver&lt;T&gt;</a> mechanism as shown in
            <a class="xref" href="#bv.example.ValidationConfig" title="Example&nbsp;16.2.&nbsp;Using ValidationConfig to configure Validator.">Example&nbsp;16.2, &#8220;Using <code class="literal">ValidationConfig</code> to configure <code class="literal">Validator</code>.&#8221;</a>. You can set custom instances for the following interfaces from
            the Bean Validation API:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/MessageInterpolator.html" target="_top">MessageInterpolator</a> - interpolates a given constraint violation message.
                    </p></li><li class="listitem"><p>
                        <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/TraversableResolver.html" target="_top">TraversableResolver</a> - determines if a property can be accessed by the Bean Validation provider.
                    </p></li><li class="listitem"><p>
                        <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/ConstraintValidatorFactory.html" target="_top">ConstraintValidatorFactory</a> - instantiates a <code class="literal">ConstraintValidator</code> instance based
                        off its class. Note that by setting a custom <code class="literal">ConstraintValidatorFactory</code> you may loose
                        injection of available resources/providers at the moment. See <a class="xref" href="#bv.injecting" title="16.6.&nbsp;Injecting">Section&nbsp;16.6, &#8220;Injecting&#8221;</a> how to
                        handle this.
                    </p></li><li class="listitem"><p><a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/ParameterNameProvider.html" target="_top">ParameterNameProvider</a> - provides names for method and constructor parameters.</p></li></ul></div><p>

            </p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                    In the latest versions of Jersey, the old-style setter methods (<code class="literal">set*</code>) on
                    <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/validation/ValidationConfig.html" target="_top">ValidationConfig</a> are deprecated and replaced with methods that allow the fluent use of the API
                    (e.g. <code class="literal">ValidationConfig#messageInterpolator(MessageInterpolator)</code>). Use of the new fluent methods
                    is encouraged as the old setters will be removed from the API soon.
                </p></div><p>

            </p><div class="example"><a name="bv.example.ValidationConfig"></a><p class="title"><b>Example&nbsp;16.2.&nbsp;Using <code class="literal">ValidationConfig</code> to configure <code class="literal">Validator</code>.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">/**
 * Custom configuration of validation. This configuration defines custom:
 * &lt;ul&gt;
 *     &lt;li&gt;ConstraintValidationFactory - so that validators are able to inject Jersey providers/resources.&lt;/li&gt;
 *     &lt;li&gt;ParameterNameProvider - if method input parameters are invalid, this class returns actual parameter names
 *     instead of the default ones ({@code arg0, arg1, ..})&lt;/li&gt;
 * &lt;/ul&gt;
 */
public class ValidationConfigurationContextResolver implements ContextResolver&lt;ValidationConfig&gt; {

    @Context
    private ResourceContext resourceContext;

    @Override
    public ValidationConfig getContext(final Class&lt;?&gt; type) {
        final ValidationConfig config = new ValidationConfig();
        config.setConstraintValidatorFactory(resourceContext.getResource(InjectingConstraintValidatorFactory.class));
        config.setParameterNameProvider(new CustomParameterNameProvider());
        return config;
    }

    /**
     * See ContactCardTest#testAddInvalidContact.
     */
    private class CustomParameterNameProvider implements ParameterNameProvider {

        private final ParameterNameProvider nameProvider;

        public CustomParameterNameProvider() {
            nameProvider = Validation.byDefaultProvider().configure().getDefaultParameterNameProvider();
        }

        @Override
        public List&lt;String&gt; getParameterNames(final Constructor&lt;?&gt; constructor) {
            return nameProvider.getParameterNames(constructor);
        }

        @Override
        public List&lt;String&gt; getParameterNames(final Method method) {
            // See ContactCardTest#testAddInvalidContact.
            if ("addContact".equals(method.getName())) {
                return Arrays.asList("contact");
            }
            return nameProvider.getParameterNames(method);
        }
    }
}</pre><p>Register this class in your app:</p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final Application application = new ResourceConfig()
        // Validation.
        .register(ValidationConfigurationContextResolver.class)
        // Further configuration.
        .register( ... );</pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This code snippet has been taken from <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/bean-validation-webapp" target="_top">Bean Validation example</a>.</p></div></div></div><p><br class="example-break">
        </p></div><div class="section" title="16.4.&nbsp;Validating JAX-RS resources and methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9527"></a>16.4.&nbsp;Validating JAX-RS resources and methods</h2></div></div></div><p>
            JAX-RS specification states that constraint annotations are allowed in the same locations as the following
            annotations: <code class="literal">@MatrixParam</code>, <code class="literal">@QueryParam</code>, <code class="literal">@PathParam</code>, <code class="literal">@CookieParam</code>,
            <code class="literal">@HeaderParam</code> and <code class="literal">@Context</code>, <span class="emphasis"><em>except</em></span> in class constructors and property
            setters. Specifically, they are allowed in resource method parameters, fields and property getters as well as
            resource classes, entity parameters and resource methods (return values).
            Jersey provides support for validation (see following sections) annotated input parameters and return value of the
            invoked resource method as well as validation of resource class (class constraints, field constraints) where this
            resource method is placed.
            Jersey does not support, and doesn't validate, constraints placed on constructors and Bean Validation groups (only
            <code class="literal">Default</code> group is supported at the moment).
        </p><div class="section" title="16.4.1.&nbsp;Constraint Annotations"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9556"></a>16.4.1.&nbsp;Constraint Annotations</h3></div></div></div><p>
                The JAX-RS Server API provides support for extracting request values and mapping them into Java fields,
                properties and parameters using annotations such as <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/HeaderParam.html" target="_top">@HeaderParam</a>, <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/QueryParam.html" target="_top">@QueryParam</a>, etc. It also
                supports mapping of the request entity bodies into Java objects via non-annotated parameters (i.e., parameters
                without any JAX-RS annotations).
            </p><p>
                The Bean Validation specification supports the use of <span class="emphasis"><em>constraint annotations</em></span>
                as a way of declaratively validating beans, method parameters and method returned values. For example, consider
                resource class from <a class="xref" href="#bv.example.constraints" title="Example&nbsp;16.3.&nbsp;Constraint annotations on input parameters">Example&nbsp;16.3, &#8220;Constraint annotations on input parameters&#8221;</a> augmented with constraint annotations.

                </p><div class="example"><a name="bv.example.constraints"></a><p class="title"><b>Example&nbsp;16.3.&nbsp;Constraint annotations on input parameters</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
class MyResourceClass {

    @POST
    @Consumes("application/x-www-form-urlencoded")
    public void registerUser(
            @NotNull @FormParam("firstName") String firstName,
            @NotNull @FormParam("lastName") String lastName,
            @Email @FormParam("email") String email) {
        ...
    }
}</pre></div></div><p><br class="example-break">

                The annotations <code class="literal">@NotNull</code> and <code class="literal">@Email</code> impose additional constraints on the form parameters
                <code class="literal">firstName</code>, <code class="literal">lastName</code> and <code class="literal">email</code>. The <code class="literal">@NotNull</code>
                constraint is built-in to the Bean Validation API; the <code class="literal">@Email</code>
                constraint is assumed to be user defined in the example above. These constraint annotations are not restricted to
                method parameters, they can be used in any location in which JAX-RS binding annotations are allowed with the
                exception of constructors and property setters.
            </p><p>
                Rather than using method parameters, the <code class="literal">MyResourceClass</code> shown above could have been written
                as in <a class="xref" href="#bv.example.constraints.fields" title="Example&nbsp;16.4.&nbsp;Constraint annotations on fields">Example&nbsp;16.4, &#8220;Constraint annotations on fields&#8221;</a>.

                </p><div class="example"><a name="bv.example.constraints.fields"></a><p class="title"><b>Example&nbsp;16.4.&nbsp;Constraint annotations on fields</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
class MyResourceClass {

    @NotNull
    @FormParam("firstName")
    private String firstName;

    @NotNull
    @FormParam("lastName")
    private String lastName;

    private String email;

    @FormParam("email")
    public void setEmail(String email) {
        this.email = email;
    }

    @Email
    public String getEmail() {
        return email;
    }

    ...
}</pre></div></div><p><br class="example-break">

                Note that in this version, <code class="literal">firstName</code> and <code class="literal">lastName</code> are fields initialized
                via injection and <code class="literal">email</code> is a resource class property. Constraint annotations on properties are
                specified in their corresponding getters.
            </p><p>
                Constraint annotations are also allowed on resource classes. In addition to annotating fields and properties, an
                annotation can be defined for the entire class. Let us assume that <code class="literal">@NonEmptyNames</code> validates
                that one of the two <span class="emphasis"><em>name</em></span> fields in <code class="literal">MyResourceClass</code> is provided. Using
                such an annotation, the example above can be extended to look like <a class="xref" href="#bv.example.constraints.class" title="Example&nbsp;16.5.&nbsp;Constraint annotations on class">Example&nbsp;16.5, &#8220;Constraint annotations on class&#8221;</a>

                </p><div class="example"><a name="bv.example.constraints.class"></a><p class="title"><b>Example&nbsp;16.5.&nbsp;Constraint annotations on class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
@NonEmptyNames
class MyResourceClass {

    @NotNull
    @FormParam("firstName")
    private String firstName;

    @NotNull
    @FormParam("lastName")
    private String lastName;

    private String email;

    ...
}</pre></div></div><p><br class="example-break">

                Constraint annotations on resource classes are useful for defining cross-field and cross-property constraints.
            </p></div><div class="section" title="16.4.2.&nbsp;Annotation constraints and Validators"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9642"></a>16.4.2.&nbsp;Annotation constraints and Validators</h3></div></div></div><p>
                Annotation constraints and validators are defined in accordance with the Bean Validation specification.
                The <code class="literal">@Email</code> annotation used in <a class="xref" href="#bv.example.constraints.fields" title="Example&nbsp;16.4.&nbsp;Constraint annotations on fields">Example&nbsp;16.4, &#8220;Constraint annotations on fields&#8221;</a> is defined using the
                Bean Validation <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/Constraint.html" target="_top">@Constraint</a> meta-annotation, see <a class="xref" href="#bv.example.constraints.definition" title="Example&nbsp;16.6.&nbsp;Definition of a constraint annotation">Example&nbsp;16.6, &#8220;Definition of a constraint annotation&#8221;</a>.

                </p><div class="example"><a name="bv.example.constraints.definition"></a><p class="title"><b>Example&nbsp;16.6.&nbsp;Definition of a constraint annotation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Target({ METHOD, FIELD, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = EmailValidator.class)
public @interface Email {

    String message() default "{com.example.validation.constraints.email}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};
}</pre></div></div><p><br class="example-break">

                The <code class="literal">@Constraint</code> annotation must include a reference to the validator class that will be used to validate
                decorated values. The <code class="literal">EmailValidator</code> class must implement
                <code class="literal">ConstraintValidator&lt;Email, T&gt;</code> where <code class="literal">T</code> is the type of values being
                validated, as described in <a class="xref" href="#bv.example.validator.definition" title="Example&nbsp;16.7.&nbsp;Validator implementation.">Example&nbsp;16.7, &#8220;Validator implementation.&#8221;</a>.

                </p><div class="example"><a name="bv.example.validator.definition"></a><p class="title"><b>Example&nbsp;16.7.&nbsp;Validator implementation.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class EmailValidator implements ConstraintValidator&lt;Email, String&gt; {

    public void initialize(Email email) {
        ...
    }

    public boolean isValid(String value, ConstraintValidatorContext context) {
        ...
    }
}</pre></div></div><p><br class="example-break">

                Thus, <code class="literal">EmailValidator</code> applies to values annotated with <code class="literal">@Email</code> that are of type
                <code class="literal">String</code>. Validators for other Java types can be defined for the same constraint annotation.
            </p></div><div class="section" title="16.4.3.&nbsp;Entity Validation"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9692"></a>16.4.3.&nbsp;Entity Validation</h3></div></div></div><p>
                Request entity bodies can be mapped to resource method parameters. There are two ways in which these entities can
                be validated. If the request entity is mapped to a Java bean whose class is decorated with Bean Validation
                annotations, then validation can be enabled using <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/Valid.html" target="_top">@Valid</a> as in <a class="xref" href="#bv.example.constraints.entity" title="Example&nbsp;16.8.&nbsp;Entity validation">Example&nbsp;16.8, &#8220;Entity validation&#8221;</a>.

                </p><div class="example"><a name="bv.example.constraints.entity"></a><p class="title"><b>Example&nbsp;16.8.&nbsp;Entity validation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@StandardUser
class User {

    @NotNull
    private String firstName;

    ...
}


@Path("/")
class MyResourceClass {

    @POST
    @Consumes("application/xml")
    public void registerUser(@Valid User user) {
        ...
    }
}</pre></div></div><p><br class="example-break">

                In this case, the validator associated with <code class="literal">@StandardUser</code> (as well as those for non-class
                level constraints like <code class="literal">@NotNull</code>) will be called to verify the request entity mapped to
                <code class="literal">user</code>.
            </p><p>
                Alternatively, a new annotation can be defined and used directly on the resource
                method parameter (<a class="xref" href="#bv.example.constraints.entity2" title="Example&nbsp;16.9.&nbsp;Entity validation 2">Example&nbsp;16.9, &#8220;Entity validation 2&#8221;</a>).

                </p><div class="example"><a name="bv.example.constraints.entity2"></a><p class="title"><b>Example&nbsp;16.9.&nbsp;Entity validation 2</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
class MyResourceClass {

    @POST
    @Consumes("application/xml")
    public void registerUser(@PremiumUser User user) {
        ...
    }
}</pre></div></div><p><br class="example-break">

                In the example above, <code class="literal">@PremiumUser</code> rather than <code class="literal">@StandardUser</code> will be used
                to validate the request entity. These two ways in which validation of entities can be triggered can also be
                combined by including <code class="literal">@Valid</code> in the list of constraints. The presence of <code class="literal">@Valid</code> will trigger
                validation of <span class="emphasis"><em>all</em></span> the constraint annotations decorating a Java bean class.
            </p><p>
                Response entity bodies returned from resource methods can be validated in a similar manner by annotating the
                resource method itself. To exemplify, assuming both <code class="literal">@StandardUser</code> and
                <code class="literal">@PremiumUser</code> are required to be checked before returning a user, the
                <code class="literal">getUser</code> method can be annotated as shown in
                <a class="xref" href="#bv.example.constraints.entity.response" title="Example&nbsp;16.10.&nbsp;Response entity validation">Example&nbsp;16.10, &#8220;Response entity validation&#8221;</a>.
                </p><div class="example"><a name="bv.example.constraints.entity.response"></a><p class="title"><b>Example&nbsp;16.10.&nbsp;Response entity validation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
class MyResourceClass {

    @GET
    @Path("{id}")
    @Produces("application/xml")
    @Valid @PremiumUser
    public User getUser(@PathParam("id") String id) {
        User u = findUser(id);
        return u;
    }

    ...
}</pre></div></div><p><br class="example-break">

                Note that <code class="literal">@PremiumUser</code> is explicitly listed and <code class="literal">@StandardUser</code> is triggered
                by the presence of the <code class="literal">@Valid</code> annotation - see definition of <code class="literal">User</code> class earlier in
                this section.
            </p></div><div class="section" title="16.4.4.&nbsp;Annotation Inheritance"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9773"></a>16.4.4.&nbsp;Annotation Inheritance</h3></div></div></div><p>
                The rules for inheritance of constraint annotation are defined in Bean Validation specification. It is worth
                noting that these rules are incompatible with those defined by JAX-RS. Generally speaking, constraint
                annotations in Bean Validation are cumulative (can be strengthen) across a given type hierarchy while JAX-RS
                annotations are inherited or, overridden and ignored.
            </p><p>
                For Bean Validation annotations Jersey follows the constraint annotation rules defined in the Bean Validation
                specification.
            </p></div></div><div class="section" title="16.5.&nbsp;@ValidateOnExecution"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bv.ValidateOnExecution"></a>16.5.&nbsp;@ValidateOnExecution</h2></div></div></div><p>
            According to Bean Validation specification, validation is enabled by default only for the so called
            <span class="emphasis"><em>constrained</em></span> methods. Getter
            methods as defined by the Java Beans specification are not constrained methods, so they will not be validated by
            default. The special annotation <code class="literal">@ValidateOnExecution</code> can be used to selectively enable
            and disable validation. For example, you can enable validation on method <code class="literal">getEmail</code> shown in
            <a class="xref" href="#bv.example.validateonexecution" title="Example&nbsp;16.11.&nbsp;Validate getter on execution">Example&nbsp;16.11, &#8220;Validate getter on execution&#8221;</a>.
            </p><div class="example"><a name="bv.example.validateonexecution"></a><p class="title"><b>Example&nbsp;16.11.&nbsp;Validate getter on execution</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("/")
class MyResourceClass {

    @Email
    @ValidateOnExecution
    public String getEmail() {
        return email;
    }

    ...
}</pre></div></div><p><br class="example-break">

            The default value for the <code class="literal">type</code> attribute of <code class="literal">@ValidateOnExecution</code> is
            <code class="literal">IMPLICIT</code> which results in method <code class="literal">getEmail</code> being validated.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    According to Bean Validation specification <code class="literal">@ValidateOnExecution</code> cannot be overridden once is
                    declared on a method (i.e. in subclass/sub-interface) and in this situations a
                    <code class="literal">ValidationException</code> should be raised. This default behaviour can be suppressed by
                    setting <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK" target="_top">ServerProperties.BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK</a>
                    property (Jersey specific) to <code class="literal">true</code>.
                </p></div><p>
        </p></div><div class="section" title="16.6.&nbsp;Injecting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="bv.injecting"></a>16.6.&nbsp;Injecting</h2></div></div></div><p>
            Jersey allows you to inject registered resources/providers into your <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/ConstraintValidator.html" target="_top">ConstraintValidator</a> implementation and you
            can inject <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/Configuration.html" target="_top">Configuration</a>, <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/ValidatorFactory.html" target="_top">ValidatorFactory</a> and <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/Validator.html" target="_top">Validator</a> as required by Bean Validation spec.

            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Injected <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/Configuration.html" target="_top">Configuration</a>, <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/ValidatorFactory.html" target="_top">ValidatorFactory</a> and <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/Validator.html" target="_top">Validator</a> do not inherit configuration provided
                    by <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/validation/ValidationConfig.html" target="_top">ValidationConfig</a> and need to be configured manually.
                </p></div><p>

            Injection of JAX-RS components into <code class="literal">ConstraintValidator</code>s is supported via a custom
            <code class="literal">ConstraintValidatorFactory</code> provided by Jersey. An example is shown in
            <a class="xref" href="#bv.examples.injecting" title="Example&nbsp;16.12.&nbsp;Injecting UriInfo into a ConstraintValidator">Example&nbsp;16.12, &#8220;Injecting UriInfo into a ConstraintValidator&#8221;</a>.

            </p><div class="example"><a name="bv.examples.injecting"></a><p class="title"><b>Example&nbsp;16.12.&nbsp;Injecting UriInfo into a ConstraintValidator</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class EmailValidator implements ConstraintValidator&lt;Email, String&gt; {

    @Context
    private UriInfo uriInfo;

    public void initialize(Email email) {
        ...
    }

    public boolean isValid(String value, ConstraintValidatorContext context) {
        // Use UriInfo.

        ...
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            Using a custom <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/ConstraintValidatorFactory.html" target="_top">ConstraintValidatorFactory</a> of your own disables registration of the one provided by Jersey
            and injection support for resources/providers (if needed) has to be provided by this new implementation.
            <a class="xref" href="#bv.examples.injecting.factory" title="Example&nbsp;16.13.&nbsp;Support for injecting Jersey's resources/providers via ConstraintValidatorFactory.">Example&nbsp;16.13, &#8220;Support for injecting Jersey's resources/providers via ConstraintValidatorFactory.&#8221;</a> shows how this can be achieved.

            </p><div class="example"><a name="bv.examples.injecting.factory"></a><p class="title"><b>Example&nbsp;16.13.&nbsp;Support for injecting Jersey's resources/providers via ConstraintValidatorFactory.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class InjectingConstraintValidatorFactory implements ConstraintValidatorFactory {

    @Context
    private ResourceContext resourceContext;

    @Override
    public &lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; T getInstance(final Class&lt;T&gt; key) {
        return resourceContext.getResource(key);
    }

    @Override
    public void releaseInstance(final ConstraintValidator&lt;?, ?&gt; instance) {
        // NOOP
    }
}</pre></div></div><p><br class="example-break">
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    This behaviour may likely change in one of the next version of Jersey to remove the need of
                    manually providing support for injecting resources/providers from Jersey in your own
                    <code class="literal">ConstraintValidatorFactory</code> implementation code.
                </p></div><p>
        </p></div><div class="section" title="16.7.&nbsp;Error Reporting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e9897"></a>16.7.&nbsp;Error Reporting</h2></div></div></div><p>
            Bean Validation specification defines a small hierarchy of exceptions (they all inherit from
            <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/ValidationException.html" target="_top">ValidationException</a>) that could be thrown during initialization of validation engine or (for our case more
            importantly) during validation of input/output values (<a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/javax/validation/ConstraintViolationException.html" target="_top">ConstraintViolationException</a>).
            If a thrown exception is a subclass of <code class="literal">ValidationException</code> <span class="emphasis"><em>except</em></span>
            <code class="literal">ConstraintViolationException</code> then this exception is mapped to a HTTP response with status code 500
            (Internal Server Error).
            On the other hand, when a <code class="literal">ConstraintViolationException</code> is throw two different status code would be returned:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>500 (Internal Server Error)</p><p>If the exception was thrown while validating a method return type.</p></li><li class="listitem"><p>400 (Bad Request)</p><p>Otherwise.</p></li></ul></div><p>
        </p><div class="section" title="16.7.1.&nbsp;ValidationError"><div class="titlepage"><div><div><h3 class="title"><a name="bv.ValidationError"></a>16.7.1.&nbsp;ValidationError</h3></div></div></div><p>
                By default, (during mapping <code class="literal">ConstraintViolationException</code>s) Jersey doesn't return any entities that would
                include validation errors to the client. This default behaviour could be changed by enabling
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_SEND_ERROR_IN_RESPONSE" target="_top">ServerProperties.BV_SEND_ERROR_IN_RESPONSE</a> property in your application
                (<a class="xref" href="#bv.example.jersey.properties" title="Example&nbsp;16.1.&nbsp;Configuring Jersey specific properties for Bean Validation.">Example&nbsp;16.1, &#8220;Configuring Jersey specific properties for Bean Validation.&#8221;</a>).
                When this property is enabled then our custom <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/ExceptionMapper.html" target="_top">ExceptionMapper&lt;E extends Throwable&gt;</a> (that is handling
                <code class="literal">ValidationException</code>s) would transform <code class="literal">ConstraintViolationException</code>(s) into
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/validation/ValidationError.html" target="_top">ValidationError</a>(s) and set this object (collection) as the new response entity which Jersey is
                able to sent to the client.
                Four <code class="literal">MediaType</code>s are currently supported when sending <code class="literal">ValidationError</code>s to the
                client:

                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">text/plain</code></p></li><li class="listitem"><p><code class="literal">text/html</code></p></li><li class="listitem"><p><code class="literal">application/xml</code></p></li><li class="listitem"><p><code class="literal">application/json</code></p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                                Note: You need to register one of the JSON (JAXB) providers (e.g.
                                <a class="link" href="#json.moxy" title="8.1.2.&nbsp;MOXy">MOXy</a>) to marshall validation errors to JSON.
                            </p></div></li></ul></div><p>
            </p><p>
                Let's take a look at <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/validation/ValidationError.html" target="_top">ValidationError</a> class to see which properties are send to the client:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@XmlRootElement
public final class ValidationError {

    private String message;

    private String messageTemplate;

    private String path;

    private String invalidValue;

    ...
}</pre><p>

                The <code class="literal">message</code> property is the interpolated error message, <code class="literal">messageTemplate</code>
                represents a non-interpolated error message (or key from your constraint definition e.g.
                <code class="literal">{javax.validation.constraints.NotNull.message}</code>), <code class="literal">path</code> contains information
                about the path in the validated object graph to the property holding invalid value and
                <code class="literal">invalidValue</code> is the string representation of the invalid value itself.
            </p><p>
                Here are few examples of <code class="literal">ValidationError</code> messages sent to client:

                </p><div class="example"><a name="d0e10015"></a><p class="title"><b>Example&nbsp;16.14.&nbsp;<code class="literal">ValidationError</code> to <code class="literal">text/plain</code></b></p><div class="example-contents"><pre class="screen">HTTP/1.1 500 Internal Server Error
Content-Length: 114
Content-Type: text/plain
Vary: Accept
Server: Jetty(6.1.24)

Contact with given ID does not exist. (path = ContactCardResource.getContact.&lt;return value&gt;, invalidValue = null)</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e10025"></a><p class="title"><b>Example&nbsp;16.15.&nbsp;<code class="literal">ValidationError</code> to <code class="literal">text/html</code></b></p><div class="example-contents"><pre class="screen">HTTP/1.1 500 Internal Server Error
Content-Length: ...
Content-Type: text/plain
Vary: Accept
Server: Jetty(6.1.24)

&lt;div class="validation-errors"&gt;
    &lt;div class="validation-error"&gt;
        &lt;span class="message"&gt;Contact with given ID does not exist.&lt;/span&gt;
        (
        &lt;span class="path"&gt;
            &lt;strong&gt;path&lt;/strong&gt;
            = ContactCardResource.getContact.&lt;return value&gt;
        &lt;/span&gt;
        ,
        &lt;span class="invalid-value"&gt;
            &lt;strong&gt;invalidValue&lt;/strong&gt;
            = null
        &lt;/span&gt;
        )
    &lt;/div&gt;
&lt;/div&gt;</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e10035"></a><p class="title"><b>Example&nbsp;16.16.&nbsp;<code class="literal">ValidationError</code> to <code class="literal">application/xml</code></b></p><div class="example-contents"><pre class="screen">HTTP/1.1 500 Internal Server Error
Content-Length: ...
Content-Type: text/plain
Vary: Accept
Server: Jetty(6.1.24)

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validationErrors&gt;
    &lt;validationError&gt;
        &lt;message&gt;Contact with given ID does not exist.&lt;/message&gt;
        &lt;messageTemplate&gt;{contact.does.not.exist}&lt;/messageTemplate&gt;
        &lt;path&gt;ContactCardResource.getContact.&amp;lt;return value&amp;gt;&lt;/path&gt;
    &lt;/validationError&gt;
&lt;/validationErrors&gt;</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e10045"></a><p class="title"><b>Example&nbsp;16.17.&nbsp;<code class="literal">ValidationError</code> to <code class="literal">application/json</code></b></p><div class="example-contents"><pre class="screen">HTTP/1.1 500 Internal Server Error
Content-Length: 174
Content-Type: application/json
Vary: Accept
Server: Jetty(6.1.24)

[ {
   "message" : "Contact with given ID does not exist.",
   "messageTemplate" : "{contact.does.not.exist}",
   "path" : "ContactCardResource.getContact.&lt;return value&gt;"
} ]</pre></div></div><p><br class="example-break">
            </p></div></div><div class="section" title="16.8.&nbsp;Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10055"></a>16.8.&nbsp;Example</h2></div></div></div><p>To see a complete working example of using Bean Validation (JSR-349) with Jersey refer to the
            <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/bean-validation-webapp" target="_top">Bean Validation example</a>.</p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;17.&nbsp;Entity Data Filtering"><div class="titlepage"><div><div><h2 class="title"><a name="entity-filtering"></a>Chapter&nbsp;17.&nbsp;Entity Data Filtering</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e10091">17.1. Enabling and configuring Entity Filtering in your application</a></span></dt><dt><span class="section"><a href="#d0e10192">17.2. Components used to describe Entity Filtering concepts</a></span></dt><dt><span class="section"><a href="#ef.annotations">17.3. Using custom annotations to filter entities</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10347">17.3.1. Server-side Entity Filtering</a></span></dt><dt><span class="section"><a href="#d0e10465">17.3.2. Client-side Entity Filtering</a></span></dt></dl></dd><dt><span class="section"><a href="#ef.security.annotations">17.4. Role-based Entity Filtering using (<code class="literal">javax.annotation.security</code>) annotations</a></span></dt><dt><span class="section"><a href="#ef.custom.annotations">17.5. Defining custom handling for entity-filtering annotations</a></span></dt><dt><span class="section"><a href="#ef.custom.providers">17.6. Supporting Entity Data Filtering in custom entity providers or frameworks</a></span></dt><dt><span class="section"><a href="#ef.modules">17.7. Modules with support for Entity Data Filtering</a></span></dt><dt><span class="section"><a href="#d0e10630">17.8. Examples</a></span></dt></dl></div><p>
        Support for Entity Filtering in Jersey introduces a convenient facility for reducing the amount of data exchanged over
        the wire between client and server without a need to create specialized data view components. The main idea behind this
        feature is to give you APIs that will let you to selectively filter out any non-relevant data from the marshalled object
        model before sending the data to the other party based on the context of the particular message exchange.
        This way, only the necessary or relevant portion of the data is transferred over the network with each client request
        or server response, without a need to create special facade models for transferring these limited subsets of the model
        data.
    </p><p>
        Entity filtering feature allows you to define your own entity-filtering rules for your entity classes based on the
        current context (e.g. matched resource method) and keep these rules in one place (directly in your domain model).
        With Jersey entity filtering facility it is also possible to assign security access rules to entity classes properties
        and property accessors.
    </p><p>
        We will first explain the main concepts and then we will explore the entity filtering feature topics from a perspective
        of basic use-cases,

        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="xref" href="#ef.annotations" title="17.3.&nbsp;Using custom annotations to filter entities">Section&nbsp;17.3, &#8220;Using custom annotations to filter entities&#8221;</a></p></li><li class="listitem"><p><a class="xref" href="#ef.security.annotations" title="17.4.&nbsp;Role-based Entity Filtering using (javax.annotation.security) annotations">Section&nbsp;17.4, &#8220;Role-based Entity Filtering using (<code class="literal">javax.annotation.security</code>) annotations&#8221;</a></p></li></ul></div><p>

        as well as some more complex ones.

        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="xref" href="#ef.custom.annotations" title="17.5.&nbsp;Defining custom handling for entity-filtering annotations">Section&nbsp;17.5, &#8220;Defining custom handling for entity-filtering annotations&#8221;</a></p></li></ul></div><p>
    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            Jersey entity filtering feature is supported via Jersey extension modules listed in <a class="xref" href="#ef.modules" title="17.7.&nbsp;Modules with support for Entity Data Filtering">Section&nbsp;17.7, &#8220;Modules with support for Entity Data Filtering&#8221;</a>.
        </p></div><div class="section" title="17.1.&nbsp;Enabling and configuring Entity Filtering in your application"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10091"></a>17.1.&nbsp;Enabling and configuring Entity Filtering in your application</h2></div></div></div><p>
            Entity Filtering support in Jersey is provided as an extension module and needs to be mentioned explicitly in your
            <code class="literal">pom.xml</code> file (in case of using Maven):

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    gutter: false;">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-entity-filtering&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    If you're not using Maven make sure to have also all the transitive dependencies
                    (see <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-entity-filtering/dependencies.html" target="_top">jersey-entity-filtering</a>) on the classpath.
                </p></div><p>
        </p><p>
            The entity-filtering extension module provides two <code class="literal">Feature</code>s which you can register into server/client
            runtime in prior to use Entity Filtering in an application:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/EntityFilteringFeature.html" target="_top">EntityFilteringFeature</a></p><p>
                        Filtering based on entity-filtering annotations (or i.e. external configuration file) created using
                        <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/EntityFiltering.html" target="_top">@EntityFiltering</a> meta-annotation.
                    </p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/SecurityEntityFilteringFeature.html" target="_top">SecurityEntityFilteringFeature</a></p><p>Filtering based on security (<code class="literal">javax.annotation.security</code>) and entity-filtering
                        annotations.</p></li></ul></div><p>

            If you want to use both entity-filtering annotations and security annotations for entity data filtering it is enough
            to register <code class="literal">SecurityEntityFilteringFeature</code> as this feature registers also
            <code class="literal">EntityFilteringFeature</code>.
        </p><p>
            Entity-filtering currently recognizes one property that can be passed into the <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configuration.html" target="_top">Configuration</a> instance
            (client/server):

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/EntityFilteringFeature.html#ENTITY_FILTERING_SCOPE" target="_top">EntityFilteringFeature.ENTITY_FILTERING_SCOPE</a> - "<code class="literal">jersey.config.entityFiltering.scope</code>"</p><p>
                        Defines one or more annotations that should be used as entity-filtering scope when reading/writing an
                        entity.
                    </p></li></ul></div><p>

            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Processing of entity-filtering annotations to create an entity-filtering scope is defined by
                    following: "<code class="literal">Request/Resource entity annotations</code>" &gt;
                    "<code class="literal">Configuration</code>" &gt; "<code class="literal">Resource method/class annotations</code>"
                    (on server).
                </p></div><p>
        </p><p>
            You can configure entity-filtering on server (basic + security examples) as follows:

            </p><div class="example"><a name="ef.example.server.registration"></a><p class="title"><b>Example&nbsp;17.1.&nbsp;Registering and configuring entity-filtering feature on server.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    // Set entity-filtering scope via configuration.
    .property(EntityFilteringFeature.ENTITY_FILTERING_SCOPE, new Annotation[] {ProjectDetailedView.Factory.get()})
    // Register the EntityFilteringFeature.
    .register(EntityFilteringFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="ef.example.server.security.registration"></a><p class="title"><b>Example&nbsp;17.2.&nbsp;Registering and configuring entity-filtering feature with security annotations on server.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    // Set entity-filtering scope via configuration.
    .property(EntityFilteringFeature.ENTITY_FILTERING_SCOPE, new Annotation[] {SecurityAnnotations.rolesAllowed("manager")})
    // Register the SecurityEntityFilteringFeature.
    .register(SecurityEntityFilteringFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">
        </p><p>
            Use similar steps to register entity-filtering on client:

            </p><div class="example"><a name="ef.example.client.registration"></a><p class="title"><b>Example&nbsp;17.3.&nbsp;Registering and configuring entity-filtering feature on client.</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">final ClientConfig config = new ClientConfig()
    // Set entity-filtering scope via configuration.
    .property(EntityFilteringFeature.ENTITY_FILTERING_SCOPE, new Annotation[] {ProjectDetailedView.Factory.get()})
    // Register the EntityFilteringFeature.
    .register(EntityFilteringFeature.class)
    // Further configuration of ClientConfig.
    .register( ... );

// Create new client.
final Client client = ClientClientBuilder.newClient(config);

// Use the client.</pre></div></div><p><br class="example-break">
        </p></div><div class="section" title="17.2.&nbsp;Components used to describe Entity Filtering concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10192"></a>17.2.&nbsp;Components used to describe Entity Filtering concepts</h2></div></div></div><p>
            In the next section the entity-filtering features will be illustrated on a project-tracking application that
            contains three classes in it's domain model and few resources (only <code class="literal">Project</code> resource will be
            shown in this chapter). The full source code for the example application can be found in Jersey
            <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/entity-filtering" target="_top">Entity Filtering example</a>.
        </p><p>
            Suppose there are three domain model classes (or entities) in our model:
            <code class="literal">Project</code>, <code class="literal">User</code> and <code class="literal">Task</code> (getters/setter are omitted for
            brevity).

            </p><div class="example"><a name="d0e10214"></a><p class="title"><b>Example&nbsp;17.4.&nbsp;Project</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Project {

    private Long id;

    private String name;

    private String description;

    private List&lt;Task&gt; tasks;

    private List&lt;User&gt; users;

    // getters and setters
}</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e10220"></a><p class="title"><b>Example&nbsp;17.5.&nbsp;User</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class User {

    private Long id;

    private String name;

    private String email;

    private List&lt;Project&gt; projects;

    private List&lt;Task&gt; tasks;

    // getters and setters
}</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e10226"></a><p class="title"><b>Example&nbsp;17.6.&nbsp;Task</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Task {

    private Long id;

    private String name;

    private String description;

    private Project project;

    private User user;

    // getters and setters
}</pre></div></div><p><br class="example-break">
        </p><p>
            To retrieve the entities from server to client, we have created also a couple of JAX-RS resources from whose the
            <code class="literal">ProjectsResource</code> is shown as example.

            </p><div class="example"><a name="d0e10237"></a><p class="title"><b>Example&nbsp;17.7.&nbsp;ProjectsResource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("projects")
@Produces("application/json")
public class ProjectsResource {

    @GET
    @Path("{id}")
    public Project getProject(@PathParam("id") final Long id) {
        return getDetailedProject(id);
    }

    @GET
    public List&lt;Project&gt; getProjects() {
        return getDetailedProjects();
    }
}</pre></div></div><p><br class="example-break">
        </p></div><div class="section" title="17.3.&nbsp;Using custom annotations to filter entities"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.annotations"></a>17.3.&nbsp;Using custom annotations to filter entities</h2></div></div></div><p>
            Entity filtering via annotations is based on an <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/EntityFiltering.html" target="_top">@EntityFiltering</a> meta-annotation.
            This meta-annotation is used to identify entity-filtering annotations that can be then attached to

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>domain model classes (supported on both, server and client sides), and</p></li><li class="listitem"><p>resource methods / resource classes (only on server side)</p></li></ul></div><p>

            An example of entity-filtering annotation applicable to a class, field or method can be seen in
            <a class="xref" href="#ef.annotations.sample.annotation" title="Example&nbsp;17.8.&nbsp;ProjectDetailedView">Example&nbsp;17.8, &#8220;ProjectDetailedView&#8221;</a> bellow.

            </p><div class="example"><a name="ef.annotations.sample.annotation"></a><p class="title"><b>Example&nbsp;17.8.&nbsp;ProjectDetailedView</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@EntityFiltering
public @interface ProjectDetailedView {

    /**
     * Factory class for creating instances of {@code ProjectDetailedView} annotation.
     */
    public static class Factory
                        extends AnnotationLiteral&lt;ProjectDetailedView&gt;
                        implements ProjectDetailedView {

        private Factory() {
        }

        public static ProjectDetailedView get() {
            return new Factory();
        }
    }
}</pre></div></div><p><br class="example-break">

        </p><p>
            Since creating annotation instances directly in Java code is not trivial, it is a good practice to provide an inner
            annotation <code class="literal">Factory</code> class in each custom filtering annotation, through which new instances of
            the annotation can be directly created. The annotation factory class can be created by extending the HK2
            <code class="literal">AnnotationLiteral</code> class and implementing the annotation interface itself. It should also provide
            a static factory method that will create and return a new instance of the <code class="literal">Factory</code> class when
            invoked. Such annotation instances can be then passed to the client and server run-times to define or override
            entity-filtering scopes.
        </p><p>
            By placing an entity-filtering annotation on an entity (class, fields, getters or setters) we define a so-called
            <span class="emphasis"><em>entity-filtering scope</em></span> for the entity. The purpose of entity-filtering scope is to identify
            parts of the domain model that should be processed when the model is to be sent over the wire in a particular
            entity-filtering scope. We distinguish between:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        global entity-filtering scope (defined by placing filtering annotation on a class itself), and
                    </p></li><li class="listitem"><p>
                        local entity-filtering scope (defined by placing filtering annotation on a field, getter or setter)
                    </p></li></ul></div><p>

            Unannotated members of a domain model class are automatically added to all existing global entity-filtering scopes.
            If there is no explicit global entity-filtering scope defined on a class a default scope is created for this class
            to group these members.
        </p><p>
            Creating entity-filtering scopes using custom entity-filtering annotations in domain model classes is illustrated
            in the following examples.

            </p><div class="example"><a name="d0e10293"></a><p class="title"><b>Example&nbsp;17.9.&nbsp;Annotated Project</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Project {

    private Long id;

    private String name;

    private String description;

    @ProjectDetailedView
    private List&lt;Task&gt; tasks;

    @ProjectDetailedView
    private List&lt;User&gt; users;

    // getters and setters
}</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e10299"></a><p class="title"><b>Example&nbsp;17.10.&nbsp;Annotated User</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class User {

    private Long id;

    private String name;

    private String email;

    @UserDetailedView
    private List&lt;Project&gt; projects;

    @UserDetailedView
    private List&lt;Task&gt; tasks;

    // getters and setters
}</pre></div></div><p><br class="example-break">

                </p><div class="example"><a name="d0e10305"></a><p class="title"><b>Example&nbsp;17.11.&nbsp;Annotated Task</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Task {

    private Long id;

    private String name;

    private String description;

    @TaskDetailedView
    private Project project;

    @TaskDetailedView
    private User user;

    // getters and setters
}</pre></div></div><p><br class="example-break">

            As you can see in the examples above, we have defined 3 separate scopes using <code class="literal">@ProjectDetailedView</code>,
            <code class="literal">@UserDetailedView</code> and <code class="literal">@TaskDetailedView</code> annotations and we have applied
            these scopes selectively to certain fields in the domain model classes.
        </p><p>
            Once the entity-filtering scopes are applied to the parts of a domain model, the entity filtering facility (when
            enabled) will check the active scopes when the model is being sent over the wire, and filter out all parts from
            the model for which there is no active scope set in the given context. Therefore, we need a way how to control
            the scopes active in any given context in order to process the model data in a certain way (e.g. expose the detailed
            view). We need to tell the server/client runtime which entity-filtering scopes we want to apply. There are 2 ways
            how to do this for client-side and 3 ways for server-side:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Out-bound client request or server response programmatically created with entity-filtering annotations
                        that identify the scopes to be applied (available on both, client and server)</p></li><li class="listitem"><p>Property identifying the applied scopes passed through <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configuration.html" target="_top">Configuration</a>
                        (available on both, client and server)</p></li><li class="listitem"><p>Entity-filtering annotations identifying the applied scopes attached to a resource method or class
                        (server-side only)</p></li></ul></div><p>

            When the multiple approaches are combined, the priorities of calculating the applied scopes are as follows:
            <code class="literal">Entity annotations in request or response</code> &gt;
            <code class="literal">Property passed through Configuration</code> &gt;
            <code class="literal">Annotations applied to a resource method or class</code>.
        </p><p>
            In a graph of domain model objects, the entity-filtering scopes are applied to the root node as well as transitively
            to all the child nodes. Fields and child nodes that do not match at least a single active scope are filtered out.
            When the scope matching is performed, annotations applied to the domain model classes and fields
            are used to compute the scope for each particular component of the model. If there are no annotations on the class
            or it's fields, the default scope is assumed. During the filtering, first, the annotations on root model class
            and it's fields are considered. For all composite fields that have not been filtered out, the annotations on the
            referenced child class and it's fields are considered next, and so on.
        </p><div class="section" title="17.3.1.&nbsp;Server-side Entity Filtering"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10347"></a>17.3.1.&nbsp;Server-side Entity Filtering</h3></div></div></div><p>
                To pass entity-filtering annotations via <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Response.html" target="_top">Response</a> returned from a resource method you can leverage the
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Response.ResponseBuilder.html#entity(java.lang.Object, java.lang.annotation.Annotation[])" target="_top">Response.ResponseBuilder#entity(Object, Annotation[])</a>
                method. The next example illustrates this approach. You will also see why every custom entity-filtering
                annotation should contain a factory for creating instances of the annotation.

                </p><div class="example"><a name="d0e10358"></a><p class="title"><b>Example&nbsp;17.12.&nbsp;ProjectsResource - Response entity-filtering annotations</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("projects")
@Produces("application/json")
public class ProjectsResource {

    @GET
    public Response getProjects(@QueryParam("detailed") final boolean isDetailed) {
        return Response
                .ok()
                .entity(new GenericEntity&lt;List&lt;Project&gt;&gt;(EntityStore.getProjects()) {},
                        isDetailed ? new Annotation[]{ProjectDetailedView.Factory.get()} : new Annotation[0])
                .build();
    }
}</pre></div></div><p><br class="example-break">

                Annotating a resource method / class is typically easier although it is less flexible and may require more
                resource methods to be created to cover all the alternative use case scenarios. For example:

                </p><div class="example"><a name="d0e10364"></a><p class="title"><b>Example&nbsp;17.13.&nbsp;ProjectsResource - Entity-filtering annotations on methods</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("projects")
@Produces("application/json")
public class ProjectsResource {

    @GET
    public List&lt;Project&gt; getProjects() {
        return getDetailedProjects();
    }

    @GET
    @Path("detailed")
    @ProjectDetailedView
    public List&lt;Project&gt; getDetailedProjects() {
        return EntityStore.getProjects();
    }
}</pre></div></div><p><br class="example-break">

                To see how entity-filtering scopes can be applied using a <code class="literal">Configuration</code> property,
                see the <a class="xref" href="#ef.example.server.registration" title="Example&nbsp;17.1.&nbsp;Registering and configuring entity-filtering feature on server.">Example&nbsp;17.1, &#8220;Registering and configuring entity-filtering feature on server.&#8221;</a> example.
            </p><p>
                When a <code class="literal">Project</code> model from the example above is requested in a scope represented by
                <code class="literal">@ProjectDetailedView</code> entity-filtering annotation, the <code class="literal">Project</code> model
                data sent over the wire would contain:

                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            <code class="literal">Project</code> - <code class="literal">id</code>, <code class="literal">name</code>,
                            <code class="literal">description</code>, <code class="literal">tasks</code>, <code class="literal">users</code>
                        </p></li><li class="listitem"><p>
                            <code class="literal">Task</code> - <code class="literal">id</code>, <code class="literal">name</code>,
                            <code class="literal">description</code>
                        </p></li><li class="listitem"><p>
                            <code class="literal">User</code> - <code class="literal">id</code>, <code class="literal">name</code>, <code class="literal">email</code>
                        </p></li></ul></div><p>

                Or, to illustrate this in JSON format:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "description" : "Jersey is the open source (under dual CDDL+GPL license) JAX-RS 2.0 (JSR 339) production quality Reference Implementation for building RESTful Web services.",
   "id" : 1,
   "name" : "Jersey",
   "tasks" : [ {
      "description" : "Entity Data Filtering",
      "id" : 1,
      "name" : "ENT_FLT"
   }, {
      "description" : "OAuth 1 + 2",
      "id" : 2,
      "name" : "OAUTH"
   } ],
   "users" : [ {
      "email" : "very@secret.com",
      "id" : 1,
      "name" : "Jersey Robot"
   } ]
}</pre><p>

                For the <span class="emphasis"><em>default entity-filtering scope</em></span> the filtered model would look like:

                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            <code class="literal">Project</code> - <code class="literal">id</code>, <code class="literal">name</code>, <code class="literal">description</code>
                        </p></li></ul></div><p>

                Or in JSON format:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">{
   "description" : "Jersey is the open source (under dual CDDL+GPL license) JAX-RS 2.0 (JSR 339) production quality Reference Implementation for building RESTful Web services.",
   "id" : 1,
   "name" : "Jersey"
}</pre><p>
            </p></div><div class="section" title="17.3.2.&nbsp;Client-side Entity Filtering"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10465"></a>17.3.2.&nbsp;Client-side Entity Filtering</h3></div></div></div><p>
                As mentioned above you can define applied entity-filtering scopes using a property set either in the client
                run-time <code class="literal">Configuration</code> (see <a class="xref" href="#ef.example.client.registration" title="Example&nbsp;17.3.&nbsp;Registering and configuring entity-filtering feature on client.">Example&nbsp;17.3, &#8220;Registering and configuring entity-filtering feature on client.&#8221;</a>) or by
                passing the entity-filtering annotations during a creation of an individual request to be sent to server.

                </p><div class="example"><a name="d0e10475"></a><p class="title"><b>Example&nbsp;17.14.&nbsp;Client - Request entity-filtering annotations</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ClientBuilder.newClient(config)
    .target(uri)
    .request()
    .post(Entity.entity(project, new Annotation[] {ProjectDetailedView.Factory.get()}));</pre></div></div><p><br class="example-break">

                You can use the mentioned method with client injected into a resource as well.

                </p><div class="example"><a name="d0e10481"></a><p class="title"><b>Example&nbsp;17.15.&nbsp;Client - Request entity-filtering annotations</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("clients")
@Produces("application/json")
public class ClientsResource {

    @Uri("projects")
    private WebTarget target;

    @GET
    public List&lt;Project&gt; getProjects() {
        return target.request()
            .post(Entity.entity(project, new Annotation[] {ProjectDetailedView.Factory.get()}));
    }
}</pre></div></div><p><br class="example-break">
            </p></div></div><div class="section" title="17.4.&nbsp;Role-based Entity Filtering using (javax.annotation.security) annotations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.security.annotations"></a>17.4.&nbsp;Role-based Entity Filtering using (<code class="literal">javax.annotation.security</code>) annotations</h2></div></div></div><p>
            Filtering the content sent to the client (or server) based on the authorized security roles is a commonly
            required use case. By registering <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/SecurityEntityFilteringFeature.html" target="_top">SecurityEntityFilteringFeature</a> you can
            leverage the Jersey Entity Filtering facility in connection with standard
            <code class="literal">javax.annotation.security</code> annotations exactly the same way as you would with custom
            entity-filtering annotations described in previous chapters. Supported security annotations are:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="http://docs.oracle.com/javaee/6/api/javax/annotation/security/PermitAll.html" target="_top">@PermitAll</a>,</p></li><li class="listitem"><p><a class="link" href="http://docs.oracle.com/javaee/6/api/javax/annotation/security/RolesAllowed.html" target="_top">@RolesAllowed</a>, and</p></li><li class="listitem"><p><a class="link" href="http://docs.oracle.com/javaee/6/api/javax/annotation/security/DenyAll.html" target="_top">@DenyAll</a></p></li></ul></div><p>
        </p><p>
            Although the mechanics of the Entity Data Filtering feature used for the security annotation-based filtering is
            the same as with the entity-filtering annotations, the processing of security annotations differs in a few important
            aspects:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        Custom <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/SecurityContext.html" target="_top">SecurityContext</a> should be set by a container request filter in order to use
                        <code class="literal">@RolesAllowed</code> for role-based filtering of domain model data (server-side)
                    </p></li><li class="listitem"><p>
                        There is no need to provide entity-filtering (or security) annotations on resource methods in order to
                        define entity-filtering scopes for <code class="literal">@RolesAllowed</code> that is applied to the domain model
                        components, as all the available roles for the current user are automatically determined using
                        the information from the provided <code class="literal">SecurityContext</code> (server-side only).
                    </p></li></ul></div><p>

            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Instances of security annotations (to be used for programmatically defined scopes either on client or server)
                    can be created using one of the methods in the <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/SecurityAnnotations.html" target="_top">SecurityAnnotations</a> factory class
                    that is part of the Jersey Entity Filtering API.
                </p></div><p>
        </p></div><div class="section" title="17.5.&nbsp;Defining custom handling for entity-filtering annotations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.custom.annotations"></a>17.5.&nbsp;Defining custom handling for entity-filtering annotations</h2></div></div></div><p>
            To create a custom entity-filtering annotation with special handling, i.e. an field aggregator annotation used
            to annotate classes like the one in <a class="xref" href="#ef.custom.annotations.annotation" title="Example&nbsp;17.16.&nbsp;Entity-filtering annotation with custom meaning">Example&nbsp;17.16, &#8220;Entity-filtering annotation with custom meaning&#8221;</a> it is, in most cases,
            sufficient to implement and register the following SPI contracts:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/spi/EntityProcessor.html" target="_top">EntityProcessor</a></p><p>Implementations of this SPI are invoked to process entity class and it's members. Custom
                        implementations can extend from <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/spi/AbstractEntityProcessor.html" target="_top">AbstractEntityProcessor</a>.</p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/spi/ScopeResolver.html" target="_top">ScopeResolver</a></p><p>Implementations of this SPI are invoked to retrieve entity-filtering scopes from an array of
                        provided annotations.</p></li></ul></div><p>

            </p><div class="example"><a name="ef.custom.annotations.annotation"></a><p class="title"><b>Example&nbsp;17.16.&nbsp;Entity-filtering annotation with custom meaning</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@EntityFiltering
public @interface FilteringAggregator {

    /**
     * Entity-filtering scope to add given fields to.
     */
    Annotation filteringScope();

    /**
     * Fields to be a part of the entity-filtering scope.
     */
    String[] fields();
}</pre></div></div><p><br class="example-break">
        </p></div><div class="section" title="17.6.&nbsp;Supporting Entity Data Filtering in custom entity providers or frameworks"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.custom.providers"></a>17.6.&nbsp;Supporting Entity Data Filtering in custom entity providers or frameworks</h2></div></div></div><p>
            To support Entity Data Filtering in custom entity providers (e.g. as in <a class="xref" href="#ef.modules.custom" title="Example&nbsp;17.17.&nbsp;Entity Data Filtering support in MOXy JSON binding provider">Example&nbsp;17.17, &#8220;Entity Data Filtering support in MOXy JSON binding provider&#8221;</a>),
            it is sufficient in most of the cases to implement and register the following SPI contracts:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/spi/ObjectProvider.html" target="_top">ObjectProvider</a></p><p>
                        To be able to obtain an instance of a filtering object model your provider understands and can act on.
                        The implementations can extend <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/spi/AbstractObjectProvider.html" target="_top">AbstractObjectProvider</a>.
                    </p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/spi/ObjectGraphTransformer.html" target="_top">ObjectGraphTransformer</a></p><p>
                        To transform a read-only generic representation of a domain object model graph to be processed into
                        an entity-filtering object model your provider understands and can act on. The implementations can
                        extend <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/spi/AbstractObjectProvider.html" target="_top">AbstractObjectProvider</a>.
                    </p></li></ul></div><p>

            </p><div class="example"><a name="ef.modules.custom"></a><p class="title"><b>Example&nbsp;17.17.&nbsp;Entity Data Filtering support in MOXy JSON binding provider</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Singleton
public class FilteringMoxyJsonProvider extends ConfigurableMoxyJsonProvider {

    @Inject
    private Provider&lt;ObjectProvider&lt;ObjectGraph&gt;&gt; provider;

    @Override
    protected void preWriteTo(final Object object, final Class&lt;?&gt; type, final Type genericType, final Annotation[] annotations,
                              final MediaType mediaType, final MultivaluedMap&lt;String, Object&gt; httpHeaders,
                              final Marshaller marshaller) throws JAXBException {
        super.preWriteTo(object, type, genericType, annotations, mediaType, httpHeaders, marshaller);

        // Entity Filtering.
        if (marshaller.getProperty(MarshallerProperties.OBJECT_GRAPH) == null) {
            final Object objectGraph = provider.get().getFilteringObject(genericType, true, annotations);

            if (objectGraph != null) {
                marshaller.setProperty(MarshallerProperties.OBJECT_GRAPH, objectGraph);
            }
        }
    }

    @Override
    protected void preReadFrom(final Class&lt;Object&gt; type, final Type genericType, final Annotation[] annotations,
                               final MediaType mediaType, final MultivaluedMap&lt;String, String&gt; httpHeaders,
                               final Unmarshaller unmarshaller) throws JAXBException {
        super.preReadFrom(type, genericType, annotations, mediaType, httpHeaders, unmarshaller);

        // Entity Filtering.
        if (unmarshaller.getProperty(MarshallerProperties.OBJECT_GRAPH) == null) {
            final Object objectGraph = provider.get().getFilteringObject(genericType, false, annotations);

            if (objectGraph != null) {
                unmarshaller.setProperty(MarshallerProperties.OBJECT_GRAPH, objectGraph);
            }
        }
    }
}</pre></div></div><p><br class="example-break">
        </p></div><div class="section" title="17.7.&nbsp;Modules with support for Entity Data Filtering"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ef.modules"></a>17.7.&nbsp;Modules with support for Entity Data Filtering</h2></div></div></div><p>
            List of modules from Jersey workspace that support Entity Filtering:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        <a class="link" href="#json.moxy" title="8.1.2.&nbsp;MOXy">MOXy</a>
                    </p></li></ul></div><p>
        </p><p>
            In order to use Entity Filtering in mentioned modules you need to explicitly register either
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/EntityFilteringFeature.html" target="_top">EntityFilteringFeature</a> or <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/message/filtering/SecurityEntityFilteringFeature.html" target="_top">SecurityEntityFilteringFeature</a>
            to activate Entity Filtering for particular module.
        </p></div><div class="section" title="17.8.&nbsp;Examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10630"></a>17.8.&nbsp;Examples</h2></div></div></div><p>
            To see a complete working examples of entity-filtering feature refer to the:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/entity-filtering" target="_top">Entity Filtering example</a></p></li><li class="listitem"><p><a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/entity-filtering-security" target="_top">Entity Filtering example (with security annotations)</a></p></li></ul></div><p>
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;18.&nbsp;MVC Templates"><div class="titlepage"><div><div><h2 class="title"><a name="mvc"></a>Chapter&nbsp;18.&nbsp;MVC Templates</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e10651">18.1. Dependencies</a></span></dt><dt><span class="section"><a href="#d0e10730">18.2. Registration and Configuration</a></span></dt><dt><span class="section"><a href="#d0e10869">18.3. Explicit vs. Implicit View Templates</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e10889">18.3.1. <code class="literal">Viewable</code> - Explicit View Templates</a></span></dt><dt><span class="section"><a href="#d0e10973">18.3.2. <code class="literal">@Template</code> - Implicit View Templates</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e11088">18.4. JSP</a></span></dt><dt><span class="section"><a href="#mvc.spi">18.5. Custom Templating Engines</a></span></dt><dt><span class="section"><a href="#d0e11170">18.6. Other Examples</a></span></dt></dl></div><p>
        Jersey provides an extension to support the Model-View-Controller (MVC) design pattern.
        In the context of Jersey components, the Controller from the MVC pattern corresponds to a resource class or method,
        the View to a template bound to the resource class or method, and the Model to a Java object (or a Java bean) returned
        from a resource method.
    </p><div class="section" title="18.1.&nbsp;Dependencies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10651"></a>18.1.&nbsp;Dependencies</h2></div></div></div><p>
            Jersey MVC templating support is provided by Jersey as a set of (three) extension modules:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc/dependencies.html" target="_top">jersey-mvc</a></p><p>
                        The base module that provides API and extension SPI for MVC templating support in Jersey. This
                        module is required by any particular MVC templating engine integration module that implements the exposed
                        SPI.
                    </p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc-freemarker/dependencies.html" target="_top">jersey-mvc-freemarker</a></p><p>
                        An integration module with Freemarker-based templating engine. The module provides a custom
                        <code class="literal">TemplateProcessor</code> for Freemarker templates and a set of related engine-specific
                        configuration properties.
                    </p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc-jsp/dependencies.html" target="_top">jersey-mvc-jsp</a></p><p>
                        An integration module for JSP-based templating engine. The module provides a custom
                        <code class="literal">TemplateProcessor</code> for JSP templates, custom tag implementation and a set of
                        related engine-specific configuration properties.
                    </p></li></ul></div><p>
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                In a typical set-up projects using the Jersey MVC templating support would depend on the base module that
                provides the API and SPI and a single templating engine module for the templating engine of your choice.
                These modules need to be mentioned explicitly in your <code class="literal">pom.xml</code> file.
            </p></div><p>
            If you want to use just templating API infrastructure provided by Jersey for the MVC templating support in order to
            implement your custom support for a templating engine other than the ones provided by Jersey (JSP/Freemarker),
            you will need to add the base <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc/dependencies.html" target="_top">jersey-mvc</a> module into the list of your dependencies:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-mvc&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
        </p><p>
            To use one of the templating engines for which Jersey provides the integration implementation (JSP/Freemarker)
            in your project, you need to add the <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc-jsp/dependencies.html" target="_top">jersey-mvc-jsp</a> or <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc-freemarker/dependencies.html" target="_top">jersey-mvc-freemarker</a> module to your <code class="literal">pom.xml</code>
            respectively:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-mvc-jsp&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-mvc-freemarker&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

            Both of these modules transitively depend on the base <code class="literal">jersey-mvc</code>, so it is not necessary to add
            the base <code class="literal">jersey-mvc</code> module explicitly into your dependency list, however it is a recommended
            Maven practice to do so.
        </p><p>
            If you are not using Maven you need to make sure to have all required transitive dependencies
            (see <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc/dependencies.html" target="_top">jersey-mvc</a>/<a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc-freemarker/dependencies.html" target="_top">jersey-mvc-freemarker</a>/<a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc-jsp/dependencies.html" target="_top">jersey-mvc-jsp</a>) on the classpath.
        </p></div><div class="section" title="18.2.&nbsp;Registration and Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10730"></a>18.2.&nbsp;Registration and Configuration</h2></div></div></div><p>
            To use capabilities of Jersey MVC templating support in your JAX-RS/Jersey application you need to register
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Feature.html" target="_top">Feature</a>s provided by the modules mentioned above. For <code class="literal">jersey-mvc</code> it is
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/MvcFeature.html" target="_top">MvcFeature</a>, for <code class="literal">jersey-mvc-jsp</code> it's <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/JspMvcFeature.html" target="_top">JspMvcFeature</a> and
            for <code class="literal">jersey-mvc-freemarker</code> it is <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/FreemarkerMvcFeature.html" target="_top">FreemarkerMvcFeature</a>.

            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Both <code class="literal">JspMvcFeature</code> and <code class="literal">FreemarkerMvcFeature</code> also register
                    <code class="literal">MvcFeature</code> so you don't need to register it explicitly when using these
                    JSP/Freemarker modules.
                </p></div><p>

            </p><div class="example"><a name="d0e10769"></a><p class="title"><b>Example&nbsp;18.1.&nbsp;Registering <code class="literal">MvcFeature</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    .register(org.glassfish.jersey.server.mvc.MvcFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e10777"></a><p class="title"><b>Example&nbsp;18.2.&nbsp;Registering <code class="literal">JspMvcFeature</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    .register(org.glassfish.jersey.server.mvc.jsp.JspMvcFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            </p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    Jersey web applications that want to use MVC templating support feature should be registered as Servlet
                    filters rather than Servlets in the application's <code class="literal">web.xml</code>. The
                    <code class="literal">web.xml</code>-less deployment style introduced in Servlet 3.0 is not supported at the moment
                    for web applications that require use of Jersey MVC templating support.
                </p></div><p>
        </p><p>
            Each of the three MVC modules contains a <code class="literal">*Properties</code>
            (e.g. <code class="literal">FreemarkerMvcProperties</code>) file which defines a set of properties that could be
            set in a JAX-RS <code class="literal">Application</code> / <code class="literal">ResourceConfig</code> in order to take effect,
            see the <a class="xref" href="#mvc.ex.rc.properties" title="Example&nbsp;18.3.&nbsp;Setting MvcProperties.TEMPLATE_BASE_PATH value in ResourceConfig">Example&nbsp;18.3, &#8220;Setting <code class="literal">MvcProperties.TEMPLATE_BASE_PATH</code> value in <code class="literal">ResourceConfig</code>&#8221;</a> and <a class="xref" href="#mvc.ex.web.xml.properties" title="Example&nbsp;18.4.&nbsp;Setting FreemarkerMvcProperties.TEMPLATE_BASE_PATH value in web.xml">Example&nbsp;18.4, &#8220;Setting <code class="literal">FreemarkerMvcProperties.TEMPLATE_BASE_PATH</code> value in <code class="literal">web.xml</code>&#8221;</a>.
        </p><p>
            Following list contains description of the available properties:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">MvcProperties.TEMPLATE_BASE_PATH</code> - "<code class="literal">jersey.config.server.mvc.templateBasepath</code>"</p><p>The base path where templates are located.</p></li><li class="listitem"><p><code class="literal">FreemarkerMvcProperties.TEMPLATE_BASE_PATH</code> - "<code class="literal">jersey.config.server.mvc.templateBasepath.freemarker</code>"</p><p>The base path where Freemarker templates are located.</p></li><li class="listitem"><p><code class="literal">JspMvcProperties.TEMPLATE_BASE_PATH</code> - "<code class="literal">jersey.config.server.mvc.templateBasepath.jsp</code>"</p><p>The base path where JSP templates are located.</p></li></ul></div><p>

            </p><div class="example"><a name="mvc.ex.rc.properties"></a><p class="title"><b>Example&nbsp;18.3.&nbsp;Setting <code class="literal">MvcProperties.TEMPLATE_BASE_PATH</code> value in <code class="literal">ResourceConfig</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    .property(MvcProperties.TEMPLATE_BASE_PATH, "templates")
    .register(MvcFeature.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="mvc.ex.web.xml.properties"></a><p class="title"><b>Example&nbsp;18.4.&nbsp;Setting <code class="literal">FreemarkerMvcProperties.TEMPLATE_BASE_PATH</code> value in <code class="literal">web.xml</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;servlet&gt;
    &lt;servlet-name&gt;org.glassfish.jersey.examples.freemarker.MyApplication&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.glassfish.jersey.servlet.ServletContainer&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
        &lt;param-value&gt;org.glassfish.jersey.examples.freemarker.MyApplication&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;jersey.config.server.mvc.templateBasePath.freemarker&lt;/param-name&gt;
        &lt;param-value&gt;freemarker&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;</pre></div></div><p><br class="example-break">
        </p></div><div class="section" title="18.3.&nbsp;Explicit vs. Implicit View Templates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e10869"></a>18.3.&nbsp;Explicit vs. Implicit View Templates</h2></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Some of the passages/examples from this and the next section was taken from
                <a class="link" href="https://blogs.oracle.com/sandoz/entry/mvcj" target="_top">MVCJ</a> blog article written by Paul Sandoz
                earlier.
            </p></div><p>
            In Jersey 2.0, the base MVC API (excluding the SPI part) consists of two classes (in the
            <code class="literal">org.glassfish.jersey.server.mvc</code> package  in base MVC module) that we will explore in more detail
            now, namely <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/Viewable.html" target="_top">Viewable</a> and <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/Template.html" target="_top">@Template</a>.
            These classes determines which approach (explicit/implicit) you would be taking when working with Jersey MVC
            templating support.
        </p><div class="section" title="18.3.1.&nbsp;Viewable - Explicit View Templates"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10889"></a>18.3.1.&nbsp;<code class="literal">Viewable</code> - Explicit View Templates</h3></div></div></div><p>
                In this approach a resource method explicitly returns a reference to a view template and the data model to be
                used. For this purpose the <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/Viewable.html" target="_top">Viewable</a> class has been introduced in Jersey 1 and is also
                present (under a different package) in Jersey 2. A simple example of usage can be seen in
                <a class="xref" href="#mvc.example.viewable.simple" title="Example&nbsp;18.5.&nbsp;Using Viewable in a resource class">Example&nbsp;18.5, &#8220;Using <code class="literal">Viewable</code> in a resource class&#8221;</a>.

                </p><div class="example"><a name="mvc.example.viewable.simple"></a><p class="title"><b>Example&nbsp;18.5.&nbsp;Using <code class="literal">Viewable</code> in a resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">package com.foo;

@Path("foo")
public class Foo {

    @GET
    public Viewable get() {
        return new Viewable("index", "FOO");
    }
}</pre></div></div><p><br class="example-break">
            </p><p>
                In this example, the <code class="literal">Foo</code> JAX-RS resource class is the controller and the
                <code class="literal">Viewable</code> instance encapsulates the provided data model (<code class="literal">"FOO"</code> string)
                and a named reference to the associated view template (<code class="literal">"index"</code>).
            </p><p>
                The template name reference <code class="literal">"index"</code> is a relative value that Jersey will resolve to its
                absolute template reference using the fully qualified class name of <code class="literal">Foo</code> (more on resolving
                relative template name to the absolute one can be found in the JavaDoc of <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/Viewable.html" target="_top">Viewable</a> class),
                which, in our case, is:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">"/com/foo/Foo/index"</pre><p>
            </p><p>
                Jersey will then search all the registered template processors (see <a class="xref" href="#mvc.spi" title="18.5.&nbsp;Custom Templating Engines">Section&nbsp;18.5, &#8220;Custom Templating Engines&#8221;</a>) to find a template
                processor that can resolve the absolute template reference further to a "processable" template reference. If
                a template processor is found then the "processable" template is processed using the supplied data model.
            </p><p>
                Let's change the resource <code class="literal">GET</code> method in our <code class="literal">Foo</code> resource a little:

                </p><div class="example"><a name="mvc.example.viewable.absolutePath"></a><p class="title"><b>Example&nbsp;18.6.&nbsp;Using absolute path to template in <code class="literal">Viewable</code></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public Viewable get() {
    return new Viewable("/index", "FOO");
}
</pre></div></div><p><br class="example-break">

                In this case, since the template reference begins with <code class="literal">"/"</code>, Jersey will consider the reference
                to be absolute already and will not attempt to absolutize it again. The reference will be used "as is" when
                resolving it to a "processable" template reference as described earlier.
            </p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                    All HTTP methods may return <code class="literal">Viewable</code> instances. Thus a <code class="literal">POST</code> method may
                    return a template reference to a template that produces a view that is the result of processing an
                    HTML <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Form.html" target="_top">Form</a>.
                </p></div></div><div class="section" title="18.3.2.&nbsp;@Template - Implicit View Templates"><div class="titlepage"><div><div><h3 class="title"><a name="d0e10973"></a>18.3.2.&nbsp;<code class="literal">@Template</code> - Implicit View Templates</h3></div></div></div><div class="section" title="18.3.2.1.&nbsp;Resource classes"><div class="titlepage"><div><div><h4 class="title"><a name="d0e10978"></a>18.3.2.1.&nbsp;Resource classes</h4></div></div></div><p>
                    A resource class can have templates implicitly associated with it via <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/Template.html" target="_top">@Template</a> annotation.
                    For example, take a look at the resource class listing in <a class="xref" href="#mvc.example.implicit.class" title="Example&nbsp;18.7.&nbsp;Using @Template on a resource class">Example&nbsp;18.7, &#8220;Using <code class="literal">@Template</code> on a resource class&#8221;</a>.

                    </p><div class="example"><a name="mvc.example.implicit.class"></a><p class="title"><b>Example&nbsp;18.7.&nbsp;Using <code class="literal">@Template</code> on a resource class</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("foo")
@Template
public class Foo {

    public String getFoo() {
        return "FOO";
    }
}</pre></div></div><p><br class="example-break">
                </p><p>
                    The example above uses a lot of conventions and requires some more explanation. First of all, you may have
                    noticed that there is no resource method defined in this JAX-RS resource. Also, there is no template
                    reference defined.
                    In this case, since the <code class="literal">@Template</code> annotation placed on the resource class does not
                    contain any information, the default relative template reference <code class="literal">"index"</code> will be used. Later
                    it will get resolved to an absolute <code class="literal">"/com/foo/Foo/index"</code> template reference.
                    As for the missing resource methods, a default <code class="literal">@GET</code> method will be implicitly generated by Jersey
                    for the  <code class="literal">Foo</code> resource (our MVC Controller). The implementation of the implicitly added
                    resource method performs the equivalent of the following explicit resource method:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
public Viewable get() {
    return new Viewable("index", this);
}</pre><p>

                    As you can see, the resource class serves in this case also as a model. Producible media types are determined
                    based on the <code class="literal">@Produces</code> annotation declared on the resource class, if any.

                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                            In case of a resource class-based implicit MVC view template, the controller is also the model. In this
                            case the template reference <code class="literal">"index"</code> is special, it is the template reference
                            associated with the controller itself.
                        </p></div><p>
                </p><p>
                    Implicit sub-resource templates are also supported, for example, for a template reference
                    <code class="literal">"bar"</code> that resolves to an absolute template reference <code class="literal">"/com/foo/Foo/bar"</code>
                    that in turn resolves to a processable template reference. Following <code class="literal">@GET</code> method is also implicitly
                    added to the <code class="literal">Foo</code> controller that performs the equivalent of the following explicit
                    sub-resource method:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@GET
                        @Path("{implicit-view-path-parameter}")
                        public Viewable get(@PathParameter("{implicit-view-path-parameter}") String template) {
                        return new Viewable(template, this);
                        }</pre><p>

                    In other words, a HTTP <code class="literal">GET</code> request to a <code class="literal">"/foo/bar"</code> would be handled by this
                    auto-generated method in the <code class="literal">Foo</code> resource and would delegate the request to a registered
                    template processor supports processing of the absolute template reference
                    <code class="literal">"/com/foo/Foo/bar"</code>, while the model is still an instance of the JAX-RS resource class
                    <code class="literal">Foo</code>.
                </p></div><div class="section" title="18.3.2.2.&nbsp;Resource methods"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11059"></a>18.3.2.2.&nbsp;Resource methods</h4></div></div></div><p>
                    In case a resource method is annotated with <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/Template.html" target="_top">@Template</a> annotation then the return
                    value of the method defines the MVC model part. The processing of such a method is then essentially the same
                    as if the return type of the method was an instance of the <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/Viewable.html" target="_top">Viewable</a> class.
                    If a method is annotated with <code class="literal">@Template</code> and is also returning a
                    <code class="literal">Viewable</code> instance then the values (<code class="literal">resolvingClass</code>) from the
                    <code class="literal">Viewable</code> instance take precedence over those defined in the annotation. Producible
                    media types are determined from the method's <code class="literal">@Produces</code> annotation.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                        Implicit view templates support works dynamically (as is the case for explicit MVC) so it is possible
                        (if the deployment system is configured correctly) to add or modify templates while the application
                        is running.
                    </p></div></div></div></div><div class="section" title="18.4.&nbsp;JSP"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11088"></a>18.4.&nbsp;JSP</h2></div></div></div><p>
            As stated earlier, Jersey provides support for JSP templates in <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-mvc-jsp/dependencies.html" target="_top">jersey-mvc-jsp</a> extension module.
            There is a JSP template processor that resolves absolute template references to processable template references
            represented as JSP pages as follows:
        </p><div class="procedure" title="Procedure&nbsp;18.1.&nbsp;Resolving JSP processable template reference"><a name="d0e11096"></a><p class="title"><b>Procedure&nbsp;18.1.&nbsp;Resolving JSP processable template reference</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>
                    if the absolute template reference does not end in <code class="literal">".jsp"</code> append this suffix to the
                    reference; and
                </p></li><li class="step" title="Step 2"><p>
                    if <code class="literal">Servlet.getResource</code> returns a non-<code class="literal">null</code> value for the appended reference then
                    return the appended reference as the processable template reference otherwise return <code class="literal">null</code>
                    (to indicate the absolute reference has not been resolved by the JSP template processor).
                </p></li></ol></div><p>
            Thus the absolute template reference <code class="literal">"/com/foo/Foo/index"</code> would be resolved to
            <code class="literal">"/com/foo/Foo/index.jsp"</code>, provided there exists a <code class="literal">"/com/foo/Foo/index.jsp"</code>
            JSP page in the web application.
        </p><p>
            Jersey will assign the model instance to the attribute named "<code class="literal">it</code>". So in the case of the implicit
            example it is possible to referece the <code class="literal">foo</code> property on the <code class="literal">Foo</code> resource
            from the JSP template as follows:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;h1&gt;${it.foo}&lt;/h1&gt;</pre><p>
        </p></div><div class="section" title="18.5.&nbsp;Custom Templating Engines"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc.spi"></a>18.5.&nbsp;Custom Templating Engines</h2></div></div></div><p>
            To add support for other (custom) templating engines into Jersey MVC Templating facility, you need to implement the
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/TemplateProcessor.html" target="_top">TemplateProcessor</a> and register this class into your application.

            </p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                    When writing template processors it is recommend that you use an appropriate unique suffix for the
                    processable template references. In such case it is then possible to easily support mixing of multiple
                    templating engines in a single application without any conflicts.
                </p></div><p>

            </p><div class="example"><a name="d0e11154"></a><p class="title"><b>Example&nbsp;18.8.&nbsp;Custom <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/TemplateProcessor.html" target="_top">TemplateProcessor</a></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Provider
class MyTemplateProcessor implements TemplateProcessor&lt;String&gt; {

    @Override
    public String resolve(String path, final MediaType mediaType) {
        final String extension = ".testp";

        if (!path.endsWith(extension)) {
            path = path + extension;
        }

        final URL u = this.getClass().getResource(path);
        return u == null ? null : path;
    }

    @Override
    public void writeTo(String templateReference,
                        Viewable viewable,
                        MediaType mediaType,
                        OutputStream out) throws IOException {
        final PrintStream ps = new PrintStream(out);
        ps.print("path=");
        ps.print(templateReference);
        ps.println();
        ps.print("model=");
        ps.print(viewable.getModel().toString());
        ps.println();
    }

}</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e11162"></a><p class="title"><b>Example&nbsp;18.9.&nbsp;Registering custom <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/mvc/TemplateProcessor.html" target="_top">TemplateProcessor</a></b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">new ResourceConfig()
    .register(MyTemplateProcessor.class)
    // Further configuration of ResourceConfig.
    .register( ... );</pre></div></div><p><br class="example-break">
        </p></div><div class="section" title="18.6.&nbsp;Other Examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11170"></a>18.6.&nbsp;Other Examples</h2></div></div></div><p>To see an example of MVC (JSP) templating support in Jersey refer to the <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/bookstore-webapp" target="_top">MVC (Bookstore) example</a>.</p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;19.&nbsp;Monitoring and diagnostics"><div class="titlepage"><div><div><h2 class="title"><a name="monitoring"></a>Chapter&nbsp;19.&nbsp;Monitoring and diagnostics</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e11182">19.1. Introduction</a></span></dt><dt><span class="section"><a href="#d0e11233">19.2. Event Listeners</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e11415">19.2.1. Guidelines for implementing Jersey event listeners</a></span></dt><dt><span class="section"><a href="#d0e11461">19.2.2. Monitoring Statistics</a></span></dt><dt><span class="section"><a href="#d0e11652">19.2.3. Monitoring Statistics as MBeans</a></span></dt></dl></dd></dl></div><div class="section" title="19.1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11182"></a>19.1.&nbsp;Introduction</h2></div></div></div><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                Jersey monitoring support has been released as a <span class="emphasis"><em>beta release</em></span> in Jersey 2.1 version.
                As such, the exposed monitoring public APIs and functionality described in this section may change in the
                future Jersey releases.
            </p></div><p>
            Jersey provides functionality for monitoring JAX-RS/Jersey applications. Application monitoring is useful in cases
            when you need to identify the performance hot-spots in your JAX-RS application, observe
            execution statistics of particular resources or listen to application
            or request lifecycle events. Note that this functionality is Jersey-specific extension to JAX-RS API.
        </p><p>
            Jersey monitoring support is divided into three functional areas:

            </p><div class="variablelist"><dl><dt><span class="term">Event Listeners</span></dt><dd><p>
                            Event listeners allow users to receive and process a predefined set of events that occur during
                            a application lifecycle (such as application initialization, application destroy) as well as
                            request processing lifecycle events (request started, resource method finished, exception thrown,
                            etc.). This feature is always enabled in Jersey server runtime and is leveraged by the other
                            monitoring features.
                        </p></dd><dt><span class="term">Monitoring Statistics</span></dt><dd><p>
                            Jersey can be configured to process lifecycle events in order to expose a wide range of
                            runtime monitoring statistics to the end user. The statistics are accessible trough an injectable
                            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a> interface. The statistics provide general information
                            about the application as well as fine-grained execution statistics on particular resources and sub
                            resources and exposed URIs. For performance reasons, this functionality must be explicitly enabled
                            prior using.
                        </p></dd><dt><span class="term">JMX MBeans with statistics</span></dt><dd><p>
                            In addition to the injectable <code class="literal">MonitoringStatistics</code> data, Jersey
                            is able to expose the statistics as JMX MBeans (for example
                            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ApplicationMXBean.html" target="_top">ApplicationMXBean</a>).
                            Jersey monitoring MXBeans can be accessed programmatically using JMX APIs or browsed via JMX-enabled
                            tool (<code class="literal">JConsole</code> for example). This functionality is, too,  by default disabled for
                            performance reasons and must be enabled if needed.
                        </p></dd></dl></div><p>

            All monitoring related APIs (beta!) can be found in the <code class="literal">jersey-server</code> module in
            <code class="literal">org.glassfish.jersey.server.monitoring</code> package. Monitoring in Jersey is currently supported on
            the server side.
        </p></div><div class="section" title="19.2.&nbsp;Event Listeners"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11233"></a>19.2.&nbsp;Event Listeners</h2></div></div></div><p>
            Jersey defines two types of event listeners that you can implement and register with your application:

            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ApplicationEventListener.html" target="_top">ApplicationEventListener</a> for listening to application events, and</p></li><li class="listitem"><p><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/RequestEventListener.html" target="_top">RequestEventListener</a> for listening to events of request processing.</p></li></ul></div><p>

            Only the first type, <code class="literal">ApplicationEventListener</code>
            can be directly registered as an application-wide provider. The <code class="literal">RequestEventListener</code>
            is designed to be specific to every request and can be only returned from the
            <code class="literal">ApplicationEventListener</code> as such.
        </p><p>
            Let's start with an example. The following examples show simple implementations of Jersey event listeners as well
            as a test JAX-RS resource that will be monitored.

            </p><div class="example"><a name="d0e11261"></a><p class="title"><b>Example&nbsp;19.1.&nbsp;Application event listener</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyApplicationEventListener
            implements ApplicationEventListener {
    private volatile int requestCnt = 0;

    @Override
    public void onEvent(ApplicationEvent event) {
        switch (event.getType()) {
            case INITIALIZATION_FINISHED:
                System.out.println("Application "
                        + event.getResourceConfig().getApplicationName()
                        + " was initialized.");
                break;
            case DESTROY_FINISHED:
                System.out.println("Application "
                    + event.getResourceConfig().getApplicationName() destroyed.");
                break;
        }
    }

    @Override
    public RequestEventListener onRequest(RequestEvent requestEvent) {
        requestCnt++;
        System.out.println("Request " + requestCnt + " started.");
        // return the listener instance that will handle this request.
        return new MyRequestEventListener(requestCnt);
    }
}</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e11267"></a><p class="title"><b>Example&nbsp;19.2.&nbsp;Request event listener</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class MyRequestEventListener implements RequestEventListener {
    private final int requestNumber;
    private final long startTime;

    public MyRequestEventListener(int requestNumber) {
        this.requestNumber = requestNumber;
        startTime = System.currentTimeMillis();
    }

    @Override
    public void onEvent(RequestEvent event) {
        switch (event.getType()) {
            case RESOURCE_METHOD_START:
                System.out.println("Resource method "
                    + event.getUriInfo().getMatchedResourceMethod()
                        .getHttpMethod()
                    + " started for request " + requestNumber);
                break;
            case FINISHED:
                System.out.println("Request " + requestNumber
                    + " finished. Processing time "
                    + (System.currentTimeMillis() - startTime) + " ms.");
                break;
        }
    }
}</pre></div></div><p><br class="example-break">

            </p><div class="example"><a name="d0e11273"></a><p class="title"><b>Example&nbsp;19.3.&nbsp;Event listener test resource</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public class TestResource {
    @GET
    public String getSomething() {
        return "get";
    }

    @POST
    public String postSomething(String entity) {
        return "post";
    }
}</pre></div></div><p><br class="example-break">
        </p><p>
            Once the listeners and the monitored resource is defined, it's time to initialize our application. The following
            piece of code shows a <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> that is used to initialize the application (please
            note that only <code class="literal">ApplicationEventListener</code> is registered as provider).

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">ResourceConfig resourceConfig =
            new ResourceConfig(TestResource.class, MyApplicationEventListener.class)
            .setApplicationName("my-monitored-application");</pre><p>

            Our example application now contains a simple resource <code class="literal">TestResource</code> that defines resource methods
            for <code class="literal">GET</code> and <code class="literal">POST</code> and a custom <code class="literal">MyApplicationEventListener</code> event listener.
        </p><p>
            The registered <code class="literal">MyApplicationEventListener</code> implements two methods defined by the
            <code class="literal">ApplicationEventListener</code> interface. A method <code class="literal">onEvent()</code> handles
            all application lifecycle events. In our case the method handles only 2 application events - initialization
            and destroy. Other event types are ignored. All application event types are defined
            in <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ApplicationEvent.html" target="_top">ApplicationEvent</a><code class="literal">.Type</code>. The second method <code class="literal">onRequest</code>
            is invoked by Jersey runtime every time a new request is received. The request event type passed to the method
            is always <code class="literal">START</code>. If you want to listen to any other request lifecycle events for the new request,
            you are expected to return an instance of <code class="literal">RequestEventListener</code> that will handle the
            request. It is important to understand, that the instance will handle only the request for which it has been returned
            from an <code class="literal">ApplicationEventListener.onRequest</code> method and not any other requests. In our case the
            returned request event listener keeps information about the request number of the current request and a start time of
            the request which is later used to print out the request processing times statistics. This demonstrates the principle
            of listening to request events: for one request there is a one instance which can be used to hold all the information
            about the particular request. In other words, <code class="literal">RequestEventListener</code> is designed to be
            implicitly request-scoped.
        </p><p>
            Jersey represents lifecycle events via <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/RequestEvent.html" target="_top">RequestEvent</a> and
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ApplicationEvent.html" target="_top">ApplicationEvent</a> types. Instances of these classes contain information
            about respective events. The most important information is the event type <code class="literal">Type</code> retrievable via
            <code class="literal">getType()</code> method,
            which identifies the type of the event. Events contain also additional information that is dependent on a particular
            event type. This information can be retrieved via event getters. Again, some getters return valid information for all
            event types, some are specific to a sub-set of event types. For example, in the
            <code class="literal">RequestEvent</code>, the <code class="literal">getExceptionCause()</code> method returns valid
            information only when event type is <code class="literal">ON_EXCEPTION</code>. On the other hand,
            a <code class="literal">getContainerRequest()</code> can be used to return current request context for any request event type.
            See javadoc of events and event types to get familiar with event types and information valid for each event type.
        </p><p>
            Our <code class="literal">MyRequestEventListener</code> implementation is focused on processing 2 request events. First,
            it listens for an event that is triggered before a resource method is executed. Also, it hooks to a "request finished"
            event. As mentioned earlier, the request event <code class="literal">START</code> is handled only in the
            <code class="literal">MyApplicationEventListener</code>. The <code class="literal">START</code> event type will never be invoked on
            <code class="literal">RequestEventListener</code>. Therefore the logic for measuring the <code class="literal">startTime</code> is in the
            constructor which is invoked from <code class="literal">MyApplicationEventListener.onRequest()</code>. An attempt to handling
            the request <code class="literal">START</code> event in a <code class="literal">RequestEventListener.onEvent()</code> method would be a
            mistake.
        </p><p>
            Let's deploy the application and use a simple test client code to produce some activity in order to spawn new events:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">target.path("resource").request()
        .post(Entity.entity("post", MediaType.TEXT_PLAIN_TYPE));
    target.path("resource").request().get();</pre><p>

            In the code above, the <code class="literal">target</code> is a <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/WebTarget.html" target="_top">WebTarget</a> instance pointing to the application
            context root path. Using the <a class="xref" href="#client" title="Chapter&nbsp;5.&nbsp;Client API">Chapter&nbsp;5, <i>Client API</i></a>, we invoke <code class="literal">GET</code> and <code class="literal">POST</code> methods
            on the <code class="literal">MyResource</code> JAX-RS resource class that we implemented earlier.
        </p><p>
            When we start the application, run the test client and then stop the application, the console output for the
            deployed server-side application would contain the following output:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: text;&#xA;    gutter: false;">Application my-monitored-application was initialized.
Request 1 started.
Resource method POST started for request 1
Request 1 finished. Processing time 330 ms.
Request 2 started.
Resource method GET started for request 2
Request 2 finished. Processing time 4 ms.
Application my-monitored-application destroyed.</pre><p>
        </p><div class="section" title="19.2.1.&nbsp;Guidelines for implementing Jersey event listeners"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11415"></a>19.2.1.&nbsp;Guidelines for implementing Jersey event listeners</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    Implement event listeners as thread safe. While individual events will be arriving serially,
                    individual listener invocations may occur from different threads. Thus make sure that your listeners
                    are processing data safely with respect to their <a class="link" href="http://en.wikipedia.org/wiki/Java_Memory_Model" target="_top">Java Memory Model</a> visibility (in the example above
                    the fields <code class="literal">requestNumber</code>, <code class="literal">startTime</code> of
                    <code class="literal">MyRequestEventListener</code> are final and therefore the same value is
                    visible for all threads executing the <code class="literal">onEvent()</code> method).
                </p></li><li class="listitem"><p>
                    Do not block the thread executing the event listeners by performing long-running tasks. Execution of event
                    listeners is a part of the standard application and request processing and as such needs to finish as quickly
                    as possible to avoid negative impact on overall application performance.
                </p></li><li class="listitem"><p>
                    Do not try to modify mutable objects returned from <code class="literal">ApplicationEvent</code> and
                    <code class="literal">RequestEvent</code> getters to avoid experiencing undefined behavior.
                    Events listeners should use the information for read only purposes only. Use different techniques like
                    filters, interceptors or other providers to modify the processing of requests and applications. Even though
                    modification might be possible and might work as desired now, your code is in risk of producing intermittent
                    failures or unexpected behaviour (for example after migrating to new Jersey version).
                </p></li><li class="listitem"><p>
                    If you do not want to listen to request events, do not return an empty listener in the
                    <code class="literal">onRequest()</code> method. Return <code class="literal">null</code> instead. Returning empty listener
                    might have a negative performance impact. Do not rely on JIT optimizing out the empty listener invocation
                    code.
                </p></li><li class="listitem"><p>
                    If you miss any event type or any detail in the events, let us know via Jersey user mailing list.
                </p></li></ul></div></div><div class="section" title="19.2.2.&nbsp;Monitoring Statistics"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11461"></a>19.2.2.&nbsp;Monitoring Statistics</h3></div></div></div><p>
                Event listeners described in the previous section are all-purpose facility. For example, you may decide to
                use them to measure various execution statistics of your application. While this might be an easy task for simple
                statistics like "how much time was spent on execution of each Java method?", nevertheless, if you want to measure
                statistics based on URIs and individual resources, the implementation might get rather complex soon, especially
                when considering sub-resources and sub-resource locators. To save you the trouble, Jersey provides feature for
                collecting events and calculating a pre-defined set of monitoring and execution statistics, including
                application configuration, exception mappers execution, minimum/maximum/average execution times for individual
                resource methods as well as entire request processing etc.
            </p><p>
                Calculating the monitoring statistics has obviously a performance impact, therefore this feature is
                disabled by default. To enable the feature, set the following configuration property to <code class="literal">true</code>:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">jersey.config.server.monitoring.statistics.enabled=true</pre><p>
                The property description can be found in <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_ENABLED" target="_top">ServerProperties.MONITORING_STATISTICS_ENABLED</a>
                This will calculate the statistics. The easiest way how to get statistics is to let Jersey
                to inject them. See the following example:
            </p><div class="example"><a name="d0e11478"></a><p class="title"><b>Example&nbsp;19.4.&nbsp;Injecting MonitoringStatistics</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">@Path("resource")
public static class StatisticsResource {
    @Inject
    Provider&lt;MonitoringStatistics&gt; monitoringStatisticsProvider;

    @GET
    public String getSomething() {
        final MonitoringStatistics snapshot
            = monitoringStatisticsProvider.get().snapshot();

        final TimeWindowStatistics timeWindowStatistics
            = snapshot.getRequestStatistics()
              .getTimeWindowStatistics().get(0l);

        return "request count: " + timeWindowStatistics.getRequestCount()
            + ", average request processing [ms]: "
            + timeWindowStatistics.getAverageDuration();
    }
}}</pre></div></div><br class="example-break"><p>
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a> are
                injected into the resource using an <a class="link" href="http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html" target="_top">@Inject</a> annotation.
                Please note the usage of the <a class="link" href="http://docs.oracle.com/javaee/6/api/javax/inject/Provider.html" target="_top">Provider</a> for injection (it will be discussed later).
                Firstly, the snapshot of statistics is retrieved by the <code class="literal">snapshot()</code> method.
                The snapshot of statistics is an immutable copy of statistics which does not change over the time.
                Additionally, data in a snapshot are consistent. It's recommended to create snapshots before working with
                the statistics data and then process the snapshot data.
                Working with original non-snapshot data makes sense when data consistency is not important and
                performance is of highest concern. While it is currently not the case, the injected non-snapshot data may
                be implemented as mutable for performance reasons in a future release of Jersey.
            </p><p>
                The injected monitoring statistics represent the root of the collected statistics hierarchy. The hierarchy
                can be traversed to retrieve any partial statistics data. In the example, we retrieve certain request
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/TimeWindowStatistics.html" target="_top">TimeWindowStatistics</a> data. In our case, those are the request execution statistics
                for a time window defined by long value 0 which means unlimited time window. This means we are retrieving
                the global request execution statistics measured since a start of the application.
                Finally, request count and average duration from the statistics are used to produce the String response.
                When we invoke few <code class="literal">GET</code> requests on the <code class="literal">StatisticsResource</code>, we get the
                following console output:
                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: text;&#xA;    gutter: false;">request count: 1, average request processing [ms]: 260
request count: 2, average request processing [ms]: 135
request count: 3, average request processing [ms]: 93
request count: 4, average request processing [ms]: 73</pre><p>
            </p><p>
                Let's look closer at <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a> interface.
                <code class="literal">MonitoringStatistics</code> interface defines getters by which other nested
                statistics can be retrieved. All statistics are in the same package and ends with
                <code class="literal">Statistics</code> postfix. Statistics interfaces are the following:
                </p><div class="variablelist"><dl><dt><span class="term"><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a></span></dt><dd><p>main top level statistics</p></dd><dt><span class="term"><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ApplicationStatistics.html" target="_top">ApplicationStatistics</a></span></dt><dd><p>mostly configuration of the application</p></dd><dt><span class="term"><code class="literal">ResponseStatistics</code></span></dt><dd><p>response statistics (eg. response status codes and their count)</p></dd><dt><span class="term"><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ResourceStatistics.html" target="_top">ResourceStatistics</a></span></dt><dd><p>statistics of execution of resources (resource classes or resource URIs)</p></dd><dt><span class="term"><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ResourceMethodStatistics.html" target="_top">ResourceMethodStatistics</a></span></dt><dd><p>statistics of execution of resource methods</p></dd><dt><span class="term"><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ExecutionStatistics.html" target="_top">ExecutionStatistics</a></span></dt><dd><p>statistic of execution of a target (resource, request, resource method)</p></dd><dt><span class="term"><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/TimeWindowStatistics.html" target="_top">TimeWindowStatistics</a></span></dt><dd><p>statistics of execution time in specific interval (eg. executions in last 5 minutes)</p></dd></dl></div><p>
            </p><p>
                Each time-monitored target contains <code class="literal">ExecutionStatistics</code>. So, for example
                resource method contains execution statistics of its execution. Each
                <code class="literal">ExecutionStatistics</code> contains multiple
                <code class="literal">TimeWindowStatistics</code>. Currently, each
                <code class="literal">ExecutionStatistics</code> contains
                <code class="literal">TimeWindowStatistics</code> for these time windows:

                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>0: unlimited=&gt; all execution since start of the application</p></li><li class="listitem"><p>1000: 1s =&gt; stats measured in last 1 second</p></li><li class="listitem"><p>15000: 15s =&gt; stats measured in last 15 seconds</p></li><li class="listitem"><p>60000: 1min =&gt; stats measured in last 1 minute</p></li><li class="listitem"><p>900000: 15min =&gt; stats measured in last 15 minutes</p></li><li class="listitem"><p>3600000: 1hour =&gt; stats measured in last hour minutes</p></li></ul></div><p>

                All the time window statistics can be retrieved from a <code class="literal">Map&lt;Long, TimeWindowStatistics&gt;</code>
                map returned from <code class="literal">ExecutionStatistics.getTimeWindowStatistics()</code>. Key of the map
                is the number of milliseconds of interval (so, for example key 60000 points
                to statistics for last one minute).
            </p><p>
                Note, that <code class="literal">snapshot()</code> method was called in the example only on the top level
                <code class="literal">MonitoringStatistics</code>. This produced a snapshot of the entire
                tree of statistics and therefore we do not need to call <code class="literal">snapshot()</code>
                on <code class="literal">TimeWindowStatistics</code> again.
            </p><p>
                Statistics are injected using the <a class="link" href="http://docs.oracle.com/javaee/6/api/javax/inject/Provider.html" target="_top">Provider</a>. This is preferred way of
                injecting statistics. The reason is simple. Statistics might change over time and contract
                of <code class="literal">MonitoringStatistics</code> does not make any assumptions about mutability of
                monitoring statistics instances (to allow future optimizations and changes in implementation strategy). In
                order to get always latest statistics, we recommend injecting a <a class="link" href="http://docs.oracle.com/javaee/6/api/javax/inject/Provider.html" target="_top">Provider</a> rather than a
                direct reference and use it's <code class="literal">get()</code> method to retrieve the latest statistics. For example,
                in singleton resources the use of the technique is very important otherwise statistics might correspond
                to the time when singleton was firstly created and might not update since that time.
            </p><div class="section" title="19.2.2.1.&nbsp;Listening to statistics changes"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11644"></a>19.2.2.1.&nbsp;Listening to statistics changes</h4></div></div></div><p>
                    Statistics are not calculated for each request or each change. Statistics are calculated only
                    from the collected data in regular intervals for performance reasons (for example once per second).
                    If you want to be notified about new statistics, register an implementation of
                    <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatisticsListener.html" target="_top">MonitoringStatisticsListener</a> as one of your custom application providers.
                    Your listener will be called every time the new statistics are calculated and the updated statistics
                    data will be passed to the listener method. This is another way of receiving statistics.
                    See the linked listener API documentation for more information.
                </p></div></div><div class="section" title="19.2.3.&nbsp;Monitoring Statistics as MBeans"><div class="titlepage"><div><div><h3 class="title"><a name="d0e11652"></a>19.2.3.&nbsp;Monitoring Statistics as MBeans</h3></div></div></div><p>
                Jersey provides feature to expose monitoring statistics as JMX MXBeans.
                In order to enable monitoring statistics MXBeans exposure, the
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_MBEANS_ENABLED" target="_top">ServerProperties.MONITORING_STATISTICS_MBEANS_ENABLED</a> must be set to <code class="literal">true</code>.
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">jersey.config.server.monitoring.statistics.mbeans.enabled=true</pre><p>
                Note that enabling exposure of monitoring MXBeans causes that also the calculation of
                <code class="literal">MonitoringStatistics</code> is automatically enabled as the exposed
                MXBean statistics are extracted from <code class="literal">MonitoringStatistics</code>.
            </p><p>
                The easiest way is to browse the MXBeans in the JConsole. Open the JConsole
                (<code class="literal">$JAVA_HOME/bin/jconsole</code>). Then connect to the process where JAX-RS application is running
                (server on which the application is running). Switch to a MBean tab and in the MBean tree on the left side
                find a group <code class="literal">org.glassfish.jersey</code>. All deployed Jersey applications are located under this
                group. If you don't see such this group, then MBeans are not exposed (check the configuration property and
                logs if they not contain any exceptions or errors). The following figure is an example of an output from the
                JConsole:
            </p><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td align="center"><img src="images/monitoring-jsconsole.png" align="middle" width="100%"></td></tr></table></div><p>
                Under the root <code class="literal">org.glassfish.jersey</code> Jersey MBean group you can find your application.
                If the server contains more Jersey application, all will be present under the root Jersey the group. In the
                screen-shot, the deployed JAX-RS application is named <code class="literal">myApplication</code> (the name can be defined
                via <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> directly or by setting the <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#APPLICATION_NAME" target="_top">ServerProperties.APPLICATION_NAME</a>
                property).
                Each application contains <code class="literal">Global</code>, <code class="literal">Resource</code> and
                <code class="literal">Uris</code> sub-groups. The <code class="literal">Global</code> group contains all global
                statistics like overall requests statistics of the entire application (<code class="literal">AllRequestTimes</code>),
                configuration of the JAX-RS application (<code class="literal">Configuration</code>), statistics about
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/ExceptionMapper.html" target="_top">ExceptionMapper&lt;E extends Throwable&gt;</a> execution (<code class="literal">ExceptionMapper</code>) and statistics about
                produced responses (<code class="literal">Responses</code>).
            </p><p>
                <code class="literal">Resources</code> and <code class="literal">Uris</code> groups contains monitoring statistics specific to
                individual resources.
                Statistics in <code class="literal">Resources</code> are bound to the JAX-RS resource Java classes loaded by the
                application. <code class="literal">Uris</code> contains statistics of resources based on the matched application Uris
                (one URI entry represents all methods bound to the particula URI, e.g. <code class="literal">/resource/exception</code>).
                As Jersey provides programmatic resource builders (described in the chapter
                <a class="link" href="#resource-builder" title="Chapter&nbsp;12.&nbsp;Programmatic API for Building Resources">"Programmatic API for Building Resources"</a>), one Java resource class
                can be an endpoint for resource methods on many different URIs. And also one URI can be served by method from
                many different Java classes. Therefore both views are not to be compared 1:1. Instead they provide
                different loggical views on your JAX-RS application. This monitoring feature can also help when designing
                the JAX-RS APIs as it provides nice view on available root application URIs.
            </p><p>
                Both logical views on the resources exposed by application share few common principles. A single resource entry
                is always a set of resource methods which are available under the <code class="literal">methods</code> sub-group. Statistics
                can be found in MBeans <code class="literal">MethodTimes</code> and <code class="literal">RequestTimes</code>.
                <code class="literal">MethodTimes</code> contains statistics measured on on resource methods (duration of execution of a
                code of the a resource method), whereas <code class="literal">RequestTimes</code> contains statistics of an entire request
                execution (not only a time of the execution of the resource method but the overall time of the execution of whole
                request by Jersey runtime). Another useful information is that statistics directly under resource (not under
                the <code class="literal">methods</code> sub-group) contains summary of statistics for all resource methods grouped in the
                resource entry.
            </p><p>Additional useful details that about statistics</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">Global-&gt;Configuration-&gt;Registered(Claases/Instances)</code>:
                    registered resource classes and instances by the user (i.e., not added by <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/model/ModelProcessor.html" target="_top">ModelProcessor</a>
                    during deployment for example).
                </p></li><li class="listitem"><p><code class="literal">Global-&gt;ExceptionMapper-&gt;ExceptionMapperCount</code>:
                    map that contains exception mapper classes as keys and number of their execution as values.
                </p></li><li class="listitem"><p>
                    <code class="literal">Global-&gt;Responses-?ResponseCodesToCountMap</code>:
                    map that contains response codes as keys and their total occurrence in responses as values.
                </p></li><li class="listitem"><p>
                    Resource groups contain also entries for resources that were added by Jersey at deployment time using
                    <code class="literal">ModelProcessor</code> (for example all <code class="literal">OPTIONS</code> methods, <code class="literal">WADL</code>).
                    <code class="literal">HEAD</code> methods are not present in the MXBeans view (even HEAD methods are in resources).
                </p></li><li class="listitem"><p>
                    Execution statistics for different time windows have different update intervals. The shorter the time window,
                    the shorter the update interval. This causes that immediately after the application start, the shorter time
                    windows (such as 15 seconds) may contain higher values than longer ones (e.g. 1 hour time window). The reason
                    is that 1 hour interval will show information that is not up to date and therefore has smaller value. This
                    inconsistency is not so much significant when application is running longer time. Total unlimited time windows
                    contains always up-to-date data. This inconsistency will get fixed in a future Jersey release.
                </p></li></ul></div><p>
                MXBeans can be also accessed using JMX. To do so, you would need to use the interfaces of MXBeans.
                These interfaces are even useful when working with MXBeans only trough <code class="literal">JConsole</code> as
                they contain Javadocs for each MXBean and attribute. Monitoring MBeans are defined by following interfaces:

                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ApplicationMXBean.html" target="_top">ApplicationMXBean</a>: contains configuration statistics
                    </p></li><li class="listitem"><p>
                        <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ExceptionMapperMXBean.html" target="_top">ExceptionMapperMXBean</a>: contains statistics of exception mappers
                    </p></li><li class="listitem"><p>
                        <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ResourceMethodMXBean.html" target="_top">ResourceMethodMXBean</a>: contains statistics of resource method
                    </p></li><li class="listitem"><p>
                        <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ResourceMXBean.html" target="_top">ResourceMXBean</a>: contains statistics of resource
                    </p></li><li class="listitem"><p>
                        <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/ResponseMXBean.html" target="_top">ResponseMXBean</a>: contains statistics of responses
                    </p></li></ul></div><p>

                The list does not contain MXBean for the execution and time window statistics. The reason is that
                this bean is defined as a <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/management/DynamicMBean.html" target="_top">DynamicMBean</a>. Attributes of this dynamic MBean contains
                statistics for all time windows available.
            </p><p>
                MXBeans do not reference each other but can be retrieved by their <a class="link" href="http://docs.oracle.com/javase/6/docs/api/javax/management/ObjectName.html" target="_top">ObjectName</a>s which
                are designed in the way, that final MBean tree looks nicely organized in <span class="emphasis"><em>JConsole</em></span>.
                Each MXBean is uniquely identified by its <code class="literal">ObjectName</code> and properties of
                <code class="literal">ObjectName</code> are structured hierarchically, so that each MXBean can be identified to which
                parent it belong to (e.g. execution statistics dynamic MXBean belongs to resource method MXBean, which
                belongs to resource and which belongs to application). Check the <code class="literal">ObjectName</code>s of
                exposed MXBeans to investigate the structure (for example through JConsole).
            </p><p>
                To reiterate, exposing Jersey MXBeans and the calculating monitoring statistics may have an performance impact
                on your application and therefore should be enabled only when needed. Also, please note, that it Jersey
                monitoring is exposing quite a lot of information about the monitored application which might be viewed as
                problematic in some cases (e.g. in production server deployments).
            </p></div></div></div><div lang="en" class="chapter" title="Chapter&nbsp;20.&nbsp;Spring DI"><div class="titlepage"><div><div><h2 class="title"><a name="spring"></a>Chapter&nbsp;20.&nbsp;Spring DI</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e11879">20.1. Dependencies</a></span></dt><dt><span class="section"><a href="#d0e11892">20.2. Registration and Configuration</a></span></dt><dt><span class="section"><a href="#d0e11897">20.3. Example</a></span></dt></dl></div><p>
        Jersey provides an extension to support Spring DI.
        This enables Jersey to use Spring beans as JAX-RS components (e.g. resources and providers) and also allows
        Spring to inject into Jersey managed components.
    </p><p>
        The Spring extension module configuration is based on annotations.
        Spring beans are injected and JAX-RS classes are made Spring managed using annotations.
        Injected Spring beans can have further dependencies injected using Spring XML configuration.
        Spring singleton and request scopes are supported.
    </p><p>
        Limitations:

        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Spring beans can't be injected directly into JAX-RS classes by using Spring XML configuration</p></li></ul></div><p>
    </p><div class="section" title="20.1.&nbsp;Dependencies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11879"></a>20.1.&nbsp;Dependencies</h2></div></div></div><p>
            If you want to use Jersey Spring DI support
            you will need to add the <a class="link" href="https://jersey.java.net/project-info/2.3/jersey/project/jersey-spring3/dependencies.html" target="_top">jersey-spring3</a> module into the list of your dependencies:

            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.ext&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-spring3&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
        </p><p>
            The above module does not add any transitive dependency to Spring modules, so you will need to add
            Spring 3 dependencies explicitly into your dependency list.
        </p></div><div class="section" title="20.2.&nbsp;Registration and Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11892"></a>20.2.&nbsp;Registration and Configuration</h2></div></div></div><p>
            To use capabilities of Jersey Spring 3 DI support in your JAX-RS/Jersey application you need to have
            the above mentioned module on your class-path.
        </p></div><div class="section" title="20.3.&nbsp;Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11897"></a>20.3.&nbsp;Example</h2></div></div></div><p>To see an example of Spring DI support in Jersey refer to the <a class="link" href="https://github.com/jersey/jersey/tree/2.3/examples/helloworld-spring-webapp" target="_top">Spring DI example</a>.</p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;21.&nbsp;Jersey Test Framework"><div class="titlepage"><div><div><h2 class="title"><a name="test-framework"></a>Chapter&nbsp;21.&nbsp;Jersey Test Framework</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e11927">21.1. Basics</a></span></dt><dt><span class="section"><a href="#d0e11964">21.2. Supported Containers</a></span></dt><dt><span class="section"><a href="#d0e12026">21.3. Advanced features</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e12029">21.3.1. <code class="literal">JerseyTest</code> Features</a></span></dt><dt><span class="section"><a href="#d0e12053">21.3.2. External container</a></span></dt><dt><span class="section"><a href="#d0e12064">21.3.3. Test Client configuration</a></span></dt><dt><span class="section"><a href="#d0e12078">21.3.4. Accessing the logged test records programmatically</a></span></dt></dl></dd></dl></div><p>
        Jersey Test Framework originated as an internal tool used for verifying the correct implementation of
        server-side components. Testing RESTful applications became a more pressing issue with "modern" approaches like
        test-driven development and users started to look for a tool that could help with designing and running
        the tests as fast as possible but with many options related to test execution environment.
    </p><p>
        Current implementation of Jersey Test Framework supports the following set of features:

        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>pre-configured client to access deployed application</p></li><li class="listitem"><p>support for multiple containers - grizzly, in-memory, jdk, simple</p></li><li class="listitem"><p>able to run against any external container</p></li><li class="listitem"><p>automated configurable traffic logging</p></li></ul></div><p>

        Jersey Test Framework is based on JUnit and works almost out-of-the box. It is easy to integrate it
        within your Maven-based project. While it is usable on all environments where you can run JUnit, we support primarily the
        Maven-based setups.
    </p><div class="section" title="21.1.&nbsp;Basics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11927"></a>21.1.&nbsp;Basics</h2></div></div></div><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class SimpleTest extends JerseyTest {

    @Path("hello")
    public static class HelloResource {
        @GET
        public String getHello() {
            return "Hello World!";
        }
    }

    @Override
    protected Application configure() {
        return new ResourceConfig(HelloResource.class);
    }

    @Test
    public void test() {
        final String hello = target("hello").request().get(String.class);
        assertEquals("Hello World!", hello);
    }
}</pre><p>
            If you want to develop a test using Jersey Test Framework, you need to subclass <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/org/glassfish/jersey/test/JerseyTest.html" target="_top">JerseyTest</a> and
            configure the set of resources and/or providers that will be deployed as part of the test application. This short
            code snippet shows basic resource class <code class="literal">HelloResource</code> used in tests defined as part of the
            <code class="literal">SimpleTest</code> class. The overridden <code class="literal">configure</code> method returns
            a <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> of the test application,that contains only the <code class="literal">HelloResource</code>
            resource class. <code class="literal">ResourceConfig</code> is a sub-class of JAX-RS <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Application.html" target="_top">Application</a>. It is a Jersey
            convenience class for configuring JAX-RS applications. <code class="literal">ResourceConfig</code> also implements JAX-RS
            <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/core/Configurable.html" target="_top">Configurable</a> interface to make the application configuration more flexible.
        </p></div><div class="section" title="21.2.&nbsp;Supported Containers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e11964"></a>21.2.&nbsp;Supported Containers</h2></div></div></div><p>
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/org/glassfish/jersey/test/JerseyTest.html" target="_top">JerseyTest</a> supports deploying applications on various containers, all (except the external container
            wrapper) need to have some "glue" code to be supported. Currently Jersey Test Framework provides support for
            Grizzly, In-Memory, JDK (<code class="literal">com.sun.net.httpserver.HttpServer</code>) and Simple HTTP container
            (<code class="literal">org.simpleframework.http</code>).
        </p><p>
            A test container is selected based on various inputs.
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/test/JerseyTest.html#getTestContainerFactory()" target="_top">JerseyTest#getTestContainerFactory()</a>
            is always executed, so if you override it and provide your own version of
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/org/glassfish/jersey/test/spi/TestContainerFactory.html" target="_top">TestContainerFactory</a>, nothing else will be considered.
            Setting a system variable
            <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/test/TestProperties.html#CONTAINER_FACTORY" target="_top">TestProperties#CONTAINER_FACTORY</a>
            has similar effect. This way you may defer the decision on which containers you want to run your tests
            from the compile time to the test execution time.
            Default implementation of <code class="literal">TestContainerFactory</code> looks for container factories on classpath.
            If more than one instance is found and there is a Grizzly test container factory among them, it will be used; if not,
            a warning will be logged and the first found factory will be instantiated.
        </p><p>
            Following is a brief description of all containers supported in Jersey Test Framework.
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                        Grizzly container can run as a light-weight, plain HTTP container. Almost all Jersey tests are using
                        Grizzly by default.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-grizzly2&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    </p></li><li class="listitem"><p>
                        In-Memory container is not a real container. It starts Jersey application and directly calls internal
                        APIs to handle request created by client provided by test framework. There is no network communication
                        involved. This containers does not support servlet and other container dependent features, but it is
                        a perfect choice for simple unit tests.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-inmemory&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    </p></li><li class="listitem"><p>
                        <code class="literal">HttpServer</code> from Oracle JDK is another supported test container.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-jdk-http&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    </p></li><li class="listitem"><p>
                        Simple container (<code class="literal">org.simpleframework.http</code>) is another light-weight HTTP container
                        that integrates with Jersey and is supported by Jersey Test Framework.

                        </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-simple&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
                    </p></li></ul></div><p>
        </p></div><div class="section" title="21.3.&nbsp;Advanced features"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12026"></a>21.3.&nbsp;Advanced features</h2></div></div></div><div class="section" title="21.3.1.&nbsp;JerseyTest Features"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12029"></a>21.3.1.&nbsp;<code class="literal">JerseyTest</code> Features</h3></div></div></div><p><code class="literal">JerseyTest</code> provide
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/test/JerseyTest.html#enable(java.lang.String)" target="_top">enable(...)</a>,
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/test/JerseyTest.html#forceEnable(java.lang.String)" target="_top">forceEnable(...)</a>
                and <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/test/JerseyTest.html#disable(java.lang.String)" target="_top">disable(...)</a>
                methods, that give you control over configuring values of the properties defined and described in the
                <code class="literal">TestProperties</code> class. A typical code that overrides the default property values is listed
                bellow:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class SimpleTest extends JerseyTest {
    // ...

    @Override
    protected Application configure() {
        enable(TestProperties.LOG_TRAFFIC);
        enable(TestProperties.DUMP_ENTITY);

        // ...

    }
}</pre><p>

                The code in the example above enables test traffic logging (inbound and outbound headers) as well as
                dumping the HTTP message entity as part of the traffic logging.
            </p></div><div class="section" title="21.3.2.&nbsp;External container"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12053"></a>21.3.2.&nbsp;External container</h3></div></div></div><p>
                Complicated test scenarios may require fully started containers with complex setup configuration, that is not
                easily doable with current Jersey container support. To address these use cases, Jersey Test Framework providers
                general fallback mechanism - an External Test Container Factory. Support of this external container "wrapper" is
                provided as the following module:

                </p><pre class="&#xA;    toolbar: false;&#xA;    brush: xml;&#xA;    ">&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.jersey.test-framework.providers&lt;/groupId&gt;
    &lt;artifactId&gt;jersey-test-framework-provider-external&lt;/artifactId&gt;
    &lt;version&gt;2.3&lt;/version&gt;
&lt;/dependency&gt;</pre><p>

                As indicated, the "container" exposed by this module is just a wrapper or stub, that redirects all request to
                a configured host and port. Writing tests for this container is same as for any other but you have to provide
                the information about host and port during the test execution:

                </p><pre class="screen">mvn test -Djersey.test.host=myhost.org -Djersey.config.test.container.port=8080</pre><p>
            </p></div><div class="section" title="21.3.3.&nbsp;Test Client configuration"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12064"></a>21.3.3.&nbsp;Test Client configuration</h3></div></div></div><p>
                Tests might require some advanced client configuration. This is possible by overriding
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/test/JerseyTest.html#configureClient(org.glassfish.jersey.client.ClientConfig)" target="_top">configureClient(ClientConfig clientConfig)</a>
                method. Typical use case for this is registering more providers, such as <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyReader.html" target="_top">MessageBodyReader&lt;T&gt;</a>s or
                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/MessageBodyWriter.html" target="_top">MessageBodyWriter&lt;T&gt;</a>s, or enabling additional features.
            </p></div><div class="section" title="21.3.4.&nbsp;Accessing the logged test records programmatically"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12078"></a>21.3.4.&nbsp;Accessing the logged test records programmatically</h3></div></div></div><p>
                Sometimes you might need to check a logged message as part of your test assertions. For this purpose Jersey Test
                Framework provides convenient access to the logged records via
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/test/JerseyTest.html#getLastLoggedRecord()" target="_top">JerseyTest#getLastLoggedRecord()</a>
                and
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/test/JerseyTest.html#getLoggedRecords()" target="_top">JerseyTest#getLoggedRecords()</a>
                methods. Note that this feature is not enabled by default, see
                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/test/TestProperties.html#RECORD_LOG_LEVEL" target="_top">TestProperties#RECORD_LOG_LEVEL</a>
                for more information.
            </p></div></div></div><div lang="en" class="chapter" title="Chapter&nbsp;22.&nbsp;Building and Testing Jersey"><div class="titlepage"><div><div><h2 class="title"><a name="how-to-build"></a>Chapter&nbsp;22.&nbsp;Building and Testing Jersey</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#checkout">22.1. Checking Out the Source</a></span></dt><dt><span class="section"><a href="#building">22.2. Building the Source</a></span></dt><dt><span class="section"><a href="#testing">22.3. Testing</a></span></dt><dt><span class="section"><a href="#netbeans-build">22.4. Using NetBeans</a></span></dt></dl></div><div class="section" title="22.1.&nbsp;Checking Out the Source"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="checkout"></a>22.1.&nbsp;Checking Out the Source</h2></div></div></div><p>
            Jersey source code is available on GitHub. You can browse the sources at
            <a class="link" href="https://github.com/jersey/jersey" target="_top">https://github.com/jersey/jersey</a>.
        </p><p>
            In case you are not familiar with Git, we recommend reading some of the many "Getting Started with Git" articles
            you can find on the web. For example this
            <a class="link" href="http://refcardz.dzone.com/refcardz/getting-started-git" target="_top">DZone RefCard</a>.
        </p><p>
            To clone the Jersey repository you can execute the following command on the command-line
            (provided you have a command-line Git client installed on your machine):
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">git clone git://github.com/jersey/jersey.git</pre><p>
            This creates read-only copy of Jersey workspace. If you want to contribute, please use "pull request":
            <a class="link" href="https://help.github.com/articles/creating-a-pull-request" target="_top">https://help.github.com/articles/creating-a-pull-request</a>.
        </p><p>
            Milestones and releases of Jersey are tagged. You can list the tags by executing the standard Git command in the repository directory:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">git tag -l</pre><p> or by visiting
            <a class="link" href="https://github.com/jersey/jersey/tags" target="_top">https://github.com/jersey/jersey/tags</a>.
        </p></div><div class="section" title="22.2.&nbsp;Building the Source"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="building"></a>22.2.&nbsp;Building the Source</h2></div></div></div><p>
            Jersey source code requires Java SE 6 or greater. The build is based on Maven.
            Maven 3 or greater is highly recommended. Also it is recommended you use the following
            Maven options when building the workspace (can be set in <code class="literal">MAVEN_OPTS</code> environment
            variable):
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">-Xmx1048m -XX:PermSize=64M -XX:MaxPermSize=128M</pre><p>
        </p><p>
            It is recommended to build all of Jersey after you cloned the source code repository.
            To do that execute the following commands in the directory where jersey source repository
            was cloned (typically the directory named "jersey"):
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn -Dmaven.test.skip=true clean install</pre><p>
            This command will build Jersey, but skip the test execution.
            If you don't want to skip the tests, execute the following instead:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn clean install</pre><p>
            Building the whole Jersey project including tests could take significant amount of time.
        </p></div><div class="section" title="22.3.&nbsp;Testing"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testing"></a>22.3.&nbsp;Testing</h2></div></div></div><p>
            Jersey contains many tests. Unit tests are in the individual Jersey modules,
            integration and end-to-end tests are in <code class="literal">jersey/tests/e2e</code> directory.
            You can run tests related to a particular area using the following command:
            </p><pre class="&#xA;    toolbar: false;&#xA;    brush: bash;&#xA;    gutter: false;">mvn -Dtest=&lt;pattern&gt; test</pre><p>
            where
            <code class="literal">pattern</code>
            may be a comma separated set of names matching tests classes or individual methods (like
            <code class="literal">LinkTest#testDelimiters</code>).
        </p></div><div class="section" title="22.4.&nbsp;Using NetBeans"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="netbeans-build"></a>22.4.&nbsp;Using NetBeans</h2></div></div></div><p>
            <a class="link" href="http://netbeans.org" target="_top">NetBeans IDE</a>
            has excellent maven support. The Jersey maven
            modules can be loaded, built and tested in NetBeans without any additional
            NetBeans-specific project files.
        </p></div></div><div lang="en" class="chapter" title="Chapter&nbsp;23.&nbsp;Migration Guide"><div class="titlepage"><div><div><h2 class="title"><a name="migration"></a>Chapter&nbsp;23.&nbsp;Migration Guide</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#mig-2.3">23.1. Migrating from Jersey 2.0, 2.1 or 2.2 to 2.3</a></span></dt><dt><span class="section"><a href="#mig-1.x">23.2. Migrating from Jersey 1.x to 2.0</a></span></dt><dd><dl><dt><span class="section"><a href="#mig-server-api">23.2.1. Server API</a></span></dt><dt><span class="section"><a href="#mig-client-api">23.2.2. Migrating Jersey Client API</a></span></dt></dl></dd></dl></div><div class="section" title="23.1.&nbsp;Migrating from Jersey 2.0, 2.1 or 2.2 to 2.3"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mig-2.3"></a>23.1.&nbsp;Migrating from Jersey 2.0, 2.1 or 2.2 to 2.3</h2></div></div></div><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    All existing SSE <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/InboundEvent.html" target="_top">InboundEvent</a> <code class="literal">getData(...)</code> methods have been made
                    deprecated and new <code class="literal">readData(...)</code> methods have been introduced instead for consistency
                    with other parts of client-side JAX-RS API. The deprecated <code class="literal">getData(...)</code> methods will
                    be removed in Jersey 2.4. A new SSE <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/InboundEvent.html" target="_top">InboundEvent</a> <code class="literal">byte[] getRawData()</code> method
                    has been introduced to provide access to the raw SSE event data content.
                </p></li><li class="listitem"><p>
                    Generic <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/Broadcaster.html" target="_top">Broadcaster</a> methods for adding/removing <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/BroadcasterListener.html" target="_top">BroadcasterListener</a>
                    registrations have been renamed from <code class="literal">addBroadcasterListener/removeBroadcasterListener</code>
                    to simply <code class="literal">add/remove</code>.
                </p></li><li class="listitem"><p>
                    Generic <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/Broadcaster.html" target="_top">Broadcaster</a> (and transitively, <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/SseBroadcaster.html" target="_top">SseBroadcaster</a>)
                    <code class="literal">add/remove</code> methods - that are responsible for
                    adding/removing <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/BroadcasterListener.html" target="_top">BroadcasterListener</a> and <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ChunkedOuptut.html" target="_top">ChunkedOutput</a>
                    (or <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/media/sse/EventOutput.html" target="_top">EventOutput</a>) registrations - no longer try to avoid duplicate registrations by comparing
                    hash code of the added/removed instance with the hash codes of already registered instances. This behavior
                    has been identified as a potential source of hard to discover bugs and was removed as such. The issue with
                    the former behavior was that hash codes as integer values provide only a very limited value space that
                    could lead to false-positive duplicate registration rejections, especially with larger number of
                    simultaneously connected SSE clients (represented by <code class="literal">ChunkedOutput</code> or
                    <code class="literal">EventOutput</code> broadcaster registrations). Consequently, users who rely on the old registration
                    behavior in their application code need to adapt the code to the revised behavior of
                    <code class="literal">Broadcaster</code> <code class="literal">add/remove</code> methods.
                </p></li></ul></div><p>
        </p></div><div class="section" title="23.2.&nbsp;Migrating from Jersey 1.x to 2.0"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mig-1.x"></a>23.2.&nbsp;Migrating from Jersey 1.x to 2.0</h2></div></div></div><p>
            This chapter is a migration guide for people switching from Jersey 1.x. Since many of the Jersey 1.x features
            became part of JAX-RS 2.0 standard which caused changes in the package names, we decided it is a good time
            to do a more significant incompatible refactoring, which will allow us to introduce some more interesting new
            features in the future. As the result, there are many incompatibilities between Jersey 1.x and Jersey 2.0.
            This chapter summarizes how to migrate the concepts found in Jersey 1.x to Jersey/JAX-RS 2.0 concepts.
        </p><div class="section" title="23.2.1.&nbsp;Server API"><div class="titlepage"><div><div><h3 class="title"><a name="mig-server-api"></a>23.2.1.&nbsp;Server API</h3></div></div></div><p>
                Jersey 1.x contains number of proprietary server APIs. This section covers migration of application code relying
                on those APIs.
            </p><div class="section" title="23.2.1.1.&nbsp;Injecting custom objects"><div class="titlepage"><div><div><h4 class="title"><a name="mig-server-inject-custom-objects"></a>23.2.1.1.&nbsp;Injecting custom objects</h4></div></div></div><p>Jersey 1.x have its own internal dependency injection framework which handles injecting various parameters
                    into field or methods. It also provides a way how to register custom injection provider in Singleton or PerRequest
                    scopes. Jersey 2.x uses HK2 as dependency injection framework and users are also able to register custom classes
                    or instances to be injected in various scopes.
                </p><p>Main difference in Jersey 2.x is that you don't need to create special classes or providers for this task;
                    everything should be achievable using HK2 API. Custom injectables can be registered at ResourceConfig level by adding
                    new HK2 Module or by dynamically adding binding almost anywhere using injected HK2 Services instance.
                </p><p>Jersey 1.x Singleton:
                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">ResourceConfig resourceConfig = new DefaultResourceConfig();
resourceConfig.getSingletons().add(
        new SingletonTypeInjectableProvider&lt;Context, SingletonType&gt;(
                SingletonType.class, new SingletonType()) {});</pre><p>
                </p><p>Jersey 1.x PerRequest:
                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">ResourceConfig resourceConfig = new DefaultResourceConfig();
resourceConfig.getSingletons().add(
        new PerRequestTypeInjectableProvider&lt;Context, PerRequestType&gt;() {
            @Override
            public Injectable&lt;PerRequestType&gt; getInjectable(ComponentContext ic, Context context) {
                //...
            }
        });</pre><p>
                </p><p>Jersey 2.0 HK2 Module:
                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">public static class MyBinder extends AbstractBinder {

    @Override
    protected void configure() {
        // request scope binding
        bind(MyInjectablePerRequest.class).to(MyInjectablePerRequest.class).in(RequestScope.class);
        // singleton binding
        bind(MyInjectableSingleton.class).in(Singleton.class);
        // singleton instance binding
        bind(new MyInjectableSingleton()).to(MyInjectableSingleton.class);
    }

}

// register module to ResourceConfig (can be done also in constructor)
ResourceConfig rc = new ResourceConfig();
rc.addClasses(/* ... */);
rc.addBinders(new MyBinder());</pre><p>
                </p><p>Jersey 2.0 dynamic binding:
                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">public static class MyApplication extends Application {

    @Inject
    public MyApplication(ServiceLocator serviceLocator) {
        System.out.println("Registering injectables...");

        DynamicConfiguration dc = Injections.getConfiguration(serviceLocator);

        // request scope binding
        Injections.addBinding(
        Injections.newBinder(MyInjectablePerRequest.class).to(MyInjectablePerRequest.class).in(RequestScoped.class),
                dc);

        // singleton binding
        Injections.addBinding(
                Injections.newBinder(MyInjectableSingleton.class)
                        .to(MyInjectableSingleton.class)
                        .in(Singleton.class),
                dc);

        // singleton instance binding
        Injections.addBinding(
                Injections.newBinder(new MyInjectableSingleton())
                        .to(MyInjectableSingleton.class),
                dc);

        // request scope binding with specified custom annotation
        Injections.addBinding(
                Injections.newBinder(MyInjectablePerRequest.class)
                        .to(MyInjectablePerRequest.class)
                        .qualifiedBy(new MyAnnotationImpl())
                        .in(RequestScoped.class),
                dc);

        // commits changes
        dc.commit();
    }

    @Override
    public Set&lt;Class&lt;?&gt;&gt; getClasses() {
        return ...
    }}</pre><p>
                </p></div><div class="section" title="23.2.1.2.&nbsp;ResourceConfig Reload"><div class="titlepage"><div><div><h4 class="title"><a name="mig-server-reload"></a>23.2.1.2.&nbsp;ResourceConfig Reload</h4></div></div></div><p>
                    In Jersey 1, the reload functionality is based on two interfaces:
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">com.sun.jersey.spi.container.ContainerListener</li><li class="listitem">com.sun.jersey.spi.container.ContainerNotifier</li></ol></div><p>

                    Containers, which support the reload functionality implement the <code class="literal">ContainerListener</code>
                    interface, so that once you get access to the actual container instance, you could call it's
                    <code class="literal">onReload</code> method and get the container re-load the config. The second interface helps you to
                    obtain the actual container instance reference. An example on how things are wired together follows.

                    </p><div class="example"><a name="d0e12312"></a><p class="title"><b>Example&nbsp;23.1.&nbsp;Jersey 1 reloader implementation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Reloader implements ContainerNotifier {
    List&lt;ContainerListener&gt; ls;

    public Reloader() {
        ls = new ArrayList&lt;ContainerListener&gt;();
    }

    public void addListener(ContainerListener l) {
        ls.add(l);
    }

    public void reload() {
        for (ContainerListener l : ls) {
            l.onReload();
        }
    }
}</pre></div></div><p><br class="example-break">

                    </p><div class="example"><a name="d0e12318"></a><p class="title"><b>Example&nbsp;23.2.&nbsp;Jersey 1 reloader registration</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Reloader reloader = new Reloader();
resourceConfig.getProperties().put(ResourceConfig.PROPERTY_CONTAINER_NOTIFIER, reloader);</pre></div></div><p><br class="example-break">

                    In Jersey 2, two interfaces are involved again, but these have been re-designed.

                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">org.glassfish.jersey.server.spi.Container</li><li class="listitem">org.glassfish.jersey.server.spi.ContainerLifecycleListener</li></ol></div><p>

                    The <code class="literal">Container</code> interface introduces two <code class="literal">reload</code> methods, which you can call
                    to get the application re-loaded. One of these methods allows to pass in a new <code class="literal">ResourceConfig</code>
                    instance.

                    You can register your implementation of <code class="literal">ContainerLifecycleListener</code> the same way as any
                    other provider (i.e. either by annotating it by <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/ext/Provider.html" target="_top">@Provider</a> annotation or adding it to the
                    Jersey <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ResourceConfig.html" target="_top">ResourceConfig</a> directly either using the class (using
                    <code class="literal">ResourceConfig.addClasses()</code>) or registering a particular instance using
                    <code class="literal">ResourceConfig.addSingletons()</code> method.
                </p><p>
                    An example on how things work in Jersey 2 follows.

                    </p><div class="example"><a name="d0e12358"></a><p class="title"><b>Example&nbsp;23.3.&nbsp;Jersey 2 reloader implementation</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">public class Reloader implements ContainerLifecycleListener {

    Container container;

    public void reload(ResourceConfig newConfig) {
        container.reload(newConfig);
    }

    public void reload() {
        container.reload();
    }

    @Override
    public void onStartup(Container container) {
        this.container = container;
    }

    @Override
    public void onReload(Container container) {
        // ignore or do whatever you want after reload has been done
    }

    @Override
    public void onShutdown(Container container) {
        // ignore or do something after the container has been shutdown
    }
}</pre></div></div><p><br class="example-break">
                    </p><div class="example"><a name="d0e12364"></a><p class="title"><b>Example&nbsp;23.4.&nbsp;Jersey 2 reloader registration</b></p><div class="example-contents"><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    ">Reloader reloader = new Reloader();
resourceConfig.addSingletons(reloader);
                        </pre></div></div><p><br class="example-break">
                </p></div><div class="section" title="23.2.1.3.&nbsp;MessageBodyReaders and MessageBodyWriters ordering"><div class="titlepage"><div><div><h4 class="title"><a name="mig-server-provider-ordering"></a>23.2.1.3.&nbsp;MessageBodyReaders and MessageBodyWriters ordering</h4></div></div></div><p>JAX-RS 2.0 defines new order of MessageBodyWorkers - whole set is sorted by declaration distance,
                    media type and source (custom providers having higher priority than default ones provided by Jersey).
                    JAX-RS 1.x ordering can still be forced by setting parameter
                    <code class="literal">MessageProperties.LEGACY_WORKERS_ORDERING</code>
                    (<code class="literal">"jersey.config.workers.legacyOrdering"</code>) to <code class="literal">true</code> in <code class="literal">ResourceConfig</code>
                    or <code class="literal">ClientConfig</code> properties.
                </p></div></div><div class="section" title="23.2.2.&nbsp;Migrating Jersey Client API"><div class="titlepage"><div><div><h3 class="title"><a name="mig-client-api"></a>23.2.2.&nbsp;Migrating Jersey Client API</h3></div></div></div><p>
                JAX-RS 2.0 provides functionality that is equivalent to the Jersey 1.x proprietary client API. Here is a rough
                mapping between the Jersey 1.x and JAX-RS 2.0 Client API classes:
            </p><div class="table"><a name="d0e12395"></a><p class="title"><b>Table&nbsp;23.1.&nbsp;Mapping of Jersey 1.x to JAX-RS 2.0 client classes</b></p><div class="table-contents"><table summary="Mapping of Jersey 1.x to JAX-RS 2.0 client classes" border="1"><colgroup><col width="0%" align="left" class="c1"><col width="0%" align="left" class="c2"><col width="100%" align="left" class="c3"></colgroup><thead><tr><th align="left">Jersey 1.x Class</th><th align="left">JAX-RS 2.0 Class</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">
                                <a class="link" href="http://jersey.java.net/nonav/apidocs/1.17/jersey/com/sun/jersey/api/client/Client.html" target="_top">com.sun.jersey.api.client.Client</a>
                            </td><td align="left">
                                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/ClientBuilder.html" target="_top">ClientBuilder</a>
                            </td><td align="left">For the static factory methods and constructors.</td></tr><tr><td align="left">&nbsp;</td><td align="left">
                                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/Client.html" target="_top">Client</a>
                            </td><td align="left">For the instance methods.</td></tr><tr><td align="left">
                                <a class="link" href="http://jersey.java.net/nonav/apidocs/1.17/jersey/com/sun/jersey/api/client/WebResource.html" target="_top">com.sun.jersey.api.client.WebResource</a>
                            </td><td align="left">
                                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/WebTarget.html" target="_top">WebTarget</a>
                            </td><td align="left">&nbsp;</td></tr><tr><td align="left">
                                <a class="link" href="http://jersey.java.net/nonav/apidocs/1.17/jersey/com/sun/jersey/api/client/AsyncWebResource.html" target="_top">com.sun.jersey.api.client.AsyncWebResource</a>
                            </td><td align="left">
                                <a class="link" href="http://jax-rs-spec.java.net/nonav/2.0/apidocs/javax/ws/rs/client/WebTarget.html" target="_top">WebTarget</a>
                            </td><td align="left">You can access async versions of the async methods by calling
                                <code class="literal">WebTarget.request().async()</code>
                            </td></tr></tbody></table></div></div><br class="table-break"><p>The following sub-sections show code examples.</p><div class="section" title="23.2.2.1.&nbsp;Making a simple client request"><div class="titlepage"><div><div><h4 class="title"><a name="mig-client-simple-request"></a>23.2.2.1.&nbsp;Making a simple client request</h4></div></div></div><p>
                    Jersey 1.x way:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">Client client = Client.create();
WebResource webResource = client.resource(restURL).path("myresource/{param}");
String result = webResource.pathParam("param", "value").get(String.class);</pre><p>
                </p><p>
                    JAX-RS 2.0 way:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">Client client = ClientBuilder.newClient();
WebTarget target = client.target(restURL).path("myresource/{param}");
String result = target.pathParam("param", "value").get(String.class);</pre><p>
                </p></div><div class="section" title="23.2.2.2.&nbsp;Registering filters"><div class="titlepage"><div><div><h4 class="title"><a name="mig-client-filter-register"></a>23.2.2.2.&nbsp;Registering filters</h4></div></div></div><p>
                    Jersey 1.x way:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">Client client = Client.create();
WebResource webResource = client.resource(restURL);
webResource.addFilter(new HTTPBasicAuthFilter(username, password));</pre><p>
                </p><p>
                    JAX-RS 2.0 way:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">Client client = ClientBuilder.newClient();
WebTarget target = client.target(restURL);
target.register(new HttpBasicAuthFilter(username, password));</pre><p>
                </p></div><div class="section" title="23.2.2.3.&nbsp;Setting &#34;Accept&#34; header"><div class="titlepage"><div><div><h4 class="title"><a name="mig-client-accept-header"></a>23.2.2.3.&nbsp;Setting "Accept" header</h4></div></div></div><p>
                    Jersey 1.x way:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">Client client = Client.create();
WebResource webResource = client.resource(restURL).accept("text/plain");
ClientResponse response = webResource.get(ClientResponse.class);</pre><p>
                </p><p>
                    JAX-RS 2.0 way:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">Client client = ClientBuilder.newClient();
WebTarget target = client.target(restURL);
Response response = target.request("text/plain").get();</pre><p>
                </p></div><div class="section" title="23.2.2.4.&nbsp;Attaching entity to request"><div class="titlepage"><div><div><h4 class="title"><a name="mig-client-add-entity"></a>23.2.2.4.&nbsp;Attaching entity to request</h4></div></div></div><p>
                    Jersey 1.x way:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">Client client = Client.create();
WebResource webResource = client.resource(restURL);
ClientResponse response = webResource.post(ClientResponse.class, "payload");</pre><p>
                </p><p>
                    JAX-RS 2.0 way:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">Client client = ClientBuilder.newClient();
WebTarget target = client.target(restURL);
Response response = target.request().post(Entity.text("payload"));</pre><p>
                </p></div><div class="section" title="23.2.2.5.&nbsp;Setting SSLContext and/or HostnameVerifier"><div class="titlepage"><div><div><h4 class="title"><a name="mig-client-ssl"></a>23.2.2.5.&nbsp;Setting SSLContext and/or HostnameVerifier</h4></div></div></div><p>
                    Jersey 1.x way:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">HTTPSProperties prop = new HTTPSProperties(hostnameVerifier, sslContext);
DefaultClientConfig dcc = new DefaultClientConfig();
dcc.getProperties().put(HTTPSProperties.PROPERTY_HTTPS_PROPERTIES, prop);
Client client = Client.create(dcc);</pre><p>
                </p><p>
                    Jersey 2.0 way:

                    </p><pre class="&#xA;    toolbar: false;&#xA;    brush: java;&#xA;    gutter: false;">Client client = ClientBuilder.newBuilder()
        .sslContext(sslContext)
        .hostnameVerifier(hostnameVerifier)
        .build();
                    </pre><p>
                </p></div></div></div></div><div lang="en" class="appendix" title="Appendix&nbsp;A.&nbsp;Configuration Properties"><div class="titlepage"><div><div><h2 class="title"><a name="appendix-properties"></a>Appendix&nbsp;A.&nbsp;Configuration Properties</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#appendix-properties-common">A.1. Common (client/server) configuration properties</a></span></dt><dt><span class="section"><a href="#appendix-properties-server">A.2. Server configuration properties</a></span></dt><dt><span class="section"><a href="#appendix-properties-client">A.3. Client configuration properties</a></span></dt></dl></div><div class="section" title="A.1.&nbsp;Common (client/server) configuration properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="appendix-properties-common"></a>A.1.&nbsp;Common (client/server) configuration properties</h2></div></div></div><p>
            List of common configuration properties that can be found in <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html" target="_top">CommonProperties</a> class. All of these properties
            can be overridden by their server/client counterparts.
        </p><div class="table"><a name="d0e12540"></a><p class="title"><b>Table&nbsp;A.1.&nbsp;List of common configuration properties</b></p><div class="table-contents"><table summary="List of common configuration properties" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th>Constant</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">CommonProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></td><td><code class="literal">jersey.config.disableAutoDiscovery</code></td><td>
                            <p>
                                Disables feature auto discovery globally on client/server. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">CommonProperties.JSON_PROCESSING_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.disableJsonProcessing</code></td><td>
                            <p>
                                Disables configuration of Json Processing (JSR-353) feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">CommonProperties.METAINF_SERVICES_LOOKUP_DISABLE</a></td><td><code class="literal">jersey.config.disableMetainfServicesLookup</code></td><td>
                            <p>
                                Disables META-INF/services lookup globally on client/server. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">CommonProperties.MOXY_JSON_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.disableMoxyJson</code></td><td>
                            <p>
                                Disables configuration of MOXy Json feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/CommonProperties.html#OUTBOUND_CONTENT_LENGTH_BUFFER" target="_top">CommonProperties.OUTBOUND_CONTENT_LENGTH_BUFFER</a></td><td><code class="literal">jersey.config.contentLength.buffer</code></td><td>
                            <p>
                                An integer value that defines the buffer size used to buffer the outbound message entity in order to
                                determine its size and set the value of HTTP <code class="literal">Content-Length</code> header. Default
                                value is <code class="literal">8192</code>.
                            </p>
                        </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="A.2.&nbsp;Server configuration properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="appendix-properties-server"></a>A.2.&nbsp;Server configuration properties</h2></div></div></div><p>
            List of server configuration properties that can be found in <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html" target="_top">ServerProperties</a> class.
        </p><div class="table"><a name="d0e12639"></a><p class="title"><b>Table&nbsp;A.2.&nbsp;List of server configuration properties</b></p><div class="table-contents"><table summary="List of server configuration properties" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th>Constant</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#APPLICATION_NAME" target="_top">ServerProperties.APPLICATION_NAME</a></td><td><code class="literal">jersey.config.server.application.name</code></td><td>
                            <p>
                                Defines the application name. The name is an arbitrary user defined name which is used to
                                distinguish between Jersey applications in the case that more applications are deployed on
                                the same runtime (container). The name can be used for example for purposes of monitoring
                                by JMX when name identifies to which application deployed MBeans belong to. The name should
                                be unique in the runtime. The property does not have a default value.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_FEATURE_DISABLE" target="_top">ServerProperties.BV_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.beanValidation.disable.server</code></td><td>
                            <p>
                                Disables Bean Validation support. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK" target="_top">ServerProperties
                            .BV_DISABLE_VALIDATE_ON_EXECUTABLE_OVERRIDE_CHECK</a></td><td><code class="literal">jersey.config.beanValidation
                            .disable.validateOnExecutableCheck.server</code></td><td>
                            <p>
                                Disables <code class="literal">@ValidateOnExecution</code> check. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#BV_SEND_ERROR_IN_RESPONSE" target="_top">ServerProperties.BV_SEND_ERROR_IN_RESPONSE</a></td><td><code class="literal">jersey.config.beanValidation
                            .enableOutputValidationErrorEntity.server</code></td><td>
                            <p>
                                Enables sending validation error information to the client. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">ServerProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></td><td><code class="literal">jersey.config.disableAutoDiscovery.server</code></td><td>
                            <p>
                                Disables feature auto discovery on server. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#HTTP_METHOD_OVERRIDE" target="_top">ServerProperties.HTTP_METHOD_OVERRIDE</a></td><td><code class="literal">jersey.config.server.httpMethodOverride</code></td><td>
                            <p>
                                Defines configuration of HTTP method overriding.
                                This property is used by <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/filter/HttpMethodOverrideFilter.html" target="_top">HttpMethodOverrideFilter</a> to determine
                                where it should look for method override information (e.g. request header or query parameters).
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">ServerProperties.JSON_PROCESSING_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.disableJsonProcessing.server</code></td><td>
                            <p>
                                Disables configuration of Json Processing (JSR-353) feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#LANGUAGE_MAPPINGS" target="_top">ServerProperties.LANGUAGE_MAPPINGS</a></td><td><code class="literal">jersey.config.server.languageMappings</code></td><td>
                            <p>
                                Defines mapping of URI extensions to languages. The property is used by <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/filter/UriConnegFilter.html" target="_top">UriConnegFilter</a>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#MEDIA_TYPE_MAPPINGS" target="_top">ServerProperties.MEDIA_TYPE_MAPPINGS</a></td><td><code class="literal">jersey.config.server.mediaTypeMappings</code></td><td>
                            <p>
                                Defines mapping of URI extensions to media types. The property is used by <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/filter/UriConnegFilter.html" target="_top">UriConnegFilter</a>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">ServerProperties.METAINF_SERVICES_LOOKUP_DISABLE</a></td><td><code class="literal">jersey.config
                            .disableMetainfServicesLookup.server</code></td><td>
                            <p>
                                Disables META-INF/services lookup on server. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">ServerProperties.MOXY_JSON_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.disableMoxyJson.server</code></td><td>
                            <p>
                                Disables configuration of MOXy Json feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_ENABLED" target="_top">ServerProperties.MONITORING_STATISTICS_ENABLED</a></td><td><code class="literal">jersey.config.server
                            .monitoring.statistics.enabled</code></td><td>
                            <p>
                                If <code class="literal">true</code>, the calculation of monitoring statistics will be enabled. This will enable the
                                possibility of injecting <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a> into resource and
                                providers and also the registered listeners implementing
                                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatisticsListener.html" target="_top">MonitoringStatisticsListener</a> will be called when statistics are
                                available for processing. Note that enabling statistics may have a negative performance impact
                                and therefore should be enabled only when needed. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_MBEANS_ENABLED" target="_top">ServerProperties.MONITORING_STATISTICS_MBEANS_ENABLED</a></td><td><code class="literal">jersey.config.server
                            .monitoring.statistics.mbeans.enabled</code></td><td>
                            <p>
                                If <code class="literal">true</code> then Jersey will expose MBeans for the collected monitoring statistics. Exposed
                                JMX MBeans are based on <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/monitoring/MonitoringStatistics.html" target="_top">MonitoringStatistics</a> data and therefore when
                                enabled, the calculation of monitoring statistics gets automatically enabled too (the same result
                                as setting the property <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#MONITORING_STATISTICS_ENABLED" target="_top">ServerProperties.MONITORING_STATISTICS_ENABLED</a> to
                                <code class="literal">true</code>). Note that enabling MBeans for monitoring statistics may have a negative performance
                                impact and therefore should be enabled only when needed. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#OUTBOUND_CONTENT_LENGTH_BUFFER" target="_top">ServerProperties.OUTBOUND_CONTENT_LENGTH_BUFFER</a>
                            (Jersey 2.2 or later)</td><td><code class="literal">jersey.config.contentLength.buffer.server</code></td><td>
                            <p>
                                An integer value that defines the buffer size used to buffer the outbound message entity in order to
                                determine its size and set the value of HTTP <code class="literal">Content-Length</code> header. Default
                                value is <code class="literal">8192</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#PROVIDER_CLASSNAMES" target="_top">ServerProperties.PROVIDER_CLASSNAMES</a></td><td><code class="literal">jersey.config.server.provider.classnames</code></td><td>
                            <p>
                                Defines one or more class names that implement application-specific resources
                                and providers. If the property is set, the specified classes will be instantiated
                                and registered as either application JAX-RS root resources or providers.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#PROVIDER_CLASSPATH" target="_top">ServerProperties.PROVIDER_CLASSPATH</a></td><td><code class="literal">jersey.config.server.provider.classpath</code></td><td>
                            <p>
                                Defines class-path that contains application-specific resources and
                                providers. If the property is set, the specified packages will be scanned for
                                JAX-RS root resources and providers.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#PROVIDER_PACKAGES" target="_top">ServerProperties.PROVIDER_PACKAGES</a></td><td><code class="literal">jersey.config.server.provider.packages</code></td><td>
                            <p>
                                Defines one or more packages that contain application-specific resources and
                                providers. If the property is set, the specified packages will be scanned for
                                JAX-RS root resources and providers.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#PROVIDER_SCANNING_RECURSIVE" target="_top">ServerProperties.PROVIDER_SCANNING_RECURSIVE</a></td><td><code class="literal">jersey.config.server
                            .provider.scanning.recursive</code></td><td>
                            <p>
                                Sets the recursion strategy for package scanning. Default value is <code class="literal">true</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#RESOURCE_VALIDATION_DISABLE" target="_top">ServerProperties.RESOURCE_VALIDATION_DISABLE</a></td><td><code class="literal">jersey.config.server
                            .resource.validation.disable</code></td><td>
                            <p>
                                Disables <code class="literal">Resource</code> validation. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#RESOURCE_VALIDATION_IGNORE_ERRORS" target="_top">ServerProperties.RESOURCE_VALIDATION_IGNORE_ERRORS</a></td><td><code class="literal">jersey.config.server
                            .resource.validation.ignoreErrors</code></td><td>
                            <p>
                                Determines whether validation of application resource models should fail even in case of a fatal
                                validation errors. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#WADL_FEATURE_DISABLE" target="_top">ServerProperties.WADL_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.server.wadl.disableWadl</code></td><td>
                            <p>
                                Disables WADL generation. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/ServerProperties.html#WADL_GENERATOR_CONFIG" target="_top">ServerProperties.WADL_GENERATOR_CONFIG</a></td><td><code class="literal">jersey.config.server.wadl.generatorConfig</code></td><td>
                            <p>
                                Defines the wadl generator configuration that provides a <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/server/wadl/WadlGenerator.html" target="_top">WadlGenerator</a>.
                            </p>
                        </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="A.3.&nbsp;Client configuration properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="appendix-properties-client"></a>A.3.&nbsp;Client configuration properties</h2></div></div></div><p>
            List of client configuration properties that can be found in <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html" target="_top">ClientProperties</a> class.
        </p><div class="table"><a name="d0e13009"></a><p class="title"><b>Table&nbsp;A.3.&nbsp;List of client configuration properties</b></p><div class="table-contents"><table summary="List of client configuration properties" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th>Constant</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#ASYNC_THREADPOOL_SIZE" target="_top">ClientProperties.ASYNC_THREADPOOL_SIZE</a></td><td><code class="literal">jersey.config.client.async.threadPoolSize</code></td><td>
                            <p>
                                Asynchronous thread pool size. Default value is not set. <span class="emphasis"><em>NOT SUPPORTED</em></span>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#BUFFER_RESPONSE_ENTITY_ON_EXCEPTION" target="_top">ClientProperties.BUFFER_RESPONSE_ENTITY_ON_EXCEPTION</a></td><td><code class="literal">jersey.config.client.bufferResponseEntityOnException</code></td><td>
                            <p>
                                Automatic response buffering in case of an exception. Default value is <code class="literal">true</code>. <span class="emphasis"><em>NOT SUPPORTED</em></span>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#CHUNKED_ENCODING_SIZE" target="_top">ClientProperties.CHUNKED_ENCODING_SIZE</a></td><td><code class="literal">jersey.config.client.chunkedEncodingSize</code></td><td>
                            <p>
                                Chunked encoding size. Default value is not set. <span class="emphasis"><em>NOT SUPPORTED</em></span>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#CONNECT_TIMEOUT" target="_top">ClientProperties.CONNECT_TIMEOUT</a></td><td><code class="literal">jersey.config.client.connectTimeout</code></td><td>
                            <p>
                                Read timeout interval, in milliseconds. Default value is <code class="literal">0</code> (infinity).
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#FEATURE_AUTO_DISCOVERY_DISABLE" target="_top">ClientProperties.FEATURE_AUTO_DISCOVERY_DISABLE</a></td><td><code class="literal">jersey.config.disableAutoDiscovery.client</code></td><td>
                            <p>
                                Disables feature auto discovery on client. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#FOLLOW_REDIRECTS" target="_top">ClientProperties.FOLLOW_REDIRECTS</a></td><td><code class="literal">jersey.config.client.followRedirects</code></td><td>
                            <p>
                                Declares that the client will automatically redirect to the URI declared in 3xx responses. Default value is <code class="literal">true</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#HTTP_URL_CONNECTION_SET_METHOD_WORKAROUND" target="_top">ClientProperties
                            .HTTP_URL_CONNECTION_SET_METHOD_WORKAROUND</a></td><td><code class="literal">jersey.config.client
                            .httpUrlConnection.setMethodWorkaround</code></td><td>
                            <p>
                                Declares that the client will try to set unsupported HTTP method to <code class="literal">HttpURLConnection</code>
                                via reflection. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#JSON_PROCESSING_FEATURE_DISABLE" target="_top">ClientProperties.JSON_PROCESSING_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.disableJsonProcessing.client</code></td><td>
                            <p>
                                Disables configuration of Json Processing (JSR-353) feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#METAINF_SERVICES_LOOKUP_DISABLE" target="_top">ClientProperties.METAINF_SERVICES_LOOKUP_DISABLE</a></td><td><code class="literal">jersey.config.disableMetainfServicesLookup.client</code></td><td>
                            <p>
                                Disables META-INF/services lookup on client. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#MOXY_JSON_FEATURE_DISABLE" target="_top">ClientProperties.MOXY_JSON_FEATURE_DISABLE</a></td><td><code class="literal">jersey.config.disableMoxyJson.client</code></td><td>
                            <p>
                                Disables configuration of MOXy Json feature. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#OUTBOUND_CONTENT_LENGTH_BUFFER" target="_top">ClientProperties.OUTBOUND_CONTENT_LENGTH_BUFFER</a>
                            (Jersey 2.2 or later)</td><td><code class="literal">jersey.config.contentLength.buffer.client</code></td><td>
                            <p>
                                An integer value that defines the buffer size used to buffer the outbound message entity in order to
                                determine its size and set the value of HTTP <code class="literal">Content-Length</code> header. Default
                                value is <code class="literal">8192</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#READ_TIMEOUT" target="_top">ClientProperties.READ_TIMEOUT</a></td><td><code class="literal">jersey.config.client.readTimeout</code></td><td>
                            <p>
                                Read timeout interval, in milliseconds. Default value is <code class="literal">0</code> (infinity).
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#SUPPRESS_HTTP_COMPLIANCE_VALIDATION" target="_top">ClientProperties.SUPPRESS_HTTP_COMPLIANCE_VALIDATION</a>
                            (Jersey 2.2 or later)</td><td><code class="literal">jersey.config.client.suppressHttpComplianceValidation</code></td><td>
                            <p>
                                If <code class="literal">true</code>, the strict validation of HTTP specification compliance for client-side
                                requests will be suppressed. When compliance checks are suppressed, any violations will
                                be merely logged as warnings, rather than causing exceptions being raised in Jersey
                                runtime. Default value is <code class="literal">false</code>.
                            </p>
                        </td></tr><tr><td><a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/ClientProperties.html#USE_ENCODING" target="_top">ClientProperties.USE_ENCODING</a></td><td><code class="literal">jersey.config.client.useEncoding</code></td><td>
                            <p>
                                Indicates the value of <code class="literal">Content-Encoding</code> property the
                                <a class="link" href="https://jersey.java.net/apidocs/2.3/jersey/org/glassfish/jersey/client/filter/EncodingFilter.html" target="_top">EncodingFilter</a> should be adding. Default value is not set.
                            </p>
                        </td></tr></tbody></table></div></div><br class="table-break"></div></div></div><link href="https://jersey.java.net/sh/shCore.css" rel="stylesheet" type="text/css"><link href="https://jersey.java.net/sh/shThemeDefault.css" rel="stylesheet" type="text/css"><script src="https://jersey.java.net/sh/shCore.js" type="text/javascript"></script><script src="https://jersey.java.net/sh/shAutoloader.js" type="text/javascript"></script><script type="text/javascript">
            function path() {
              var args = arguments,
                  result = []
                  ;

              for(var i = 0; i < args.length; i++)
                  result.push(args[i].replace('@', 'https://jersey.java.net/sh/'));

              return result
            };

            SyntaxHighlighter.autoloader.apply(null, path(
              'applescript            @shBrushAppleScript.js',
              'actionscript3 as3      @shBrushAS3.js',
              'bash shell             @shBrushBash.js',
              'coldfusion cf          @shBrushColdFusion.js',
              'cpp c                  @shBrushCpp.js',
              'c# c-sharp csharp      @shBrushCSharp.js',
              'css                    @shBrushCss.js',
              'delphi pascal          @shBrushDelphi.js',
              'diff patch pas         @shBrushDiff.js',
              'erl erlang             @shBrushErlang.js',
              'groovy                 @shBrushGroovy.js',
              'java                   @shBrushJava.js',
              'jfx javafx             @shBrushJavaFX.js',
              'js jscript javascript  @shBrushJScript.js',
              'perl pl                @shBrushPerl.js',
              'php                    @shBrushPhp.js',
              'text plain             @shBrushPlain.js',
              'py python              @shBrushPython.js',
              'ruby rails ror rb      @shBrushRuby.js',
              'sass scss              @shBrushSass.js',
              'scala                  @shBrushScala.js',
              'sql                    @shBrushSql.js',
              'vb vbnet               @shBrushVb.js',
              'xml xhtml xslt html    @shBrushXml.js'
            ));

            SyntaxHighlighter.all();
        </script></div></body></html>